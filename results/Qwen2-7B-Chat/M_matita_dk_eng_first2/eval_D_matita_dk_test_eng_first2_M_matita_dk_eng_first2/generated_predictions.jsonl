{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_Type2_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nassistant\n", "label": "axiom range_rect_Type2_body (_A : cic.Univ univs.Type0) (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type2 (Q_ x_923)", "predict": "axiom range_rect_Type2_body (_A : cic.Univ univs.Type0) (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term univs.Type2 (Q_ x_923)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nP_ord_times. Let $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq", "label": "p_ord_times : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> qa : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ra : cic.Term univs.Type0 matita_arithmetics_nat.nat -> qb : cic.Term univs.Type0 matita_arithmetics_nat.nat -> rb : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)) -> __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) (matita_arithmetics_nat.times ra rb))) .", "predict": "pord_times : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> qa : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ra : cic.Term univs.Type0 matita_arithmetics_nat.nat -> qb : cic.Term univs.Type0 matita_arithmetics_nat.nat -> rb : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra)) -> __4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) (matita_arithmetics_nat.times ra rb))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.\nassistant\n", "label": "Axiom lstar_lstar_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) .", "predict": "Axiom lstar_lstar_r : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_913$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_913$.\nassistant\n", "label": "ACop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_913) .", "predict": "ACop_rect_CProp0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_913 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_913) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_upper_bound6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_upper_bound6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_upper_bound6 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_to_le_times_to_lt_S_to_div. For all elements $a$ and $c$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $c$.\nassistant\n", "label": "lt_to_le_times_to_lt_S_to_div : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c) .", "predict": "lt_to_le_times_to_lt_S_to_div : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFalse_rect_Type2_body. Let $Q_$ be a function from elements $_x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_70$.\nassistant\n", "label": "axiom False_rect_Type2_body (Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type2) (x_70 : cic.Term cic.prop matita_basics_logic.False) : cic.Term univs.Type2 (Q_ x_70)", "predict": "axiom False_rect_Type2_body (Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type2) (x_70 : cic.Term cic.prop matita_basics_logic.False) : cic.Term univs.Type2 (Q_ x_70)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_gcd_nm. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $m$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $n$.\nassistant\n", "label": "postulate divides_gcd_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n))", "predict": "postulate divides_gcd_nm : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_CProp1. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z641$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_CProp1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) .", "predict": "bool_inv_rect_CProp1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.\nassistant\n", "label": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "Axiom le_to_le_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) .", "predict": "Axiom le_to_le_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMk_range. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$.\nassistant\n", "label": "Axiom mk_range : forall A : cic.Univ univs.Type0, forall _enum : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _filter : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 (matita_arithmetics_bigops.range A) .", "predict": "Axiom mk_range : forall A : cic.Univ univs.Type0, forall _enum : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _filter : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 (matita_arithmetics_bigops.range A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_times. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.times$ applied to $n2$ and $m2$.\nassistant\n", "label": "postulate le_times : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n1 m1) (matita_arithmetics_nat.times n2 m2))", "predict": "postulate le_times : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n1 m1) (matita_arithmetics_nat.times n2 m2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_divides_true. Let $l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.list_divides$ applied to $l$ and $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.\nassistant\n", "label": "postulate list_divides_true : (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n)))", "predict": "postulate list_divides_true : (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_gcd_mod. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.\nassistant\n", "label": "axiom divides_gcd_mod (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)))", "predict": "axiom divides_gcd_mod (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_inv_rect_Type0. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1266$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1267$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Prod_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type0 (P Hterm) .", "predict": "Axiom Prod_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nR4. For all elements $T0$ of $cic.Univ$ of $univs.Type0$, for all elements $a0$ of $cic.Term$ of $univs.Type0$ and $T0$, for all functions $T1$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$, for all functions $T2$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs", "label": "axiom R4 (T0 : cic.Univ univs.Type0) (a0 : cic.Term univs.Type0 T0) (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univ", "predict": "axiom R4 (T0 : cic.Univ univs.Type0) (a0 : cic.Term univs.Type0 T0) (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1 a2))) : cic.Term univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1 a2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIter. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "axiom iter (H : cic.Univ univs.Type0) (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 H) : cic.Term univs.Type0 H", "predict": "axiom iter (H : cic.Univ univs.Type0) (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 H) : cic.Term univs.Type0 H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_CProp2_body. Let $Q_$ be a function from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.\nassistant\n", "label": "bool_rect_CProp2_body : Q_ : (_x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_356) .", "predict": "bool_rect_CProp2_body : Q_ : (_x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_356) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqnot_to_noteq. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.\nassistant\n", "label": "eqnot_to_noteq : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) .", "predict": "eqnot_to_noteq : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.\nassistant\n", "label": "Axiom nil : forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_lists_list.list A) .", "predict": "Axiom nil : forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_lists_list.list A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDividesb_div_true. Let $d$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $d$ and $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "dividesb_div_true : d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) .", "predict": "dividesb_div_true : d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAssociative. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom associative (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop", "predict": "axiom associative (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate Sum : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate Sum : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLength_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$.\nassistant\n", "label": "axiom length_append (A : cic.Univ univs.Type0) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)))", "predict": "axiom length_append (A : cic.Univ univs.Type0) (l1 l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.append A l1 l2)) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nIncreasing_to_monotonic. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and $f$.\nassistant\n", "label": "Axiom increasing_to_monotonic : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f) .", "predict": "Axiom increasing_to_monotonic : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt f) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSmallest_factor_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "Axiom smallest_factor_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) .", "predict": "Axiom smallest_factor_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nHint_declaration_CProp2. For all elements $_a$ and $_b$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "hint_declaration_CProp2 : _a : cic.Univ cic.prop -> _b : cic.Univ cic.prop -> cic.Univ univs.Type0 .", "predict": "hint_declaration_CProp2 : _a : cic.Univ cic.prop -> _b : cic.Univ cic.prop -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_divides_to_dividesb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "not_divides_to_dividesb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false) .", "predict": "not_divides_to_dividesb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_rect_Type0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_None$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_611$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_611$, for all elements $x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_610$.\nassistant\n", "label": "axiom option_rect_Type0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type0 (Q_ x_610)", "predict": "axiom option_rect_Type0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type0 (Q_ x_610)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_n_Sm_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $P$ of $cic.Univ$ of $cic.prop$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, $cic.Term$ holds for $cic.prop$ and $P$.\nassistant\n", "label": "postulate le_n_Sm_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))) -> (P : cic.Univ cic.prop) -> (__1 : (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> (__2 : (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> cic.Term cic.prop P", "predict": "postulate le_n_Sm_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))) -> (P : cic.Univ cic.prop) -> (__1 : (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> (__2 : (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P) -> cic.Term cic.prop P"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_to_leb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "axiom le_to_leb_true (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)", "predict": "axiom le_to_leb_true (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_Type3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z599$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_Type3 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> _H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm) .", "predict": "bool_inv_rect_Type3 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> _H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_rect_Type4. For all functions $Q_$ from elements $_x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_I$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_42$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_42$.\nassistant\n", "label": "Axiom True_rect_Type4 : forall Q_ : ((_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4), forall _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I), forall x_42 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type4 (Q_ x_42) .", "predict": "Axiom True_rect_Type4 : forall Q_ : ((_x_42 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type4), forall _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I), forall x_42 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type4 (Q_ x_42) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTheta_pi_p_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "Axiom theta_pi_p_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (fun p => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m)))) .", "predict": "Axiom theta_pi_p_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (fun p => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => p)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.S m)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.\nassistant\n", "label": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) .", "predict": "Axiom range_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type0 (Q_ x_927) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_CProp0_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.\nassistant\n", "label": "axiom list_rect_CProp0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)", "predict": "axiom list_rect_CProp0_body (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.\nassistant\n", "label": "postulate eq_rect_CProp5_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)", "predict": "postulate eq_rect_CProp5_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nHint_declaration_Type2. Let $_a$ and $_b$ be elements of $cic.Univ$ of $univs.Type2$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "hint_declaration_Type2 : _a : cic.Univ univs.Type2 -> _b : cic.Univ univs.Type2 -> cic.Univ univs.Type0 .", "predict": "hint_declaration_Type2 : _a : cic.Univ univs.Type2 -> _b : cic.Univ univs.Type2 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_of_primes. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "list_of_primes : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) .", "predict": "list_of_primes : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_sqrt. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $n$ and $n$.\nassistant\n", "label": "postulate eq_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times n n)) n)", "predict": "postulate eq_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times n n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTheta. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom theta : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom theta : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10332. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_10332 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_inv_rect_Type0. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1464$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_835$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_834$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1465$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_835$ and $x_834$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate div_mod_spec_inv_rect_Type0 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1464 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type0) -> (_H1 : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1465 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate div_mod_spec_inv_rect_Type0 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1464 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type0) -> (_H1 : (x_835 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_834 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1465 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_835 x_834))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTech. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$", "label": "axiom tech (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))", "predict": "axiom tech (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod", "label": "Dop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type1 (Q_ x_953) .", "predict": "Dop_rect_Type1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type1 (Q_ x_953) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_mod_aux_m_m. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod_aux$ applied to $p$ and $n$ and $m$ and $m$.\nassistant\n", "label": "axiom le_mod_aux_m_m (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m)", "predict": "axiom le_mod_aux_m_m (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_73. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.\nassistant\n", "label": "axiom let_clause_73 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (x134 x135 x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))", "predict": "axiom let_clause_73 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (x134 x135 x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_CProp3. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.\nassistant\n", "label": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)", "predict": "postulate Not_rect_CProp3 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_107 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_106)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_ind_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.\nassistant\n", "label": "Axiom list_ind_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))), forall x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_716) .", "predict": "Axiom list_ind_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_718 : cic.Term univs.Type0 _A) -> (x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_720 : cic.Term cic.prop (Q_ x_717)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))), forall x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_716) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_inv_ind. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z257$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z258$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_80$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_80$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Not_inv_ind : (x1 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) -> (P : (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) -> (_H1 : (x_80 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z258 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc", "label": "postulate Aop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)", "predict": "postulate Aop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_r_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $x1$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x4$ and $x5$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from elements $_z2386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_z2385$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2384$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ and elements $_z2388$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2387$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$, for all functions $_H2$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of", "label": "lstar_r_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1) -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 x1 -> x5 : cic.Term univs.Type0 x1 -> _Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5) -> P : (_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _z2385 : cic.Term univs.Type0 x1 -> _z2384 : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> _H1 : (b : cic.Term univs.Type0 x1 -> _z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O) -> _z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b) -> _z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) -> _H2 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1", "predict": "lstar_r_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1) -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 x1 -> x5 : cic.Term univs.Type0 x1 -> _Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5) -> P : (_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _z2385 : cic.Term univs.Type0 x1 -> _z2384 : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> _H1 : (b : cic.Term univs.Type0 x1 -> _z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O) -> _z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b) -> _z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) -> _H2 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 x1 -> b2 : cic.Term univs.Type0 x1 -> _z2390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 (matita_arithmetics_nat.plus l matita_arithmetics_nat.O)) -> _z2391 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 (matita_basics_logic.R0 x1 b1)) -> _z2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_lstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_lstar_r : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z) .", "predict": "filter_lstar_r : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R __ __1 __2) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_rect_Type2_body. For all functions $Q_$ from elements $_x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_I$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_48$.\nassistant\n", "label": "postulate True_rect_Type2_body : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)", "predict": "postulate True_rect_Type2_body : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_ind_body. For all functions $Q_$ from elements $_x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_495$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_495$.\nassistant\n", "label": "Axiom unit_ind_body : forall Q_ : ((_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_495 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_495) .", "predict": "Axiom unit_ind_body : forall Q_ : ((_x_495 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_495 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_495) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_pair_fst_snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $p$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $p$.\nassistant\n", "label": "postulate eq_pair_fst_snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))", "predict": "postulate eq_pair_fst_snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nP_ord_O_to_not_divides. Let $n$ and $i$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.nth_prime$ applied to $i$ and $n$.\nassistant\n", "label": "axiom p_ord_O_to_not_divides (n i r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))", "predict": "axiom p_ord_O_to_not_divides (n i r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPermut_S_to_permut_transpose. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $f$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $m$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)", "predict": "postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1698$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to", "label": "Dop_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) .", "predict": "Dop_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNotb. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom notb : forall __ : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom notb : forall __ : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nP_ord_to_not_eq_O. Let $n$ and $p$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom p_ord_to_not_eq_O (n p q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime p)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r matita_arithmetics_nat.O))", "predict": "axiom p_ord_to_not_eq_O (n p q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime p)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_929$.\nassistant\n", "label": "axiom range_rect_CProp4 (_A : cic.Univ univs.Type0) (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_929)", "predict": "axiom range_rect_CProp4 (_A : cic.Univ univs.Type0) (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_929)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1553. Let $n$ and $n0$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita", "label": "Axiom let_clause_1553 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hn : cic.Term cic", "predict": "Axiom let_clause_1553 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hn : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_rect_CProp4_body. For all functions $Q_$ from elements $_x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_54$.\nassistant\n", "label": "postulate True_rect_CProp4_body : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)", "predict": "postulate True_rect_CProp4_body : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_log_exp. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $n$.\nassistant\n", "label": "eq_log_exp : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp p n)) n) .", "predict": "eq_log_exp : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_exp.exp p n)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15625. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_ar", "label": "Axiom let_clause_15625 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O", "predict": "Axiom let_clause_15625 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S mat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_S. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "Axiom lstar_S : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall b : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (R b1 b), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b2 : cic.Term univs.Type0 B, forall __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) .", "predict": "Axiom lstar_S : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall b : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (R b1 b), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b2 : cic.Term univs.Type0 B, forall __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2), cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFind. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.\nassistant\n", "label": "axiom find (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_types.option B)", "predict": "axiom find (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_types.option B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nGcd_O_to_eq_O. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom gcd_O_to_eq_O (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))", "predict": "axiom gcd_O_to_eq_O (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTight_apart. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_eq$ and $_ap$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom tight_apart : forall A : cic.Univ univs.Type0, forall _eq : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _ap : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom tight_apart : forall A : cic.Univ univs.Type0, forall _eq : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _ap : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDpi1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "dpi1 : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f) -> cic.Term univs.Type0 A .", "predict": "dpi1 : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f) -> cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_933$.\nassistant\n", "label": "range_rect_CProp3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_933) .", "predict": "range_rect_CProp3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_933) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPermut_O_to_eq_O. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "permut_O_to_eq_O : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O) .", "predict": "permut_O_to_eq_O : h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_inv_rect_Type3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $P$ from elements $_z665$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_380$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $x_378$ and elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "nat_inv_rect_Type3 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type3) -> _H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> _H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378) -> cic.Term univs.Type3 (P x_378)) -> _z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378)) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "nat_inv_rect_Type3 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type3) -> _H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> _H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378) -> cic.Term univs.Type3 (P x_378)) -> _z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378)) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_O_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.\nassistant\n", "label": "lt_O_nth_prime_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n)) .", "predict": "lt_O_nth_prime_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_primes.nth_prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus. Let $n1$ and $n2$ and $m1$ and $m2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.\nassistant\n", "label": "Axiom le_plus : forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) .", "predict": "Axiom le_plus : forall n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_Type5_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type5_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5), forall _H_div_mod_spec_intro : ((x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))), forall x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type5 (Q_ x_817) .", "predict": "Axiom div_mod_spec_rect_Type5_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5), forall _H_div_mod_spec_intro : ((x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))), forall x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type5 (Q_ x_817) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $", "label": "Axiom Dop_rect_CProp5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_959) .", "predict": "Axiom Dop_rect_CProp5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_959) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_inv_rect_CProp2. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z371$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z372$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "And_inv_rect_CProp2 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_160 : cic.Term cic.prop x1 -> x_159 : cic.Term cic.prop x2 -> _z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm) .", "predict": "And_inv_rect_CProp2 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_160 : cic.Term cic.prop x1 -> x_159 : cic.Term cic.prop x2 -> _z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus_a. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $a$ and $m$.\nassistant\n", "label": "axiom le_plus_a (a n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus a m))", "predict": "axiom le_plus_a (a n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus a m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1668$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1669$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom range_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1668 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1669 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term cic.prop (P Hterm)", "predict": "axiom range_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1668 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1669 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFound_max_spec. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $m$.\nassistant\n", "label": "found_max_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m) .", "predict": "found_max_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_inv_rect_Type2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMem_single. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.cons$ applied to $A$ and $b$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $b$.\nassistant\n", "label": "Axiom mem_single : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b) .", "predict": "Axiom mem_single : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type2. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.\nassistant\n", "label": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)", "predict": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_inv_plus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.\nassistant\n", "label": "Axiom le_inv_plus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z), cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) .", "predict": "Axiom le_inv_plus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z), cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_rect_Type2. For all functions $Q_$ from elements $_x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_true$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_338$.\nassistant\n", "label": "axiom bool_rect_Type2 (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type2 (Q_ x_338)", "predict": "axiom bool_rect_Type2 (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type2 (Q_ x_338)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_ind. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_587$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_587$, for all elements $x_586$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_586$.\nassistant\n", "label": "postulate option_ind : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)", "predict": "postulate option_ind : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_587 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_587))) -> (x_586 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_586)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_CProp2. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.\nassistant\n", "label": "False_rect_CProp2 : Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_76) .", "predict": "False_rect_CProp2 : Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_76 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_76) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPsi'. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom Psi' (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom Psi' (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIter_iter. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_iteration.iter$ applied to $A$ and $g$ and $c$ and $matita_arithmetics_iteration.iter$ applied to $A$ and $g$ and $b$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $A$ and $g$ and $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$.\nassistant\n", "label": "postulate iter_iter : (A : cic.Univ univs.Type0) -> (g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_iteration.iter A g c (matita_arithmetics_iteration.iter A g b a)) (matita_arithmetics_iteration.iter A g (matita_arithmetics_nat.plus b c) a))", "predict": "postulate iter_iter : (A : cic.Univ univs.Type0) -> (g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_iteration.iter A g c (matita_arithmetics_iteration.iter A g b a)) (matita_arithmetics_iteration.iter A g (matita_arithmetics_nat.plus b c) a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil", "label": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_871)", "predict": "postulate Aop_rect_Type1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type1) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type1 (Q_ x_871)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPred. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "pred : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "pred : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_inv_rect_Type3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1710$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$", "label": "axiom Dop_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type3 (P Hterm)", "predict": "axiom Dop_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "axiom le_2_fact (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))", "predict": "axiom le_2_fact (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPlus_O_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom plus_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))", "predict": "axiom plus_O_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus matita_arithmetics_nat.O n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOrb_true_r2. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "orb_true_r2 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) .", "predict": "orb_true_r2 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExists. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Exists : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Univ cic.prop .", "predict": "Exists : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $P$ from elements $_z713$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_416$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_414$ and elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom nat_inv_rect_CProp0 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall _H2 : ((x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom nat_inv_rect_CProp0 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall _H2 : ((x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_to_smallest_factor. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom prime_to_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "Axiom prime_to_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiscr_plus_xy_minus_xz. Let $x$ and $z$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $matita_arithmetics_nat.minus$ applied to $x$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate discr_plus_xy_minus_xz : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x y) (matita_arithmetics_nat.minus x z))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)", "predict": "postulate discr_plus_xy_minus_xz : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x y) (matita_arithmetics_nat.minus x z))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrimeb_true_to_prime. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.\nassistant\n", "label": "postulate primeb_true_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)", "predict": "postulate primeb_true_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_rect_CProp0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_688$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_688$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_688$.\nassistant\n", "label": "axiom Sig_rect_CProp0_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_688)", "predict": "axiom Sig_rect_CProp0_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_688 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_688)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_pair_fst_snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $p$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $p$.\nassistant\n", "label": "eq_pair_fst_snd : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> p : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p))) .", "predict": "eq_pair_fst_snd : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> p : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp5_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.\nassistant\n", "label": "axiom range_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_931)", "predict": "axiom range_rect_CProp5_body (_A : cic.Univ univs.Type0) (Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_931)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_inv_rect_CProp4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z942$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z943$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) .", "predict": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nIncreasing_to_le2. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.\nassistant\n", "label": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) .", "predict": "increasing_to_le2 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_867$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_n", "label": "axiom Aop_rect_Type3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type3 (Q_ x_867)", "predict": "axiom Aop_rect_Type3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type3 (Q_ x_867)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_plus_n. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "axiom le_plus_n (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m))", "predict": "axiom le_plus_n (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBigop_prod. Let $k1$ and $k2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $x$ to $p1$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $x$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $x$ and $i", "label": "postulate bigop_prod : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 x) B nil (matita_arithmetics_bigops.op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x i))) (matita_ar", "predict": "postulate bigop_prod : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 x) B nil (matita_arithmetics_bigops.op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.times k1 k2) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (p1 (matita_arithmetics_div_and_mod.div i k2)) (p2 (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLhd_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "postulate lhd_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "postulate lhd_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIff_or_r. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Or$ applied to $A$ and $C$ and $matita_basics_logic.Or$ applied to $B$ and $C$.\nassistant\n", "label": "axiom iff_or_r (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or A C) (matita_basics_logic.Or B C))", "predict": "axiom iff_or_r (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) : cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Or A C) (matita_basics_logic.Or B C))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_rect_CProp2_body. Let $Q_$ be a function from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.\nassistant\n", "label": "postulate nat_rect_CProp2_body : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)", "predict": "postulate nat_rect_CProp2_body : (Q_ : (_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))) -> (x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_405)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.\nassistant\n", "label": "Axiom Prod_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_714) .", "predict": "Axiom Prod_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_714) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_Conf3. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.\nassistant\n", "label": "Axiom lstar_Conf3 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B), forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall __ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l)) .", "predict": "Axiom lstar_Conf3 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B), forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall __ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R), forall l : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_ind. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_80$, for all elements $x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_79$.\nassistant\n", "label": "Not_ind : _A : cic.Univ cic.prop -> Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_80 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_79) .", "predict": "Not_ind : _A : cic.Univ cic.prop -> Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_80 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_79) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCons_injective_r. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a1$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $a2$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)", "predict": "postulate cons_injective_r : (A : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a1 l1) (matita_basics_lists_list.cons A a2 l2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_Type1_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_conj$ from elements $x_140$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_140$ and $x_139$, for all elements $x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_138$.\nassistant\n", "label": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)", "predict": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_div. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.div$ applied to $b$ and $c$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $c$.\nassistant\n", "label": "Axiom times_div : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides c b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div b c)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) c)) .", "predict": "Axiom times_div : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides c b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div b c)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nP_ord_aux_body. For all elements $__$ and $__1$ and $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "p_ord_aux_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) .", "predict": "p_ord_aux_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_662$.\nassistant\n", "label": "DPair_rect_CProp0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) .", "predict": "DPair_rect_CProp0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1194$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1195$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sig_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type1) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Sig_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type1) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBijn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$.\nassistant\n", "label": "postulate bijn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)", "predict": "postulate bijn_Sn_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFound_min_spec. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "postulate found_min_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)", "predict": "postulate found_min_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_17041. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "let_clause_17041 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) .", "predict": "let_clause_17041 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_to_divides_M. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.\nassistant\n", "label": "Axiom prime_to_divides_M : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m)) .", "predict": "Axiom prime_to_divides_M : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nHint_declaration_CProp2. Let $_a$ and $_b$ be elements of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "hint_declaration_CProp2 : _a : cic.Univ cic.prop -> _b : cic.Univ cic.prop -> cic.Univ univs.Type0 .", "predict": "hint_declaration_CProp2 : _a : cic.Univ cic.prop -> _b : cic.Univ cic.prop -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPosition_of_aux_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom position_of_aux_body (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)", "predict": "axiom position_of_aux_body (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_minl. Let $i$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$.\nassistant\n", "label": "postulate le_minl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le i n)", "predict": "postulate le_minl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) -> cic.Term cic.prop (matita_arithmetics_nat.le i n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSameF_upto_le. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $m$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $n$ and $A$ and $f$ and $g$.\nassistant\n", "label": "Axiom sameF_upto_le : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g), cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g) .", "predict": "Axiom sameF_upto_le : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g), cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_aop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$.\nassistant\n", "label": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)", "predict": "postulate let_aop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_to_log_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom lt_to_log_O (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)", "predict": "axiom lt_to_log_O (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_2_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "Axiom le_2_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n)) .", "predict": "Axiom le_2_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_factorial.fact n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_inv_rect_Type1. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_ind_r. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $x$ and $p$.\nassistant\n", "label": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) .", "predict": "eq_ind_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term cic.prop (P x p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRewrite_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.\nassistant\n", "label": "rewrite_r : A : cic.Univ univs.Type2 -> x : cic.Term univs.Type2 A -> P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P x) -> y : cic.Term univs.Type2 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq A y x) -> cic.Term univs.Type2 (P y) .", "predict": "rewrite_r : A : cic.Univ univs.Type2 -> x : cic.Term univs.Type2 A -> P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P x) -> y : cic.Term univs.Type2 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq A y x) -> cic.Term univs.Type2 (P y) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_exp_priml. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "le_exp_priml : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) .", "predict": "le_exp_priml : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_pair_fst_snd. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $p$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $p$.\nassistant\n", "label": "axiom eq_pair_fst_snd (A B : cic.Univ univs.Type0) (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))", "predict": "axiom eq_pair_fst_snd (A B : cic.Univ univs.Type0) (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_to_gcd. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $n$.\nassistant\n", "label": "Axiom divides_to_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) n) .", "predict": "Axiom divides_to_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nHint_declaration_CProp2. For all elements $_a$ and $_b$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom hint_declaration_CProp2 : forall _a : cic.Univ cic.prop, forall _b : cic.Univ cic.prop, cic.Univ univs.Type0 .", "predict": "Axiom hint_declaration_CProp2 : forall _a : cic.Univ cic.prop, forall _b : cic.Univ cic.prop, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSameF_upto_le. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $m$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $n$ and $A$ and $f$ and $g$.\nassistant\n", "label": "postulate sameF_upto_le : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g)", "predict": "postulate sameF_upto_le : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto m A f g)) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto n A f g)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_909$.\nassistant\n", "label": "postulate ACop_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_909)", "predict": "postulate ACop_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_909)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPi_1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom pi_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "axiom pi_1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp4_body. Let $Q_$ be a function from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, for all elements $x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.\nassistant\n", "label": "axiom nat_rect_CProp4_body (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_393)", "predict": "axiom nat_rect_CProp4_body (Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : cic.Term cic.prop (Q_ x_394)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) (x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_393)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15624. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $", "label": "let_clause_15624 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_ar", "predict": "let_clause_15624 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _dclearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_891$.\nassistant\n", "label": "ACop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type4) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type4 (Q_ x_891) .", "predict": "ACop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type4) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type4 (Q_ x_891) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1551. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqn0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $x347$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $x347$ and $n$.\nassistant\n", "label": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))", "predict": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNil_to_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "Axiom nil_to_nil : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A)), cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A))) .", "predict": "Axiom nil_to_nil : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A)), cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTranspose_i_j_j_i. Let $i$ and $j$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $j$ and $i$ and $n$.\nassistant\n", "label": "postulate transpose_i_j_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n))", "predict": "postulate transpose_i_j_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_inv_rect_Type0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1200$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1201$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sig_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type0 (P Hterm) .", "predict": "Axiom Sig_inv_rect_Type0 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1200 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ univs.Type0), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1201 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_nth_prime_to_not_prime. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $m$.\nassistant\n", "label": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))", "predict": "postulate lt_nth_prime_to_not_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S n)))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_elim_left. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $S$, for all functions $__1$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $S$ and elements $tl$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $tl$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.append$ applied to $S$ and $tl$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$.\nassistant\n", "label": "list_elim_left : S : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)) -> __1 : (a : cic.Term univs.Type0 S -> tl : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> __1 : cic.Term cic.prop (P tl) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))) -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (P l) .", "predict": "list_elim_left : S : cic.Univ univs.Type0 -> P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)) -> __1 : (a : cic.Term univs.Type0 S -> tl : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> __1 : cic.Term cic.prop (P tl) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))) -> l : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (P l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nReverse_reverse. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l$ and $l$.\nassistant\n", "label": "axiom reverse_reverse (S : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.reverse S l)) l)", "predict": "axiom reverse_reverse (S : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.reverse S l)) l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_exp. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $m$.\nassistant\n", "label": "le_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) .", "predict": "le_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp p n) (matita_arithmetics_exp.exp p m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "prod : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> _x_969 : cic.Term univs.Type0 A -> _x_970 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A .", "predict": "prod : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> _x_969 : cic.Term univs.Type0 A -> _x_970 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_eq_S. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "axiom not_eq_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))", "predict": "axiom not_eq_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_inv_step. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $b1$ and $b2$.\nassistant\n", "label": "axiom lstar_inv_step (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) : cic.Term cic.prop (R b1 b2)", "predict": "axiom lstar_inv_step (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2)) : cic.Term cic.prop (R b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1698$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $x", "label": "Dop_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) .", "predict": "Dop_inv_ind : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOrd_rem_eq. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_basics_types.snd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom ord_rem_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p))) .", "predict": "Axiom ord_rem_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord_rem n p) (matita_basics_types.snd matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_13$ and $x_14$.\nassistant\n", "label": "eq_rect_Type2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_13 : cic.Term univs.Type2 A -> _x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Univ univs.Type2) -> _H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)) -> x_13 : cic.Term univs.Type2 A -> x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Term univs.Type2 (Q_ x_13 x_14) .", "predict": "eq_rect_Type2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_13 : cic.Term univs.Type2 A -> _x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Univ univs.Type2) -> _H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)) -> x_13 : cic.Term univs.Type2 A -> x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) -> cic.Term univs.Type2 (Q_ x_13 x_14) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_16001. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of", "label": "axiom let_clause_16001 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (", "predict": "axiom let_clause_16001 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arith"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPos_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nassistant\n", "label": "axiom pos_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))", "predict": "axiom pos_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAxiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $__ - __1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate minus : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate minus : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_to_minus_r. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.\nassistant\n", "label": "Axiom le_plus_to_minus_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c), cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b)) .", "predict": "Axiom le_plus_to_minus_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c), cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.\nassistant\n", "label": "axiom DPair_rect_CProp1_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_660)", "predict": "axiom DPair_rect_CProp1_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_660)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSub_pi2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ and $P'$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $P'$ applied to $x$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and the function that maps $x$ to $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $P'$ applied to $matita_basics_types.pi1$ applied to $A$ and the function that maps $x0$ to $P$ applied to $x0$ and $x$.\nassistant\n", "label": "axiom sub_pi2 (A : cic.Univ univs.Type0) (P P' : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (__ : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> cic.Term cic.prop (P' x)) (x : cic.Term univs.Type0 (matita_basics_types.Sig A (λ x => P x))) : cic.Term cic.prop (P' (matita_basics_types.pi1 A (λ x0 => P x0) x))", "predict": "axiom sub_pi2 (A : cic.Univ univs.Type0) (P P' : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (__ : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P x)) -> cic.Term cic.prop (P' x)) (x : cic.Term univs.Type0 (matita_basics_types.Sig A (λ x => P x))) : cic.Term cic.prop (P' (matita_basics_types.pi1 A (λ x0 => P x0) x))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAssociative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.\nassistant\n", "label": "axiom associative_times : cic.Term cic.prop (matita_basics_relations.associative matita_arithmetics_nat.nat matita_arithmetics_nat.times)", "predict": "axiom associative_times : cic.Term cic.prop (matita_basics_relations.associative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNil_cons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "postulate nil_cons : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))", "predict": "postulate nil_cons : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInv_eq_minus_O. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.\nassistant\n", "label": "axiom inv_eq_minus_O (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "axiom inv_eq_minus_O (x y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus x y) matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_times_div_div_times. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $m$.\nassistant\n", "label": "Axiom le_times_div_div_times : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m)) .", "predict": "Axiom le_times_div_div_times : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a n) m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_CProp0_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_939$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_939$.\nassistant\n", "label": "range_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_939) .", "predict": "range_rect_CProp0_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_939 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_939) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_false. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $a$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.\nassistant\n", "label": "Axiom filter_false : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 A, forall p : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.filter A p l)) .", "predict": "Axiom filter_false : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 A, forall p : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.filter A p l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_899$.\nassistant\n", "label": "axiom ACop_rect_Type1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)", "predict": "axiom ACop_rect_Type1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_Type3_body. Let $Q_$ be a function from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$. Then for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.\nassistant\n", "label": "Axiom bool_rect_Type3_body : forall Q_ : ((_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3), forall _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false), forall x_335 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type3 (Q_ x_335) .", "predict": "Axiom bool_rect_Type3_body : forall Q_ : ((_x_335 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3), forall _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false), forall x_335 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type3 (Q_ x_335) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.\nassistant\n", "label": "eq_rect_Type3_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_10 : cic.Term univs.Type2 A -> _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Univ univs.Type3) -> _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) -> x_10 : cic.Term univs.Type2 A -> x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Term univs.Type3 (Q_ x_10 x_11) .", "predict": "eq_rect_Type3_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_10 : cic.Term univs.Type2 A -> _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Univ univs.Type3) -> _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) -> x_10 : cic.Term univs.Type2 A -> x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Term univs.Type3 (Q_ x_10 x_11) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrimes_all. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom primes_all (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom primes_all (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nStart_lop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate start_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.list_of_primes n)) (matita_basics_types.Some matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_CProp5. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.\nassistant\n", "label": "postulate ACop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)", "predict": "postulate ACop_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDistributive2. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "distributive2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _g : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> cic.Univ cic.prop .", "predict": "distributive2 : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> _g : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_941$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "axiom filter_body (A : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (_x_941 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool", "predict": "axiom filter_body (A : cic.Univ univs.Type0) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) (_x_941 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_sigma. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $", "label": "le_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arith", "predict": "le_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (p1 n) (p2 n)) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_Type0. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.\nassistant\n", "label": "axiom Prod_rect_Type0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type0 (Q_ x_702)", "predict": "axiom Prod_rect_Type0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type0 (Q_ x_702)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1002$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_552$, for all functions $_H2$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1003$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_553$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Sum_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1002 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type0) -> _H1 : (x_552 : cic.Term univs.Type0 x1 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_552)) -> cic.Term univs.Type0 (P (matita_basics_types.inl x1 x2 x_552))) -> _H2 : (x_553 : cic.Term univs.Type0 x2 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_553)) -> cic.Term univs.Type0 (P (matita_basics_types.inr x1 x2 x_553))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "Sum_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1002 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ univs.Type0) -> _H1 : (x_552 : cic.Term univs.Type0 x1 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_552)) -> cic.Term univs.Type0 (P (matita_basics_types.inl x1 x2 x_552))) -> _H2 : (x_553 : cic.Term univs.Type0 x2 -> _z1003 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_553)) -> cic.Term univs.Type0 (P (matita_basics_types.inr x1 x2 x_553))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type1. For all functions $Q_$ from elements $_x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_I$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_50$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_50$.\nassistant\n", "label": "axiom True_rect_Type1 (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) (x_50 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type1 (Q_ x_50)", "predict": "axiom True_rect_Type1 (Q_ : (_x_50 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1) (_H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I)) (x_50 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type1 (Q_ x_50)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom DPair_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom DPair_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_n", "label": "Axiom Aop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type3 (Q_ x_787) .", "predict": "Axiom Aop_rect_Type3_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type3 (Q_ x_787) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_O_gcd. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.\nassistant\n", "label": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))", "predict": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_to_lt_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $n$ and $matita_basics_bool.false$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$.\nassistant\n", "label": "Axiom false_to_lt_max : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max m f) n) .", "predict": "Axiom false_to_lt_max : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max m f) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrimes_all. For all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom primes_all : forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom primes_all : forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_ind. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1233$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1232$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1231$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1234$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1236$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1235$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b$ and $b2$ and $x_1235$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus", "label": "postulate lstar_ind : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop) -> (_H_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (_H_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat", "predict": "postulate lstar_ind : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (Q_ : (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R x_1233 x_1232 x_1231)) -> cic.Univ cic.prop) -> (_H_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> (_H_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (x_1236 : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (x_1235 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> (_x_1238 : cic.Term cic.prop (Q_ l b b2 x_1235)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b x_1236 l b2 x_1235 _x_1238))) -> (x_1233 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1232 : cic.Term univs.Type0 B) -> (x_1231 : cic.Term univs.Type0 B) -> (_x_1234 : cic.Term cic.prop (matita_arithmetics_lstar.l"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_662$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_662$.\nassistant\n", "label": "DPair_rect_CProp0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) .", "predict": "DPair_rect_CProp0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_662 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_662) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAssoc_plus1. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $c$ and $matita_arithmetics_nat.plus$ applied to $b$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$.\nassistant\n", "label": "Axiom assoc_plus1 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus c (matita_arithmetics_nat.plus b a)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus b c) a)) .", "predict": "Axiom assoc_plus1 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus c (matita_arithmetics_nat.plus b a)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus b c) a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFmin_true. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "axiom fmin_true (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_minimization.min n b f))) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)", "predict": "axiom fmin_true (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_minimization.min n b f))) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15621. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $", "label": "let_clause_15621 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_ar", "predict": "let_clause_15621 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _d : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_transpose. Let $i$ and $j$ and $k$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $k$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $matita_arithmetics_permutation.transpose$ applied to $k$ and $j$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $n$.\nassistant\n", "label": "axiom eq_transpose (i j k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))", "predict": "axiom eq_transpose (i j k n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFind_body. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.\nassistant\n", "label": "find_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 (matita_basics_types.option B)) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option B) .", "predict": "find_body : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 (matita_basics_types.option B)) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIso. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.\nassistant\n", "label": "axiom iso (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "axiom iso (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNilr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $a$.\nassistant\n", "label": "Axiom nilr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a) .", "predict": "Axiom nilr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a nil) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNotb. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "postulate notb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate notb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFold_sum. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $I$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $J$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.append$ applied to $A$ and $I$ and $J$.\nassistant\n", "label": "fold_sum : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> I : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> J : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil) -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.append A I J))) .", "predict": "fold_sum : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> I : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> J : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> nil : cic.Term univs.Type0 B -> op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil) -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.append A I J))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_B1_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B1$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "le_B1_theta : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B1 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "le_B1_theta : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n) -> __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B1 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_ind. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_915$.\nassistant\n", "label": "range_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_915) .", "predict": "range_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_915) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z671$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_382$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_384$ from elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_382$ and elements $_z672$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_382$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_382$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom nat_inv_rect_Type2 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2), forall _H1 : ((_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)), forall _H2 : ((x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom nat_inv_rect_Type2 : forall Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((_z671 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type2), forall _H1 : ((_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type2 (P matita_arithmetics_nat.O)), forall _H2 : ((x_382 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_384 : (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_382)) -> cic.Term univs.Type2 (P x_382)) -> (_z672 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_382))) -> cic.Term univs.Type2 (P (matita_arithmetics_nat.S x_382))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1320$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_740$ from elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $x_737$ and elements $_z1321$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_738$ and $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x", "label": "postulate list_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_738 : cic.Term univs.Type0 x1) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737)) -> cic.Term univs.Type2 (P x_737)) -> (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate list_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1320 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type2) -> (_H1 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_738 : cic.Term univs.Type0 x1) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_740 : (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_737)) -> cic.Term univs.Type2 (P x_737)) -> (_z1321 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P (matita_basics_lists_list.cons x1 x_738 x_737))) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAxiom. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then we can say that $__$ is prime.\nassistant\n", "label": "Axiom prime : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom prime : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_B2_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B2$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom le_B2_exp (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))", "predict": "axiom le_B2_exp (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIrreflexive. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom irreflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom irreflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_max_to_pi_p_primeb. For all elements $q$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $m$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $i$ and $matita_arithmetics_primes.dividesb$ applied to $i$ and $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $q$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_primes.dividesb$ applied to $p$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.\nassistant\n", "label": "lt_max_to_pi_p_primeb : q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max (matita_arithmetics_nat.S m) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i m))) q) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop q (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p)))) .", "predict": "lt_max_to_pi_p_primeb : q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max (matita_arithmetics_nat.S m) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i m))) q) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop q (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd. Let $s1$ and $s2$ be elements of $Sort$. Then for all elements $a$ of $Univ$ of $s1$, for all functions $b$ from elements of $Term$ of $s1$ and $a$ to elements of $Univ$ of $s2$, $Univ$ holds for $rule$ applied to $s1$ and $s2$.\nassistant\n", "label": "prod : s1 : Sort -> s2 : Sort -> a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ (rule s1 s2) .", "predict": "prod : s1 : Sort -> s2 : Sort -> a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ (rule s1 s2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_r_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $x1$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x4$ and $x5$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x5$, for all functions $P$ from elements $_z2386$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_z2385$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2384$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z2389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x3$ and $matita_arithmetics_nat.O$ and elements $_z2388$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x4$ and $b$ and elements $_z2387$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $x5$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$, for all functions $_H2$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic", "label": "axiom lstar_r_inv_ind (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1)) (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x4 x5 : cic.Term univs.Type0 x1) (_Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5)) (P : (_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2385 : cic.Term univs.Type0 x1) -> (_z2384 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (_H1 : (b : cic.Term univs.Type0 x1) -> (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) (_H2 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term un", "predict": "axiom lstar_r_inv_ind (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 (matita_basics_relations.relation x1)) (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (x4 x5 : cic.Term univs.Type0 x1) (_Hterm : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r x1 x2 x3 x4 x5)) (P : (_z2386 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_z2385 : cic.Term univs.Type0 x1) -> (_z2384 : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (_H1 : (b : cic.Term univs.Type0 x1) -> (_z2389 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x3 matita_arithmetics_nat.O)) -> (_z2388 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x4 b)) -> (_z2387 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x5 b)) -> cic.Term cic.prop (P matita_arithmetics_nat.O b b)) (_H2 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 x1) -> (b2 : cic.Term univs.Type0 x1) -> (_z2381 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) l (matita_arithmetics_nat.plus matita_arithmetics_nat.O matita_arithmetics_nat.S l))) -> (_z2380 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) x3 b1)) -> (_z2379 :"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $", "label": "axiom match_lstar (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 __2 : cic.Term univs.Type0 B) (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) : cic.Term return_sort (return_type __ __1 __2 z)", "predict": "axiom match_lstar (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) (case_lstar_O : (b : cic.Term univs.Type0 B) -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) (case_lstar_S : (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (_R b1 b)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 __2 : cic.Term univs.Type0 B) (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) : cic.Term return_sort (return_type __ __1 __2 z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_inv_rect_CProp3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z948$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z949$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_CProp3 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z948 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z949 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) .", "predict": "Axiom unit_inv_rect_CProp3 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z948 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z949 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_minus_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom eq_minus_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) .", "predict": "Axiom eq_minus_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.ex matita_arithmetics_nat.nat (fun b => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_34$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_35$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_34$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_34$ and $x_35$.\nassistant\n", "label": "axiom eq_rect_CProp1_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_34 : cic.Term univs.Type2 A) (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) : cic.Term cic.prop (Q_ x_34 x_35)", "predict": "axiom eq_rect_CProp1_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_34 : cic.Term univs.Type2 A) -> (_x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_34 : cic.Term univs.Type2 A) (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34)) : cic.Term cic.prop (Q_ x_34 x_35)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNth_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.nth$ applied to $i$ and $A$ and $matita_basics_lists_list.nil$ applied to $A$ and $a$ and $a$.\nassistant\n", "label": "postulate nth_nil : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.nth i A (matita_basics_lists_list.nil A) a) a)", "predict": "postulate nth_nil : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.nth i A (matita_basics_lists_list.nil A) a) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1034. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_1034 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))", "predict": "postulate let_clause_1034 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_theta. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$.\nassistant\n", "label": "axiom le_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))", "predict": "axiom le_theta (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1140$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1141$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate DPair_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate DPair_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nInjective_times_l. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $m$ and $n$.\nassistant\n", "label": "postulate injective_times_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times m n))", "predict": "postulate injective_times_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnique. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop", "predict": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_Type4_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_conj$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_124$ and $x_123$, for all elements $x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_122$.\nassistant\n", "label": "postulate And_rect_Type4_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) -> (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type4 (Q_ x_122)", "predict": "postulate And_rect_Type4_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type4) -> (_H_conj : (x_124 : cic.Term cic.prop _A) -> (x_123 : cic.Term cic.prop _B) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type4 (Q_ x_122)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1326$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z1327$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_743$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_742$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_745$ from elements $_z1327$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_742$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $x_742$ and elements $_z1327$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_743$ and $x_742$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x", "label": "postulate list_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1326 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_743 : cic.Term univs.Type0 x1) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_745 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_742)) -> cic.Term univs.Type1 (P x_742)) -> (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate list_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1326 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_743 : cic.Term univs.Type0 x1) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_745 : (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_742)) -> cic.Term univs.Type1 (P x_742)) -> (_z1327 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P (matita_basics_lists_list.cons x1 x_743 x_742))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_Type2_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_698$.\nassistant\n", "label": "postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)", "predict": "postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_883$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr", "label": "Axiom Aop_rect_CProp1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_883) .", "predict": "Axiom Aop_rect_CProp1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_883 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_883) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1560. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)", "predict": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate list : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate list : (_A : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRev_append. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "Axiom rev_append : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "Axiom rev_append : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_bool. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_bool : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term return_sort (return_type z) .", "predict": "filter_bool : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_CProp4_body. Let $Q_$ be a function from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.\nassistant\n", "label": "Axiom bool_rect_CProp4_body : forall Q_ : ((_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_347 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_347) .", "predict": "Axiom bool_rect_CProp4_body : forall Q_ : ((_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_347 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_347) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_CProp0_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_116$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_116$, for all elements $x_115$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_115$.\nassistant\n", "label": "postulate Not_rect_CProp0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)", "predict": "postulate Not_rect_CProp0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRewrite_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.\nassistant\n", "label": "postulate rewrite_r : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A y x)) -> cic.Term univs.Type2 (P y)", "predict": "postulate rewrite_r : (A : cic.Univ univs.Type2) -> (x : cic.Term univs.Type2 A) -> (P : (__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P x)) -> (y : cic.Term univs.Type2 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq A y x)) -> cic.Term univs.Type2 (P y)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDecidable_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom decidable_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.divides n m)) .", "predict": "Axiom decidable_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.divides n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_inv_rect_CProp1. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom And_inv_rect_CProp1 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) : cic.Term cic.prop (P Hterm)", "predict": "axiom And_inv_rect_CProp1 (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiscr_plus_xy_minus_xz. For all elements $x$ and $z$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $matita_arithmetics_nat.minus$ applied to $x$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom discr_plus_xy_minus_xz : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x y) (matita_arithmetics_nat.minus x z)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O) .", "predict": "Axiom discr_plus_xy_minus_xz : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x y) (matita_arithmetics_nat.minus x z)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_Type4. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_nmk$ from functions $x_83$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_83$, for all elements $x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_82$.\nassistant\n", "label": "postulate Not_rect_Type4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)", "predict": "postulate Not_rect_Type4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4) -> (_H_nmk : (x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) -> (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type4 (Q_ x_82)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCongruent. Let $_n$ and $_m$ and $_p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate congruent : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrimeb. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom primeb : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom primeb : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_n_1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "exp_n_1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) .", "predict": "exp_n_1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.\nassistant\n", "label": "Axiom eq_rect_CProp0 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_37 : cic.Term univs.Type2 A, forall x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37), cic.Term cic.prop (Q_ x_37 x_38) .", "predict": "Axiom eq_rect_CProp0 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_37 : cic.Term univs.Type2 A, forall x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37), cic.Term cic.prop (Q_ x_37 x_38) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1710$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $", "label": "Axiom Dop_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom Dop_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nF_max_true. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom f_max_true : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true) .", "predict": "Axiom f_max_true : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f (matita_arithmetics_minimization.max n f)) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1559. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "postulate let_clause_1559 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)", "predict": "postulate let_clause_1559 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAnd_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom And_inv_rect_CProp0 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom And_inv_rect_CProp0 : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2), forall P : ((_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_r_ind. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to", "label": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1", "predict": "lstar_r_ind : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339 _x_1342))) -> x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod", "label": "postulate Dop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)", "predict": "postulate Dop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_965)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOr_introl. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $A$ and $B$.\nassistant\n", "label": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)", "predict": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCr_pair3. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom cr_pair3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "Axiom cr_pair3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_minus_O. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "eq_minus_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) matita_arithmetics_nat.O) .", "predict": "eq_minus_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1314$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_735$ from elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $x_732$ and elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_733$ and $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_73", "label": "axiom list_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) : cic.Term univs.Type3 (P Hterm)", "predict": "axiom list_inv_rect_Type3 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) : cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLprim_ex. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to", "label": "axiom lprim_ex : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_basics_lists_list.nil matita_arithmetics_nat.nat))))))", "predict": "axiom lprim_ex : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_basics_lists_list.cons matita_arithmetics_nat.nat (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_basics_lists_list.nil matita_arithmetics_nat.nat))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_exp_primr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate le_exp_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate le_exp_primr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nP_ord_times. Let $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord", "label": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.n", "predict": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.plus qa qb) ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_fact. For all elements $n$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $i$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "divides_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> cic.Term cic.prop (matita_arithmetics_primes.divides i (matita_arithmetics_factorial.fact n)) .", "predict": "divides_fact : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> cic.Term cic.prop (matita_arithmetics_primes.divides i (matita_arithmetics_factorial.fact n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_955$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$", "label": "postulate Dop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type0 (Q_ x_955)", "predict": "postulate Dop_rect_Type0_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type0 (Q_ x_955)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_r_sn. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "postulate lstar_r_sn : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) -> (b1 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)", "predict": "postulate lstar_r_sn : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) -> (b1 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nGcd_1_to_lt_O. For all elements $i$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $i$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $i$.\nassistant\n", "label": "axiom gcd_1_to_lt_O (i n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)", "predict": "axiom gcd_1_to_lt_O (i n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExp_pi_l. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.times$ applied to $a$ and $f$ applied to $i$.\nassistant\n", "label": "postulate exp_pi_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a n) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times a (f i))))", "predict": "postulate exp_pi_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a n) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times a (f i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1104$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1105$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom DPair_inv_ind (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term cic.prop (P Hterm)", "predict": "axiom DPair_inv_ind (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.\nassistant\n", "label": "Axiom ACop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_903) .", "predict": "Axiom ACop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_903) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill", "label": "postulate Aop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)", "predict": "postulate Aop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_CProp2_body. Let $Q_$ be a function from elements $_x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_515$.\nassistant\n", "label": "postulate unit_rect_CProp2_body : (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_515)", "predict": "postulate unit_rect_CProp2_body : (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_515)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nReflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom reflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom reflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCommutative_times. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$.\nassistant\n", "label": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)", "predict": "postulate commutative_times : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.times)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_eq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_eq : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> __ : cic.Term univs.Type2 A -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z) .", "predict": "filter_eq : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> __ : cic.Term univs.Type2 A -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.eq A _x __) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_inv_rect_Type1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z996$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$, for all functions $_H2$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sum_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Sum_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAssociative_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.associative$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$.\nassistant\n", "label": "associative_append : A : cic.Univ univs.Type0 -> cic.Term cic.prop (matita_basics_relations.associative (matita_basics_lists_list.list A) (matita_basics_lists_list.append A)) .", "predict": "associative_append : A : cic.Univ univs.Type0 -> cic.Term cic.prop (matita_basics_relations.associative (matita_basics_lists_list.list A) (matita_basics_lists_list.append A)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRC. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$.\nassistant\n", "label": "postulate RC : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.relation A)", "predict": "postulate RC : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.relation A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_ind_r. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.\nassistant\n", "label": "postulate lstar_ind_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b2)", "predict": "postulate lstar_ind_r : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) -> cic.Term cic.prop (P l b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_664$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_664$.\nassistant\n", "label": "Axiom Sig_ind_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term cic.prop (Q_ x_664) .", "predict": "Axiom Sig_ind_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term cic.prop (Q_ x_664) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBc_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom bc_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) .", "predict": "Axiom bc_n_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMap. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.\nassistant\n", "label": "postulate map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)", "predict": "postulate map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_log_n_n. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $n$.\nassistant\n", "label": "le_log_n_n : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) n) .", "predict": "le_log_n_n : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_to_dividesb_true. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom divides_to_dividesb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) .", "predict": "Axiom divides_to_dividesb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_dividesb_true. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate divides_to_dividesb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)", "predict": "postulate divides_to_dividesb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_CProp3_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_623$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_623$, for all elements $x_622$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_622$.\nassistant\n", "label": "postulate option_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> (x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_622)", "predict": "postulate option_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_623 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_623))) -> (x_622 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_622)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_previous_prime4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_previous_prime4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_previous_prime4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom ACop_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term univs.Type4 (P Hterm) .", "predict": "Axiom ACop_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2), forall P : ((_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))), cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nType0. $cic.Sort$.\nassistant\n", "label": "axiom Type0 : cic.Sort", "predict": "axiom Type0 : cic.Sort"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDecidable_not. For all elements $P$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Not$ applied to $P$.\nassistant\n", "label": "axiom decidable_not (P : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) : cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))", "predict": "axiom decidable_not (P : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) : cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_Type1_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_nmk$ from functions $x_95$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_95$, for all elements $x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_94$.\nassistant\n", "label": "Not_rect_Type1_body : _A : cic.Univ cic.prop -> Q_ : (_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type1) -> _H_nmk : (x_95 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))) -> x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type1 (Q_ x_94) .", "predict": "Not_rect_Type1_body : _A : cic.Univ cic.prop -> Q_ : (_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type1) -> _H_nmk : (x_95 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))) -> x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type1 (Q_ x_94) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_min. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $b$ and $matita_basics_bool.true$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $b$.\nassistant\n", "label": "postulate true_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b)", "predict": "postulate true_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f b) matita_basics_bool.true)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_CProp2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1416$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic", "label": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1416 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1417 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1416 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1417 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLhd_cons_ltl. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $l$ and $n$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $l$.\nassistant\n", "label": "axiom lhd_cons_ltl (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)", "predict": "axiom lhd_cons_ltl (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_Dop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_", "label": "Axiom match_Dop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort), forall case_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term return_sort (return_type z) .", "predict": "Axiom match_Dop : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort), forall case_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_S_S. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "axiom le_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))", "predict": "axiom le_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_676$.\nassistant\n", "label": "Sig_rect_Type0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type0) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type0 (Q_ x_676) .", "predict": "Sig_rect_Type0 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type0) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type0 (Q_ x_676) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1632$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1633$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom range_inv_ind : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1632 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1633 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom range_inv_ind : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1632 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1633 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.\nassistant\n", "label": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)", "predict": "axiom And_rect_Type2 (_A _B : cic.Univ cic.prop) (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type2 (Q_ x_134)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSub_hk. Let $__$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.\nassistant\n", "label": "Axiom sub_hk : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) .", "predict": "Axiom sub_hk : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_diff. For all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $i$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $x$ to $p$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $f$ applied to $x$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $op$ and $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $x$ to $matita_basics_bool.andb$ applied to $matita_basics_bool.notb$ applied to $matita_arithmetics_nat.eqb$ applied to $i$ and $x$ and $p$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $", "label": "axiom bigop_diff (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (i n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ x => p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (λ x => matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x))))", "predict": "axiom bigop_diff (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (i n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (λ x => p x) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x)) (matita_arithmetics_bigops.aop__o__op B nil op (f i) (matita_arithmetics_bigops.bigop n (λ x => matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.eqb i x)) (p x)) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (λ x => f x))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_le_minus_l. For all elements $p$ and $q$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $q$ and $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom monotonic_le_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) .", "predict": "Axiom monotonic_le_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_inv_rect_CProp0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z966$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z967$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_CProp0 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z966 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) .", "predict": "Axiom unit_inv_rect_CProp0 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z966 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H1 : ((_z967 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMem. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "mem : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 H -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Univ cic.prop .", "predict": "mem : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 H -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_of_primes. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "list_of_primes : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) .", "predict": "list_of_primes : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_inv_rect_Type0. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1266$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1267$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_Type0 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type0) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom Prod_inv_rect_Type0 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1266 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type0) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1267 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_to_le_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $m$ and $b$ and $f$.\nassistant\n", "label": "le_to_le_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min m b f)) .", "predict": "le_to_le_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min m b f)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_rect_CProp0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.\nassistant\n", "label": "Axiom Prod_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_714) .", "predict": "Axiom Prod_rect_CProp0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term cic.prop (Q_ x_714) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAppend_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$ and $l$.\nassistant\n", "label": "postulate append_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l (matita_basics_lists_list.nil A)) l)", "predict": "postulate append_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l (matita_basics_lists_list.nil A)) l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1056$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1057$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_603$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_603$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom option_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type2), forall _H1 : ((_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))), forall _H2 : ((x_603 : cic.Term univs.Type0 x1) -> (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom option_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1056 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type2), forall _H1 : ((_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type2 (P (matita_basics_types.None x1))), forall _H2 : ((x_603 : cic.Term univs.Type0 x1) -> (_z1057 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_603))) -> cic.Term univs.Type2 (P (matita_basics_types.Some x1 x_603))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $n$ and $n$.\nassistant\n", "label": "minus_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.minus n n)) .", "predict": "minus_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.minus n n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nGcd_1_to_lt_O. Let $i$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $i$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $i$.\nassistant\n", "label": "gcd_1_to_lt_O : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i) .", "predict": "gcd_1_to_lt_O : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBigop_commute. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p11$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p12$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p21$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p22$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt", "label": "postulate bigop_commute : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics", "predict": "postulate bigop_commute : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p11 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p12 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p21 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p22 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (p12 __ __1)) -> (__3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (p22 __ __1)) -> cic.Term cic.prop (matita_b"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and", "label": "postulate Aop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)", "predict": "postulate Aop_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_gen. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.\nassistant\n", "label": "axiom le_gen (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) : cic.Term cic.prop (P n)", "predict": "axiom le_gen (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) : cic.Term cic.prop (P n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMk_Prod. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_fst$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_snd$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$.\nassistant\n", "label": "postulate mk_Prod : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_fst : cic.Term univs.Type0 A) -> (_snd : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod A B)", "predict": "postulate mk_Prod : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_fst : cic.Term univs.Type0 A) -> (_snd : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_le_Sn_O. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom not_le_Sn_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) .", "predict": "Axiom not_le_Sn_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_And. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z) .", "predict": "filter_And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_O. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.O$ and $b$ and $b$.\nassistant\n", "label": "postulate lstar_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b)", "predict": "postulate lstar_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTimes_body. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom times_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom times_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMod_times_mod. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $p$ and $p$.\nassistant\n", "label": "axiom mod_times_mod (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p))", "predict": "axiom mod_times_mod (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTri_relation. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom tri_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, forall __2 : cic.Univ univs.Type0, cic.Univ univs.Type0 .", "predict": "Axiom tri_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, forall __2 : cic.Univ univs.Type0, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_plus_to_minus_r. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.\nassistant\n", "label": "Axiom lt_plus_to_minus_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c), cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b)) .", "predict": "Axiom lt_plus_to_minus_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c), cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_eq_O_S. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "Axiom not_eq_O_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) .", "predict": "Axiom not_eq_O_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15621. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arith", "label": "Axiom let_clause_15621 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O", "predict": "Axiom let_clause_15621 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S mat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPredicate. For all elements $__$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "predicate : __ : cic.Univ univs.Type0 -> cic.Univ univs.Type0 .", "predict": "predicate : __ : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and", "label": "Axiom Aop_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type5 (Q_ x_785) .", "predict": "Axiom Aop_rect_Type5_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type5 (Q_ x_785) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_times. For all elements $n$ and $m$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.\nassistant\n", "label": "postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))", "predict": "postulate divides_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times p q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_f. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type2$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Term$ of $univs.Type2$ and $B$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $f$ applied to $x$ and $f$ applied to $y$.\nassistant\n", "label": "Axiom eq_f : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> cic.Term univs.Type2 B), forall x : cic.Term univs.Type2 A, forall y : cic.Term univs.Type2 A, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x y), cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y)) .", "predict": "Axiom eq_f : forall A : cic.Univ univs.Type2, forall B : cic.Univ univs.Type2, forall f : ((__ : cic.Term univs.Type2 A) -> cic.Term univs.Type2 B), forall x : cic.Term univs.Type2 A, forall y : cic.Term univs.Type2 A, forall __ : cic.Term cic.prop (matita_basics_logic.eq A x y), cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSub_comp_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ and $R1$ and $R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $R1$ and $R2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R$ and $R2$.\nassistant\n", "label": "sub_comp_r : A : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2)) .", "predict": "sub_comp_r : A : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> __ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_rect_CProp4. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_753$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_752$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_755$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_752$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_753$ and $x_752$, for all elements $x_751$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_751$.\nassistant\n", "label": "list_rect_CProp4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_753 : cic.Term univs.Type0 _A -> x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_755 : cic.Term cic.prop (Q_ x_752) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_751) .", "predict": "list_rect_CProp4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_753 : cic.Term univs.Type0 _A -> x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_755 : cic.Term cic.prop (Q_ x_752) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_753 x_752))) -> x_751 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_751) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_ind. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_690$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_690$.\nassistant\n", "label": "Prod_ind : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_690) .", "predict": "Prod_ind : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ cic.prop) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term cic.prop (Q_ x_690) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_ex. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_ex : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z) .", "predict": "filter_ex : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1704$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $", "label": "Axiom Dop_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type4 (P Hterm) .", "predict": "Axiom Dop_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNth. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "postulate nth : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate nth : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_Type4_body. For all functions $Q_$ from elements $_x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_67$.\nassistant\n", "label": "Axiom False_rect_Type4_body : forall Q_ : ((_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4), forall x_67 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type4 (Q_ x_67) .", "predict": "Axiom False_rect_Type4_body : forall Q_ : ((_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4), forall x_67 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type4 (Q_ x_67) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null", "label": "Dop_rect_Type5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type5) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type5 (Q_ x_947) .", "predict": "Dop_rect_Type5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type5) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type5 (Q_ x_947) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_eq_O_S. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "not_eq_O_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) .", "predict": "not_eq_O_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.S n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_sqrt_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.\nassistant\n", "label": "axiom lt_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)", "predict": "axiom lt_sqrt_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt n) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nP_ord_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.\nassistant\n", "label": "Axiom p_ord_exp1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) .", "predict": "Axiom p_ord_exp1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_le_to_not_le_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "postulate not_le_to_not_le_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))", "predict": "postulate not_le_to_not_le_S_S : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_S_mod. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)", "predict": "axiom permut_S_mod (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPermut_S_to_permut_transpose. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $f$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $m$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "permut_S_to_permut_transpose : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m) .", "predict": "permut_S_to_permut_transpose : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $", "label": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g2 i)))) (Hle : (i : cic.Term univs.Type", "predict": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g2 i)))) (axiom : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g2 i)))) : cic.Term cic.prop (matita_basics_logic"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_found_min_spec. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "not_found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) .", "predict": "not_found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMonotonic_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ and $b$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $g$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $b$.\nassistant\n", "label": "axiom monotonic_iter (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (a b i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))", "predict": "axiom monotonic_iter (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (a b i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExists_add. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $x$ and $l2$.\nassistant\n", "label": "axiom Exists_add (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))", "predict": "axiom Exists_add (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_O_to_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.\nassistant\n", "label": "mod_O_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) .", "predict": "mod_O_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_upper_bound2. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom let_upper_bound2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom let_upper_bound2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNotb. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "notb : __ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "notb : __ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_CProp2_body. For all functions $Q_$ from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.\nassistant\n", "label": "bool_rect_CProp2_body : Q_ : (_x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_356) .", "predict": "bool_rect_CProp2_body : Q_ : (_x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_356 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_356) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_to_le_times_to_lt_S_to_div. Let $a$ and $c$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.times$ applied to $b$ and $matita_arithmetics_nat.S$ applied to $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $b$ and $c$.\nassistant\n", "label": "postulate lt_to_le_times_to_lt_S_to_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c)", "predict": "postulate lt_to_le_times_to_lt_S_to_div : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times b c) a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.times b (matita_arithmetics_nat.S c)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div a b) c)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEqb_sym. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $a$ and $b$ and $matita_arithmetics_nat.eqb$ applied to $b$ and $a$.\nassistant\n", "label": "axiom eqb_sym (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a))", "predict": "axiom eqb_sym (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop__o__op. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $x0$, $cic.Term$ holds for $univs.Type0$ and $x0$.\nassistant\n", "label": "aop__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 .", "predict": "aop__o__op : x0 : cic.Univ univs.Type0 -> x1 : cic.Term univs.Type0 x0 -> x2 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1) -> _x_887 : cic.Term univs.Type0 x0 -> _x_888 : cic.Term univs.Type0 x0 -> cic.Term univs.Type0 x0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $len$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt2m$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.n", "label": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_square_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom le_square_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) .", "predict": "Axiom le_square_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_1_to_divides_times_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $m$.\nassistant\n", "label": "postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)", "predict": "postulate gcd_1_to_divides_times_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nassistant\n", "label": "axiom range_rect_CProp1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)", "predict": "axiom range_rect_CProp1_body (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_CProp5. Let $Q_$ be a function from elements $_x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_490$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_490$.\nassistant\n", "label": "postulate void_rect_CProp5 : (Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_490)", "predict": "postulate void_rect_CProp5 : (Q_ : (_x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_490 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_490)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_Type2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nassistant\n", "label": "range_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) .", "predict": "range_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type2) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type2 (Q_ x_923) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_x_times_x. Let $x$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.\nassistant\n", "label": "axiom le_x_times_x (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))", "predict": "axiom le_x_times_x (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_rect_Type2_body. For all functions $Q_$ from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nassistant\n", "label": "unit_rect_Type2_body : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) .", "predict": "unit_rect_Type2_body : Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it) -> x_503 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type2 (Q_ x_503) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExists_mid. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $matita_basics_lists_list.cons$ applied to $A$ and $x$ and $l2$.\nassistant\n", "label": "axiom Exists_mid (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (P x)) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))", "predict": "axiom Exists_mid (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (x : cic.Term univs.Type0 A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (P x)) : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 (matita_basics_lists_list.cons A x l2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqb_false_to_not_eq. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "eqb_false_to_not_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) .", "predict": "eqb_false_to_not_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x", "label": "Dop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_965) .", "predict": "Dop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_965) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAppend_l2_injective_r. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.\nassistant\n", "label": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)", "predict": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1242$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1243$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_Type4 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type4 (P Hterm)", "predict": "axiom Prod_inv_rect_Type4 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1242 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ univs.Type4) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1243 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_inv_rect_Type0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z683$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_392$ from elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $x_390$ and elements $_z684$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "nat_inv_rect_Type0 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> _H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390) -> cic.Term univs.Type0 (P x_390)) -> _z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390)) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "nat_inv_rect_Type0 : Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (_z683 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H1 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O) -> cic.Term univs.Type0 (P matita_arithmetics_nat.O)) -> _H2 : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : (_z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_390) -> cic.Term univs.Type0 (P x_390)) -> _z684 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_390)) -> cic.Term univs.Type0 (P (matita_arithmetics_nat.S x_390))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOr_introl. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $A$ and $B$.\nassistant\n", "label": "Axiom or_introl : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, cic.Term cic.prop (matita_basics_logic.Or A B) .", "predict": "Axiom or_introl : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, cic.Term cic.prop (matita_basics_logic.Or A B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_times_n_to_lt_r. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.\nassistant\n", "label": "axiom lt_times_n_to_lt_r (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)", "predict": "axiom lt_times_n_to_lt_r (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) .", "predict": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAssoc. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.\nassistant\n", "label": "Axiom assoc : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c)) .", "predict": "Axiom assoc : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1086$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1087$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_627$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1087$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_627$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_627$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom option_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1086 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop), forall _H1 : ((_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))), forall _H2 : ((x_627 : cic.Term univs.Type0 x1) -> (_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_627))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_627))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom option_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.option x1), forall P : ((_z1086 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop), forall _H1 : ((_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))), forall _H2 : ((x_627 : cic.Term univs.Type0 x1) -> (_z1087 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_627))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_627))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCons. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.\nassistant\n", "label": "cons : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) .", "predict": "cons : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDecidable_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.\nassistant\n", "label": "decidable_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m)) .", "predict": "decidable_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.\nassistant\n", "label": "postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))", "predict": "postulate not_divides_to_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMod_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.\nassistant\n", "label": "axiom mod_p_ord_inv (p m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p))", "predict": "axiom mod_p_ord_inv (p m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_753$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_752$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_755$ from elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_752$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_752$ and elements $_z1339$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_753$ and $x_752$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_753$ and $x_752$, $cic.Term$ holds for $c", "label": "axiom list_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_753 : cic.Term univs.Type0 x1) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752)) -> cic.Term cic.prop (P x_752)) -> (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1338 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_753 : cic.Term univs.Type0 x1) -> (x_752 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_755 : (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_752)) -> cic.Term cic.prop (P x_752)) -> (_z1339 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_753 x_752))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_753 x_752))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRelation3. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "relation3 : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 .", "predict": "relation3 : __ : cic.Univ univs.Type0 -> __1 : cic.Univ univs.Type0 -> __2 : cic.Univ univs.Type0 -> cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_rect_Type3_body. For all functions $Q_$ from elements $_x_501$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_it$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_501$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_501$.\nassistant\n", "label": "unit_rect_Type3_body : Q_ : (_x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type3) -> _H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it) -> x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type3 (Q_ x_501) .", "predict": "unit_rect_Type3_body : Q_ : (_x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type3) -> _H_it : cic.Term univs.Type3 (Q_ matita_basics_types.it) -> x_501 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type3 (Q_ x_501) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_rect_CProp1_body. Let $Q_$ be a function from elements $_x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_62$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_62$.\nassistant\n", "label": "True_rect_CProp1_body : Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_62) .", "predict": "True_rect_CProp1_body : Q_ : (_x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_62 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_62) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x", "label": "axiom Aop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_799)", "predict": "axiom Aop_rect_CProp3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_799)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMk_ACop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $aop$ and $b$ and $a$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.\nassistant\n", "label": "Axiom mk_ACop : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall _comm : ((a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))), cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil) .", "predict": "Axiom mk_ACop : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall _comm : ((a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil aop a b) (matita_arithmetics_bigops.op A nil aop b a))), cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_rect_Type4. For all functions $Q_$ from elements $_x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_true$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_329$.\nassistant\n", "label": "postulate bool_rect_Type4 : (Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)) -> (x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ x_329)", "predict": "postulate bool_rect_Type4 : (Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) -> (_H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)) -> (x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type4 (Q_ x_329)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNone. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)", "predict": "postulate None : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_types.option A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_15625. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs", "label": "postulate let_clause_15625 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (mat", "predict": "postulate let_clause_15625 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nP_ord_exp. For all elements $n$ and $m$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $i$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $i$ and $n$.\nassistant\n", "label": "Axiom p_ord_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)), forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le i p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m i) n) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat i n)) .", "predict": "Axiom p_ord_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)), forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le i p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m i) n) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat i n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_plus_Sn_r. Let $a$ and $x$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $x$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "postulate lt_plus_Sn_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus a x) (matita_arithmetics_nat.S n)))", "predict": "postulate lt_plus_Sn_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus a x) (matita_arithmetics_nat.S n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1176$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1177$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Sig_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1176 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type4) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1177 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type4 (P Hterm) .", "predict": "Sig_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1176 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type4) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1177 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type4 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_to_nth_prime. Let $p$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $p$.\nassistant\n", "label": "Axiom prime_to_nth_prime : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime i) p)) .", "predict": "Axiom prime_to_nth_prime : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime i) p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_to_divides_ord_rem. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.\nassistant\n", "label": "divides_to_divides_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) .", "predict": "divides_to_divides_ord_rem : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFound_max_spec. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $n$ and $f$ and $m$.\nassistant\n", "label": "axiom found_max_spec (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) : cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m)", "predict": "axiom found_max_spec (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) : cic.Term cic.prop (matita_arithmetics_minimization.max_spec n f m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type0. Let $Q_$ be a function from elements $_x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_H_I$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_52$.\nassistant\n", "label": "axiom True_rect_Type0 (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)", "predict": "axiom True_rect_Type0 (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_plus_to_lt_r. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.\nassistant\n", "label": "lt_plus_to_lt_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q) .", "predict": "lt_plus_to_lt_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q)) -> cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_le_minus_r. For all elements $p$ and $q$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $q$.\nassistant\n", "label": "Axiom monotonic_le_minus_r : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q)) .", "predict": "Axiom monotonic_le_minus_r : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le q p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nType3. $cic.Sort$.\nassistant\n", "label": "Axiom Type3 : cic.Sort .", "predict": "Axiom Type3 : cic.Sort ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFind. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.\nassistant\n", "label": "find : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 (matita_basics_types.option B)) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option B) .", "predict": "find : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 (matita_basics_types.option B)) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDistr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.\nassistant\n", "label": "Axiom distr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) .", "predict": "Axiom distr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTranspose_i_j_j. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $j$ and $i$.\nassistant\n", "label": "axiom transpose_i_j_j (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j j) i)", "predict": "axiom transpose_i_j_j (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j j) i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTimes_Sn_m. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$.\nassistant\n", "label": "postulate times_Sn_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus m (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) m))", "predict": "postulate times_Sn_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus m (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLhd. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "lhd : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "lhd : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nM. Let $_m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "M : _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "M : _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.\nassistant\n", "label": "Axiom ACop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_905) .", "predict": "Axiom ACop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_905) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMod_S. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.\nassistant\n", "label": "axiom mod_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)))", "predict": "axiom mod_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_O_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.\nassistant\n", "label": "Axiom lt_O_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) .", "predict": "Axiom lt_O_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for", "label": "Axiom Aop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_861) .", "predict": "Axiom Aop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_861) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nIter_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "iter_body : H : cic.Univ univs.Type0 -> __ : (__ : cic.Term univs.Type0 H -> cic.Term univs.Type0 H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 H -> cic.Term univs.Type0 H .", "predict": "iter_body : H : cic.Univ univs.Type0 -> __ : (__ : cic.Term univs.Type0 H -> cic.Term univs.Type0 H) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 H -> cic.Term univs.Type0 H ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_SO_nth_prime_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.\nassistant\n", "label": "axiom lt_SO_nth_prime_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.nth_prime n))", "predict": "axiom lt_SO_nth_prime_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.nth_prime n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom div_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) (matita_arithmetics_div_and_mod.mod n m))) .", "predict": "Axiom div_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) (matita_arithmetics_div_and_mod.mod n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_rect_CProp2. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z173$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z174$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_670$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_670$.\nassistant\n", "label": "Sig_rect_Type3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type3) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type3 (Q_ x_670) .", "predict": "Sig_rect_Type3_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type3) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type3 (Q_ x_670) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_to_le_max. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$.\nassistant\n", "label": "postulate true_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f))", "predict": "postulate true_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_exists_to_forall. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.\nassistant\n", "label": "axiom not_exists_to_forall (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) : cic.Term cic.prop (matita_basics_logic.Not (P i))", "predict": "axiom not_exists_to_forall (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) : cic.Term cic.prop (matita_basics_logic.Not (P i))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_", "label": "Axiom Aop_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) .", "predict": "Axiom Aop_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRelation. Let $__$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "axiom relation (__ : cic.Univ univs.Type0) : cic.Univ univs.Type0", "predict": "axiom relation (__ : cic.Univ univs.Type0) : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $a1$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $a1$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_list$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_lists_list.match_list$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z47$ to $P$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ and $t1$ to $matita_basics_lists_list.match_list$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $", "label": "Axiom list_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall y : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list a1)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z47 => P))) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => fun t1 => matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type", "predict": "Axiom list_discr : forall a1 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall y : cic.Term univs.Type0 (matita_basics_lists_list.list a1), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list a1)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 P (fun _z47 => P))) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) y) (fun t0 => fun t1 => matita_basics_lists_list.match_list a1 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => P)) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun _e0 => P)) (fun _z48 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$.\nassistant\n", "label": "postulate sum : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)", "predict": "postulate sum : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_O_theta. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$.\nassistant\n", "label": "Axiom lt_O_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) .", "predict": "Axiom lt_O_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_chebyshev_chebyshev_theta.theta n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_CProp4. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.\nassistant\n", "label": "Axiom False_rect_CProp4 : forall Q_ : ((_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_73 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_73) .", "predict": "Axiom False_rect_CProp4 : forall Q_ : ((_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_73 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_73) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.\nassistant\n", "label": "DPair_rect_CProp1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_660) .", "predict": "DPair_rect_CProp1_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_660) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_Type0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_676$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_676$.\nassistant\n", "label": "Sig_rect_Type0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type0) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type0 (Q_ x_676) .", "predict": "Sig_rect_Type0_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ univs.Type0) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term univs.Type0 (Q_ x_676) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_not. For all elements $P$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Not$ applied to $P$.\nassistant\n", "label": "postulate decidable_not : (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))", "predict": "postulate decidable_not : (P : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Not P))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_bertrand_to_le1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom not_bertrand_to_le1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) .", "predict": "Axiom not_bertrand_to_le1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAxiom. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then the equivalence of $_A$ and $_B$ is an element of $cic.Univ$ of $cic.prop$.\nassistant\n", "label": "iff : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop .", "predict": "eq : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom exp_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom exp_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSucc. Assume that $Sort$. Then $Sort$.\nassistant\n", "label": "Axiom succ : Sort -> Sort .", "predict": "Axiom succ : Sort -> Sort ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_sigma. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1", "label": "le_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arith", "predict": "le_sigma : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> __1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (p1 n) (p2 n)) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nVoid_rect_CProp3_body. For all functions $Q_$ from elements $_x_491$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_491$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_491$.\nassistant\n", "label": "Axiom void_rect_CProp3_body : forall Q_ : ((_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_491 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_491) .", "predict": "Axiom void_rect_CProp3_body : forall Q_ : ((_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_491 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_491) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_rect_CProp2. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then for all functions $P$ from elements $_z173$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z174$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp2 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z173 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_73. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.\nassistant\n", "label": "postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))", "predict": "postulate let_clause_73 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) -> (x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type5_body. For all functions $Q_$ from elements $_x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_I$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_44$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_44$.\nassistant\n", "label": "axiom True_rect_Type5_body (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) (x_44 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type5 (Q_ x_44)", "predict": "axiom True_rect_Type5_body (Q_ : (_x_44 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type5) (_H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I)) (x_44 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type5 (Q_ x_44)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all functions $a2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $a1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_DPair$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and", "label": "DPair_discr : a1 : cic.Univ univs.Type0 -> a2 : (__ : cic.Term univs.Type0 a1 -> cic.Univ univs.Type0) -> x : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) -> y : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 a1 => t1 : cic.Term univs.Type0 (a2 t0) => matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => u1 : cic.Term univs.Type0 (a2 u0) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) => a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (x0 : cic.Term univs.Type", "predict": "DPair_discr : a1 : cic.Univ univs.Type0 -> a2 : (__ : cic.Term univs.Type0 a1 -> cic.Univ univs.Type0) -> x : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) -> y : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair a1 a2)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 a1 => t1 : cic.Term univs.Type0 (a2 t0) => matita_basics_types.match_DPair a1 a2 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.DPair a1 a2) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 a1 => u1 : cic.Term univs.Type0 (a2 u0) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : cic.Term univs.Type0 a1 => p0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCongruent_times. Let $n$ and $m$ and $n1$ and $m1$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $n1$ and $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $m$ and $m1$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n1$ and $m1$ and $p$.\nassistant\n", "label": "postulate congruent_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n n1 p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_congruence.congruent m m1 p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p)", "predict": "postulate congruent_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n n1 p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_congruence.congruent m m1 p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent (matita_arithmetics_nat.times n m) (matita_arithmetics_nat.times n1 m1) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_Sig. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (case_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (case_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term return_sort (return_type (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_100$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_101$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_101$, for all elements $x_100$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_100$.\nassistant\n", "label": "postulate Not_rect_CProp4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)", "predict": "postulate Not_rect_CProp4 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1569. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics", "label": "Axiom let_clause_1569 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))),", "predict": "Axiom let_clause_1569 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_upper_bound3. Let $n$ and $m$ and $x$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_upper_bound3 (n m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_upper_bound3 (n m x : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSnd_body. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.\nassistant\n", "label": "postulate snd_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 B", "predict": "postulate snd_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term univs.Type0 B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAntisymmetric_divides. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "antisymmetric_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) .", "predict": "antisymmetric_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_Type1_r. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $__$ of $cic.Term$ of $univs.Type1$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $x$ and $p$.\nassistant\n", "label": "eq_rect_Type1_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type1) -> __ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type1 (P x p) .", "predict": "eq_rect_Type1_r : A : cic.Univ univs.Type2 -> a : cic.Term univs.Type2 A -> P : (x : cic.Term univs.Type2 A -> __ : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Univ univs.Type1) -> __ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a)) -> x : cic.Term univs.Type2 A -> p : cic.Term cic.prop (matita_basics_logic.eq A x a) -> cic.Term univs.Type1 (P x p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.\nassistant\n", "label": "axiom And_rect_Type5 (_A _B : cic.Univ cic.prop) (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type5 (Q_ x_126)", "predict": "axiom And_rect_Type5 (_A _B : cic.Univ cic.prop) (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type5 (Q_ x_126)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_range. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "match_range : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ return_sort) -> case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z) .", "predict": "match_range : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ return_sort) -> case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPsi_3. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) .", "predict": "Axiom Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDividesb_div_true. Let $d$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $d$ and $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom dividesb_div_true : forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) .", "predict": "Axiom dividesb_div_true : forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb d n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb (matita_arithmetics_div_and_mod.div n d) n) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_rect_Type0. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z155$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z156$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_Type0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z155 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) -> (_H1 : (_z156 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type0 (P matita_basics_logic.I)) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate True_inv_rect_Type0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z155 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) -> (_H1 : (_z156 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type0 (P matita_basics_logic.I)) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExp_S_sigma_p. Let $a$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $k$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $k$ to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $n$ and $k$.\nassistant\n", "label": "axiom exp_S_sigma_p (a n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ k => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ k => matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k)))))", "predict": "axiom exp_S_sigma_p (a n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ k => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ k => matita_arithmetics_nat.times (matita_arithmetics_binomial.bc n k) (matita_arithmetics_exp.exp a (matita_arithmetics_nat.minus n k)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_Type3. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_821$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type3 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3), forall _H_div_mod_spec_intro : ((x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))), forall x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type3 (Q_ x_821) .", "predict": "Axiom div_mod_spec_rect_Type3 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3), forall _H_div_mod_spec_intro : ((x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))), forall x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type3 (Q_ x_821) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLog_exp1. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$.\nassistant\n", "label": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) .", "predict": "log_exp1 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_exp.exp n m)) (matita_arithmetics_nat.times m (matita_arithmetics_nat.S (matita_arithmetics_log.log p n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_inv_rect_Type1. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then for all functions $P$ from elements $_z149$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_901$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_901$.\nassistant\n", "label": "ACop_rect_Type0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type0) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type0 (Q_ x_901) .", "predict": "ACop_rect_Type0 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type0) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_901 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type0 (Q_ x_901) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_873$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and", "label": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_873)", "predict": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_873)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10331. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g2$ applied to $i$, for all functions $Hle", "label": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g2 i)))) (Hle : (i : cic.Term univs.Type", "predict": "axiom let_clause_10331 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g2 i)))) (Hle : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n)) -> cic.Term cic.prop (matita_basics_bool.le (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => g1 i)) (matita_arithmetics_bigops.bigop n1 (λ i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOrb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate orb_true_r1 : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)", "predict": "postulate orb_true_r1 : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_to_decidable_eq. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.\nassistant\n", "label": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))", "predict": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_priml. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom le_priml (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))", "predict": "axiom le_priml (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAppend. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "Axiom append : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "Axiom append : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nHint_declaration_CProp0. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all elements $_a$ and $_b$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom hint_declaration_CProp0 : forall A : cic.Univ cic.prop, forall _a : cic.Term cic.prop A, forall _b : cic.Term cic.prop A, cic.Univ univs.Type0 .", "predict": "Axiom hint_declaration_CProp0 : forall A : cic.Univ cic.prop, forall _a : cic.Term cic.prop A, forall _b : cic.Term cic.prop A, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_le_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom not_le_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n)) .", "predict": "Axiom not_le_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z317$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_116$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z318$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_116$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_116$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_CProp0 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z317 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_116 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z318 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Not_inv_rect_CProp0 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z317 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_116 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z318 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOr_intror. Let $A$ and $B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $A$ and $B$.\nassistant\n", "label": "Axiom or_intror : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop B, cic.Term cic.prop (matita_basics_logic.Or A B) .", "predict": "Axiom or_intror : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop B, cic.Term cic.prop (matita_basics_logic.Or A B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_rect_Type4_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_590$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_None$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_591$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_591$, for all elements $x_590$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_590$.\nassistant\n", "label": "option_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type4) -> _H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_591 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type4 (Q_ x_590) .", "predict": "option_rect_Type4_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type4) -> _H_None : cic.Term univs.Type4 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_591 : cic.Term univs.Type0 _A -> cic.Term univs.Type4 (Q_ (matita_basics_types.Some _A x_591))) -> x_590 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type4 (Q_ x_590) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBc_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate bc_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate bc_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRefute_none_by_refl. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $E$ to $matita_basics_logic.match_False$ applied to $univs.Type0$ and the function that maps $_0$ to $B$ and $H$ applied to $E$ and the function that maps $v$ and $_0$ to $P$ applied to $v$ and $x$ and $matita", "label": "axiom refute_none_by_refl (A B : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) : cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (λ y => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (λ __1 => B)) (λ E => matita_basics_logic.match_False univs.Type0 (λ _0 => B) (H E)) (λ v => λ _0 => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))", "predict": "axiom refute_none_by_refl (A B : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) : cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (λ y => cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (λ __1 => B)) (λ E => matita_basics_logic.match_False univs.Type0 (λ _0 => B) (H E)) (λ v => λ _0 => P v) x (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExp_fact_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.\nassistant\n", "label": "postulate exp_fact_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))", "predict": "postulate exp_fact_2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTimes_mod. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $c$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_div_and_mod.mod$ applied to $a$ and $b$.\nassistant\n", "label": "times_mod : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)) (matita_arithmetics_nat.times c (matita_arithmetics_div_and_mod.mod a b))) .", "predict": "times_mod : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b c)) (matita_arithmetics_nat.times c (matita_arithmetics_div_and_mod.mod a b))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp1_body. Let $Q_$ be a function from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "axiom nat_rect_CProp1_body (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)", "predict": "axiom nat_rect_CProp1_body (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1584$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1585$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) .", "predict": "ACop_inv_rect_Type2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1584 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type2) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1585 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_max_to_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "lt_max_to_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) .", "predict": "lt_max_to_false : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt m n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_ind. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_718$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_717$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_720$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_717$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_718$ and $x_717$, for all elements $x_716$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_716$.\nassistant\n", "label": "list_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) .", "predict": "list_ind : _A : cic.Univ univs.Type0 -> Q_ : (_x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_718 : cic.Term univs.Type0 _A -> x_717 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_720 : cic.Term cic.prop (Q_ x_717) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_718 x_717))) -> x_716 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_716) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_CProp2_body. Let $Q_$ be a function from elements $_x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_492$.\nassistant\n", "label": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)", "predict": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_CProp2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.\nassistant\n", "label": "Sig_rect_CProp2_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_684) .", "predict": "Sig_rect_CProp2_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_684) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_max_f_max_g. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $g$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.\nassistant\n", "label": "Axiom le_max_f_max_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) .", "predict": "Axiom le_max_f_max_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAppend_l1_injective_r. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "Axiom append_l1_injective_r : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4)), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) .", "predict": "Axiom append_l1_injective_r : forall A : cic.Univ univs.Type0, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4)), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$", "label": "axiom Dop_rect_Type5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type5 (Q_ x_947)", "predict": "axiom Dop_rect_Type5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type5 (Q_ x_947)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_max_spec. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$, for all functions $case_not_found_max_spec$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $mat", "label": "Axiom match_max_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort), forall case_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))), forall case_not_found_max_spec : ((__ : (i : cic.Term univs.Type0 mat", "predict": "Axiom match_max_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort), forall case_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))), forall case_not_found_max_spec : ((__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type _n (matita_arithmetics_minimization.not_found_max_spec _n _f))), cic.Term return_sort (return_type _n (matita_arithmetics_minimization.match_max_spec _n _f return_sort return_type case_found_max_spec case_not_found_max_spec)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEx2_intro. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $Q$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $P$ and $Q$.\nassistant\n", "label": "axiom ex2_intro (A : cic.Univ univs.Type0) (P Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (x : cic.Term univs.Type0 A) (__ : cic.Term cic.prop (P x)) (__1 : cic.Term cic.prop (Q x)) : cic.Term cic.prop (matita_basics_logic.ex2 A P Q)", "predict": "axiom ex2_intro (A : cic.Univ univs.Type0) (P Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (x : cic.Term univs.Type0 A) (__ : cic.Term cic.prop (P x)) (__1 : cic.Term cic.prop (Q x)) : cic.Term cic.prop (matita_basics_logic.ex2 A P Q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_mod_aux_m_m. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.mod_aux$ applied to $p$ and $n$ and $m$ and $m$.\nassistant\n", "label": "le_mod_aux_m_m : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m) .", "predict": "le_mod_aux_m_m : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod_aux p n m) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.\nassistant\n", "label": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)", "predict": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_to_lt_to_lt. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$.\nassistant\n", "label": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)", "predict": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_x_times_x. Let $x$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.\nassistant\n", "label": "le_x_times_x : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x)) .", "predict": "le_x_times_x : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1575. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of", "label": "axiom let_clause_1575 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (mat", "predict": "axiom let_clause_1575 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom min : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom min : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMem_map_forward. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $B$ and $f$ applied to $a$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$.\nassistant\n", "label": "postulate mem_map_forward : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l)) -> cic.Term cic.prop (matita_basics_lists_list.mem B (f a) (matita_basics_lists_list.map A B f l))", "predict": "postulate mem_map_forward : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a l)) -> cic.Term cic.prop (matita_basics_lists_list.mem B (f a) (matita_basics_lists_list.map A B f l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1512$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$", "label": "Aop_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1512 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type3) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1513 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "Aop_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1512 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ univs.Type3) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1513 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExp_2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $n$.\nassistant\n", "label": "axiom exp_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n))", "predict": "axiom exp_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times n n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_Type2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_None$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_603$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_603$, for all elements $x_602$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_602$.\nassistant\n", "label": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)", "predict": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z972$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_522$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_522$, for all functions $_H2$ from elements $x_523$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z973$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_523$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z972 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_522 : cic.Term univs.Type0 x1) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_522))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_522))) -> (_H2 : (x_523 : cic.Term univs.Type0 x2) -> (_z973 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_523))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_le. For all elements $_n$ and $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_le : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_arithmetics_nat.le _n __), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_le : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_arithmetics_nat.le _n __), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_Type4_body. For all functions $Q_$ from elements $_x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_true$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_329$.\nassistant\n", "label": "Axiom bool_rect_Type4_body : forall Q_ : ((_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4), forall _H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false), forall x_329 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type4 (Q_ x_329) .", "predict": "Axiom bool_rect_Type4_body : forall Q_ : ((_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4), forall _H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false), forall x_329 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type4 (Q_ x_329) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEqb_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate eqb_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n n) matita_basics_bool.true)", "predict": "postulate eqb_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n n) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type0. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_conj$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_144$ and $x_143$, for all elements $x_142$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_142$.\nassistant\n", "label": "axiom And_rect_Type0 (_A _B : cic.Univ cic.prop) (Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type0) (_H_conj : (x_144 : cic.Term cic.prop _A) -> (x_143 : cic.Term cic.prop _B) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) (x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type0 (Q_ x_142)", "predict": "axiom And_rect_Type0 (_A _B : cic.Univ cic.prop) (Q_ : (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type0) (_H_conj : (x_144 : cic.Term cic.prop _A) -> (x_143 : cic.Term cic.prop _B) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) (x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type0 (Q_ x_142)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_rect_Type4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A", "label": "Axiom Dop_rect_Type4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type4 (Q_ x_945) .", "predict": "Axiom Dop_rect_Type4_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type4), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type4 (Q_ x_945) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_CProp0. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.\nassistant\n", "label": "Axiom list_rect_CProp0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))), forall x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_776) .", "predict": "Axiom list_rect_CProp0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))), forall x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_776) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.\nassistant\n", "label": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)", "predict": "postulate nat_case : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBi_relation. Let $__$ and $__1$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom bi_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, cic.Univ univs.Type0 .", "predict": "Axiom bi_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_of_primes_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom list_of_primes_def (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_chebyshev_bertrand256.lprim n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)))", "predict": "axiom list_of_primes_def (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_chebyshev_bertrand256.lprim n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_797$ of", "label": "Aop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_797) .", "predict": "Aop_rect_CProp5_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_797) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLhd_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "postulate lhd_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "postulate lhd_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_upper_bound4. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom let_upper_bound4 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom let_upper_bound4 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCommutative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.\nassistant\n", "label": "Axiom commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus) .", "predict": "Axiom commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1230$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1231$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sig_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Sig_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2), forall P : ((_z1230 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1231 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_pair_fst_snd. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $p$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $p$.\nassistant\n", "label": "postulate eq_pair_fst_snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))", "predict": "postulate eq_pair_fst_snd : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSplit_rev_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $H$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "axiom split_rev_body (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))", "predict": "axiom split_rev_body (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLtl_body. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "axiom ltl_body (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "axiom ltl_body (H : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_698$.\nassistant\n", "label": "Prod_rect_Type2 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type2) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type2 (Q_ x_698) .", "predict": "Prod_rect_Type2 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type2) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type2 (Q_ x_698) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMap_body. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.\nassistant\n", "label": "postulate map_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)", "predict": "postulate map_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_lists_list.list B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom min_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom min_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : ((__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_le_to_not_le_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "not_le_to_not_le_S_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) .", "predict": "not_le_to_not_le_S_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_ind. For all functions $Q_$ from elements $_x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_366$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_368$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_366$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_366$, for all elements $x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_365$.\nassistant\n", "label": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)", "predict": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nK_def. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom k_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) .", "predict": "Axiom k_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1063. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $permf$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lein$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $lejn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $b$ and $j$,", "label": "axiom let_clause_1063 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b)", "predict": "axiom let_clause_1063 (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) (i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBi_RC. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$.\nassistant\n", "label": "bi_RC : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) .", "predict": "bi_RC : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_inv_rect_CProp2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1152$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1153$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1152 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1153 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom DPair_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1152 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1153 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_943$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of", "label": "Dop_ind : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_943) .", "predict": "Dop_ind : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_943 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_943) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$", "label": "Axiom Dop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom Dop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLeb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.leb$ applied to $n$ and $m$.\nassistant\n", "label": "axiom leb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))", "predict": "axiom leb_elim (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_times_gcd_aux. Let $p$ and $m$ and $n$ and $d$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $m$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_nat.times$ applied to $c$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.\nassistant\n", "label": "Axiom divides_times_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __3 : cic.Term cic.prop (matita_arithmetics_nat.le n p), forall __4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m)), forall __5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n)), cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n))) .", "predict": "Axiom divides_times_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n m), forall __3 : cic.Term cic.prop (matita_arithmetics_nat.le n p), forall __4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m)), forall __5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n)), cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0", "label": "postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \\ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \\ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ u1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a2 a) a)) -> \\ u2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a a2) a)) -> \\ u3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (u0 a (u0 b c)) (u0 (u0 a b) c))) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (\\ __ : cic.Term univs.Type0 a1 -> cic.prod univs.Type0 univs.Type0 a1 (\\ __1 : cic.Term univs.Type0 a1 -> a1", "predict": "postulate Aop_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 a1) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop a1 a2)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 a1) -> (__1 : cic.Term univs.Type0 a1) -> cic.Term univs.Type0 a1) -> \\ t1 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a2 a) a)) -> \\ t2 : ((a : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a a2) a)) -> \\ t3 : ((a : cic.Term univs.Type0 a1) -> (b : cic.Term univs.Type0 a1) -> (c : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (t0 a (t0 b c)) (t0 (t0 a b) c))) -> matita_arithmetics_bigops.match_Aop a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop a1 a2) -> cic.univ univs.Type2"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSome. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "axiom Some (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 A) : cic.Term univs.Type0 (matita_basics_types.option A)", "predict": "axiom Some (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 A) : cic.Term univs.Type0 (matita_basics_types.option A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nACop_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_889$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_889$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_889$.\nassistant\n", "label": "Axiom ACop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_889) .", "predict": "Axiom ACop_ind_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop), forall _H_mk_ACop : ((aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))), forall x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil), cic.Term cic.prop (Q_ x_889) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nB2_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.B2$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom B2_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B2 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k n p))) (matita_arithmetics_chebyshev_bertrand.k n p))))) .", "predict": "Axiom B2_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B2 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k n p))) (matita_arithmetics_chebyshev_bertrand.k n p))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1728$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$", "label": "axiom Dop_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1728 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type0) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1729 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom Dop_inv_rect_Type0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) (P : (_z1728 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type0) (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1729 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_le. Let $_n$ and $__$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate filter_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_743$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_742$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_745$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $x_742$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_743$ and $x_742$, for all elements $x_741$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_741$.\nassistant\n", "label": "postulate list_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type1) -> (_H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_743 : cic.Term univs.Type0 _A) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_745 : cic.Term univs.Type1 (Q_ x_742)) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> (x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type1 (Q_ x_741)", "predict": "postulate list_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type1) -> (_H_nil : cic.Term univs.Type1 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_743 : cic.Term univs.Type0 _A) -> (x_742 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_745 : cic.Term univs.Type1 (Q_ x_742)) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.cons _A x_743 x_742))) -> (x_741 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type1 (Q_ x_741)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_gcd_aux_mn. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $m$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $n$.\nassistant\n", "label": "axiom divides_gcd_aux_mn (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))", "predict": "axiom divides_gcd_aux_mn (p m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFlatten_to_mem. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, for all elements $l1$ and $l2$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_basics_lists_list.list$ applied to $A$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $x$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $a$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita", "label": "Axiom flatten_to_mem : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A)), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : ((x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) x l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.flatten A l) (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a l2))), forall __4 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun q => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_arithmetics_nat.times n q))), cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) a l) .", "predict": "Axiom flatten_to_mem : forall A : cic.Univ univs.Type0, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A)), forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall a : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : ((x : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) x l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A x) n)), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A a) n), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.flatten A l) (matita_basics_lists_list.append A l1 (matita_basics_lists_list.append A a l2))), forall __4 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun q => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_arithmetics_nat.times n q))), cic.Term cic.prop (matita_basics_lists_list.mem (matita_basics_lists_list.list A) a l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_Prod. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_Prod : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_Prod : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort), forall return : ((z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)), forall z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_n_Sm_elim. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $P$ of $cic.Univ$ of $cic.prop$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, for all functions $__2$ from elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$, $cic.Term$ holds for $cic.prop$ and $P$.\nassistant\n", "label": "Axiom le_n_Sm_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)), forall P : cic.Univ cic.prop, forall __1 : ((__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P), forall __2 : ((__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P), cic.Term cic.prop P .", "predict": "Axiom le_n_Sm_elim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)), forall P : cic.Univ cic.prop, forall __1 : ((__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P), forall __2 : ((__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop P), cic.Term cic.prop P ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z317$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_116$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z318$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_116$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_116$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Not_inv_rect_CProp0 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z317 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_116 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z318 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Not_inv_rect_CProp0 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z317 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_116 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z318 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_116))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEqnot_to_noteq. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.\nassistant\n", "label": "Axiom eqnot_to_noteq : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) .", "predict": "Axiom eqnot_to_noteq : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1614$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1615$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)", "predict": "axiom ACop_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1614 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1615 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_Type3_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_735$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_733$ and $x_732$, for all elements $x_731$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_731$.\nassistant\n", "label": "axiom list_rect_Type3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)", "predict": "axiom list_rect_Type3_body (_A : cic.Univ univs.Type0) (Q_ : (_x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type3) (_H_nil : cic.Term univs.Type3 (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_733 : cic.Term univs.Type0 _A) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_735 : cic.Term univs.Type3 (Q_ x_732)) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.cons _A x_733 x_732))) (x_731 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term univs.Type3 (Q_ x_731)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15625. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arith", "label": "Axiom let_clause_15625 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O", "predict": "Axiom let_clause_15625 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S mat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSquare_S. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom square_S (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus (matita_arithmetics_exp.exp a (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "axiom square_S (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus (matita_arithmetics_exp.exp a (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_CProp2. For all functions $Q_$ from elements $_x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_515$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_515$.\nassistant\n", "label": "axiom unit_rect_CProp2 (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_515 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_515)", "predict": "axiom unit_rect_CProp2 (Q_ : (_x_515 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_515 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_515)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_to_log_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom lt_to_log_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O) .", "predict": "Axiom lt_to_log_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_to_dividesb_true. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom divides_to_dividesb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) .", "predict": "Axiom divides_to_dividesb_true : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_inv_rect_CProp2. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1020$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1021$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_572$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_572$, for all functions $_H2$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1021$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_573$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_573$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Sum_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_572 : cic.Term univs.Type0 x1 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572)) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))) -> _H2 : (x_573 : cic.Term univs.Type0 x2 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573)) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P Hterm) .", "predict": "Sum_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> P : (_z1020 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_572 : cic.Term univs.Type0 x1 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_572)) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_572))) -> _H2 : (x_573 : cic.Term univs.Type0 x2 -> _z1021 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_573)) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_573))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExteqR. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom exteqR (A B : cic.Univ univs.Type0) (_R _S : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) : cic.Univ cic.prop", "predict": "axiom exteqR (A B : cic.Univ univs.Type0) (_R _S : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_Type1_body. For all functions $Q_$ from elements $_x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_true$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_341$.\nassistant\n", "label": "Axiom bool_rect_Type1_body : forall Q_ : ((_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1), forall _H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false), forall x_341 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type1 (Q_ x_341) .", "predict": "Axiom bool_rect_Type1_body : forall Q_ : ((_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1), forall _H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false), forall x_341 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type1 (Q_ x_341) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and", "label": "Axiom Aop_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) .", "predict": "Axiom Aop_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_minus_m_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $m$.\nassistant\n", "label": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) .", "predict": "plus_minus_m_m : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom mod_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom mod_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRev_append. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "rev_append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) .", "predict": "rev_append : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Term univs.Type0 (matita_basics_lists_list.list H) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_discr. For all elements $a1$ and $a2$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p0$ to $a2$ applied to $u0$ and $e0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $", "label": "axiom Prod_discr (a1 a2 : cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2) t1 u0 e0) u1) (λ _e1 => P))) (λ _z45 => P))) y) x)", "predict": "axiom Prod_discr (a1 a2 : cic.Univ univs.Type0) (x y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) : cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ t0 => λ t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (λ u0 => λ u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (λ e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((λ x0 => λ p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (λ x0 => λ p0 => a2) t1 u0 e0) u1) (λ _e1 => P))) (λ _z43 => P))) y) x)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin0. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom min0 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom min0 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_rect_Type3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z984$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$, for all functions $_H2$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOrb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "postulate orb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate orb : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> (__1 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z299$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z300$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_107$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_107$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Not_inv_rect_CProp3 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Not_inv_rect_CProp3 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z299 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_107 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z300 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_107))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_found_min_spec. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "Axiom not_found_min_spec : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)), cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) .", "predict": "Axiom not_found_min_spec : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)), cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_previous_prime2. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_previous_prime2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_previous_prime2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_plus_times. For all elements $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $m$ and $r$ and $m$ and $q$.\nassistant\n", "label": "axiom div_plus_times (m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt r m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r) m) q)", "predict": "axiom div_plus_times (m q r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt r m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r) m) q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.\nassistant\n", "label": "axiom filter (T : cic.Univ univs.Type0) (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) : cic.Term univs.Type0 (matita_basics_lists_list.list T)", "predict": "axiom filter (T : cic.Univ univs.Type0) (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) : cic.Term univs.Type0 (matita_basics_lists_list.list T)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom eq (A : cic.Univ univs.Type2) (_x __ : cic.Term univs.Type2 A) : cic.Univ cic.prop", "predict": "axiom eq (A : cic.Univ univs.Type2) (_x __ : cic.Term univs.Type2 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_inv_rect_CProp2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1218$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1219$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1218 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1219 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sig_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1218 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1219 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExists_forall_lt. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$.\nassistant\n", "label": "Axiom exists_forall_lt : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (fun __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)))) .", "predict": "Axiom exists_forall_lt : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (fun __ => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_le_Sn_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "axiom not_le_Sn_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n))", "predict": "axiom not_le_Sn_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBc2. For all elements $n$ and $k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $k$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "bc2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le k n) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k))) (matita_arithmetics_factorial.fact n)) .", "predict": "bc2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le k n) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k))) (matita_arithmetics_factorial.fact n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInvert_permut_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom invert_permut_body (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom invert_permut_body (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "mod_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) .", "predict": "mod_n_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMk_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.\nassistant\n", "label": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) .", "predict": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp4. Let $Q_$ be a function from elements $_x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_396$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, for all elements $x_393$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_393$.\nassistant\n", "label": "nat_rect_CProp4 : Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_396 : cic.Term cic.prop (Q_ x_394) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_393) .", "predict": "nat_rect_CProp4 : Q_ : (_x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_396 : cic.Term cic.prop (Q_ x_394) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_394))) -> x_393 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_393) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_False. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $return_sort$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom match_False : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort), forall z : cic.Term cic.prop matita_basics_logic.False, cic.Term return_sort (return_type z) .", "predict": "Axiom match_False : forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ return_sort), forall z : cic.Term cic.prop matita_basics_logic.False, cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom range_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term cic.prop (P Hterm)", "predict": "axiom range_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10131. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n0$ and $f$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltj$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $j$ and $matita_arithmetics_nat.S$ applied to $n0$, for all elements $x7$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x7$ and $matita_arithmetics_nat.plus$ applied to $m$ and $x7$.\nassistant\n", "label": "let_clause_10131 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m) -> fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0)) -> x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7)) .", "predict": "let_clause_10131 : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m) -> fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false) -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0)) -> x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.\nassistant\n", "label": "axiom divides_to_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)", "predict": "axiom divides_to_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom Not : forall _A : cic.Univ cic.prop, cic.Univ cic.prop .", "predict": "Axiom Not : forall _A : cic.Univ cic.prop, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProj1. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $A$.\nassistant\n", "label": "proj1 : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.And A B) -> cic.Term cic.prop A .", "predict": "proj1 : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.And A B) -> cic.Term cic.prop A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_map_some. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $v$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.Some$ applied to $B$ and $v$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $y$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $y$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $y$ and $v$.\nassistant\n", "label": "axiom option_map_some (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (v : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v))) : cic.Term cic.prop (matita_basics_logic.ex A (λ y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v)))", "predict": "axiom option_map_some (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (v : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v))) : cic.Term cic.prop (matita_basics_logic.ex A (λ y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp1. For all functions $Q_$ from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "axiom nat_rect_CProp1 (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)", "predict": "axiom nat_rect_CProp1 (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_map. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $x$ and $g$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $g$ and $l$.\nassistant\n", "label": "postulate eq_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : (x : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l))", "predict": "postulate eq_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : (x : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_", "label": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)", "predict": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nReverse_single. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.\nassistant\n", "label": "reverse_single : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) .", "predict": "reverse_single : S : cic.Univ univs.Type0 -> a : cic.Term univs.Type0 S -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nIff_and_l. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.And$ applied to $C$ and $A$ and $matita_basics_logic.And$ applied to $C$ and $B$.\nassistant\n", "label": "iff_and_l : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> C : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.iff A B) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.And C A) (matita_basics_logic.And C B)) .", "predict": "iff_and_l : A : cic.Univ cic.prop -> B : cic.Univ cic.prop -> C : cic.Univ cic.prop -> __ : cic.Term cic.prop (matita_basics_logic.iff A B) -> cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.And C A) (matita_basics_logic.And C B)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nS_mod. Let $_n$ and $_m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "S_mod : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "S_mod : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_map_none. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.None$ applied to $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$.\nassistant\n", "label": "axiom option_map_none (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))", "predict": "axiom option_map_none (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.None B))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.\nassistant\n", "label": "eq_rect_Type3_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_10 : cic.Term univs.Type2 A -> _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Univ univs.Type3) -> _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) -> x_10 : cic.Term univs.Type2 A -> x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Term univs.Type3 (Q_ x_10 x_11) .", "predict": "eq_rect_Type3_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_10 : cic.Term univs.Type2 A -> _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Univ univs.Type3) -> _H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) -> x_10 : cic.Term univs.Type2 A -> x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) -> cic.Term univs.Type3 (Q_ x_10 x_11) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_div_to_times. Let $n$ and $m$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $q$ and $m$.\nassistant\n", "label": "Axiom lt_div_to_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m)) .", "predict": "Axiom lt_div_to_times : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n q) m), cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_nat.times q m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_927$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_927$.\nassistant\n", "label": "postulate range_rect_Type0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)", "predict": "postulate range_rect_Type0 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type0) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_927 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type0 (Q_ x_927)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1074$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1075$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_615$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_615$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "option_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_615 : cic.Term univs.Type0 x1 -> _z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm) .", "predict": "option_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.option x1) -> P : (_z1074 : cic.Term univs.Type0 (matita_basics_types.option x1) -> cic.Univ cic.prop) -> _H1 : (_z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> _H2 : (x_615 : cic.Term univs.Type0 x1 -> _z1075 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_615)) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_615))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_n_O_to_eq. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate le_n_O_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)", "predict": "postulate le_n_O_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_Type3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1710$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$", "label": "Axiom Dop_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom Dop_inv_rect_Type3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1710 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type3), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1711 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot. For all elements $_A$ of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Not : _A : cic.Univ cic.prop -> cic.Univ cic.prop .", "predict": "Not : _A : cic.Univ cic.prop -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_O. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.O$ and $b$ and $b$.\nassistant\n", "label": "postulate lstar_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b)", "predict": "postulate lstar_O : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R matita_arithmetics_nat.O b b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTight_apart. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_eq$ and $_ap$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "tight_apart : A : cic.Univ univs.Type0 -> _eq : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _ap : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop .", "predict": "tight_apart : A : cic.Univ univs.Type0 -> _eq : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _ap : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPosition_of_aux. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom position_of_aux (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)", "predict": "axiom position_of_aux (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_CProp3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_656$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_656$.\nassistant\n", "label": "axiom DPair_rect_CProp3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_656)", "predict": "axiom DPair_rect_CProp3_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_656 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_656)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_ind. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_80$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_80$, for all elements $x_79$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_79$.\nassistant\n", "label": "postulate Not_ind : (_A : cic.Univ cic.prop) -> (Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_79)", "predict": "postulate Not_ind : (_A : cic.Univ cic.prop) -> (Q_ : (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_80 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) -> (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_79)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_map_def. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.\nassistant\n", "label": "postulate option_map_def : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 (matita_basics_types.option A)) -> cic.Term univs.Type0 B", "predict": "postulate option_map_def : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 (matita_basics_types.option A)) -> cic.Term univs.Type0 B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPlus_le_0. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom plus_le_0 : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) .", "predict": "Axiom plus_le_0 : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_rect_CProp0. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1032$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_582$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_582$, for all functions $_H2$ from elements $x_583$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1033$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_583$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))) -> (_H2 : (x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1032 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_582 : cic.Term univs.Type0 x1) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_582))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_582))) -> (_H2 : (x_583 : cic.Term univs.Type0 x2) -> (_z1033 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_583))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAbsurd. Let $A$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.False$.\nassistant\n", "label": "axiom absurd (A : cic.Univ cic.prop) (__ : cic.Term cic.prop A) (__1 : cic.Term cic.prop (matita_basics_logic.Not A)) : cic.Term cic.prop matita_basics_logic.False", "predict": "axiom absurd (A : cic.Univ cic.prop) (__ : cic.Term cic.prop A) (__1 : cic.Term cic.prop (matita_basics_logic.Not A)) : cic.Term cic.prop matita_basics_logic.False"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_CProp5_body. Let $Q_$ be a function from elements $_x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_511$.\nassistant\n", "label": "axiom unit_rect_CProp5_body (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_511 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_511)", "predict": "axiom unit_rect_CProp5_body (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_511 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_511)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_inv_rect_CProp3. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1477$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom div_mod_spec_inv_rect_CProp3 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop), forall _H1 : ((x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom div_mod_spec_inv_rect_CProp3 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop), forall _H1 : ((x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrim. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom prim (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom prim (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAnd_rect_Type5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.\nassistant\n", "label": "Axiom And_rect_Type5_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) .", "predict": "Axiom And_rect_Type5_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMonotonic_div. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$.\nassistant\n", "label": "postulate monotonic_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.div m n))", "predict": "postulate monotonic_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_div_and_mod.div m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_rect_CProp5. Let $Q_$ be a function from elements $_x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_511$.\nassistant\n", "label": "Axiom unit_rect_CProp5 : forall Q_ : ((_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_511 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_511) .", "predict": "Axiom unit_rect_CProp5 : forall Q_ : ((_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_511 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_511) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nP_ord_aux_Strue. For all elements $n$ and $m$ and $p$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $q$ and $r$.\nassistant\n", "label": "postulate p_ord_aux_Strue : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_div_and_mod.div n m) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S p) n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S q) r))", "predict": "postulate p_ord_aux_Strue : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p (matita_arithmetics_div_and_mod.div n m) m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux (matita_arithmetics_nat.S p) n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S q) r))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPermut_S_to_permut_transpose. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $f$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $m$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)", "predict": "postulate permut_S_to_permut_transpose : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (\\ n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10131. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n0$ and $f$ and $m$, for all elements $fm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, for all elements $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltj$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $j$ and $matita_arithmetics_nat.S$ applied to $n0$, for all elements $x7$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x7$ and $matita_arithmetics_nat.plus$ applied to $m$ and $x7$.\nassistant\n", "label": "Axiom let_clause_10131 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m), forall fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0)), forall x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7)) .", "predict": "Axiom let_clause_10131 : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n0) f) m), forall fm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall ltj : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S j) (matita_arithmetics_nat.S n0)), forall x7 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x7 (matita_arithmetics_nat.plus m x7)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.\nassistant\n", "label": "DPair_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type4) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type4 (Q_ x_640) .", "predict": "DPair_rect_Type4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type4) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type4 (Q_ x_640) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSubR. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ and $_S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom subR (A : cic.Univ univs.Type0) (_R _S : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom subR (A : cic.Univ univs.Type0) (_R _S : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nF_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $m$ and $m$.\nassistant\n", "label": "postulate f_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m)", "predict": "postulate f_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_permutation.invert_permut n f m)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_inv_rect_Type1. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z149$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom True_inv_rect_Type1 : forall Hterm : cic.Term cic.prop matita_basics_logic.True, forall P : ((_z149 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type1), forall _H1 : ((_z150 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term univs.Type1 (P matita_basics_logic.I)), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_forall_to_exists. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$ applied to $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__1$ to $P$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.\nassistant\n", "label": "postulate not_forall_to_exists : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (P i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> P i))))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Not (P i))))", "predict": "postulate not_forall_to_exists : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (P i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> P i))))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.Not (P i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_Psi_2_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $mat", "label": "postulate eq_Psi_2_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "postulate eq_Psi_2_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_nat.S n) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrime_to_divides_M. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.\nassistant\n", "label": "postulate prime_to_divides_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m))", "predict": "postulate prime_to_divides_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S m) p)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_binomial.M m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_rect_Type2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_672$.\nassistant\n", "label": "postulate Sig_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)", "predict": "postulate Sig_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type2 (Q_ x_672)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPosition_of. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom position_of : forall A : cic.Univ univs.Type0, forall __ : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) .", "predict": "Axiom position_of : forall A : cic.Univ univs.Type0, forall __ : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTech_log. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $x$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $x$ and $n$.\nassistant\n", "label": "tech_log : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) .", "predict": "tech_log : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_Type1. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_700$.\nassistant\n", "label": "axiom Prod_rect_Type1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type1 (Q_ x_700)", "predict": "axiom Prod_rect_Type1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type1 (Q_ x_700)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.\nassistant\n", "label": "Sig_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_680) .", "predict": "Sig_rect_CProp5_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Univ cic.prop) -> _H_mk_Sig : (pi1 : cic.Term univs.Type0 A -> _pi2 : cic.Term cic.prop (_f pi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f) -> cic.Term cic.prop (Q_ x_680) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "range_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) .", "predict": "range_inv_rect_CProp0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_exists_to_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $P$ applied to $i$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $P$ applied to $i$.\nassistant\n", "label": "postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))", "predict": "postulate not_exists_to_forall : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (P i))))) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> cic.Term cic.prop (matita_basics_logic.Not (P i))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNill_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "Axiom nill_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a) .", "predict": "Axiom nill_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx nil a) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMax_spec_inv_ind. Let $x1$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $x1$ and $x2$ and $x3$, for all functions $P$ from elements $_z1769$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $x1$ and elements $_x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.false$ and elements $_z1770$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univ", "label": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift", "predict": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_minimization.max x1 x2) matita_basics_bool.true)) -> cic.Term cic.prop (P (matita_arithmetics_minimization.max x1 x2))) -> (_H2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSmallest_factor_fact. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "axiom smallest_factor_fact (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))", "predict": "axiom smallest_factor_fact (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_primes.smallest_factor (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1518$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to", "label": "Axiom Aop_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type2 (P Hterm) .", "predict": "Axiom Aop_inv_rect_Type2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1518 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type2), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1519 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_times_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_times_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_inv_rect_CProp2. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then for all functions $P$ from elements $_z173$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z174$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "True_inv_rect_CProp2 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z173 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) .", "predict": "True_inv_rect_CProp2 : Hterm : cic.Term cic.prop matita_basics_logic.True -> P : (_z173 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H1 : (_z174 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_minus_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.\nassistant\n", "label": "postulate eq_minus_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m)))))", "predict": "postulate eq_minus_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPlus_minus1. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$.\nassistant\n", "label": "postulate plus_minus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c))", "predict": "postulate plus_minus1 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_rect_Type4_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_723$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_722$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_725$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_723$ and $x_722$, for all elements $x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_721$.\nassistant\n", "label": "postulate list_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) -> (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) -> (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type4 (Q_ x_721)", "predict": "postulate list_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) -> (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) -> (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type4 (Q_ x_721)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_Type4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z593$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_Type4 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> _H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm) .", "predict": "bool_inv_rect_Type4 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> _H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1140$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1141$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom DPair_inv_rect_CProp4 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1140 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1141 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_Dop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Dop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z605$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate bool_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type2 (P matita_basics_bool.true)) -> (_H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type2 (P matita_basics_bool.false)) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate bool_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type2 (P matita_basics_bool.true)) -> (_H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type2 (P matita_basics_bool.false)) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBk_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.\nassistant\n", "label": "Bk_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p)))) .", "predict": "Bk_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_CProp2_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_160$ and $x_159$, for all elements $x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_158$.\nassistant\n", "label": "axiom And_rect_CProp2_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_158)", "predict": "axiom And_rect_CProp2_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_158)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLength_tail1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "axiom length_tail1 (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))", "predict": "axiom length_tail1 (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_765$ from elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_762$ and elements $_z1345$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_763$ and $x_762$, $cic.Term$ holds for $c", "label": "list_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_763 : cic.Term univs.Type0 x1 -> x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762) -> cic.Term cic.prop (P x_762)) -> _z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm) .", "predict": "list_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_763 : cic.Term univs.Type0 x1 -> x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762) -> cic.Term cic.prop (P x_762)) -> _z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRewrite_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $x$, for all elements $y$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $y$ and $x$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $y$.\nassistant\n", "label": "Axiom rewrite_r : forall A : cic.Univ univs.Type2, forall x : cic.Term univs.Type2 A, forall P : ((__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2), forall __ : cic.Term univs.Type2 (P x), forall y : cic.Term univs.Type2 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq A y x), cic.Term univs.Type2 (P y) .", "predict": "Axiom rewrite_r : forall A : cic.Univ univs.Type2, forall x : cic.Term univs.Type2 A, forall P : ((__ : cic.Term univs.Type2 A) -> cic.Univ univs.Type2), forall __ : cic.Term univs.Type2 (P x), forall y : cic.Term univs.Type2 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq A y x), cic.Term univs.Type2 (P y) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and", "label": "axiom Aop_rect_Type5_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type5 (Q_ x_785)", "predict": "axiom Aop_rect_Type5_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term univs.Type5 (Q_ x_785)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_13$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_14$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_13$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_13$ and $x_14$.\nassistant\n", "label": "axiom eq_rect_Type2_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_13 : cic.Term univs.Type2 A) -> (_x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Univ univs.Type2) (_H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x))) (x_13 : cic.Term univs.Type2 A) (x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) : cic.Term univs.Type2 (Q_ x_13 x_14)", "predict": "axiom eq_rect_Type2_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_13 : cic.Term univs.Type2 A) -> (_x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) -> cic.Univ univs.Type2) (_H_refl : cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x))) (x_13 : cic.Term univs.Type2 A) (x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13)) : cic.Term univs.Type2 (Q_ x_13 x_14)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nReverse_append. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.append$ applied to $S$ and $l1$ and $l2$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l2$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l1$.\nassistant\n", "label": "reverse_append : S : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1))) .", "predict": "reverse_append : S : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_CProp2. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$, for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp2 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))), forall x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_849) .", "predict": "Axiom div_mod_spec_rect_CProp2 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))), forall x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_849) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_CProp4. For all functions $Q_$ from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.\nassistant\n", "label": "bool_rect_CProp4 : Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_347 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_347) .", "predict": "bool_rect_CProp4 : Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_347 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_347) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExp_fact_2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.\nassistant\n", "label": "axiom exp_fact_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))", "predict": "axiom exp_fact_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_to_andb_true. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "Axiom true_to_andb_true : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) .", "predict": "Axiom true_to_andb_true : forall b1 : cic.Term univs.Type0 matita_basics_bool.bool, forall b2 : cic.Term univs.Type0 matita_basics_bool.bool, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $mat", "label": "let_clause_16002 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita", "predict": "let_clause_16002 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _dclearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_r_inv_lstar. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.\nassistant\n", "label": "lstar_r_inv_lstar : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) .", "predict": "lstar_r_inv_lstar : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b2 : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_CProp2_body. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.\nassistant\n", "label": "Axiom False_rect_CProp2_body : forall Q_ : ((_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_76 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_76) .", "predict": "Axiom False_rect_CProp2_body : forall Q_ : ((_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_76 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_76) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_sqrt_nl. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_sqrt_nl : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) .", "predict": "Axiom le_sqrt_nl : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_times_plus_to_congruent. Let $n$ and $m$ and $p$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $r$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "Axiom eq_times_plus_to_congruent : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m)), cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p) .", "predict": "Axiom eq_times_plus_to_congruent : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times r p) m)), cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_CProp4_body. For all functions $Q_$ from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.\nassistant\n", "label": "False_rect_CProp4_body : Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_73 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_73) .", "predict": "False_rect_CProp4_body : Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_73 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_73) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_rect_Type2. For all functions $Q_$ from elements $_x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_I$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_48$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_48$.\nassistant\n", "label": "postulate True_rect_Type2 : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)", "predict": "postulate True_rect_Type2 : (Q_ : (_x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type2) -> (_H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I)) -> (x_48 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type2 (Q_ x_48)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_exp_to_lt. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_exp.exp$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.\nassistant\n", "label": "postulate lt_exp_to_lt : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp a n) (matita_arithmetics_exp.exp a m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)", "predict": "postulate lt_exp_to_lt : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp a n) (matita_arithmetics_exp.exp a m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_CProp0. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.\nassistant\n", "label": "postulate void_rect_CProp0 : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)", "predict": "postulate void_rect_CProp0 : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIt. $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.unit$.\nassistant\n", "label": "postulate it : cic.Term univs.Type0 matita_basics_types.unit", "predict": "postulate it : cic.Term univs.Type0 matita_basics_types.unit"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_Type1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_conj$ from elements $x_140$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_140$ and $x_139$, for all elements $x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_138$.\nassistant\n", "label": "postulate And_rect_Type1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)", "predict": "postulate And_rect_Type1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_minr. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$.\nassistant\n", "label": "Axiom le_minr : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m)), cic.Term cic.prop (matita_arithmetics_nat.le i m) .", "predict": "Axiom le_minr : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m)), cic.Term cic.prop (matita_arithmetics_nat.le i m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLength_ltl. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $matita_arithmetics_nat.minus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$ and $n$.\nassistant\n", "label": "length_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n)) .", "predict": "length_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.ltl A l n)) (matita_arithmetics_nat.minus (matita_basics_lists_list.length A l) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_sqrt_n1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom le_sqrt_n1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_sqrt.sqrt n))) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "axiom le_sqrt_n1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_sqrt.sqrt n))) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_Type1. Let $Q_$ be a function from elements $_x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_505$.\nassistant\n", "label": "axiom unit_rect_Type1 (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) (x_505 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type1 (Q_ x_505)", "predict": "axiom unit_rect_Type1 (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) (x_505 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type1 (Q_ x_505)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_897$.\nassistant\n", "label": "axiom ACop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type2 (Q_ x_897)", "predict": "axiom ACop_rect_Type2_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type2 (Q_ x_897)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.\nassistant\n", "label": "axiom DPair_rect_Type3 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)", "predict": "axiom DPair_rect_Type3 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLhd_cons_ltl. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $l$ and $n$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $l$.\nassistant\n", "label": "lhd_cons_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) .", "predict": "lhd_cons_ltl : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_Type0_body. For all functions $Q_$ from elements $_x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_I$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_52$.\nassistant\n", "label": "axiom True_rect_Type0_body (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)", "predict": "axiom True_rect_Type0_body (Q_ : (_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0) (_H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I)) (x_52 : cic.Term cic.prop matita_basics_logic.True) : cic.Term univs.Type0 (Q_ x_52)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAppend_l2_injective_r. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l3$ and $l4$.\nassistant\n", "label": "append_l2_injective_r : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4)) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4) .", "predict": "append_l2_injective_r : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4)) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nStreicherK. For all elements $T$ of $cic.Univ$ of $univs.Type2$, for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.\nassistant\n", "label": "postulate streicherK : (T : cic.Univ univs.Type2) -> (t : cic.Term univs.Type2 T) -> (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) -> (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Term univs.Type2 (P p)", "predict": "postulate streicherK : (T : cic.Univ univs.Type2) -> (t : cic.Term univs.Type2 T) -> (P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Univ univs.Type2) -> (__ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t))) -> (p : cic.Term cic.prop (matita_basics_logic.eq T t t)) -> cic.Term univs.Type2 (P p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1128$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1129$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "DPair_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type1) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "DPair_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type1) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSameF_p_le. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_p$ applied to $m$ and $p$ and $A$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sameF_p$ applied to $n$ and $p$ and $A$ and $f$ and $g$.\nassistant\n", "label": "sameF_p_le : A : cic.Univ univs.Type0 -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g) .", "predict": "sameF_p_le : A : cic.Univ univs.Type0 -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 A) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> __1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p m p A f g) -> cic.Term cic.prop (matita_arithmetics_bigops.sameF_p n p A f g) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_div_div_div_div. Let $n$ and $m$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $n$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_div_and_mod.div$ applied to $q$ and $m$ and $n$.\nassistant\n", "label": "postulate eq_div_div_div_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q m) n))", "predict": "postulate eq_div_div_div_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q n) m) (matita_arithmetics_div_and_mod.div (matita_arithmetics_div_and_mod.div q m) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp3_body. For all functions $Q_$ from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.\nassistant\n", "label": "nat_rect_CProp3_body : Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : cic.Term cic.prop (Q_ x_402) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_401) .", "predict": "nat_rect_CProp3_body : Q_ : (_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_404 : cic.Term cic.prop (Q_ x_402) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))) -> x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_401) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z1333$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_748$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_747$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_750$ from elements $_z1333$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $x_747$ and elements $_z1333$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_748$ and $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_", "label": "list_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1332 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type0) -> _H1 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_748 : cic.Term univs.Type0 x1 -> x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_750 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_747) -> cic.Term univs.Type0 (P x_747)) -> _z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_748 x_747)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.cons x1 x_748 x_747))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "list_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1332 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type0) -> _H1 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_748 : cic.Term univs.Type0 x1 -> x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_750 : (_z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_747) -> cic.Term univs.Type0 (P x_747)) -> _z1333 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_748 x_747)) -> cic.Term univs.Type0 (P (matita_basics_lists_list.cons x1 x_748 x_747))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_Type5. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.\nassistant\n", "label": "axiom And_rect_Type5 (_A _B : cic.Univ cic.prop) (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type5 (Q_ x_126)", "predict": "axiom And_rect_Type5 (_A _B : cic.Univ cic.prop) (Q_ : (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5) (_H_conj : (x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term univs.Type5 (Q_ x_126)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_rect_CProp4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "Axiom DPair_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) .", "predict": "Axiom DPair_rect_CProp4_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_Type0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_873$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and", "label": "axiom Aop_rect_Type0_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_873)", "predict": "axiom Aop_rect_Type0_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_873 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term univs.Type0 (Q_ x_873)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrime_to_not_divides_fact. Let $p$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "postulate prime_to_not_divides_fact : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))", "predict": "postulate prime_to_not_divides_fact : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSplit_exists. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l1$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l2$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $n$.\nassistant\n", "label": "split_exists : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n)))) .", "predict": "split_exists : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_mod. Let $p$ and $a$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $p$ and $matita_arithmetics_nat.pred$ applied to $p$.\nassistant\n", "label": "axiom permut_mod (p a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a))) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p))", "predict": "axiom permut_mod (p a : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p a))) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times a n) p) (matita_arithmetics_nat.pred p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExample5. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate example5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_basics_bool.false)", "predict": "postulate example5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_max_to_false. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)", "predict": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_smallest_factor_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom le_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "Axiom le_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_min_spec. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_minimization.found", "label": "match_min_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __) -> cic.Univ return_sort) -> case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arith", "predict": "match_min_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __) -> cic.Univ return_sort) -> case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found _n _b _f __))) -> _g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type _n (matita_arithmetics_minimization.match_min _n _b _f _g)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_aux_mod_aux. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div_aux$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_div_and_mod.mod_aux$ applied to $p$ and $n$ and $m$.\nassistant\n", "label": "Axiom div_aux_mod_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div_aux p n m) (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.mod_aux p n m))) .", "predict": "Axiom div_aux_mod_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div_aux p n m) (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.mod_aux p n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and", "label": "axiom Dop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_961)", "predict": "axiom Dop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_961)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.minus$ applied to $m$ and $p$.\nassistant\n", "label": "minus_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus p (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.minus m p))) .", "predict": "minus_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus p (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.minus m p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEx_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.\nassistant\n", "label": "postulate ex_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)", "predict": "postulate ex_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.\nassistant\n", "label": "Axiom min_f_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) .", "predict": "Axiom min_f_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_B_Psi4. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom le_B_Psi4 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)))", "predict": "axiom le_B_Psi4 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_gcd_aux_mn. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $m$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$ and $n$.\nassistant\n", "label": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))", "predict": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_168 : cic.Term cic.prop x1) -> (x_167 : cic.Term cic.prop x2) -> (_z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_to_not_lt. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$.\nassistant\n", "label": "le_to_not_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n)) .", "predict": "le_to_not_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_rect_CProp3_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.\nassistant\n", "label": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)", "predict": "postulate div_mod_spec_rect_CProp3_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))) -> (x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_845)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMem_map_forward. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $B$ and $f$ applied to $a$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$.\nassistant\n", "label": "Axiom mem_map_forward : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall a : cic.Term univs.Type0 A, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a l), cic.Term cic.prop (matita_basics_lists_list.mem B (f a) (matita_basics_lists_list.map A B f l)) .", "predict": "Axiom mem_map_forward : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall a : cic.Term univs.Type0 A, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a l), cic.Term cic.prop (matita_basics_lists_list.mem B (f a) (matita_basics_lists_list.map A B f l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTimes_times. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $y$ and $z$ and $matita_arithmetics_nat.times$ applied to $y$ and $matita_arithmetics_nat.times$ applied to $x$ and $z$.\nassistant\n", "label": "axiom times_times (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times x (matita_arithmetics_nat.times y z)) (matita_arithmetics_nat.times y (matita_arithmetics_nat.times x z)))", "predict": "axiom times_times (x y z : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times x (matita_arithmetics_nat.times y z)) (matita_arithmetics_nat.times y (matita_arithmetics_nat.times x z)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1062$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1063$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_607$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_607$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOrb_elim. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_bool.match_bool$ applied to $cic.type$ applied to $cic.z$ and the function that maps $__$ to $cic.univ$ applied to $cic.prop$ and $P$ applied to $matita_basics_bool.true$ and $P$ applied to $b2$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_basics_bool.orb$ applied to $b1$ and $b2$.\nassistant\n", "label": "orb_elim : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ cic.prop) (P matita_basics_bool.true) (P b2) b1) -> cic.Term cic.prop (P (matita_basics_bool.orb b1 b2)) .", "predict": "orb_elim : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ cic.prop) (P matita_basics_bool.true) (P b2) b1) -> cic.Term cic.prop (P (matita_basics_bool.orb b1 b2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_O_l. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.\nassistant\n", "label": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)", "predict": "postulate gcd_O_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_nth_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$.\nassistant\n", "label": "Axiom prime_nth_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.nth_prime n)) .", "predict": "Axiom prime_nth_prime : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.prime (matita_arithmetics_primes.nth_prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_singlevalued. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $B$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.singlevalued$ applied to $B$ and $B$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.singlevalued$ applied to $B$ and $B$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$.\nassistant\n", "label": "postulate lstar_singlevalued : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B)) -> (__ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l))", "predict": "postulate lstar_singlevalued : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation2 B B)) -> (__ : cic.Term cic.prop (matita_basics_relations.singlevalued B B R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.singlevalued B B (matita_arithmetics_lstar.lstar B R l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom option : forall _A : cic.Univ univs.Type0, cic.Univ univs.Type0 .", "predict": "Axiom option : forall _A : cic.Univ univs.Type0, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_plus_to_minus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.\nassistant\n", "label": "postulate le_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))", "predict": "postulate le_plus_to_minus_r : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a b) c)) -> cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_nat.minus c b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nassistant\n", "label": "Axiom range_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type2 (Q_ x_923) .", "predict": "Axiom range_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type2 (Q_ x_923) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPrimes_below. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "primes_below : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "primes_below : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_inv_ind. Let $x1$ and $x2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z2006$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2$ and $matita_arithmetics_nat.times$ applied to $x1$ and $q$ and elements $_z2007$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_primes.divides$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_primes.quotient$ applied to $x1$ and $x2$ and $q$ and $x_1193$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom divides_inv_ind (x1 x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) : cic.Term cic.prop (P Hterm)", "predict": "axiom divides_inv_ind (x1 x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) (P : (_z2006 : cic.Term cic.prop (matita_arithmetics_primes.divides x1 x2)) -> cic.Univ cic.prop) (_H1 : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2 (matita_arithmetics_nat.times x1 q))) -> (_z2007 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_primes.divides x1 x2)) Hterm (matita_arithmetics_primes.quotient x1 x2 q x_1193))) -> cic.Term cic.prop (P (matita_arithmetics_primes.quotient x1 x2 q x_1193))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nReverse_append. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.append$ applied to $S$ and $l1$ and $l2$ and $matita_basics_lists_list.append$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l2$ and $matita_basics_lists_list.reverse$ applied to $S$ and $l1$.\nassistant\n", "label": "postulate reverse_append : (S : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1)))", "predict": "postulate reverse_append : (S : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.append S l1 l2)) (matita_basics_lists_list.append S (matita_basics_lists_list.reverse S l2) (matita_basics_lists_list.reverse S l1)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFact. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "fact : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "fact : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_CProp2. Let $Q_$ be a function from elements $_x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_492$.\nassistant\n", "label": "postulate void_rect_CProp2 : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)", "predict": "postulate void_rect_CProp2 : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nF_ind_aux. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.\nassistant\n", "label": "Axiom f_ind_aux : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall P : cic.Term univs.Type0 (matita_basics_relations.predicate A), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n), cic.Term cic.prop (P a) .", "predict": "Axiom f_ind_aux : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall P : cic.Term univs.Type0 (matita_basics_relations.predicate A), forall __ : ((n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n), cic.Term cic.prop (P a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom Not (_A : cic.Univ cic.prop) : cic.Univ cic.prop", "predict": "axiom Not (_A : cic.Univ cic.prop) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_rect_CProp4_body. Let $Q_$ be a function from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.\nassistant\n", "label": "axiom void_rect_CProp4_body (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)", "predict": "axiom void_rect_CProp4_body (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBigop_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__3$ from elements $__3$ of $cic.Term$ of $univs.Type0$ and $H$ and elements $__4$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all functions $__4$ from elements $__4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNil_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))", "predict": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom div_mod_spec_inv_rect_Type1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1) (_H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom div_mod_spec_inv_rect_Type1 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1) (_H1 : (x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIncreasing_to_le2. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $f$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_nat.lt$ applied to $m$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $i$.\nassistant\n", "label": "postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))", "predict": "postulate increasing_to_le2 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.increasing f)) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (f matita_arithmetics_nat.O) m)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.le (f i) m) (matita_arithmetics_nat.lt m (f (matita_arithmetics_nat.S i)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_inv_rect_Type4. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1440$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1441$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_815$ and $x_814$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAndb_true_r. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.andb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "axiom andb_true_r (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)", "predict": "axiom andb_true_r (b1 b2 : cic.Term univs.Type0 matita_basics_bool.bool) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb b1 b2) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b2 matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_or_ge. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "axiom lt_or_ge (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt m n) (matita_arithmetics_nat.le n m))", "predict": "axiom lt_or_ge (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt m n) (matita_arithmetics_nat.le n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_times. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $p$ and $p$.\nassistant\n", "label": "mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times n m) p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod m p)) p)) .", "predict": "mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times n m) p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod m p)) p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_B2_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B2$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "le_B2_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "le_B2_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B2 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.pred (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_upper_bound1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom let_upper_bound1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom let_upper_bound1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_CProp4_body. For all functions $Q_$ from elements $_x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_509$.\nassistant\n", "label": "axiom unit_rect_CProp4_body (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_509 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_509)", "predict": "axiom unit_rect_CProp4_body (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_509 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_509)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTo_min. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$.\nassistant\n", "label": "postulate to_min : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))", "predict": "postulate to_min : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i m)) -> cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_ind. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.\nassistant\n", "label": "postulate div_mod_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)", "predict": "postulate div_mod_spec_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLists_length_split. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $la$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $lb$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $la$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.append$ applied to $A$ and $la$ and $lb$.\nassistant\n", "label": "lists_length_split : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (la : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) .", "predict": "lists_length_split : A : cic.Univ univs.Type0 -> l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (la : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.ex (matita_basics_lists_list.list A) (lb : cic.Term univs.Type0 (matita_basics_lists_list.list A) => matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.append A la lb))) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A la) (matita_basics_lists_list.length A l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.append A la lb)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_rect_Type1_body. Let $Q_$ be a function from elements $_x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$. Then for all elements $_H_true$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_341$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_341$.\nassistant\n", "label": "postulate bool_rect_Type1_body : (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) -> (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) -> (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ x_341)", "predict": "postulate bool_rect_Type1_body : (Q_ : (_x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1) -> (_H_true : cic.Term univs.Type1 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type1 (Q_ matita_basics_bool.false)) -> (x_341 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ x_341)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMin_spec_ind. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of", "label": "axiom min_spec_ind (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic", "predict": "axiom min_spec_ind (_n _b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.mk_min_spec _n _b _f x_1075))) (_H_not_found_min_spec : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.not_min_spec _n _b _f x_1075)) -> cic.Term cic.prop (Q_ x_1075 _x_1076)) : cic.Term cic.prop (Q_ _"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTight_apart. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_eq$ and $_ap$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom tight_apart (A : cic.Univ univs.Type0) (_eq _ap : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom tight_apart (A : cic.Univ univs.Type0) (_eq _ap : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_log2_sqrt. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$.\nassistant\n", "label": "postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))", "predict": "postulate le_log2_sqrt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_sqrt.sqrt n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_CProp3_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_933$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_933$.\nassistant\n", "label": "postulate range_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_933)", "predict": "postulate range_rect_CProp3_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_933 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_933)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_fact_to_le. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$.\nassistant\n", "label": "divides_fact_to_le : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)) -> cic.Term cic.prop (matita_arithmetics_nat.le p n) .", "predict": "divides_fact_to_le : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)) -> cic.Term cic.prop (matita_arithmetics_nat.le p n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPsi_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.\nassistant\n", "label": "postulate psi_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_log.log p n))))", "predict": "postulate psi_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_log.log p n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_theta. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$.\nassistant\n", "label": "Axiom le_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) .", "predict": "Axiom le_theta : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_theta.theta m) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_Type4. For all functions $Q_$ from elements $_x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_67$.\nassistant\n", "label": "False_rect_Type4 : Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type4) -> x_67 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type4 (Q_ x_67) .", "predict": "False_rect_Type4 : Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type4) -> x_67 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type4 (Q_ x_67) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLength_map. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "Axiom length_map : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) .", "predict": "Axiom length_map : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDividesb_true_to_lt_O. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$.\nassistant\n", "label": "dividesb_true_to_lt_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) .", "predict": "dividesb_true_to_lt_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAxiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the sum of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom plus (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom plus (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBijn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom bijn : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom bijn : forall __ : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_rect_Type3_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_821$.\nassistant\n", "label": "div_mod_spec_rect_Type3_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type3) -> _H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type3 (Q_ x_821) .", "predict": "div_mod_spec_rect_Type3_body : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type3) -> _H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type3 (Q_ x_821) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_div_S_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nassistant\n", "label": "postulate lt_div_S_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m))", "predict": "postulate lt_div_S_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_eq_n_Sn. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "not_eq_n_Sn : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n))) .", "predict": "not_eq_n_Sn : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_to_le_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "postulate true_to_le_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m)", "predict": "postulate true_to_le_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_to_le_max. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_minimization.max$ applied to $n$ and $f$.\nassistant\n", "label": "postulate true_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f))", "predict": "postulate true_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_minimization.max n f))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_fact_10. $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_fact_10 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) .", "predict": "Axiom le_fact_10 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_911$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_911$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_911$.\nassistant\n", "label": "axiom ACop_rect_CProp1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_911)", "predict": "axiom ACop_rect_CProp1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_911)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_Type2_body. Let $Q_$ be a function from elements $_x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $x_70$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_70$.\nassistant\n", "label": "False_rect_Type2_body : Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type2) -> x_70 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type2 (Q_ x_70) .", "predict": "False_rect_Type2_body : Q_ : (_x_70 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type2) -> x_70 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type2 (Q_ x_70) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_iter. Let $g$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $g$ applied to $x$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$.\nassistant\n", "label": "Axiom le_iter : forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a)) .", "predict": "Axiom le_iter : forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (g x))), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le a (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_Type4_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_891$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_891$.\nassistant\n", "label": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNill. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "Axiom nill : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) .", "predict": "Axiom nill : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil), forall a : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_CProp0_body. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.\nassistant\n", "label": "postulate void_rect_CProp0_body : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)", "predict": "postulate void_rect_CProp0_body : (Q_ : (_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_494)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nGcd_O_l. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.\nassistant\n", "label": "Axiom gcd_O_l : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) .", "predict": "Axiom gcd_O_l : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd matita_arithmetics_nat.O m) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnique_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom unique_body : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Univ cic.prop .", "predict": "Axiom unique_body : forall H : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list H), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_prim_prim_pred. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate eq_prim_prim_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate eq_prim_prim_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTransitive_lt. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$.\nassistant\n", "label": "postulate transitive_lt : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_nat.lt)", "predict": "postulate transitive_lt : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_nat.lt)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_949$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and", "label": "Axiom Dop_rect_Type3 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type3 (Q_ x_949) .", "predict": "Axiom Dop_rect_Type3 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term univs.Type3 (Q_ x_949) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nConfluent. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.\nassistant\n", "label": "confluent : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A)) .", "predict": "confluent : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAll. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "All : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Univ cic.prop .", "predict": "All : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNotb_elim. Let $b$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_bool.match_bool$ applied to $cic.type$ applied to $cic.z$ and the function that maps $__$ to $cic.univ$ applied to $cic.prop$ and $P$ applied to $matita_basics_bool.false$ and $P$ applied to $matita_basics_bool.true$ and $b$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_basics_bool.notb$ applied to $b$.\nassistant\n", "label": "axiom notb_elim (b : cic.Term univs.Type0 matita_basics_bool.bool) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (λ __ => cic.univ cic.prop) (P matita_basics_bool.false) (P matita_basics_bool.true) b)) : cic.Term cic.prop (P (matita_basics_bool.notb b))", "predict": "axiom notb_elim (b : cic.Term univs.Type0 matita_basics_bool.bool) (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_bool.match_bool (cic.type cic.z) (λ __ => cic.univ cic.prop) (P matita_basics_bool.false) (P matita_basics_bool.true) b)) : cic.Term cic.prop (P (matita_basics_bool.notb b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_CProp3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.\nassistant\n", "label": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)", "predict": "postulate eq_rect_CProp3_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_945$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and", "label": "Dop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type4 (Q_ x_945) .", "predict": "Dop_rect_Type4 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type4) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_945 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type4 (Q_ x_945) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_CProp5. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_654$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_654$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_654$.\nassistant\n", "label": "postulate DPair_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_654)", "predict": "postulate DPair_rect_CProp5 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_654 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_654)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_S_S_to_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_S_S_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_S_S_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $a1$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $a1$ and $x$ and $y$, $cic.Term$ holds for", "label": "range_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) => cic.univ univs.Type2) (t0 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 a1) => t1 : cic.Term univs.Type0 matita_arithmetics_nat.nat => t2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) => matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) => cic.univ univs.Type2) (u0 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 a1) => u1 : cic.Term univs.Type0 matita_arithmetics_nat.nat => u2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => a1)) t0) u0) (e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => a1)) t0) u0) => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((x0 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 a1) => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat => a1))) (matita_basics_logic.R", "predict": "range_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) => cic.univ univs.Type2) (t0 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) => t1 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) => t2 : (__ : cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_bool.bool) => matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) => cic.univ univs.Type2) (u0 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) => u1 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) => u2 : (__ : cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_bool.bool) => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_nat.nat)) (matita_basics_logic.R0 matita_arithmetics_nat.nat t0) u0) (e0 : cic.Term cic.prop (matita_basics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPosition_of_aux. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom position_of_aux (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)", "predict": "axiom position_of_aux (A : cic.Univ univs.Type0) (_found : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_acc : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_to_mod. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.\nassistant\n", "label": "axiom le_to_mod (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m))", "predict": "axiom le_to_mod (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_div_and_mod.mod n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFact. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "fact : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "fact : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z942$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z943$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) .", "predict": "unit_inv_rect_CProp4 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z942 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ cic.prop) -> _H1 : (_z943 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAppend_l1_injective. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $matita_basics_lists_list.length$ applied to $A$ and $l2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "postulate append_l1_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)", "predict": "postulate append_l1_injective : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) (matita_basics_lists_list.length A l2))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_CProp1. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z641$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z642$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_CProp1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) .", "predict": "bool_inv_rect_CProp1 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_aux. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom div_aux : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom div_aux : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_range. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_range : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ return_sort) -> (case_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_Type3_body. For all functions $Q_$ from elements $_x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_true$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_335$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_335$.\nassistant\n", "label": "bool_rect_Type3_body : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) .", "predict": "bool_rect_Type3_body : Q_ : (_x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type3) -> _H_true : cic.Term univs.Type3 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type3 (Q_ matita_basics_bool.false) -> x_335 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type3 (Q_ x_335) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_CProp2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1548$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic", "label": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Aop_inv_rect_CProp2 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> P : (_z1548 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1549 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDecidable_mem_nat. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $n$ and $l$.\nassistant\n", "label": "decidable_mem_nat : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)) .", "predict": "decidable_mem_nat : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nConfluent. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.\nassistant\n", "label": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))", "predict": "postulate confluent : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_700$.\nassistant\n", "label": "Prod_rect_Type1 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type1) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type1 (Q_ x_700) .", "predict": "Prod_rect_Type1 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type1) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type1 (Q_ x_700) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.\nassistant\n", "label": "Axiom eq_rect_CProp5_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_25 : cic.Term univs.Type2 A, forall x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25), cic.Term cic.prop (Q_ x_25 x_26) .", "predict": "Axiom eq_rect_CProp5_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_25 : cic.Term univs.Type2 A, forall x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25), cic.Term cic.prop (Q_ x_25 x_26) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBi_RC. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$.\nassistant\n", "label": "axiom bi_RC (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)", "predict": "axiom bi_RC (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)) : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_781$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_781$ of", "label": "axiom Aop_ind_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_781)", "predict": "axiom Aop_ind_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_781)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_inv_ind. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z587$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z588$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate bool_inv_ind : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate bool_inv_ind : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z587 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z588 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nGcd_mod. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.\nassistant\n", "label": "gcd_mod : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n)) .", "predict": "gcd_mod : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_rect_CProp4. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_615$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_615$, for all elements $x_614$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_614$.\nassistant\n", "label": "option_rect_CProp4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_615 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) -> x_614 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_614) .", "predict": "option_rect_CProp4 : _A : cic.Univ univs.Type0 -> Q_ : (_x_614 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ cic.prop) -> _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_615 : cic.Term univs.Type0 _A -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_615))) -> x_614 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term cic.prop (Q_ x_614) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_CProp1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_712$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_712$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_712$.\nassistant\n", "label": "postulate Prod_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_712)", "predict": "postulate Prod_rect_CProp1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_712)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIff_trans. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $C$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $C$.\nassistant\n", "label": "axiom iff_trans (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) : cic.Term cic.prop (matita_basics_logic.iff A C)", "predict": "axiom iff_trans (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) : cic.Term cic.prop (matita_basics_logic.iff A C)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_map. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $__$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $x$ and $g$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $g$ and $l$.\nassistant\n", "label": "eq_map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : (x : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l)) .", "predict": "eq_map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : (x : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f x) (g x))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list B)) (matita_basics_lists_list.map A B f l) (matita_basics_lists_list.map A B g l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_ex. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "match_ex : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ return_sort) -> case_ex_intro : (x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (_P x) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z) .", "predict": "match_ex : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Univ return_sort) -> case_ex_intro : (x : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (_P x) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> z : cic.Term cic.prop (matita_basics_logic.ex A _P) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_log_n_n. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $n$.\nassistant\n", "label": "axiom lt_log_n_n (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log p n) n)", "predict": "axiom lt_log_n_n (p n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_log.log p n) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEx_intro. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $P$.\nassistant\n", "label": "axiom ex_intro (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (x : cic.Term univs.Type0 A) (__ : cic.Term cic.prop (P x)) : cic.Term cic.prop (matita_basics_logic.ex A P)", "predict": "axiom ex_intro (A : cic.Univ univs.Type0) (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (x : cic.Term univs.Type0 A) (__ : cic.Term cic.prop (P x)) : cic.Term cic.prop (matita_basics_logic.ex A P)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nassistant\n", "label": "axiom range_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)", "predict": "axiom range_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_Type0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_748$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_747$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_750$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_748$ and $x_747$, for all elements $x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_746$.\nassistant\n", "label": "Axiom list_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type0), forall _H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_748 : cic.Term univs.Type0 _A) -> (x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_750 : cic.Term univs.Type0 (Q_ x_747)) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))), forall x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type0 (Q_ x_746) .", "predict": "Axiom list_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type0), forall _H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_748 : cic.Term univs.Type0 _A) -> (x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_750 : cic.Term univs.Type0 (Q_ x_747)) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))), forall x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type0 (Q_ x_746) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp1. Let $Q_$ be a function from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "nat_rect_CProp1 : Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_412 : cic.Term cic.prop (Q_ x_410) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_409) .", "predict": "nat_rect_CProp1 : Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_412 : cic.Term cic.prop (Q_ x_410) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_409) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_length2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and the function that maps $x$ to $matita_basics_bool.notb$ applied to $p$ applied to $x$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "postulate filter_length2 : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A (matita_basics_lists_list.filter A p l)) (matita_basics_lists_list.length A (matita_basics_lists_list.filter A (\\ x : cic.Term univs.Type0 A -> matita_basics_bool.notb (p x)) l))) (matita_basics_lists_list.length A l))", "predict": "postulate filter_length2 : (A : cic.Univ univs.Type0) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_basics_lists_list.length A (matita_basics_lists_list.filter A p l)) (matita_basics_lists_list.length A (matita_basics_lists_list.filter A (\\ x : cic.Term univs.Type0 A -> matita_basics_bool.notb (p x)) l))) (matita_basics_lists_list.length A l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_rect_CProp3. Let $Q_$ be a function from elements $_x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_353$.\nassistant\n", "label": "axiom bool_rect_CProp3 (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_353)", "predict": "axiom bool_rect_CProp3 (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term cic.prop (Q_ x_353)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.\nassistant\n", "label": "Axiom lstar : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_relations.relation B) .", "predict": "Axiom lstar : forall B : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_relations.relation B) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom mod_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m))) .", "predict": "Axiom mod_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.\nassistant\n", "label": "axiom Prod_rect_Type3_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type3 (Q_ x_696)", "predict": "axiom Prod_rect_Type3_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type3 (Q_ x_696)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_rect_CProp2. For all functions $Q_$ from elements $_x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_60$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_60$.\nassistant\n", "label": "True_rect_CProp2 : Q_ : (_x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_60) .", "predict": "True_rect_CProp2 : Q_ : (_x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Univ cic.prop) -> _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) -> x_60 : cic.Term cic.prop matita_basics_logic.True -> cic.Term cic.prop (Q_ x_60) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nIncreasing_to_injective. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.increasing$ applied to $f$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $f$.\nassistant\n", "label": "increasing_to_injective : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f) .", "predict": "increasing_to_injective : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_arithmetics_nat.increasing f) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat f) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_Type1_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_925$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_925$.\nassistant\n", "label": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)", "predict": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_of_primes_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate list_of_primes_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_chebyshev_bertrand256.lprim n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)))", "predict": "postulate list_of_primes_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_chebyshev_bertrand256.lprim n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_lists_list.nil matita_arithmetics_nat.nat)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_DPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_DPair (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_DPair (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.\nassistant\n", "label": "axiom list_rect_CProp0 (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)", "predict": "axiom list_rect_CProp0 (_A : cic.Univ univs.Type0) (Q_ : (_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) (_H_cons : (x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))) (x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term cic.prop (Q_ x_776)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAntisymmetric. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate antisymmetric : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate antisymmetric : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate lt : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate lt : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_times_div_m_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $m$ and $n$.\nassistant\n", "label": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)", "predict": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_789$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all", "label": "Aop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_789) .", "predict": "Aop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_789 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_789) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_ind. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_86", "label": "axiom Aop_ind (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_861)", "predict": "axiom Aop_ind (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term cic.prop (Q_ x_861)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_to_not_lt. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom le_to_not_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n)) .", "predict": "Axiom le_to_not_lt : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_rect_Type1. Let $Q_$ be a function from elements $_x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_505$.\nassistant\n", "label": "unit_rect_Type1 : Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type1) -> _H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it) -> x_505 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type1 (Q_ x_505) .", "predict": "unit_rect_Type1 : Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type1) -> _H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it) -> x_505 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type1 (Q_ x_505) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTranspose_i_j_j. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $j$ and $i$.\nassistant\n", "label": "postulate transpose_i_j_j : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j j) i)", "predict": "postulate transpose_i_j_j : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j j) i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_Type5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_947$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$", "label": "postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)", "predict": "postulate Dop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_947 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type5 (Q_ x_947)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_times_n. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "postulate lt_times_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.times n m))", "predict": "postulate lt_times_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.times n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_CProp1. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z377$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z378$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_164$ and $x_163$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp1 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_164 : cic.Term cic.prop x1) -> (x_163 : cic.Term cic.prop x2) -> (_z378 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRC_reflexive. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.reflexive$ applied to $A$ and $matita_basics_relations.RC$ applied to $A$ and $R$.\nassistant\n", "label": "Axiom RC_reflexive : forall A : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R)) .", "predict": "Axiom RC_reflexive : forall A : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_949$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and", "label": "Dop_rect_Type3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type3) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type3 (Q_ x_949) .", "predict": "Dop_rect_Type3 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type3) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type3 (Q_ x_949) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIrreflexive. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate irreflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate irreflexive : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLog_times_l. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "axiom log_times_l (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))", "predict": "axiom log_times_l (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_previous_prime5. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_previous_prime5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_previous_prime5 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $a1$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $a1$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z37$ to $P$ and the function that maps $u0$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and the function that maps $t0$ to $matita_basics_types.match_option$ applied to $a1$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1", "label": "option_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.option a1) -> y : cic.Term univs.Type0 (matita_basics_types.option a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z37 : cic.Term univs.Type1 P => P))) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (t0 : cic.Term univs.Type0 a1 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type", "predict": "option_discr : a1 : cic.Univ univs.Type0 -> x : cic.Term univs.Type0 (matita_basics_types.option a1) -> y : cic.Term univs.Type0 (matita_basics_types.option a1) -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option a1)) x y) -> cic.Term univs.Type2 (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z37 : cic.Term univs.Type1 P => P))) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (t0 : cic.Term univs.Type0 a1 => matita_basics_types.match_option a1 (cic.succ univs.Type2) (__ : cic.Term univs.Type0 (matita_basics_types.option a1) => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (u0 : cic.Term univs.Type0 a1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nP_ord_aux_false. For all elements $p$ and $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate p_ord_aux_false : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) (matita_arithmetics_nat.S a))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n))", "predict": "postulate p_ord_aux_false : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) (matita_arithmetics_nat.S a))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqb_sym. Let $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $a$ and $b$ and $matita_arithmetics_nat.eqb$ applied to $b$ and $a$.\nassistant\n", "label": "eqb_sym : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a)) .", "predict": "eqb_sym : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb a b) (matita_arithmetics_nat.eqb b a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1560$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$", "label": "Axiom Aop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Aop_inv_rect_CProp0 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2), forall P : ((_z1560 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1561 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1092$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1093$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_631$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1093$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_631$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_631$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom option_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1092 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_631 : cic.Term univs.Type0 x1) -> (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_631))) : cic.Term cic.prop (P Hterm)", "predict": "axiom option_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) (P : (_z1092 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) (_H1 : (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) (_H2 : (x_631 : cic.Term univs.Type0 x1) -> (_z1093 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_631))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_631))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_to_leb_false. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "axiom lt_to_leb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "axiom lt_to_leb_false (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLprim_body. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "lprim_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) .", "predict": "lprim_body : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_666$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_666$.\nassistant\n", "label": "Axiom Sig_rect_Type4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type4 (Q_ x_666) .", "predict": "Axiom Sig_rect_Type4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type4), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_666 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type4 (Q_ x_666) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_CProp3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.\nassistant\n", "label": "Axiom list_rect_CProp3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))), forall x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_761) .", "predict": "Axiom list_rect_CProp3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))), forall x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_761) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_ind_body. Let $Q_$ be a function from elements $_x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_66$.\nassistant\n", "label": "Axiom False_ind_body : forall Q_ : ((_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_66 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_66) .", "predict": "Axiom False_ind_body : forall Q_ : ((_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_66 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_66) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nHd. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_d$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "postulate hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_d : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A", "predict": "postulate hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (_d : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1146$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1147$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom DPair_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom DPair_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0), forall Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2), forall P : ((_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $i$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "postulate lt_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))", "predict": "postulate lt_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMatch_min_spec. For all elements $_n$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_min", "label": "Axiom match_min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort), forall case_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return", "predict": "Axiom match_min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall return_sort : cic.Sort, forall return_type : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort), forall case_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.min _n _b _f __))), forall case_not_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_Type1. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_nmk$ from functions $x_95$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_95$, for all elements $x_94$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_94$.\nassistant\n", "label": "Axiom Not_rect_Type1 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type1), forall _H_nmk : ((x_95 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))), forall x_94 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type1 (Q_ x_94) .", "predict": "Axiom Not_rect_Type1 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type1), forall _H_nmk : ((x_95 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))), forall x_94 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type1 (Q_ x_94) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_CProp5. Let $Q_$ be a function from elements $_x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_511$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_511$.\nassistant\n", "label": "postulate unit_rect_CProp5 : (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_511)", "predict": "postulate unit_rect_CProp5 : (Q_ : (_x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_511 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_511)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAll_mp. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ to elements of $cic.Term$ of $cic.prop$ and $Q$ applied to $a$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $Q$ and $l$.\nassistant\n", "label": "Axiom All_mp : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall __ : ((a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P a)) -> cic.Term cic.prop (Q a)), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l), cic.Term cic.prop (matita_basics_lists_list.All A Q l) .", "predict": "Axiom All_mp : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall __ : ((a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (P a)) -> cic.Term cic.prop (Q a)), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __1 : cic.Term cic.prop (matita_basics_lists_list.All A P l), cic.Term cic.prop (matita_basics_lists_list.All A Q l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMinus_pred_pred. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.pred$ applied to $n$ and $matita_arithmetics_nat.pred$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))", "predict": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLhd_cons_ltl. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.lhd$ applied to $A$ and $l$ and $n$ and $matita_basics_lists_list.ltl$ applied to $A$ and $l$ and $n$ and $l$.\nassistant\n", "label": "postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)", "predict": "postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_exp_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.\nassistant\n", "label": "postulate divides_exp_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n)", "predict": "postulate divides_exp_to_divides : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m))) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_ACop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom match_ACop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) (case_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom match_ACop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ return_sort) (case_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nGe. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom ge : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom ge : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_rect_Type3_body. Let $Q_$ be a function from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$. Then for all elements $_H_I$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.\nassistant\n", "label": "Axiom True_rect_Type3_body : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) .", "predict": "Axiom True_rect_Type3_body : forall Q_ : ((_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3), forall _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I), forall x_46 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type3 (Q_ x_46) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_ex2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_ex2 : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term return_sort (return_type z) .", "predict": "filter_ex2 : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_aux. Let $_p$ and $_m$ and $_n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom mod_aux : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom mod_aux : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec_ind_body. Let $_n$ and $_b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $", "label": "Axiom min_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop), forall _H_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool", "predict": "Axiom min_spec_ind_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop), forall _H_found_min_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.min _n _b _f x_1075))), forall _H_not_found_min_spec : ((x_1081 : cic.Term cic.prop (matita_arithmetics_nat.lt _b matita_arithmetics_nat.plus _n _b)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.min _n _b _"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_smallest_factor_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "le_smallest_factor_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "le_smallest_factor_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "div_mod_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "div_mod_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSplit_rev_len. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ and $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $acc$.\nassistant\n", "label": "axiom split_rev_len (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l acc : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_arithmetics_nat.plus n (matita_basics_lists_list.length A acc)))", "predict": "axiom split_rev_len (A : cic.Univ univs.Type0) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l acc : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_arithmetics_nat.plus n (matita_basics_lists_list.length A acc)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_CProp2_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.\nassistant\n", "label": "postulate DPair_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_658)", "predict": "postulate DPair_rect_CProp2_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_658)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_pair_fst_snd. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $p$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $p$.\nassistant\n", "label": "Axiom eq_pair_fst_snd : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p))) .", "predict": "Axiom eq_pair_fst_snd : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall p : cic.Term univs.Type0 (matita_basics_types.Prod A B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B (matita_basics_types.fst A B p) (matita_basics_types.snd A B p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIrreflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom irreflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom irreflexive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_16171. Let $p$ and $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq$ applied to $", "label": "let_clause_16171 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd", "predict": "let_clause_16171 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.n"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.\nassistant\n", "label": "axiom Sum_rect_Type0_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type0 (Q_ x_551)", "predict": "axiom Sum_rect_Type0_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type0) (_H_inl : (x_552 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) (_H_inr : (x_553 : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) (x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type0 (Q_ x_551)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_to_not_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nassistant\n", "label": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) .", "predict": "lt_to_not_le : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_m. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_m : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type3. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.\nassistant\n", "label": "Prod_rect_Type3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) .", "predict": "Prod_rect_Type3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_rect_CProp0. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.\nassistant\n", "label": "Axiom eq_rect_CProp0 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_37 : cic.Term univs.Type2 A, forall x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37), cic.Term cic.prop (Q_ x_37 x_38) .", "predict": "Axiom eq_rect_CProp0 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_37 : cic.Term univs.Type2 A) -> (_x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_37 : cic.Term univs.Type2 A, forall x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37), cic.Term cic.prop (Q_ x_37 x_38) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTransitive_divides. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.transitive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.divides$.\nassistant\n", "label": "Axiom transitive_divides : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_primes.divides) .", "predict": "Axiom transitive_divides : cic.Term cic.prop (matita_basics_relations.transitive matita_arithmetics_nat.nat matita_arithmetics_primes.divides) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLog_exp. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.\nassistant\n", "label": "Axiom log_exp : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m))) .", "predict": "Axiom log_exp : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_inv_step. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $b1$ and $b2$.\nassistant\n", "label": "Axiom lstar_inv_step : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2), cic.Term cic.prop (R b1 b2) .", "predict": "Axiom lstar_inv_step : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b1 : cic.Term univs.Type0 B, forall b2 : cic.Term univs.Type0 B, forall __ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.S matita_arithmetics_nat.O) b1 b2), cic.Term cic.prop (R b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMinus_minus_comm. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $a$ and $c$ and $b$.\nassistant\n", "label": "axiom minus_minus_comm (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a b) c) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a c) b))", "predict": "axiom minus_minus_comm (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a b) c) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus a c) b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nInjective_invert_permut. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $n$.\nassistant\n", "label": "injective_invert_permut : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> cic.Term cic.prop (matita_arithmetics_permutation.injn (matita_arithmetics_permutation.invert_permut n f) n) .", "predict": "injective_invert_permut : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n) -> cic.Term cic.prop (matita_arithmetics_permutation.injn (matita_arithmetics_permutation.invert_permut n f) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMonotonic_lt_plus_r. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "monotonic_lt_plus_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.plus n m)) .", "predict": "monotonic_lt_plus_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.plus n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $len$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lt2m$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics", "label": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_10331 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt2m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) m), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nStreicherK. Let $T$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $t$ of $cic.Term$ of $univs.Type2$ and $T$, for all functions $P$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $__$ of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.refl$ applied to $T$ and $t$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $T$ and $t$ and $t$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $p$.\nassistant\n", "label": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) .", "predict": "streicherK : T : cic.Univ univs.Type2 -> t : cic.Term univs.Type2 T -> P : (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Univ univs.Type2) -> __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) -> p : cic.Term cic.prop (matita_basics_logic.eq T t t) -> cic.Term univs.Type2 (P p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "Axiom eqb_true_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) .", "predict": "Axiom eqb_true_to_eq : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_775$ from elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_772$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_772$ and elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_773$ and $x_772$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_773$ and $x_772$, $cic.Term$ holds for $cic.prop", "label": "list_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_773 : cic.Term univs.Type0 x1 -> x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772) -> cic.Term cic.prop (P x_772)) -> _z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm) .", "predict": "list_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ cic.prop) -> _H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_773 : cic.Term univs.Type0 x1 -> x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772) -> cic.Term cic.prop (P x_772)) -> _z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772)) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEx_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_primes.prime$ applied to $m$.\nassistant\n", "label": "postulate ex_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n m) (matita_arithmetics_nat.le m (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) (matita_arithmetics_primes.prime m)))", "predict": "postulate ex_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n m) (matita_arithmetics_nat.le m (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)))) (matita_arithmetics_primes.prime m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_upper_bound4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_upper_bound4 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_CProp2. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_160$ and $x_159$, for all elements $x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_158$.\nassistant\n", "label": "postulate And_rect_CProp2 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_158)", "predict": "postulate And_rect_CProp2 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) -> (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_158)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAxiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom gcd (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom gcd (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_7", "label": "axiom Aop_rect_CProp5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_797)", "predict": "axiom Aop_rect_CProp5 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) (x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term cic.prop (Q_ x_797)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nInjective_exp_r. Let $b$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $b$ and $i$.\nassistant\n", "label": "Axiom injective_exp_r : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b), cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (fun i => matita_arithmetics_exp.exp b i)) .", "predict": "Axiom injective_exp_r : forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) b), cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (fun i => matita_arithmetics_exp.exp b i)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSucc. If $Sort$, then $Sort$.\nassistant\n", "label": "Axiom succ : Sort -> Sort .", "predict": "Axiom succ : Sort -> Sort ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_inv_rect_Type2. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z275$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $x_92$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z276$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_92$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_92$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom Not_inv_rect_Type2 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ univs.Type2) (_H1 : (x_92 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z276 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_92))) -> cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nInjective_times_r. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "postulate injective_times_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times n m))", "predict": "postulate injective_times_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFst_p_ord_times. For all elements $p$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.fst$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$.\nassistant\n", "label": "Axiom fst_p_ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p)) (matita_arithmetics_nat.plus (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p)) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p)))) .", "predict": "Axiom fst_p_ord_times : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord (matita_arithmetics_nat.times a b) p)) (matita_arithmetics_nat.plus (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p)) (matita_basics_types.fst matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_inv_rect_CProp4. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then for all functions $P$ from elements $_z161$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_rect_CProp5. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.\nassistant\n", "label": "Axiom Sum_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))), forall _H_inr : ((x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))), forall x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_561) .", "predict": "Axiom Sum_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))), forall _H_inr : ((x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))), forall x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_561) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_lstar. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $__$ and $__1$ and $__2$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_lstar_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_O$ applied to $B$ and $_R$ and $b$, for all functions $case_lstar_S$ from elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b1$ and $b$ and elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $_R$ and $l$ and $b$ and $b2$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$ and $matita_arithmetics_lstar.lstar_S$ applied to $", "label": "match_lstar : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Univ return_sort) -> case_lstar_O : (b : cic.Term univs.Type0 B -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> case_lstar_S : (b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (_R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Term return_sort (return_type __ __1 __2 z) .", "predict": "match_lstar : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> return_sort : cic.Sort -> return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Univ return_sort) -> case_lstar_O : (b : cic.Term univs.Type0 B -> cic.Term return_sort (return_type matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_O B _R b))) -> case_lstar_S : (b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (_R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R l b b2) -> cic.Term return_sort (return_type (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_S B _R b1 b __ l b2 __1))) -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 B -> __2 : cic.Term univs.Type0 B -> z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2) -> cic.Term return_sort (return_type __ __1 __2 z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_case. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.\nassistant\n", "label": "Axiom nat_case : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall __1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))), cic.Term cic.prop (P n) .", "predict": "Axiom nat_case : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)), forall __1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))), cic.Term cic.prop (P n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEx_inv_ind. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z455$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $x$ and elements $_z456$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.ex$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.ex_intro$ applied to $x1$ and $x2$ and $x$ and $x_236$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.ex_intro$ applied to $x1$ and $x2$ and $x$ and $x_236$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom ex_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2), forall P : ((_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x : cic.Term univs.Type0 x1) -> (x_236 : cic.Term cic.prop (x2 x)) -> (_z456 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2)) Hterm (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom ex_inv_ind : forall x1 : cic.Univ univs.Type0, forall x2 : ((__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop), forall Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2), forall P : ((_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x : cic.Term univs.Type0 x1) -> (x_236 : cic.Term cic.prop (x2 x)) -> (_z456 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2)) Hterm (matita_basics_logic.ex_intro x1 x2 x x_236))) -> cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_discr. For all elements $x$ and $y$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_logic.match_True$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_logic.match_True$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z5$ to $P$ and $y$ and $x$.\nassistant\n", "label": "axiom True_discr (x y : cic.Term cic.prop matita_basics_logic.True) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y)) : cic.Term univs.Type2 (matita_basics_logic.match_True (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (matita_basics_logic.match_True (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 P (λ _z5 => P))) y) x)", "predict": "axiom True_discr (x y : cic.Term cic.prop matita_basics_logic.True) (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y)) : cic.Term univs.Type2 (matita_basics_logic.match_True (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (matita_basics_logic.match_True (cic.succ univs.Type2) (λ __ => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (λ P => cic.prod univs.Type1 univs.Type1 P (λ _z5 => P))) y) x)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_ind_body. Let $Q_$ be a function from elements $_x_40$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_40$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_40$.\nassistant\n", "label": "axiom True_ind_body (Q_ : (_x_40 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_40 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_40)", "predict": "axiom True_ind_body (Q_ : (_x_40 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_40 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_40)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_div_times_m. For all elements $a$ and $i$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $i$ and $m$ and $matita_arithmetics_div_and_mod.div$ applied to $a$ and $i$.\nassistant\n", "label": "Axiom le_div_times_m : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div m i)) m) (matita_arithmetics_div_and_mod.div a i)) .", "predict": "Axiom le_div_times_m : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a (matita_arithmetics_div_and_mod.div m i)) m) (matita_arithmetics_div_and_mod.div a i)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_ind. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_915$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_915$.\nassistant\n", "label": "axiom range_ind (_A : cic.Univ univs.Type0) (Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_915)", "predict": "axiom range_ind (_A : cic.Univ univs.Type0) (Q_ : (_x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_915 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_915)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.\nassistant\n", "label": "Axiom Sig_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term cic.prop (Q_ x_684) .", "predict": "Axiom Sig_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term cic.prop (Q_ x_684) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBk. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Bk : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Bk : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCompose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all functions $_g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_x$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $C$.\nassistant\n", "label": "Axiom compose : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall _g : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall _x : cic.Term univs.Type0 A, cic.Term univs.Type0 C .", "predict": "Axiom compose : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall _g : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall _x : cic.Term univs.Type0 A, cic.Term univs.Type0 C ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFind_body. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $B$.\nassistant\n", "label": "axiom find_body (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_types.option B)", "predict": "axiom find_body (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 (matita_basics_types.option B)) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_types.option B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nP_ord_p. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $p$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom p_ord_p (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "axiom p_ord_p (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_pi. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $f$ applied to $i$ and $m$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $m$.\nassistant\n", "label": "exp_pi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) m)) .", "predict": "exp_pi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp (f i) m)) (matita_arithmetics_exp.exp (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_inv_rect_CProp3. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z948$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z949$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom unit_inv_rect_CProp3 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z948 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z949 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)", "predict": "axiom unit_inv_rect_CProp3 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z948 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H1 : (_z949 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nB. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom B : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom B : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMin_spec_to_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "min_spec_to_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m) .", "predict": "min_spec_to_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_bertrand_to_le1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate not_bertrand_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))", "predict": "postulate not_bertrand_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_minus. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $q$.\nassistant\n", "label": "axiom divides_minus (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q)) : cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q))", "predict": "axiom divides_minus (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q)) : cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_to_not_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$.\nassistant\n", "label": "axiom le_to_not_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n))", "predict": "axiom le_to_not_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.lt m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_rect_Type3. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_div_mod_spec_intro$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_823$ and $x_822$, for all elements $x_821$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_821$.\nassistant\n", "label": "postulate div_mod_spec_rect_Type3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)", "predict": "postulate div_mod_spec_rect_Type3 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type3) -> (_H_div_mod_spec_intro : (x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_823 x_822))) -> (x_821 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type3 (Q_ x_821)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "plus_to_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p) .", "predict": "plus_to_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.\nassistant\n", "label": "DPair_rect_CProp2 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_658) .", "predict": "DPair_rect_CProp2 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_658) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDistributive_times_minus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.minus$.\nassistant\n", "label": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)", "predict": "postulate distributive_times_minus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.minus)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_rect_CProp4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_148$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_147$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_148$ and $x_147$, for all elements $x_146$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_146$.\nassistant\n", "label": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) .", "predict": "And_rect_CProp4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_148 : cic.Term cic.prop _A -> x_147 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) -> x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_146) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_elim2. For all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $__2$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$ and $m$.\nassistant\n", "label": "axiom nat_elim2 (R : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R matita_arithmetics_nat.O n)) (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) (__2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (R n m)) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (R n m)", "predict": "axiom nat_elim2 (R : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R matita_arithmetics_nat.O n)) (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) (__2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (R n m)) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (R n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1034. For all elements $n$ and $m$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "axiom let_clause_1034 (n m q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))", "predict": "axiom let_clause_1034 (n m q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAll_nth. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.All$ applied to $A$ and $P$ and $l$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $matita_basics_lists_list.nth_opt$ applied to $A$ and $n$ and $l$ and $matita_basics_types.Some$ applied to $A$ and $a$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.\nassistant\n", "label": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)", "predict": "postulate All_nth : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) (matita_basics_lists_list.nth_opt A n l) (matita_basics_types.Some A a))) -> cic.Term cic.prop (P a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $m$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $c$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_ar", "label": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))", "predict": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFact_to_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "postulate fact_to_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))", "predict": "postulate fact_to_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_factorial.fact n)) (matita_arithmetics_factorial.fact n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMk_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$.\nassistant\n", "label": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) .", "predict": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_rect_Type0_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_inl$ from elements $x_552$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_552$, for all functions $_H_inr$ from elements $x_553$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_553$, for all elements $x_551$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_551$.\nassistant\n", "label": "Sum_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) .", "predict": "Sum_rect_Type0_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type0) -> _H_inl : (x_552 : cic.Term univs.Type0 _A -> cic.Term univs.Type0 (Q_ (matita_basics_types.inl _A _B x_552))) -> _H_inr : (x_553 : cic.Term univs.Type0 _B -> cic.Term univs.Type0 (Q_ (matita_basics_types.inr _A _B x_553))) -> x_551 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type0 (Q_ x_551) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_698$.\nassistant\n", "label": "axiom Prod_rect_Type2_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type2 (Q_ x_698)", "predict": "axiom Prod_rect_Type2_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type2 (Q_ x_698)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLop_Sfalse. Let $m$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.list_divides$ applied to $acc$ and $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $i$ and $acc$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_basics_lists_list.append$ applied to $matita_arithmetics_nat.nat$ and $acc$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $i$ and $matita_basics_lists_list.nil$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom lop_Sfalse : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S m) i acc) (matita_arithmetics_chebyshev_bertrand256.lprim m (matita_arithmetics_nat.S i) (matita_basics_lists_list.append matita_arithmetics_nat.nat acc (matita_basics_lists_list.cons matita_arithmetics_nat.nat i (matita_basics_lists_list.nil matita_arithmetics_nat.nat))))) .", "predict": "Axiom lop_Sfalse : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (matita_arithmetics_chebyshev_bertrand256.lprim (matita_arithmetics_nat.S m) i acc) (matita_arithmetics_chebyshev_bertrand256.lprim m (matita_arithmetics_nat.S i) (matita_basics_lists_list.append matita_arithmetics_nat.nat acc (matita_basics_lists_list.cons matita_arithmetics_nat.nat i (matita_basics_lists_list.nil matita_arithmetics_nat.nat))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.\nassistant\n", "label": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)", "predict": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_rect_Type2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.\nassistant\n", "label": "list_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type2) -> _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_738 : cic.Term univs.Type0 _A -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_740 : cic.Term univs.Type2 (Q_ x_737) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type2 (Q_ x_736) .", "predict": "list_rect_Type2 : _A : cic.Univ univs.Type0 -> Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ univs.Type2) -> _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_738 : cic.Term univs.Type0 _A -> x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_740 : cic.Term univs.Type2 (Q_ x_737) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term univs.Type2 (Q_ x_736) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1740$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__", "label": "Dop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) .", "predict": "Dop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_option. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_option : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term return_sort (return_type z) .", "predict": "filter_option : _A : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_or_ge. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "le_or_ge : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.le m n) (matita_arithmetics_nat.le n m)) .", "predict": "le_or_ge : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.le m n) (matita_arithmetics_nat.le n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDistr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.\nassistant\n", "label": "Axiom distr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) .", "predict": "Axiom distr_body : forall A : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 A, forall xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil), forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 A, forall c : cic.Term univs.Type0 A, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_Type2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_698$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_698$.\nassistant\n", "label": "postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)", "predict": "postulate Prod_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type2) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_698 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type2 (Q_ x_698)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_Type3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z335$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z336$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_Sig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Sig : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCr_pair5. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate cr_pair5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_arithmetics_nat.O (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))))", "predict": "postulate cr_pair5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) matita_arithmetics_nat.O (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))))))))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSub_lt. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $e$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to the function that maps $x$ to $x$ and the function that maps $x$ to $x$ and $A$ and $matita_arithmetics_bigops.mk_range$ applied to $A$ and $e$ and $n$ and $p$ and $matita_arithmetics_bigops.mk_range$ applied to $A$ and $e$ and $m$ and $p$.\nassistant\n", "label": "axiom sub_lt (A : cic.Univ univs.Type0) (e : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (λ x => x) (λ x => x) A (matita_arithmetics_bigops.mk_range A e n p) (matita_arithmetics_bigops.mk_range A e m p))", "predict": "axiom sub_lt (A : cic.Univ univs.Type0) (e : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk (λ x => x) (λ x => x) A (matita_arithmetics_bigops.mk_range A e n p) (matita_arithmetics_bigops.mk_range A e m p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_le. For all elements $_n$ and $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_le : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z) .", "predict": "filter_le : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_nat.le _n __) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_mod_to_divides. Let $n$ and $m$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "eq_mod_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m)) .", "predict": "eq_mod_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q)) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMk_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, for all functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $nil$ and $a$ and $a$, for all functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $nil$ and $a$, for all functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.\nassistant\n", "label": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) .", "predict": "mk_Aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_minus. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $q$.\nassistant\n", "label": "divides_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q) -> cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q)) .", "predict": "divides_minus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides n p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n q) -> cic.Term cic.prop (matita_arithmetics_primes.divides n (matita_arithmetics_nat.minus p q)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1571. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "axiom let_clause_1571 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)", "predict": "axiom let_clause_1571 (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLd_to_prime. For all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $acc$ and $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.list_divides$ applied to $acc$ and $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $i$.\nassistant\n", "label": "Axiom ld_to_prime : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false), cic.Term cic.prop (matita_arithmetics_primes.prime i) .", "predict": "Axiom ld_to_prime : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below acc i), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides acc i) matita_basics_bool.false), cic.Term cic.prop (matita_arithmetics_primes.prime i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExists_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate Exists_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop", "predict": "postulate Exists_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_intro. Let $n$ and $m$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $m$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $n$ and $m$ and $q$ and $r$.\nassistant\n", "label": "div_mod_spec_intro : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r) .", "predict": "div_mod_spec_intro : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt r m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_Type1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_700$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_700$.\nassistant\n", "label": "postulate Prod_rect_Type1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type1 (Q_ x_700)", "predict": "postulate Prod_rect_Type1 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type1) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_700 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type1 (Q_ x_700)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le_n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (le_n : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_inv_rect_CProp4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z623$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z624$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z624$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom bool_inv_rect_CProp4 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z623 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H1 : ((_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)), forall _H2 : ((_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)), cic.Term cic.prop (P Hterm) .", "predict": "Axiom bool_inv_rect_CProp4 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z623 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H1 : ((_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)), forall _H2 : ((_z624 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.\nassistant\n", "label": "DPair_rect_Type3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) .", "predict": "DPair_rect_Type3 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type3) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type3 (Q_ x_644) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNill. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "nill : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) .", "predict": "nill : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBc. Let $_n$ and $_k$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate bc : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate bc : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMinus_le_minus_minus_comm. For all elements $b$ and $c$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $c$ and $b$.\nassistant\n", "label": "postulate minus_le_minus_minus_comm : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a c) b))", "predict": "postulate minus_le_minus_minus_comm : (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le c b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a c) b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSplit_rev_eq. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ and $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $acc$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$.\nassistant\n", "label": "split_rev_eq : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A acc) l) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n)))) .", "predict": "split_rev_eq : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A acc) l) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nCommutative. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom commutative (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop", "predict": "axiom commutative (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_plus_to_le. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom eq_plus_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p)), cic.Term cic.prop (matita_arithmetics_nat.le m n) .", "predict": "Axiom eq_plus_to_le : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p)), cic.Term cic.prop (matita_arithmetics_nat.le m n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFact_body. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom fact_body (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom fact_body (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_rect_Type4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_inl$ from elements $x_527$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_527$, for all functions $_H_inr$ from elements $x_528$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_528$, for all elements $x_526$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_526$.\nassistant\n", "label": "Axiom Sum_rect_Type4 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type4), forall _H_inl : ((x_527 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))), forall _H_inr : ((x_528 : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))), forall x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type4 (Q_ x_526) .", "predict": "Axiom Sum_rect_Type4 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type4), forall _H_inl : ((x_527 : cic.Term univs.Type0 _A) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inl _A _B x_527))), forall _H_inr : ((x_528 : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.inr _A _B x_528))), forall x_526 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type4 (Q_ x_526) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDecidable_forall. For all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$ applied to $i$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__1$ to $P$ applied to $i$.\nassistant\n", "label": "Axiom decidable_forall : forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (P i))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.decidable (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (fun __1 => P i)))) .", "predict": "Axiom decidable_forall : forall P : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (P i))), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.decidable (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (fun i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (fun __1 => P i)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.\nassistant\n", "label": "postulate Prod_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)", "predict": "postulate Prod_rect_Type3_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type3) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type3 (Q_ x_696)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.\nassistant\n", "label": "Axiom bijn_transpose : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n), cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n) .", "predict": "Axiom bijn_transpose : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le i n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n), cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "Axiom le_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)) .", "predict": "Axiom le_S : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n m), cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_955$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$", "label": "axiom Dop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type0 (Q_ x_955)", "predict": "axiom Dop_rect_Type0 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type0) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_955 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type0 (Q_ x_955)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExteqR. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "exteqR : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> _S : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> cic.Univ cic.prop .", "predict": "exteqR : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> _S : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_672$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_672$.\nassistant\n", "label": "Axiom Sig_rect_Type2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type2 (Q_ x_672) .", "predict": "Axiom Sig_rect_Type2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type2), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type2 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_672 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type2 (Q_ x_672) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_n", "label": "Axiom Aop_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type1 (Q_ x_791) .", "predict": "Axiom Aop_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type1 (Q_ x_791) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_to_le_min. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "Axiom true_to_le_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le b m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) .", "predict": "Axiom true_to_le_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le b m), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements", "label": "Dop_rect_CProp1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_965) .", "predict": "Dop_rect_CProp1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_965) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nConj. Let $A$ and $B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$.\nassistant\n", "label": "postulate conj : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> (__1 : cic.Term cic.prop B) -> cic.Term cic.prop (matita_basics_logic.And A B)", "predict": "postulate conj : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> (__1 : cic.Term cic.prop B) -> cic.Term cic.prop (matita_basics_logic.And A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom Sum : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, cic.Univ univs.Type0 .", "predict": "Axiom Sum : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nType. Assume that $Nat$. Then $Sort$.\nassistant\n", "label": "postulate type : Nat -> Sort", "predict": "postulate type : Nat -> Sort"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_Type5. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_nmk$ from functions $x_86$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_86$, for all elements $x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_85$.\nassistant\n", "label": "Not_rect_Type5 : _A : cic.Univ cic.prop -> Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type5) -> _H_nmk : (x_86 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type5 (Q_ x_85) .", "predict": "Not_rect_Type5 : _A : cic.Univ cic.prop -> Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type5) -> _H_nmk : (x_86 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type5 (Q_ x_85) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_73. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x134$ and $x135$ and $x136$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $x136$ and $matita_arithmetics_nat.plus$ applied to $x135$ and $matita_arithmetics_nat.plus$ applied to $x134$ and $x136$.\nassistant\n", "label": "Axiom let_clause_73 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136))) .", "predict": "Axiom let_clause_73 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall x134 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x135 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x136 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x134 (matita_arithmetics_nat.plus x135 x136)) (matita_arithmetics_nat.plus x135 (matita_arithmetics_nat.plus x134 x136))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_rect_Type4_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_723$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_722$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_725$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $x_722$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_723$ and $x_722$, for all elements $x_721$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_721$.\nassistant\n", "label": "postulate list_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) -> (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) -> (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type4 (Q_ x_721)", "predict": "postulate list_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type4) -> (_H_nil : cic.Term univs.Type4 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_723 : cic.Term univs.Type0 _A) -> (x_722 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_725 : cic.Term univs.Type4 (Q_ x_722)) -> cic.Term univs.Type4 (Q_ (matita_basics_lists_list.cons _A x_723 x_722))) -> (x_721 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type4 (Q_ x_721)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1033. For all elements $p$ and $n$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $ndivpr$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, for all elements $q0$ and $q1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $q1$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $q1$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), forall q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1))), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)), forall Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r)), forall q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1))), forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_inv_rect_Type1. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z611$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $_z612$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z612$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom bool_inv_rect_Type1 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z611 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1), forall _H1 : ((_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type1 (P matita_basics_bool.true)), forall _H2 : ((_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type1 (P matita_basics_bool.false)), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom bool_inv_rect_Type1 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z611 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type1), forall _H1 : ((_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type1 (P matita_basics_bool.true)), forall _H2 : ((_z612 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type1 (P matita_basics_bool.false)), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_pi_p_M1. For all elements $m$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_bigops.bigop$ applied to $i$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.\nassistant\n", "label": "postulate divides_pi_p_M1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))", "predict": "postulate divides_pi_p_M1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))))) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop i (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_Type2. Let $Q_$ be a function from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nassistant\n", "label": "axiom unit_rect_Type2 (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) (x_503 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type2 (Q_ x_503)", "predict": "axiom unit_rect_Type2 (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) (x_503 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_Type2. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nassistant\n", "label": "Axiom range_rect_Type2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type2 (Q_ x_923) .", "predict": "Axiom range_rect_Type2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term univs.Type2 (Q_ x_923) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_CProp3_body. For all functions $Q_$ from elements $_x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_75$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_75$.\nassistant\n", "label": "Axiom False_rect_CProp3_body : forall Q_ : ((_x_75 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_75 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_75) .", "predict": "Axiom False_rect_CProp3_body : forall Q_ : ((_x_75 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_75 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_75) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDecidable_prime. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_primes.prime$ applied to $n$.\nassistant\n", "label": "decidable_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.prime n)) .", "predict": "decidable_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_primes.prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "axiom Sig (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) : cic.Univ univs.Type0", "predict": "axiom Sig (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z311$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_113$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z312$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_113$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_113$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Not_inv_rect_CProp1 : x1 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) -> P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1) -> cic.Univ cic.prop) -> _H1 : (x_113 : (__ : cic.Term cic.prop x1 -> cic.Term cic.prop matita_basics_logic.False) -> _z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113)) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P Hterm) .", "predict": "Not_inv_rect_CProp1 : x1 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) -> P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1) -> cic.Univ cic.prop) -> _H1 : (x_113 : (__ : cic.Term cic.prop x1 -> cic.Term cic.prop matita_basics_logic.False) -> _z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113)) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1350$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1351$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_768$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_767$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_770$ from elements $_z1351$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_767$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_767$ and elements $_z1351$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_768$ and $x_767$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_768$ and $x_767$, $cic.Term$ holds for $cic.prop", "label": "axiom list_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1350 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_768 : cic.Term univs.Type0 x1) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_770 : (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_767)) -> cic.Term cic.prop (P x_767)) -> (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_768 x_767))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_768 x_767))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_rect_CProp2 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1350 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_768 : cic.Term univs.Type0 x1) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_770 : (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_767)) -> cic.Term cic.prop (P x_767)) -> (_z1351 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_768 x_767))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_768 x_767))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_16171. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $gcd1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $nm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $c$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $p$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_basics_logic.eq", "label": "postulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m", "predict": "postulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a p)) (matita_arithmetics_gcd.gcd p m))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univ"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_sigma_pi_SO_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom eq_sigma_pi_SO_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)", "predict": "axiom eq_sigma_pi_SO_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (λ i => matita_basics_bool.true) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTrue_or_false. Let $b$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b$ and $matita_basics_bool.true$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b$ and $matita_basics_bool.false$.\nassistant\n", "label": "true_or_false : b : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.false)) .", "predict": "true_or_false : b : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b matita_basics_bool.false)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNil_append_elim. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.\nassistant\n", "label": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)", "predict": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_CProp2_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_110$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_110$, for all elements $x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_109$.\nassistant\n", "label": "Not_rect_CProp2_body : _A : cic.Univ cic.prop -> Q_ : (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_110 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) -> x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_109) .", "predict": "Not_rect_CProp2_body : _A : cic.Univ cic.prop -> Q_ : (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_110 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) -> x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_109) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSplit_rev. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_basics_lists_list.list$ applied to $H$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "postulate split_rev : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))", "predict": "postulate split_rev : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_types.Prod (matita_basics_lists_list.list H) (matita_basics_lists_list.list H))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_rect_Type3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z984$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_537$, for all functions $_H2$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z985$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_538$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate Sum_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z984 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_537 : cic.Term univs.Type0 x1) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_537))) -> cic.Term univs.Type3 (P (matita_basics_types.inl x1 x2 x_537))) -> (_H2 : (x_538 : cic.Term univs.Type0 x2) -> (_z985 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P (matita_basics_types.inr x1 x2 x_538))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPi_p_primeb. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.\nassistant\n", "label": "postulate pi_p_primeb : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))", "predict": "postulate pi_p_primeb : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDpi1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "dpi1_body : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f) -> cic.Term univs.Type0 A .", "predict": "dpi1_body : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> _xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f) -> cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSinglevalued. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation2$ applied to $A$ and $B$.\nassistant\n", "label": "axiom singlevalued (A B : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))", "predict": "axiom singlevalued (A B : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_max_spec. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $__2$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $__$ and $__1$ and $__2$, for all functions $case_not_found_max_spec$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita", "label": "axiom match_max_spec (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort) (case_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))) (case_not_found_max_spec : (__ : (i : cic.Term univs.Type0 matita_ar", "predict": "axiom match_max_spec (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (return_sort : cic.Sort) (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort) (case_found_max_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__2 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type m (matita_arithmetics_minimization.found_max_spec _n _f m __ __1 __2))) (case_not_found_max_spec : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type _n (matita_arithmetics_minimization.not_found_max_spec _n _f))) : cic.Term return_sort (return_type _n (matita_arithmetics_minimization.match_max_spec _n _f return_sort return_type case_found_max_spec case_not_found_max_spec))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1559. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "Axiom let_clause_1559 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) .", "predict": "Axiom let_clause_1559 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExteqR. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom exteqR : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall _S : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), cic.Univ cic.prop .", "predict": "Axiom exteqR : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall _R : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), forall _S : ((__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_inv_rect_Type1. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z996$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$, for all functions $_H2$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sum_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate Sum_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) -> (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_r_ind_body. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all functions $Q_$ from elements $x_1337$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1336$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1335$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $_x_1338$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $x_1337$ and $x_1336$ and $x_1335$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_lstar_r_O$ from elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$ and $b$ and $b$ and $matita_arithmetics_lstar.lstar_r_O$ applied to $B$ and $_R$ and $b$, for all functions $_H_lstar_r_S$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1340$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $_R$ and $l$ and $b1$ and $b$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $x_1339$ of $cic.Term$ of $cic.prop$ and $_R$ applied to $b$ and $b2$ and elements $_x_1342$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $l$ and $b1$ and $b$ and $x_1340$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.plus$ applied to", "label": "lstar_r_ind_body : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1", "predict": "lstar_r_ind_body : B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> Q_ : (x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x_1335) -> cic.Univ cic.prop) -> _H_lstar_r_O : (b : cic.Term univs.Type0 B -> cic.Term cic.prop (Q_ matita_arithmetics_nat.O b b (matita_arithmetics_lstar.lstar_r_O B _R b))) -> _H_lstar_r_S : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> x_1340 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R l b1 b) -> b2 : cic.Term univs.Type0 B -> x_1339 : cic.Term cic.prop (_R b b2) -> _x_1342 : cic.Term cic.prop (Q_ l b1 b x_1340) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2 (matita_arithmetics_lstar.lstar_r_S B _R l b1 b x_1340 b2 x_1339 _x_1342))) -> x_1337 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1336 : cic.Term univs.Type0 B -> x_1335 : cic.Term univs.Type0 B -> _x_1338 : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B _R x_1337 x_1336 x"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp1. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nassistant\n", "label": "Axiom range_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_937) .", "predict": "Axiom range_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_937) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $n$.\nassistant\n", "label": "axiom permut_invert_permut (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)", "predict": "axiom permut_invert_permut (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_a. Let $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $matita_arithmetics_nat.S$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $f$ applied to $a$.\nassistant\n", "label": "axiom bigop_a (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (λ i => (λ i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (λ i => (λ i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f (matita_arithmetics_nat.S i0)) (matita_arithmetics_nat.plus i a))) (f a)))", "predict": "axiom bigop_a (a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (λ i => (λ i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (λ i => (λ i0 => matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f (matita_arithmetics_nat.S i0)) (matita_arithmetics_nat.plus i a))) (f a)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSnd_eq. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_types.snd$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $b$.\nassistant\n", "label": "Axiom snd_eq : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 B, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b) .", "predict": "Axiom snd_eq : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 B, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_types.snd A B (matita_basics_types.mk_Prod A B a b)) b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPi_p_primeb. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.\nassistant\n", "label": "pi_p_primeb : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)))) .", "predict": "pi_p_primeb : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord n p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.\nassistant\n", "label": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)", "predict": "axiom ACop_rect_CProp4 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_903)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nP_ord. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "p_ord : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) .", "predict": "p_ord : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1224$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1225$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sig_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nR4. For all elements $T0$ of $cic.Univ$ of $univs.Type0$, for all elements $a0$ of $cic.Term$ of $univs.Type0$ and $T0$, for all functions $T1$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$, for all functions $T2$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs", "label": "R4 : T0 : cic.Univ univs.Type0 -> a0 : cic.Term univs.Type0 T0 -> T1 : (x0 : cic.Term univs.Type0 T0 -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> cic.Univ univs.Type0) -> a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)) -> T2 : (x0 : cic.Term univs.Type0 T0 -> p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> x1 : cic.Term univs.Type0 (T1 x0 p0) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1) -> cic.Univ univs.Type0) -> a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1", "predict": "R4 : T0 : cic.Univ univs.Type0 -> a0 : cic.Term univs.Type0 T0 -> T1 : (x0 : cic.Term univs.Type0 T0 -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> cic.Univ univs.Type0) -> a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)) -> T2 : (x0 : cic.Term univs.Type0 T0 -> p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0) -> x1 : cic.Term univs.Type0 (T1 x0 p0) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1) -> cic.Univ univs.Type0) -> a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1)) -> cic.Term univs.Type0 (matita_basics_logic.match_T1 (cic.lift univs.Type0 univs.Type2 T0) a0 (cic.succ univs.Type2) (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0)) (x0 : cic.Term univs.Type0 T0 => p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.\nassistant\n", "label": "Axiom range_rect_CProp2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_935) .", "predict": "Axiom range_rect_CProp2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_935) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrimes_below_to_bertrand. Let $pm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $pm$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $pm$, for all functions $__2$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $pp$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $pp$ and $l$ and $matita_arithmetics_nat.lt$ applied to $pp$ and $p$ and $matita_arithmetics_nat.le$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $pp$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $pm$, $cic", "label": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)", "predict": "axiom primes_below_to_bertrand (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ pp => matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt n pm)) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRintersection. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R1$ and $_R2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Rintersection : A : cic.Univ univs.Type0 -> _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _a : cic.Term univs.Type0 A -> _b : cic.Term univs.Type0 A -> cic.Univ cic.prop .", "predict": "Rintersection : A : cic.Univ univs.Type0 -> _R1 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _R2 : cic.Term univs.Type0 (matita_basics_relations.relation A) -> _a : cic.Term univs.Type0 A -> _b : cic.Term univs.Type0 A -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "DPair_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type0) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm) .", "predict": "DPair_inv_rect_Type0 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ univs.Type0) -> Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2) -> cic.Univ univs.Type0) -> _H1 : (dpi1 : cic.Term univs.Type0 x1 -> _dpi2 : cic.Term univs.Type0 (x2 dpi1) -> _z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2)) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_rect_CProp5. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.\nassistant\n", "label": "axiom Sig_rect_CProp5 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_680)", "predict": "axiom Sig_rect_CProp5 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_680)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_divides. Let $_n$ and $_m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "match_divides : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Univ return_sort) -> case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q)) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z) .", "predict": "match_divides : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Univ return_sort) -> case_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q)) -> cic.Term return_sort (return_type (matita_arithmetics_primes.quotient _n _m q __))) -> z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNmk. Let $A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.\nassistant\n", "label": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)", "predict": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_square_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "le_square_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) .", "predict": "le_square_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_rect_CProp1. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_577$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_577$, for all functions $_H_inr$ from elements $x_578$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_578$, for all elements $x_576$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_576$.\nassistant\n", "label": "Axiom Sum_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))), forall _H_inr : ((x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))), forall x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_576) .", "predict": "Axiom Sum_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop), forall _H_inl : ((x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))), forall _H_inr : ((x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))), forall x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term cic.prop (Q_ x_576) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_CProp5. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp5 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))), forall x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_841) .", "predict": "Axiom div_mod_spec_rect_CProp5 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))), forall x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_841) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSub_assoc_l. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R1$ and $R2$ and $R3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.subR$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R2$ and $R3$ and $matita_basics_relations.Rcomp$ applied to $A$ and $matita_basics_relations.Rcomp$ applied to $A$ and $R1$ and $R2$ and $R3$.\nassistant\n", "label": "Axiom sub_assoc_l : forall A : cic.Univ univs.Type0, forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R3 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3)) .", "predict": "Axiom sub_assoc_l : forall A : cic.Univ univs.Type0, forall R1 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R2 : cic.Term univs.Type0 (matita_basics_relations.relation A), forall R3 : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R1 (matita_basics_relations.Rcomp A R2 R3)) (matita_basics_relations.Rcomp A (matita_basics_relations.Rcomp A R1 R2) R3)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrime_to_primeb_true. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.true$.\nassistant\n", "label": "postulate prime_to_primeb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)", "predict": "postulate prime_to_primeb_true : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_rect_Type4. For all functions $Q_$ from elements $_x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_true$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_329$.\nassistant\n", "label": "axiom bool_rect_Type4 (Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) (_H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)) (x_329 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type4 (Q_ x_329)", "predict": "axiom bool_rect_Type4 (Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4) (_H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false)) (x_329 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type4 (Q_ x_329)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLog_times_l. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "log_times_l : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m))) .", "predict": "log_times_l : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m)) (matita_arithmetics_log.log p (matita_arithmetics_nat.times n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_discr. For all elements $a1$ of $cic.Univ$ of $univs.Type0$, for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.Dop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_arithmetics_bigops.match_Dop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_arithmetics_bigops.match_Dop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $matita_basics_logic.R0$ applied to $matita_arithmetics_bigops.ACop$ applied to $a1$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$", "label": "Axiom Dop_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Term univs.Type0 a1, forall x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2), forall y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y), cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => fun t2 => fun t3 => matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => fun u2 => fun u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0", "predict": "Axiom Dop_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Term univs.Type0 a1, forall x : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2), forall y : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop a1 a2)) x y), cic.Term univs.Type2 (matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => fun t2 => fun t3 => matita_arithmetics_bigops.match_Dop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => fun u2 => fun u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop a1 a2)) (matita_basics_logic.R0 (matita_arithmetics_bigops.ACop a1 a2) t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((fun x0 => fun p0 => matita_arithmetics_bigops.op a1 a2 t0 x0 (fun x_19 => fun _x_20 => p0) t1 u0 e0)) (fun x0 => fun p0 => matita_arithmetics_bigops.op a1 a2 t0 x0 (fun x_19 => fun _x_20 => p0) t1 u0 e0) u1) (fun _e1 =>"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nHint_declaration_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type1$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type1$ and $A$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "axiom hint_declaration_Type1 (A : cic.Univ univs.Type1) (_a _b : cic.Term univs.Type1 A) : cic.Univ univs.Type0", "predict": "axiom hint_declaration_Type1 (A : cic.Univ univs.Type1) (_a _b : cic.Term univs.Type1 A) : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_exp1. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$.\nassistant\n", "label": "lt_exp1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)) .", "predict": "lt_exp1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt n m) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBijn. Let $__$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "bijn : __ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "bijn : __ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nGcd_aux_body. For all elements $_p$ and $_m$ and $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom gcd_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom gcd_aux_body : forall _p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_lt_times_r. Let $c$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $t$ to $matita_arithmetics_nat.times$ applied to $c$ and $t$.\nassistant\n", "label": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) .", "predict": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCongruent_n_mod_times. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $p$ and $p$.\nassistant\n", "label": "congruent_n_mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p) .", "predict": "congruent_n_mod_times : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n (matita_arithmetics_nat.times m p)) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOr_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$, for all functions $_H2$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Or_inv_ind : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2), forall P : ((_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))), forall _H2 : ((x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Or_inv_ind : forall x1 : cic.Univ cic.prop, forall x2 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2), forall P : ((_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))), forall _H2 : ((x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_CProp3. Let $Q_$ be a function from elements $_x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_402$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_404$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_402$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_402$, for all elements $x_401$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_401$.\nassistant\n", "label": "Axiom nat_rect_CProp3 : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) .", "predict": "Axiom nat_rect_CProp3 : forall Q_ : ((_x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_402 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_404 : cic.Term cic.prop (Q_ x_402)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_402))), forall x_401 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_401) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPermut_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "permut_transpose_l : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m) -> __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose i j (f n)) m) .", "predict": "permut_transpose_l : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j m) -> __2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (n : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_permutation.transpose i j (f n)) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nF3_ind_aux. For all elements $A1$ and $A2$ and $A3$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $__2$ of $cic.Term$ of $univs.Type0$ and $A3$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation3$ applied to $A1$ and $A2$ and $A3$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a1$ and $a2$ and $a3$ and elements $a1$ of $cic.Term$ of $univs.Type0$ and $A1$ and elements $a2$ of $cic.Term$ of $univs.Type0$ and $A2$ and elements $a3$ of $cic.Term$ of $univs.Type0$ and $A3$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a1$ and $a2$ and $a3$ and $n$ to elements of", "label": "f3_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> A3 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> __2 : cic.Term univs.Type0 A3 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3) .", "predict": "f3_ind_aux : A1 : cic.Univ univs.Type0 -> A2 : cic.Univ univs.Type0 -> A3 : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A1 -> __1 : cic.Term univs.Type0 A2 -> __2 : cic.Term univs.Type0 A3 -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.relation3 A1 A2 A3) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3)) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1 : cic.Term univs.Type0 A1 -> a2 : cic.Term univs.Type0 A2 -> a3 : cic.Term univs.Type0 A3 -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a1 a2 a3) n) -> cic.Term cic.prop (P a1 a2 a3) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1033. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $len$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lep$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$, for all elements $ltp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat", "label": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p) -> ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true) -> H", "predict": "let_clause_1033 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n) -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p) -> ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_Type5_body. Let $Q_$ be a function from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.\nassistant\n", "label": "postulate unit_rect_Type5_body : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)", "predict": "postulate unit_rect_Type5_body : (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) -> (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) -> (x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type5 (Q_ x_499)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1585. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $m$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $m$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "let_clause_1585 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m) -> auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) .", "predict": "let_clause_1585 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides m n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O m) -> auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times m d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPrimeb_false_to_not_prime. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.primeb$ applied to $n$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.prime$ applied to $n$.\nassistant\n", "label": "primeb_false_to_not_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n)) .", "predict": "primeb_false_to_not_prime : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.primeb n) matita_basics_bool.false) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.prime n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_O_n_elim. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $P$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $n$.\nassistant\n", "label": "postulate lt_O_n_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)", "predict": "postulate lt_O_n_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (P : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (P (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (P n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDpi1__o__aop. Let $x0$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x1$ of $cic.Term$ of $univs.Type0$ and $x0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x3$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $matita_arithmetics_bigops.ACop$ applied to $x0$ and $x1$ and $x2$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x0$ and $x1$.\nassistant\n", "label": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)", "predict": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_previous_prime1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_previous_prime1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_previous_prime1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_inv_rect_Type4. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z978$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_527$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z979$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_527$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_527$, for all functions $_H2$ from elements $x_528$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z979$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_528$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_528$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Sum_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z978 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((x_527 : cic.Term univs.Type0 x1) -> (_z979 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_527))) -> cic.Term univs.Type4 (P (matita_basics_types.inl x1 x2 x_527))), forall _H2 : ((x_528 : cic.Term univs.Type0 x2) -> (_z979 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_528))) -> cic.Term univs.Type4 (P (matita_basics_types.inr x1 x2 x_528))), cic.Term univs.Type4 (P Hterm) .", "predict": "Axiom Sum_inv_rect_Type4 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2), forall P : ((_z978 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type4), forall _H1 : ((x_527 : cic.Term univs.Type0 x1) -> (_z979 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_527))) -> cic.Term univs.Type4 (P (matita_basics_types.inl x1 x2 x_527))), forall _H2 : ((x_528 : cic.Term univs.Type0 x2) -> (_z979 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_528))) -> cic.Term univs.Type4 (P (matita_basics_types.inr x1 x2 x_528))), cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPi1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "Axiom pi1_body : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f), cic.Term univs.Type0 A .", "predict": "Axiom pi1_body : forall A : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f), cic.Term univs.Type0 A ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_112$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_113$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_113$, for all elements $x_112$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_112$.\nassistant\n", "label": "Axiom Not_rect_CProp1 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))), forall x_112 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_112) .", "predict": "Axiom Not_rect_CProp1 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_113 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))), forall x_112 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_112) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUniv. Let $s$ be an element of $Sort$. Then $Univ$ holds for $succ$ applied to $s$.\nassistant\n", "label": "axiom univ (s : Sort) : Univ (succ s)", "predict": "axiom univ (s : Sort) : Univ (succ s)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_1_to_lt_n. Let $i$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $i$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$.\nassistant\n", "label": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)", "predict": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_divides. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "axiom list_divides (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool", "predict": "axiom list_divides (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_r. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$.\nassistant\n", "label": "axiom lstar_r (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_relations.relation B)", "predict": "axiom lstar_r (B : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 (matita_basics_relations.relation B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_minus_to_plus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $c$ and $b$.\nassistant\n", "label": "axiom lt_minus_to_plus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus b c))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a c) b)", "predict": "axiom lt_minus_to_plus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus b c))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a c) b)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_gcd_times. Let $m$ and $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom le_gcd_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p))) .", "predict": "Axiom le_gcd_times : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_gcd.gcd m n) (matita_arithmetics_gcd.gcd m (matita_arithmetics_nat.times n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nChecker_abl. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $a$ and $b$ and $matita_arithmetics_nat.le$ applied to $b$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.checker$ applied to $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $b$ and $l$ and $matita_basics_bool.true$.\nassistant\n", "label": "checker_abl : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true)) .", "predict": "checker_abl : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_transpose_l. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "axiom permut_transpose_l (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => matita_arithmetics_permutation.transpose i j (f n)) m)", "predict": "axiom permut_transpose_l (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => matita_arithmetics_permutation.transpose i j (f n)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom times_n_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O)) .", "predict": "Axiom times_n_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_elim2. Let $R$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$ and $n$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.O$, for all functions $__2$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$ and $m$.\nassistant\n", "label": "nat_elim2 : R : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R matita_arithmetics_nat.O n)) -> __1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) -> __2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (R n m) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R n m) .", "predict": "nat_elim2 : R : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R matita_arithmetics_nat.O n)) -> __1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) matita_arithmetics_nat.O)) -> __2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __2 : cic.Term cic.prop (R n m) -> cic.Term cic.prop (R (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m))) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (R n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10334. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "axiom let_clause_10334 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "axiom let_clause_10334 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_mop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $a$ and $_x_969$ and $_x_970$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.\nassistant\n", "label": "postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B", "predict": "postulate let_mop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> (_x_969 : cic.Term univs.Type0 B) -> (_x_970 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_squareS_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom le_squareS_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) .", "predict": "Axiom le_squareS_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEx2_inv_ind. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ and $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $x1$ and $x2$ and $x3$, for all functions $P$ from elements $_z521$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $x1$ and $x2$ and $x3$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $x3$ applied to $x$ and elements $_z522$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.ex2$ applied to $x1$ and $x2$ and $x3$ and $Hterm$ and $matita_basics_logic.ex2_intro$ applied to $x1$ and $x2$ and $x3$ and $x$ and $x_276$ and $x_275$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.ex2_intro$ applied to $x1$ and $x2$ and $x3$ and $x$ and $x_276$ and $x_275$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom ex2_inv_ind (x1 : cic.Univ univs.Type0) (x2 x3 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3)) (P : (_z521 : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3)) -> cic.Univ cic.prop) (_H1 : (x : cic.Term univs.Type0 x1) -> (x_276 : cic.Term cic.prop (x2 x)) -> (x_275 : cic.Term cic.prop (x3 x)) -> (_z522 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex2 x1 x2 x3)) Hterm (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) -> cic.Term cic.prop (P (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) : cic.Term cic.prop (P Hterm)", "predict": "axiom ex2_inv_ind (x1 : cic.Univ univs.Type0) (x2 x3 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3)) (P : (_z521 : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3)) -> cic.Univ cic.prop) (_H1 : (x : cic.Term univs.Type0 x1) -> (x_276 : cic.Term cic.prop (x2 x)) -> (x_275 : cic.Term cic.prop (x3 x)) -> (_z522 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex2 x1 x2 x3)) Hterm (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) -> cic.Term cic.prop (P (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTimesAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "axiom timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBi_relation. Let $__$ and $__1$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "axiom bi_relation (__ __1 : cic.Univ univs.Type0) : cic.Univ univs.Type0", "predict": "axiom bi_relation (__ __1 : cic.Univ univs.Type0) : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nVoid_rect_CProp2. For all functions $Q_$ from elements $_x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_492$.\nassistant\n", "label": "Axiom void_rect_CProp2 : forall Q_ : ((_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_492 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_492) .", "predict": "Axiom void_rect_CProp2 : forall Q_ : ((_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_492 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_492) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_Type4_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_692$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_692$.\nassistant\n", "label": "axiom Prod_rect_Type4_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type4 (Q_ x_692)", "predict": "axiom Prod_rect_Type4_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term univs.Type4 (Q_ x_692)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_plus_to_minus_r. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $c$ and $b$.\nassistant\n", "label": "axiom lt_plus_to_minus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c)) : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b))", "predict": "axiom lt_plus_to_minus_r (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus a b) c)) : cic.Term cic.prop (matita_arithmetics_nat.lt a (matita_arithmetics_nat.minus c b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_Type2_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.\nassistant\n", "label": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)", "predict": "postulate And_rect_Type2_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type2) -> (_H_conj : (x_136 : cic.Term cic.prop _A) -> (x_135 : cic.Term cic.prop _B) -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type2 (Q_ x_134)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_mod_m_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$.\nassistant\n", "label": "postulate lt_mod_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m)", "predict": "postulate lt_mod_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.mod n m) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCommutative_min. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.min$.\nassistant\n", "label": "commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min) .", "predict": "commutative_min : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.min) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_Psil1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $n$.\nassistant\n", "label": "axiom le_Psil1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => n)))", "predict": "axiom le_Psil1 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ p => n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_sqrt_log_n. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $n$ and $n$.\nassistant\n", "label": "le_sqrt_log_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_log.log b n)) n) .", "predict": "le_sqrt_log_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_log.log b n)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAxiom. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then the greatest common divisor of $__$ and $__1$ is an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "gcd : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "gcd : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_gcd_l. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $n$.\nassistant\n", "label": "axiom divides_gcd_l (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)", "predict": "axiom divides_gcd_l (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_963$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements", "label": "Dop_rect_CProp2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_963) .", "predict": "Dop_rect_CProp2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ cic.prop) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_963 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term cic.prop (Q_ x_963) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSquare_double. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $n$.\nassistant\n", "label": "axiom square_double (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))", "predict": "axiom square_double (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDpi1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "postulate dpi1_body : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 A", "predict": "postulate dpi1_body : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.DPair A f)) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_CProp2. For all functions $Q_$ from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.\nassistant\n", "label": "Axiom False_rect_CProp2 : forall Q_ : ((_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_76 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_76) .", "predict": "Axiom False_rect_CProp2 : forall Q_ : ((_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop), forall x_76 : cic.Term cic.prop matita_basics_logic.False, cic.Term cic.prop (Q_ x_76) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_or. Let $P$ and $Q$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $P$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.decidable$ applied to $Q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.Or$ applied to $P$ and $Q$.\nassistant\n", "label": "postulate decidable_or : (P : cic.Univ cic.prop) -> (Q : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> (__1 : cic.Term cic.prop (matita_basics_logic.decidable Q)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Or P Q))", "predict": "postulate decidable_or : (P : cic.Univ cic.prop) -> (Q : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.decidable P)) -> (__1 : cic.Term cic.prop (matita_basics_logic.decidable Q)) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.Or P Q))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_mod. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.\nassistant\n", "label": "Axiom mod_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p)) .", "predict": "Axiom mod_mod : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_CProp5. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_619$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_619$, for all elements $x_618$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_618$.\nassistant\n", "label": "Axiom option_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))), forall x_618 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_618) .", "predict": "Axiom option_rect_CProp5 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_618 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_619 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_619))), forall x_618 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_618) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1033. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $ndivpr$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, for all elements $q0$ and $q1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $q1$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $q1$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2", "label": "postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> (q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1)))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "postulate let_clause_1033 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (ndivpr : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (Hn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> (q0 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S q1) (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S q1)))) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_953$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $", "label": "axiom Dop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type1 (Q_ x_953)", "predict": "axiom Dop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type1) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_953 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type1 (Q_ x_953)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExists_forall_lt. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ and $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and the function that maps $__$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate exists_forall_lt : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))))", "predict": "postulate exists_forall_lt : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n) (\\ __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLength_map. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $B$ and $matita_basics_lists_list.map$ applied to $A$ and $B$ and $f$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "length_map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) .", "predict": "length_map : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCommutative. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate commutative : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop", "predict": "postulate commutative : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_CProp2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_None$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_627$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_627$, for all elements $x_626$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_626$.\nassistant\n", "label": "Axiom option_rect_CProp2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))), forall x_626 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_626) .", "predict": "Axiom option_rect_CProp2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop), forall _H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))), forall x_626 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term cic.prop (Q_ x_626) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_581$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_582$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_582$, for all functions $_H_inr$ from elements $x_583$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_583$, for all elements $x_581$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_581$.\nassistant\n", "label": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSmallest_factor_to_min. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $matita_arithmetics_minimization.min$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $m$ to $matita_arithmetics_nat.eqb$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate smallest_factor_to_min : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))", "predict": "postulate smallest_factor_to_min : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) (matita_arithmetics_minimization.min n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.eqb (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_879$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nil", "label": "postulate Aop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)", "predict": "postulate Aop_rect_CProp3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_879 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_879)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPsi_3. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate Psi_3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.\nassistant\n", "label": "postulate DPair_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_660)", "predict": "postulate DPair_rect_CProp1_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_660)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_rect_CProp0. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.\nassistant\n", "label": "postulate div_mod_spec_rect_CProp0 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)", "predict": "postulate div_mod_spec_rect_CProp0 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExample13. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "example13 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))) .", "predict": "example13 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_rect_CProp0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_967$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_", "label": "Axiom Dop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_967) .", "predict": "Axiom Dop_rect_CProp0 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_967 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_967) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSub_hk. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.\nassistant\n", "label": "axiom sub_hk (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "axiom sub_hk (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_O_to_divides. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$.\nassistant\n", "label": "mod_O_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) .", "predict": "mod_O_to_divides : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod m n) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_arithmetics_primes.divides n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_rect_CProp0_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp0_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_857)", "predict": "axiom div_mod_spec_rect_CProp0_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_857)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOp. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "axiom op (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (_x_887 _x_888 : cic.Term univs.Type0 A) : cic.Term univs.Type0 A", "predict": "axiom op (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (_x_887 _x_888 : cic.Term univs.Type0 A) : cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLeq_sqrt_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.\nassistant\n", "label": "leq_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n) .", "predict": "leq_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_sqrt.sqrt n)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_max_to_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "axiom lt_max_to_false (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)", "predict": "axiom lt_max_to_false (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type3_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_787$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$", "label": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)", "predict": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_le_Sn_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom not_le_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n)) .", "predict": "Axiom not_le_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_upper_bound7. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom let_upper_bound7 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom let_upper_bound7 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_nat. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) .", "predict": "filter_nat : return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_Psi_BPsi1. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "Axiom le_Psi_BPsi1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "Axiom le_Psi_BPsi1 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDividesb_true_to_lt_O. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$.\nassistant\n", "label": "postulate dividesb_true_to_lt_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)", "predict": "postulate dividesb_true_to_lt_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides m n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15311. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $d$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.\nassistant\n", "label": "let_clause_15311 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p))) .", "predict": "let_clause_15311 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom DPair : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), cic.Univ univs.Type0 .", "predict": "Axiom DPair : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_n_Sn. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "Axiom le_n_Sn : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) .", "predict": "Axiom le_n_Sn : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMin_spec_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$", "label": "min_spec_inv_ind : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4) -> P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m) -> _x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2)) -> _x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true) -> _x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0", "predict": "min_spec_inv_ind : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4) -> P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m) -> _x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2)) -> _x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true) -> _x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_minimization.min x1 x2 x3 x4))) -> cic.Term cic.prop (P x4) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_to_lt_max. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $n$ and $matita_basics_bool.false$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $m$ and $f$ and $n$.\nassistant\n", "label": "Axiom false_to_lt_max : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max m f) n) .", "predict": "Axiom false_to_lt_max : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max m f) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max m f) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_intro. For all elements $n$ and $m$ and $q$ and $r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $r$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $q$ and $m$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $n$ and $m$ and $q$ and $r$.\nassistant\n", "label": "postulate div_mod_spec_intro : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt r m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r))) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)", "predict": "postulate div_mod_spec_intro : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt r m)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r))) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec n m q r)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_inv_rect_CProp2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z635$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom bool_inv_rect_CProp2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)", "predict": "axiom bool_inv_rect_CProp2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) (_H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) (_H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_min_f_min_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $g$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$.\nassistant\n", "label": "Axiom le_min_f_min_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f)) .", "predict": "Axiom le_min_f_min_g : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : ((i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_ind_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_811$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_810$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_811$ and $x_810$, for all elements $x_809$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_809$.\nassistant\n", "label": "postulate div_mod_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)", "predict": "postulate div_mod_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_811 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_810 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_811 x_810))) -> (x_809 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_809)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_or_ge. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_arithmetics_nat.lt$ applied to $m$ and $n$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom lt_or_ge : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt m n) (matita_arithmetics_nat.le n m)) .", "predict": "Axiom lt_or_ge : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt m n) (matita_arithmetics_nat.le n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nP_ord_degenerate. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $p$ and $n$.\nassistant\n", "label": "postulate p_ord_degenerate : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n))", "predict": "postulate p_ord_degenerate : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_bool. For all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_true$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.true$, for all elements $case_false$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_bool.false$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom match_bool (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) (z : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term return_sort (return_type z)", "predict": "axiom match_bool (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ return_sort) (case_true : cic.Term return_sort (return_type matita_basics_bool.true)) (case_false : cic.Term return_sort (return_type matita_basics_bool.false)) (z : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_length_to_mem. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $matita_arithmetics_nat.nat$ and $l$ and $matita_arithmetics_nat.S$ applied to $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $matita_arithmetics_nat.nat$ and $l$, for all functions $__2$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $x$ and $l$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $n$ and $l$.\nassistant\n", "label": "postulate eq_length_to_mem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)", "predict": "postulate eq_length_to_mem : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length matita_arithmetics_nat.nat l) (matita_arithmetics_nat.S n))) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l)) -> (__2 : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat x l)) -> cic.Term cic.prop (matita_arithmetics_nat.le x n)) -> cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat n l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_rect_Type5. Let $Q_$ be a function from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.\nassistant\n", "label": "unit_rect_Type5 : Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type5) -> _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it) -> x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type5 (Q_ x_499) .", "predict": "unit_rect_Type5 : Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type5) -> _H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it) -> x_499 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Term univs.Type5 (Q_ x_499) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNth_opt_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "nth_opt_body : A : cic.Univ univs.Type0 -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option A) .", "predict": "nth_opt_body : A : cic.Univ univs.Type0 -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> cic.Term univs.Type0 (matita_basics_types.option A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIs_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom is_nil (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Univ cic.prop", "predict": "axiom is_nil (A : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDecidable. Let $__$ be an element of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom decidable : forall __ : cic.Univ cic.prop, cic.Univ cic.prop .", "predict": "Axiom decidable : forall __ : cic.Univ cic.prop, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMem_body. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "mem_body : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 H -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Univ cic.prop .", "predict": "mem_body : H : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 H -> __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_None$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $case_Some$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.Some$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom match_option (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) (z : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term return_sort (return_type z)", "predict": "axiom match_option (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) (z : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1410$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$", "label": "Aop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Aop_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool. $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate bool : cic.Univ univs.Type0", "predict": "postulate bool : cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_plus_minus_l. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $z$ and $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.plus$ applied to $x$ and $y$.\nassistant\n", "label": "minus_plus_minus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le y z) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y)) .", "predict": "minus_plus_minus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le y z) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus z x) (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.plus x y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_rect_Type5_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_nmk$ from functions $x_86$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_86$, for all elements $x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_85$.\nassistant\n", "label": "axiom Not_rect_Type5_body (_A : cic.Univ cic.prop) (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type5 (Q_ x_85)", "predict": "axiom Not_rect_Type5_body (_A : cic.Univ cic.prop) (Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type5) (_H_nmk : (x_86 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A)) : cic.Term univs.Type5 (Q_ x_85)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_x_times_x. For all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $x$ and $x$.\nassistant\n", "label": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))", "predict": "postulate le_x_times_x : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le x (matita_arithmetics_nat.times x x))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_SO_nth_prime_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.nth_prime$ applied to $n$.\nassistant\n", "label": "postulate lt_SO_nth_prime_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.nth_prime n))", "predict": "postulate lt_SO_nth_prime_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.nth_prime n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1648. Let $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posq$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n1$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $q$ and $matita_arithmetics_div_and_mod.mod$ applied to $n1$ and $q$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $q$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n1$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n1$ and $q$ and $q$, for all elements $divq$ of $cic.Term$", "label": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div", "predict": "postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q) (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n1) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n1 q)) q)))) -> (divq : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_ar"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1530$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $", "label": "postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1530 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1531 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate Aop_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1530 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1531 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nVoid_rect_Type1. Let $Q_$ be a function from elements $_x_487$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type1$. Then for all elements $x_487$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_487$.\nassistant\n", "label": "postulate void_rect_Type1 : (Q_ : (_x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type1) -> (x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type1 (Q_ x_487)", "predict": "postulate void_rect_Type1 : (Q_ : (_x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type1) -> (x_487 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type1 (Q_ x_487)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_660$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_660$.\nassistant\n", "label": "axiom DPair_rect_CProp1_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_660)", "predict": "axiom DPair_rect_CProp1_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_660 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term cic.prop (Q_ x_660)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOption_rect_Type1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_None$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_607$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_607$, for all elements $x_606$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_606$.\nassistant\n", "label": "option_rect_Type1 : _A : cic.Univ univs.Type0 -> Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type1) -> _H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_607 : cic.Term univs.Type0 _A -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type1 (Q_ x_606) .", "predict": "option_rect_Type1 : _A : cic.Univ univs.Type0 -> Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Univ univs.Type1) -> _H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A)) -> _H_Some : (x_607 : cic.Term univs.Type0 _A -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> x_606 : cic.Term univs.Type0 (matita_basics_types.option _A) -> cic.Term univs.Type1 (Q_ x_606) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_lt_minus_l. For all elements $p$ and $q$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $q$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $q$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.minus$ applied to $q$ and $n$ and $matita_arithmetics_nat.minus$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom monotonic_lt_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) .", "predict": "Axiom monotonic_lt_minus_l : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n q), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.minus q n) (matita_arithmetics_nat.minus p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "postulate DPair_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_652)", "predict": "postulate DPair_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_652)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_CProp2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Prod_inv_rect_CProp2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_plus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$.\nassistant\n", "label": "minus_plus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.plus m p))) .", "predict": "minus_plus : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.plus m p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLePsi_r2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "postulate lePsi_r2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "postulate lePsi_r2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMin_spec_ind. For all elements $_n$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_1075$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1076$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1075$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_min_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $m$ and elements $x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $_n$ and $_b$ and elements $x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false", "label": "min_spec_ind : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool", "predict": "min_spec_ind : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> _H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m) -> x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)) -> x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true) -> x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le _b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.mk_min_spec _n _b _f x_1075))) -> _H_not_found_min_spec : (x_1081 : cic.Term cic.prop (matita_arithmetics_nat.lt _b (matita_arithmetics_nat.plus _n _b)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.plus _n _b) (matita_arithmetics_minimization.mk_min_spec _n _b _f x_1081))) -> cic"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_871$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and", "label": "Aop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type1 (Q_ x_871) .", "predict": "Aop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type1) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_871 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type1 (Q_ x_871) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1531. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "let_clause_1531 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) .", "predict": "let_clause_1531 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPlus_div. Let $n$ and $m$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $d$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $m$ and $d$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $d$.\nassistant\n", "label": "axiom plus_div (n m d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))", "predict": "axiom plus_div (n m d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLength_tail1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "length_tail1 : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) .", "predict": "length_tail1 : A : cic.Univ univs.Type0 -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_divides_to_ord_O. Let $p$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate not_divides_to_ord_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)", "predict": "postulate not_divides_to_ord_O : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord m p) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExists. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom Exists : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop .", "predict": "Axiom Exists : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_times. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $y$ and $z$ and $matita_arithmetics_nat.times$ applied to $y$ and $matita_arithmetics_nat.times$ applied to $x$ and $z$.\nassistant\n", "label": "Axiom times_times : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times x (matita_arithmetics_nat.times y z)) (matita_arithmetics_nat.times y (matita_arithmetics_nat.times x z))) .", "predict": "Axiom times_times : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall z : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times x (matita_arithmetics_nat.times y z)) (matita_arithmetics_nat.times y (matita_arithmetics_nat.times x z))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_Type1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_648$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_648$.\nassistant\n", "label": "DPair_rect_Type1 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type1) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type1 (Q_ x_648) .", "predict": "DPair_rect_Type1 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type1) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_648 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type1 (Q_ x_648) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMax_spec_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $Q_$ from elements $x_971$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_972$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $x_971$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_found_max_spec$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_975$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $_n$ and elements $x_974$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $m$ and $matita_basics_bool.true$ and functions $x_973$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $_n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $_f$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $matita_arithmetics_minimization.found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973", "label": "Axiom max_spec_ind : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop), forall _H_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))), forall _", "predict": "Axiom max_spec_ind : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall Q_ : ((x_971 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f x_971)) -> cic.Univ cic.prop), forall _H_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m _n)) -> (x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i _n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.found_max_spec _n _f m x_975 x_974 x_973))), forall _H_not_found_max_spec : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_972 : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f m)) -> cic.Term cic.prop (Q_ m x_972)), cic.Term cic.prop (Q_ _n (matita_arithmetics_minimization.not_found_max_spec _n _f)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_Type0. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_748$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_747$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_750$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_747$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_748$ and $x_747$, for all elements $x_746$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_746$.\nassistant\n", "label": "Axiom list_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type0), forall _H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_748 : cic.Term univs.Type0 _A) -> (x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_750 : cic.Term univs.Type0 (Q_ x_747)) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))), forall x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type0 (Q_ x_746) .", "predict": "Axiom list_rect_Type0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type0), forall _H_nil : cic.Term univs.Type0 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_748 : cic.Term univs.Type0 _A) -> (x_747 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_750 : cic.Term univs.Type0 (Q_ x_747)) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.cons _A x_748 x_747))), forall x_746 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type0 (Q_ x_746) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1146$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1147$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate DPair_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate DPair_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.\nassistant\n", "label": "aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) .", "predict": "aop : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nCompose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $_l1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $C$.\nassistant\n", "label": "axiom compose (A B C : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) (_l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_l2 : cic.Term univs.Type0 (matita_basics_lists_list.list B)) : cic.Term univs.Type0 (matita_basics_lists_list.list C)", "predict": "axiom compose (A B C : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) (_l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (_l2 : cic.Term univs.Type0 (matita_basics_lists_list.list B)) : cic.Term univs.Type0 (matita_basics_lists_list.list C)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_inv_rect_CProp3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Prod_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) .", "predict": "Prod_inv_rect_CProp3 : x1 : cic.Univ univs.Type0 -> x2 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2) -> cic.Univ cic.prop) -> _H1 : (_fst : cic.Term univs.Type0 x1 -> _snd : cic.Term univs.Type0 x2 -> _z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "axiom Sum_rect_Type3 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type3 (Q_ x_536)", "predict": "axiom Sum_rect_Type3 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type3 (Q_ x_536)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEqb. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom eqb : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom eqb : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_rect_CProp2_body. For all functions $Q_$ from elements $_x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_492$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_492$.\nassistant\n", "label": "axiom void_rect_CProp2_body (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_492 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_492)", "predict": "axiom void_rect_CProp2_body (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_492 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_492)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_div. Let $d$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $n$.\nassistant\n", "label": "axiom divides_div (d n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_div_and_mod.div n d) n)", "predict": "axiom divides_div (d n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_div_and_mod.div n d) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTheta. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom theta (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom theta (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_eq_to_eqb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "not_eq_to_eqb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) .", "predict": "not_eq_to_eqb_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_list. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nInvert_permut_body. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom invert_permut_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom invert_permut_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : ((__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall __2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAntisymmetric. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "antisymmetric : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop .", "predict": "antisymmetric : A : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_rect_Type3_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "Sum_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type3) -> _H_inl : (x_537 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> _H_inr : (x_538 : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type3 (Q_ x_536) .", "predict": "Sum_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type3) -> _H_inl : (x_537 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> _H_inr : (x_538 : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type3 (Q_ x_536) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_map_some. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$, for all elements $v$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $B$ and $matita_basics_types.option_map$ applied to $A$ and $B$ and $f$ and $x$ and $matita_basics_types.Some$ applied to $B$ and $v$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and the function that maps $y$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $y$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $f$ applied to $y$ and $v$.\nassistant\n", "label": "axiom option_map_some (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (v : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v))) : cic.Term cic.prop (matita_basics_logic.ex A (λ y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v)))", "predict": "axiom option_map_some (A B : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (x : cic.Term univs.Type0 (matita_basics_types.option A)) (v : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option B)) (matita_basics_types.option_map A B f x) (matita_basics_types.Some B v))) : cic.Term cic.prop (matita_basics_logic.ex A (λ y => matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (f y) v)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPermut_n_to_eq_n. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom permut_n_to_eq_n : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut h n), forall __1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h n) n) .", "predict": "Axiom permut_n_to_eq_n : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut h n), forall __1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_lstar_r. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b1$ and $b2$.\nassistant\n", "label": "axiom lstar_lstar_r (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)", "predict": "axiom lstar_lstar_r (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b2)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAntisymmetric. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom antisymmetric : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom antisymmetric : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1544. For all elements $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $q$ and $m$ and $n$, for all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $c", "label": "postulate let_clause_1544 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_clause_1544 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd_aux q m n)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd_aux q m n)))))) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (lenm : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (lenq : cic.Term cic.prop (matita_arithmetics_nat.le n q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq ("}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "unit_inv_rect_Type2 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm) .", "predict": "unit_inv_rect_Type2 : Hterm : cic.Term univs.Type0 matita_basics_types.unit -> P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit -> cic.Univ univs.Type2) -> _H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_Type0_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all", "label": "Aop_rect_Type0_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type0) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type0 (Q_ x_793) .", "predict": "Aop_rect_Type0_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ univs.Type0) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term univs.Type0 (Q_ x_793) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRelation3. For all elements $__$ and $__1$ and $__2$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate relation3 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate relation3 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> (__2 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_exp_priml. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom le_exp_priml : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) .", "predict": "Axiom le_exp_priml : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_658$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_658$.\nassistant\n", "label": "Axiom DPair_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_658) .", "predict": "Axiom DPair_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_658 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_658) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_168$ and $x_167$, for all elements $x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_166$.\nassistant\n", "label": "And_rect_CProp0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_168 : cic.Term cic.prop _A -> x_167 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_166) .", "predict": "And_rect_CProp0_body : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ cic.prop) -> _H_conj : (x_168 : cic.Term cic.prop _A -> x_167 : cic.Term cic.prop _B -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) -> x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term cic.prop (Q_ x_166) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_881$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr", "label": "Axiom Aop_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) .", "predict": "Axiom Aop_rect_CProp2 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))), forall x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil), cic.Term cic.prop (Q_ x_881) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLenght_to_nil. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "postulate lenght_to_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))", "predict": "postulate lenght_to_nil : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.nil A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1224$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1225$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sig_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Sig_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_B_Bk. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$.\nassistant\n", "label": "axiom eq_B_Bk (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n))", "predict": "axiom eq_B_Bk (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFold_sum. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $I$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $J$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $matita_basics_lists_list.op$ applied to $B$ and $nil$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.append$ applied to $A$ and $I$ and $J$.\nassistant\n", "label": "Axiom fold_sum : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall J : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil), forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) (matita_basics_lists_list.append A I J))) .", "predict": "Axiom fold_sum : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall J : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil), forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (fun i => matita_basics_bool.true) (fun i => f i) (matita_basics_lists_list.append A I J))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEx2_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.\nassistant\n", "label": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)", "predict": "postulate ex2_ind : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_Q : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop) -> (_H_ex2_intro : (x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Term cic.prop (Q_ x_274)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnique_filter. Let $S$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.unique$ applied to $S$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$.\nassistant\n", "label": "postulate unique_filter : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) -> cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))", "predict": "postulate unique_filter : (S : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_lists_list.unique S l)) -> cic.Term cic.prop (matita_basics_lists_list.unique S (matita_basics_lists_list.filter S f l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEnum. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $_x_942$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A", "predict": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_Type4_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_813$.\nassistant\n", "label": "Axiom div_mod_spec_rect_Type4_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) .", "predict": "Axiom div_mod_spec_rect_Type4_body : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4), forall _H_div_mod_spec_intro : ((x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))), forall x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term univs.Type4 (Q_ x_813) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_sqrt_to_le_times_l. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $n$ and $m$.\nassistant\n", "label": "Axiom le_sqrt_to_le_times_l : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_sqrt.sqrt m)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n n) m) .", "predict": "Axiom le_sqrt_to_le_times_l : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_sqrt.sqrt m)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_S_times_2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom le_S_times_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))", "predict": "axiom le_S_times_2 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMinus_plus_plus_l. For all elements $x$ and $y$ and $h$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$.\nassistant\n", "label": "postulate minus_plus_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))", "predict": "postulate minus_plus_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (h : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLprim. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom lprim : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) .", "predict": "Axiom lprim : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNat_rect_CProp2. Let $Q_$ be a function from elements $_x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_406$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_408$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_406$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_406$, for all elements $x_405$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_405$.\nassistant\n", "label": "Axiom nat_rect_CProp2 : forall Q_ : ((_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))), forall x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_405) .", "predict": "Axiom nat_rect_CProp2 : forall Q_ : ((_x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O), forall _H_S : ((x_406 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_408 : cic.Term cic.prop (Q_ x_406)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_406))), forall x_405 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_405) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_rect_Type4_body. Let $Q_$ be a function from elements $_x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type4$. Then for all elements $x_67$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_67$.\nassistant\n", "label": "postulate False_rect_Type4_body : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)", "predict": "postulate False_rect_Type4_body : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_eq. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ and $__$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_eq : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall __ : cic.Term univs.Type2 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.eq A _x __), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_eq : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall __ : cic.Term univs.Type2 A, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_basics_logic.eq A _x __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_basics_logic.eq A _x __), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_CProp2. For all functions $Q_$ from elements $_x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_356$.\nassistant\n", "label": "Axiom bool_rect_CProp2 : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) .", "predict": "Axiom bool_rect_CProp2 : forall Q_ : ((_x_356 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_356 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_356) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_903$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_903$.\nassistant\n", "label": "postulate ACop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_903)", "predict": "postulate ACop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_903 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_903)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_CProp1. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_712$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_712$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_712$.\nassistant\n", "label": "axiom Prod_rect_CProp1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_712)", "predict": "axiom Prod_rect_CProp1 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_712 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_712)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_CProp5. Let $Q_$ be a function from elements $_x_350$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_350$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_350$.\nassistant\n", "label": "bool_rect_CProp5 : Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_350 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_350) .", "predict": "bool_rect_CProp5 : Q_ : (_x_350 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true) -> _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false) -> x_350 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term cic.prop (Q_ x_350) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLog_SO. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom log_SO : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) matita_arithmetics_nat.O) .", "predict": "Axiom log_SO : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPair_eq2. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a1$ and $b1$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a2$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b1$ and $b2$.\nassistant\n", "label": "postulate pair_eq2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)", "predict": "postulate pair_eq2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLog_div. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.\nassistant\n", "label": "Axiom log_div : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_nat.minus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m))) .", "predict": "Axiom log_div : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le m n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_log.log p (matita_arithmetics_div_and_mod.div n m)) (matita_arithmetics_nat.minus (matita_arithmetics_log.log p n) (matita_arithmetics_log.log p m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1404$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic", "label": "axiom Aop_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1404 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1405 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Aop_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) (P : (_z1404 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop) (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1405 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_to_ord. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_ord.ord_rem$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_ord.ord$ applied to $n$ and $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.\nassistant\n", "label": "divides_to_ord : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p))) .", "predict": "divides_to_ord : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_ord.ord_rem n p) (matita_arithmetics_ord.ord_rem m p)) (matita_arithmetics_nat.le (matita_arithmetics_ord.ord n p) (matita_arithmetics_ord.ord m p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_rect_Type3_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "Axiom Sum_rect_Type3_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3), forall _H_inl : ((x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))), forall _H_inr : ((x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))), forall x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type3 (Q_ x_536) .", "predict": "Axiom Sum_rect_Type3_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3), forall _H_inl : ((x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))), forall _H_inr : ((x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))), forall x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type3 (Q_ x_536) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_n. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_plus_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m)) .", "predict": "Axiom le_plus_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCongruent_n_mod_n. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.\nassistant\n", "label": "congruent_n_mod_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p) .", "predict": "congruent_n_mod_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_option. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate filter_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_rect_CProp0. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_859$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_858$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_859$ and $x_858$, for all elements $x_857$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_857$.\nassistant\n", "label": "div_mod_spec_rect_CProp0 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_857) .", "predict": "div_mod_spec_rect_CProp0 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_857) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $x$.\nassistant\n", "label": "minus_le : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x) .", "predict": "minus_le : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_gcd_aux. Let $p$ and $m$ and $n$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $m$ and $n$.\nassistant\n", "label": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))", "predict": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_sumI. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $mat", "label": "axiom bigop_sumI (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i b))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a)))))", "predict": "axiom bigop_sumI (a b c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le b c)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c a) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c b) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i b)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i b))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus c c) (λ i => (λ i0 => p i0) (matita_arithmetics_nat.plus i c)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => (λ i0 => f i0) (matita_arithmetics_nat.plus i c))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_CProp0_body. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.\nassistant\n", "label": "nat_rect_CProp0_body : Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_416 : cic.Term cic.prop (Q_ x_414) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_413) .", "predict": "nat_rect_CProp0_body : Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop) -> _H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O) -> _H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_416 : cic.Term cic.prop (Q_ x_414) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (Q_ x_413) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_le_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "Axiom not_le_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) .", "predict": "Axiom not_le_to_leb_false : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_inv_rect_CProp4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1602$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1603$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "ACop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) .", "predict": "ACop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1602 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1603 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp1. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nassistant\n", "label": "axiom range_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)", "predict": "axiom range_rect_CProp1 (_A : cic.Univ univs.Type0) (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_937)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDexp. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Dexp : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O)) .", "predict": "Dexp : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_plus_to_lt_r. For all elements $n$ and $p$ and $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.\nassistant\n", "label": "axiom lt_plus_to_lt_r (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)", "predict": "axiom lt_plus_to_lt_r (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus n p) (matita_arithmetics_nat.plus n q))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFlatten. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.\nassistant\n", "label": "axiom flatten (A : cic.Univ univs.Type0) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) : cic.Term univs.Type0 (matita_basics_lists_list.list A)", "predict": "axiom flatten (A : cic.Univ univs.Type0) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list (matita_basics_lists_list.list A))) : cic.Term univs.Type0 (matita_basics_lists_list.list A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_957$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_", "label": "Axiom Dop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_957) .", "predict": "Axiom Dop_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Dop : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))), forall x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil), cic.Term cic.prop (Q_ x_957) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBigop_sum. For all elements $k1$ and $k2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.plus$ applied to $k1$ and $k2$ and the function that maps $i$ to $matita_basics_bool.match_bool$ applied to $univs.Type0$ and the function that maps $__$ to $matita_basics_bool.bool$ and $p1$ applied to", "label": "axiom bigop_sum (k1 k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (λ i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k2 (λ i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i))))", "predict": "axiom bigop_sum (k1 k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (λ i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => f i)) (matita_arithmetics_bigops.bigop k2 (λ i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (λ i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (λ i => matita_basics_bool.match_bool univs.Type0 (λ __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_inv_rect_Type2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z990$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $x_542$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z991$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_542$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_542$, for all functions $_H2$ from elements $x_543$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z991$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_543$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_543$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sum_inv_rect_Type2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z990 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type2) (_H1 : (x_542 : cic.Term univs.Type0 x1) -> (_z991 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_542))) -> cic.Term univs.Type2 (P (matita_basics_types.inl x1 x2 x_542))) (_H2 : (x_543 : cic.Term univs.Type0 x2) -> (_z991 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_543))) -> cic.Term univs.Type2 (P (matita_basics_types.inr x1 x2 x_543))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom Sum_inv_rect_Type2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z990 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type2) (_H1 : (x_542 : cic.Term univs.Type0 x1) -> (_z991 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_542))) -> cic.Term univs.Type2 (P (matita_basics_types.inl x1 x2 x_542))) (_H2 : (x_543 : cic.Term univs.Type0 x2) -> (_z991 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_543))) -> cic.Term univs.Type2 (P (matita_basics_types.inr x1 x2 x_543))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBertrand_down. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.\nassistant\n", "label": "axiom bertrand_down (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)", "predict": "axiom bertrand_down (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))))) : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nP_ord_aux_to_not_mod_O. Let $p$ and $n$ and $m$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $r$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom p_ord_aux_to_not_mod_O : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O)) .", "predict": "Axiom p_ord_aux_to_not_mod_O : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __2 : cic.Term cic.prop (matita_arithmetics_nat.le n p), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r)), cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod r m) matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_Type0. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z353$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $x_144$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_143$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z354$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_144$ and $x_143$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate And_inv_rect_Type0 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (x_144 : cic.Term cic.prop x1) -> (x_143 : cic.Term cic.prop x2) -> (_z354 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P (matita_basics_logic.conj x1 x2 x_144 x_143))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1560. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)", "predict": "postulate let_clause_1560 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_rect_CProp4_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_704$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_704$.\nassistant\n", "label": "postulate Prod_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_704)", "predict": "postulate Prod_rect_CProp4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_704 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_704)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRev_append. Let $H$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$.\nassistant\n", "label": "axiom rev_append (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 (matita_basics_lists_list.list H)", "predict": "axiom rev_append (H : cic.Univ univs.Type0) (__ __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) : cic.Term univs.Type0 (matita_basics_lists_list.list H)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_CProp1. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_775$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_772$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_773$ and $x_772$, for all elements $x_771$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_771$.\nassistant\n", "label": "Axiom list_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))), forall x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_771) .", "predict": "Axiom list_rect_CProp1 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_773 : cic.Term univs.Type0 _A) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_775 : cic.Term cic.prop (Q_ x_772)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_773 x_772))), forall x_771 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_771) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_Type2. For all functions $Q_$ from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nassistant\n", "label": "axiom unit_rect_Type2 (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) (x_503 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type2 (Q_ x_503)", "predict": "axiom unit_rect_Type2 (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) (x_503 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDistributive_times_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.distributive$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ and $matita_arithmetics_nat.plus$.\nassistant\n", "label": "axiom distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)", "predict": "axiom distributive_times_plus : cic.Term cic.prop (matita_basics_relations.distributive matita_arithmetics_nat.nat matita_arithmetics_nat.times matita_arithmetics_nat.plus)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_CProp0. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_780$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_777$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_778$ and $x_777$, for all elements $x_776$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_776$.\nassistant\n", "label": "Axiom list_rect_CProp0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))), forall x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_776) .", "predict": "Axiom list_rect_CProp0 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop), forall _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_778 : cic.Term univs.Type0 _A) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_780 : cic.Term cic.prop (Q_ x_777)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_778 x_777))), forall x_776 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term cic.prop (Q_ x_776) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.\nassistant\n", "label": "Axiom eq_rect_CProp4_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_22 : cic.Term univs.Type2 A, forall x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22), cic.Term cic.prop (Q_ x_22 x_23) .", "predict": "Axiom eq_rect_CProp4_body : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_22 : cic.Term univs.Type2 A, forall x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22), cic.Term cic.prop (Q_ x_22 x_23) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_p_ord_inv. For all elements $p$ and $m$ and $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_ord.ord_rem$ applied to $x$ and $p$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.\nassistant\n", "label": "eq_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p))) .", "predict": "eq_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord_inv p m x) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_ord.ord_rem x p) m) (matita_arithmetics_ord.ord x p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_949$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $", "label": "axiom Dop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type3 (Q_ x_949)", "predict": "axiom Dop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type3 (Q_ x_949)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter_max_spec. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.max_spec$ applied to $_n$ and $_f$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "Axiom filter_max_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __), cic.Term return_sort (return_type z) .", "predict": "Axiom filter_max_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall return_sort : cic.Sort, forall return_type : ((z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Univ return_sort), forall return : ((z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __)) -> cic.Term return_sort (return_type z)), forall z : cic.Term cic.prop (matita_arithmetics_minimization.max_spec _n _f __), cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nUnit_discr. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_unit$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_types.match_unit$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z31$ to $P$ and $y$ and $x$.\nassistant\n", "label": "unit_discr : x : cic.Term univs.Type0 matita_basics_types.unit -> y : cic.Term univs.Type0 matita_basics_types.unit -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) x y) -> cic.Term univs.Type2 (matita_basics_types.match_unit (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_types.unit => cic.univ univs.Type2) (matita_basics_types.match_unit (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_types.unit => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z31 : cic.Term univs.Type1 P => P))) y) x) .", "predict": "unit_discr : x : cic.Term univs.Type0 matita_basics_types.unit -> y : cic.Term univs.Type0 matita_basics_types.unit -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) x y) -> cic.Term univs.Type2 (matita_basics_types.match_unit (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_types.unit => cic.univ univs.Type2) (matita_basics_types.match_unit (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_types.unit => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z31 : cic.Term univs.Type1 P => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_div_S_S_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_div_S_S_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m))) .", "predict": "Axiom le_div_S_S_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEx2_ind_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.\nassistant\n", "label": "ex2_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) .", "predict": "ex2_ind_body : A : cic.Univ univs.Type0 -> _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) -> Q_ : (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Univ cic.prop) -> _H_ex2_intro : (x : cic.Term univs.Type0 A -> x_276 : cic.Term cic.prop (_P x) -> x_275 : cic.Term cic.prop (_Q x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) -> x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) -> cic.Term cic.prop (Q_ x_274) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1553. For all elements $n$ and $n0$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n0$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hn$ of $cic.Term$ of $cic.prop$ and $matita_b", "label": "Axiom let_clause_1553 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hn : cic.Term cic", "predict": "Axiom let_clause_1553 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n0 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun a => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))), forall Hn : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n0 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_CProp2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_909$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_909$.\nassistant\n", "label": "ACop_rect_CProp2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_909) .", "predict": "ACop_rect_CProp2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_909 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_909) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_inv_rect_CProp3. For all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, for all functions $P$ from elements $_z167$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z168$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom True_inv_rect_CProp3 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z167 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) : cic.Term cic.prop (P Hterm)", "predict": "axiom True_inv_rect_CProp3 (Hterm : cic.Term cic.prop matita_basics_logic.True) (P : (_z167 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H1 : (_z168 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_907$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_907$.\nassistant\n", "label": "axiom ACop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_907)", "predict": "axiom ACop_rect_CProp3_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_907 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term cic.prop (Q_ x_907)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_inv_rect_Type1. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1458$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_831$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_830$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1459$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_831$ and $x_830$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom div_mod_spec_inv_rect_Type1 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1458 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type1), forall _H1 : ((x_831 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_830 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1459 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))) -> cic.Term univs.Type1 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_831 x_830))), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_rect_CProp5_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$, for all functions $_H_inr$ from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$, for all elements $x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.\nassistant\n", "label": "axiom Sum_rect_CProp5_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_561)", "predict": "axiom Sum_rect_CProp5_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_561)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1033. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1p$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $m$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "let_clause_1033 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_1033 : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_Type5_body. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_nmk$ from functions $x_86$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_86$, for all elements $x_85$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_85$.\nassistant\n", "label": "Not_rect_Type5_body : _A : cic.Univ cic.prop -> Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type5) -> _H_nmk : (x_86 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type5 (Q_ x_85) .", "predict": "Not_rect_Type5_body : _A : cic.Univ cic.prop -> Q_ : (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type5) -> _H_nmk : (x_86 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) -> x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type5 (Q_ x_85) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFilter. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.\nassistant\n", "label": "Axiom filter : forall T : cic.Univ univs.Type0, forall _p : ((__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list T), cic.Term univs.Type0 (matita_basics_lists_list.list T) .", "predict": "Axiom filter : forall T : cic.Univ univs.Type0, forall _p : ((__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool), forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list T), cic.Term univs.Type0 (matita_basics_lists_list.list T) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_rect_Type0. For all functions $Q_$ from elements $_x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_I$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_52$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_52$.\nassistant\n", "label": "Axiom True_rect_Type0 : forall Q_ : ((_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0), forall _H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I), forall x_52 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type0 (Q_ x_52) .", "predict": "Axiom True_rect_Type0 : forall Q_ : ((_x_52 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type0), forall _H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I), forall x_52 : cic.Term cic.prop matita_basics_logic.True, cic.Term univs.Type0 (Q_ x_52) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAop_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $nil$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$.\nassistant\n", "label": "axiom aop_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)", "predict": "axiom aop_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)) : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Prod_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Prod_inv_rect_CProp2 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2), forall P : ((_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSinglevalued. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation2$ applied to $A$ and $B$.\nassistant\n", "label": "postulate singlevalued : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))", "predict": "postulate singlevalued : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation2 A B))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_ind_body. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_quotient$ from elements $q$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_1193$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_m$ and $matita_arithmetics_nat.times$ applied to $_n$ and $q$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_primes.quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, for all elements $x_1192$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_1192$.\nassistant\n", "label": "axiom divides_ind_body (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)", "predict": "axiom divides_ind_body (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) : cic.Term cic.prop (Q_ x_1192)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_to_le_r. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $a$ and $matita_arithmetics_nat.plus$ applied to $m$ and $a$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_plus_to_le_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n a) (matita_arithmetics_nat.plus m a)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_plus_to_le_r : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n a) (matita_arithmetics_nat.plus m a)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_650$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_650$.\nassistant\n", "label": "Axiom DPair_rect_Type0 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type0 (Q_ x_650) .", "predict": "Axiom DPair_rect_Type0 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term univs.Type0 (Q_ x_650) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_times_to_le. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_times_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_times_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAnd_rect_CProp2_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_160$ and $x_159$, for all elements $x_158$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_158$.\nassistant\n", "label": "Axiom And_rect_CProp2_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))), forall x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_158) .", "predict": "Axiom And_rect_CProp2_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_160 : cic.Term cic.prop _A) -> (x_159 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))), forall x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_158) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTrue_rect_CProp5. Let $Q_$ be a function from elements $_x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_56$.\nassistant\n", "label": "axiom True_rect_CProp5 (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_56 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_56)", "predict": "axiom True_rect_CProp5 (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) (x_56 : cic.Term cic.prop matita_basics_logic.True) : cic.Term cic.prop (Q_ x_56)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g1$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n1$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arith", "label": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g1 i)) (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arith", "predict": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n1) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.true) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g1 i)) (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => g2 i)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_bigops.bigop n1 (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => p i) matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNth_opt_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "Axiom nth_opt_body : forall A : cic.Univ univs.Type0, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option A) .", "predict": "Axiom nth_opt_body : forall A : cic.Univ univs.Type0, forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term univs.Type0 (matita_basics_types.option A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1047. For all elements $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $lenk$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $k$, for all elements $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $leup$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $j$, for all functions $Hind$ from functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $j$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $i$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$", "label": "postulate let_clause_1047 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (lenk : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (leup : cic.Term cic.prop (matita_arithmetics_nat.le n j)) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i j)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat", "predict": "postulate let_clause_1047 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (lenk : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (leup : cic.Term cic.prop (matita_arithmetics_nat.le n j)) -> (Hind : (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i j)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_Type0_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_None$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_611$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_611$, for all elements $x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_610$.\nassistant\n", "label": "postulate option_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) -> (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) -> (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type0 (Q_ x_610)", "predict": "postulate option_rect_Type0_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) -> (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) -> (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type0 (Q_ x_610)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_31$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_32$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_31$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_31$ and $x_32$.\nassistant\n", "label": "eq_rect_CProp2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_31 : cic.Term univs.Type2 A -> _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_31 : cic.Term univs.Type2 A -> x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Term cic.prop (Q_ x_31 x_32) .", "predict": "eq_rect_CProp2 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_31 : cic.Term univs.Type2 A -> _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_31 : cic.Term univs.Type2 A -> x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) -> cic.Term cic.prop (Q_ x_31 x_32) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_minus1. For all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $c$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $a$ and $matita_arithmetics_nat.minus$ applied to $b$ and $c$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $b$ and $c$.\nassistant\n", "label": "plus_minus1 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le c b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c)) .", "predict": "plus_minus1 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le c b) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus a (matita_arithmetics_nat.minus b c)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus a b) c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue_rect_CProp4. Let $Q_$ be a function from elements $_x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_54$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_54$.\nassistant\n", "label": "Axiom True_rect_CProp4 : forall Q_ : ((_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I), forall x_54 : cic.Term cic.prop matita_basics_logic.True, cic.Term cic.prop (Q_ x_54) .", "predict": "Axiom True_rect_CProp4 : forall Q_ : ((_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop), forall _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I), forall x_54 : cic.Term cic.prop matita_basics_logic.True, cic.Term cic.prop (Q_ x_54) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAnd_rect_CProp0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_168$ and $x_167$, for all elements $x_166$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_166$.\nassistant\n", "label": "axiom And_rect_CProp0_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) (x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_166)", "predict": "axiom And_rect_CProp0_body (_A _B : cic.Univ cic.prop) (Q_ : (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) (_H_conj : (x_168 : cic.Term cic.prop _A) -> (x_167 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) (x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B)) : cic.Term cic.prop (Q_ x_166)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTimes_body. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate times_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate times_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_O_bc. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $m$.\nassistant\n", "label": "lt_O_bc : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) .", "predict": "lt_O_bc : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_binomial.bc n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_rect_Type2. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_conj$ from elements $x_136$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_135$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_136$ and $x_135$, for all elements $x_134$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_134$.\nassistant\n", "label": "And_rect_Type2 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type2) -> _H_conj : (x_136 : cic.Term cic.prop _A -> x_135 : cic.Term cic.prop _B -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type2 (Q_ x_134) .", "predict": "And_rect_Type2 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type2) -> _H_conj : (x_136 : cic.Term cic.prop _A -> x_135 : cic.Term cic.prop _B -> cic.Term univs.Type2 (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) -> x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type2 (Q_ x_134) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_inl$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_547$, for all functions $_H_inr$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_548$, for all elements $x_546$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_546$.\nassistant\n", "label": "axiom Sum_rect_Type1_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type1 (Q_ x_546)", "predict": "axiom Sum_rect_Type1_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type1) (_H_inl : (x_547 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inl _A _B x_547))) (_H_inr : (x_548 : cic.Term univs.Type0 _B) -> cic.Term univs.Type1 (Q_ (matita_basics_types.inr _A _B x_548))) (x_546 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term univs.Type1 (Q_ x_546)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nIs_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom is_nil : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop .", "predict": "Axiom is_nil : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_CProp3. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_107$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_107$, for all elements $x_106$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_106$.\nassistant\n", "label": "Not_rect_CProp3 : _A : cic.Univ cic.prop -> Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_107 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_106) .", "predict": "Not_rect_CProp3 : _A : cic.Univ cic.prop -> Q_ : (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ cic.prop) -> _H_nmk : (x_107 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) -> x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term cic.prop (Q_ x_106) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAnd_rect_Type5. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_conj$ from elements $x_128$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_127$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_128$ and $x_127$, for all elements $x_126$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_126$.\nassistant\n", "label": "Axiom And_rect_Type5 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) .", "predict": "Axiom And_rect_Type5 : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type5), forall _H_conj : ((x_128 : cic.Term cic.prop _A) -> (x_127 : cic.Term cic.prop _B) -> cic.Term univs.Type5 (Q_ (matita_basics_logic.conj _A _B x_128 x_127))), forall x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term univs.Type5 (Q_ x_126) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_16921. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x358$ and $x359$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x358$ and $matita_arithmetics_nat.times$ applied to $x358$ and $x359$ and $matita_arithmetics_nat.times$ applied to $x358$ and $matita_arithmetics_nat.S$ applied to $x359$.\nassistant\n", "label": "let_clause_16921 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) .", "predict": "let_clause_16921 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_minus_S_pred. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom eq_minus_S_pred : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))) .", "predict": "Axiom eq_minus_S_pred : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_d_gcd. For all elements $m$ and $n$ and $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.\nassistant\n", "label": "axiom divides_d_gcd (m n d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))", "predict": "axiom divides_d_gcd (m n d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type3_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $__$ of $cic.Term$ of $univs.Type3$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $x$ and $p$.\nassistant\n", "label": "axiom eq_rect_Type3_r (A : cic.Univ univs.Type2) (a : cic.Term univs.Type2 A) (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type3) (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) (x : cic.Term univs.Type2 A) (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) : cic.Term univs.Type3 (P x p)", "predict": "axiom eq_rect_Type3_r (A : cic.Univ univs.Type2) (a : cic.Term univs.Type2 A) (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type3) (__ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a))) (x : cic.Term univs.Type2 A) (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) : cic.Term univs.Type3 (P x p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_ind_plus. For all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.O$, for all functions $__1$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $n$ to elements of $cic.Term$ of $cic.prop$ and $R$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $R$ applied to $n$.\nassistant\n", "label": "postulate nat_ind_plus : (R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (R matita_arithmetics_nat.O)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n)", "predict": "postulate nat_ind_plus : (R : cic.Term univs.Type0 (matita_basics_relations.predicate matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (R matita_arithmetics_nat.O)) -> (__1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (R n)) -> cic.Term cic.prop (R (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (R n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_divides_to_gcd_aux. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd_aux$ applied to $matita_arithmetics_nat.S$ applied to $p$ and $m$ and $n$ and $matita_arithmetics_gcd.gcd_aux$ applied to $p$ and $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) .", "predict": "Axiom not_divides_to_gcd_aux : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd_aux (matita_arithmetics_nat.S p) m n) (matita_arithmetics_gcd.gcd_aux p n (matita_arithmetics_div_and_mod.mod m n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom exp : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom exp : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nChecker. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "checker : __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "checker : __ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nOrb_true_r1. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.orb$ applied to $b1$ and $b2$ and $matita_basics_bool.true$.\nassistant\n", "label": "orb_true_r1 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) .", "predict": "orb_true_r1 : b1 : cic.Term univs.Type0 matita_basics_bool.bool -> b2 : cic.Term univs.Type0 matita_basics_bool.bool -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.orb b1 b2) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFoldr_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.\nassistant\n", "label": "postulate foldr_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B", "predict": "postulate foldr_body : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom divides (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom divides (_n _m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_to_le_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "axiom le_to_le_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)", "predict": "axiom le_to_le_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_smallest_factor_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom divides_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "Axiom divides_smallest_factor_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nStart_lprim. For all elements $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.option_hd$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand256.lprim$ applied to $n$ and $m$ and $matita_basics_lists_list.cons$ applied to $matita_arithmetics_nat.nat$ and $a$ and $acc$ and $matita_basics_types.Some$ applied to $matita_arithmetics_nat.nat$ and $a$.\nassistant\n", "label": "Axiom start_lprim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.lprim n m (matita_basics_lists_list.cons matita_arithmetics_nat.nat a acc))) (matita_basics_types.Some matita_arithmetics_nat.nat a)) .", "predict": "Axiom start_lprim : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall acc : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option matita_arithmetics_nat.nat)) (matita_basics_lists_list.option_hd matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand256.lprim n m (matita_basics_lists_list.cons matita_arithmetics_nat.nat a acc))) (matita_basics_types.Some matita_arithmetics_nat.nat a)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nInjective. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate injective : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop", "predict": "postulate injective : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_n_O. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom divides_n_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O) .", "predict": "Axiom divides_n_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_primes.divides n matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_times_n_to_lt_l. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $p$ and $n$ and $matita_arithmetics_nat.times$ applied to $q$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.\nassistant\n", "label": "axiom lt_times_n_to_lt_l (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times p n) (matita_arithmetics_nat.times q n))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)", "predict": "axiom lt_times_n_to_lt_l (n p q : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times p n) (matita_arithmetics_nat.times q n))) : cic.Term cic.prop (matita_arithmetics_nat.lt p q)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMk_DPair. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $f$ applied to $dpi1$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $f$.\nassistant\n", "label": "axiom mk_DPair (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (dpi1 : cic.Term univs.Type0 A) (_dpi2 : cic.Term univs.Type0 (f dpi1)) : cic.Term univs.Type0 (matita_basics_types.DPair A f)", "predict": "axiom mk_DPair (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (dpi1 : cic.Term univs.Type0 A) (_dpi2 : cic.Term univs.Type0 (f dpi1)) : cic.Term univs.Type0 (matita_basics_types.DPair A f)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_to_lt_O. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom divides_to_lt_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) .", "predict": "Axiom divides_to_lt_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_le_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate not_le_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "postulate not_le_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_divides_ord_rem. For all elements $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_ord.ord_rem$ applied to $m$ and $p$.\nassistant\n", "label": "postulate not_divides_ord_rem : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p)))", "predict": "postulate not_divides_ord_rem : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_ord.ord_rem m p)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_rect_CProp3. For all functions $Q_$ from elements $_x_491$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_491$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_491$.\nassistant\n", "label": "axiom void_rect_CProp3 (Q_ : (_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_491 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_491)", "predict": "axiom void_rect_CProp3 (Q_ : (_x_491 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_491 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_491)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_Type5. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_594$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_None$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_595$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_595$, for all elements $x_594$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_594$.\nassistant\n", "label": "Axiom option_rect_Type5 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type5), forall _H_None : cic.Term univs.Type5 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_595 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.Some _A x_595))), forall x_594 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type5 (Q_ x_594) .", "predict": "Axiom option_rect_Type5 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_594 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type5), forall _H_None : cic.Term univs.Type5 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_595 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.Some _A x_595))), forall x_594 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type5 (Q_ x_594) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_exp_to_divides. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.\nassistant\n", "label": "axiom divides_exp_to_divides (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m))) : cic.Term cic.prop (matita_arithmetics_primes.divides p n)", "predict": "axiom divides_exp_to_divides (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m))) : cic.Term cic.prop (matita_arithmetics_primes.divides p n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_ind_body. For all functions $Q_$ from elements $_x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_482$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_482$.\nassistant\n", "label": "axiom void_ind_body (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_482 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_482)", "predict": "axiom void_ind_body (Q_ : (_x_482 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_482 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_482)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEx_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.\nassistant\n", "label": "axiom ex_ind (A : cic.Univ univs.Type0) (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) : cic.Term cic.prop (Q_ x_235)", "predict": "axiom ex_ind (A : cic.Univ univs.Type0) (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) : cic.Term cic.prop (Q_ x_235)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1194$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1195$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Sig_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type1) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P Hterm) .", "predict": "Sig_inv_rect_Type1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1194 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ univs.Type1) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1195 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term univs.Type1 (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBi_relation. For all elements $__$ and $__1$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "Axiom bi_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, cic.Univ univs.Type0 .", "predict": "Axiom bi_relation : forall __ : cic.Univ univs.Type0, forall __1 : cic.Univ univs.Type0, cic.Univ univs.Type0 ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNoteq_to_eqnot. For all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $matita_basics_bool.notb$ applied to $b2$.\nassistant\n", "label": "postulate noteq_to_eqnot : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))", "predict": "postulate noteq_to_eqnot : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 (matita_basics_bool.notb b2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "postulate Sum_rect_Type3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)", "predict": "postulate Sum_rect_Type3 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type3) -> (_H_inl : (x_537 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> (_H_inr : (x_538 : cic.Term univs.Type0 _B) -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> (x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type3 (Q_ x_536)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOr_div_mod. Let $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$ and $q$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $q$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $q$.\nassistant\n", "label": "postulate or_div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q))))))", "predict": "postulate or_div_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.div n q)) q))) (matita_basics_logic.And (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q)) q) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n q) q) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n q))))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_CProp4_body. Let $Q_$ be a function from elements $_x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_509$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_509$.\nassistant\n", "label": "postulate unit_rect_CProp4_body : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)", "predict": "postulate unit_rect_CProp4_body : (Q_ : (_x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_509 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_509)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_rect_Type5. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_div_mod_spec_intro$ from elements $x_819$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_818$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_819$ and $x_818$, for all elements $x_817$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_817$.\nassistant\n", "label": "div_mod_spec_rect_Type5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) .", "predict": "div_mod_spec_rect_Type5 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ univs.Type5) -> _H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term univs.Type5 (Q_ x_817) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_maxl. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$.\nassistant\n", "label": "postulate le_maxl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) -> cic.Term cic.prop (matita_arithmetics_nat.le n i)", "predict": "postulate le_maxl : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)) -> cic.Term cic.prop (matita_arithmetics_nat.le n i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_949$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$", "label": "postulate Dop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type3 (Q_ x_949)", "predict": "postulate Dop_rect_Type3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type3 (Q_ x_949)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSum_rect_Type5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_inl$ from elements $x_532$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_532$, for all functions $_H_inr$ from elements $x_533$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_533$, for all elements $x_531$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_531$.\nassistant\n", "label": "Axiom Sum_rect_Type5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5), forall _H_inl : ((x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))), forall _H_inr : ((x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))), forall x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type5 (Q_ x_531) .", "predict": "Axiom Sum_rect_Type5_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5), forall _H_inl : ((x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))), forall _H_inr : ((x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))), forall x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B), cic.Term univs.Type5 (Q_ x_531) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_r_sn. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "axiom lstar_r_sn (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) (b1 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (R b1 b)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)", "predict": "axiom lstar_r_sn (B : cic.Univ univs.Type0) (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b b2 : cic.Term univs.Type0 B) (__ : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R l b b2)) (b1 : cic.Term univs.Type0 B) (__1 : cic.Term cic.prop (R b1 b)) : cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_n_r. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom le_plus_n_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n)) .", "predict": "Axiom le_plus_n_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOr_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z389$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_171$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_introl$ applied to $x1$ and $x2$ and $x_171$, for all functions $_H2$ from elements $x_172$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z390$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Or$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.or_intror$ applied to $x1$ and $x2$ and $x_172$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Or_inv_ind (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) (P : (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) (_H2 : (x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Or_inv_ind (x1 x2 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) (P : (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2)) -> cic.Univ cic.prop) (_H1 : (x_171 : cic.Term cic.prop x1) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_introl x1 x2 x_171))) -> cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) (_H2 : (x_172 : cic.Term cic.prop x2) -> (_z390 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2)) Hterm (matita_basics_logic.or_intror x1 x2 x_172))) -> cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_primr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "le_primr : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) .", "predict": "le_primr : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim n) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSame_bigop. Let $k$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_upto$ applied to $k$ and $matita_basics_bool.bool$ and $p1$ and $p2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sameF_p$ applied to $k$ and $p1$ and $B$ and $f$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$.\nassistant\n", "label": "postulate same_bigop : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto k matita_basics_bool.bool p1 p2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p k p1 B f g)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i)))", "predict": "postulate same_bigop : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_bigops.sameF_upto k matita_basics_bool.bool p1 p2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_bigops.sameF_p k p1 B f g)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrime_to_not_divides_fact. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_factorial.fact$ applied to $n$.\nassistant\n", "label": "axiom prime_to_not_divides_fact (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))", "predict": "axiom prime_to_not_divides_fact (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt n p)) : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p (matita_arithmetics_factorial.fact n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEqb. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "Axiom eqb : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool .", "predict": "Axiom eqb : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_basics_bool.bool ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFalse_rect_CProp4_body. Let $Q_$ be a function from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.\nassistant\n", "label": "axiom False_rect_CProp4_body (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_73 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_73)", "predict": "axiom False_rect_CProp4_body (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_73 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_73)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1146$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1147$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom DPair_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term cic.prop (P Hterm)", "predict": "axiom DPair_inv_rect_CProp3 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1146 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1147 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_coerc. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.succ$ applied to $univs.Type0$ and $univs.Type2$ and $cic.univ$ applied to $univs.Type0$ and $A$ and $B$, $cic.Term$ holds for $univs.Type0$ and $B$.\nassistant\n", "label": "Axiom eq_coerc : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0)) A B), cic.Term univs.Type0 B .", "predict": "Axiom eq_coerc : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 A, forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0)) A B), cic.Term univs.Type0 B ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_ind. Let $Q_$ be a function from elements $_x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_366$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_368$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_366$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_366$, for all elements $x_365$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_365$.\nassistant\n", "label": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)", "predict": "axiom nat_ind (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_365)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_rect_Type4. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_conj$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_124$ and $x_123$, for all elements $x_122$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_122$.\nassistant\n", "label": "And_rect_Type4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type4) -> _H_conj : (x_124 : cic.Term cic.prop _A -> x_123 : cic.Term cic.prop _B -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type4 (Q_ x_122) .", "predict": "And_rect_Type4 : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> Q_ : (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Univ univs.Type4) -> _H_conj : (x_124 : cic.Term cic.prop _A -> x_123 : cic.Term cic.prop _B -> cic.Term univs.Type4 (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) -> x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) -> cic.Term univs.Type4 (Q_ x_122) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_Type1_body. For all functions $Q_$ from elements $_x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $_H_it$ of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_505$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_505$.\nassistant\n", "label": "axiom unit_rect_Type1_body (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) (x_505 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type1 (Q_ x_505)", "predict": "axiom unit_rect_Type1_body (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) (x_505 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type1 (Q_ x_505)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_div_S_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom lt_div_S_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m)) .", "predict": "Axiom lt_div_S_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S m)) (matita_arithmetics_div_and_mod.div n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_rect_Type3. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.\nassistant\n", "label": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)", "predict": "postulate option_rect_Type3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3) -> (_H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))) -> (x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type3 (Q_ x_598)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "axiom eqb_true_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)", "predict": "axiom eqb_true_to_eq (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSub0_to_false. For all functions $h$ and $k$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $I$ and $J$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $I$ and $matita_arithmetics_nat.O$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.sub_hk$ applied to $h$ and $k$ and $A$ and $J$ and $I$, for all elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_bigops.upto$ applied to $A$ and $J$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_bigops.filter$ applied to $A$ and $J$ and $i$ and $matita_basics_bool.false$.\nassistant\n", "label": "Axiom sub0_to_false : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A J I), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_bigops.upto A J)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_bigops.filter A J i) matita_basics_bool.false) .", "predict": "Axiom sub0_to_false : forall h : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall A : cic.Univ univs.Type0, forall I : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall J : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.upto A I) matita_arithmetics_nat.O), forall __1 : cic.Term cic.prop (matita_arithmetics_bigops.sub_hk h k A J I), forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_bigops.upto A J)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_bigops.filter A J i) matita_basics_bool.false) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_897$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_897$.\nassistant\n", "label": "ACop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type2) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type2 (Q_ x_897) .", "predict": "ACop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type2) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type2 (Q_ x_897) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPermut_S_mod. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_congruence.S_mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "permut_S_mod : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n) .", "predict": "permut_S_mod : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_congruence.S_mod (matita_arithmetics_nat.S n)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_rect_CProp0. For all functions $Q_$ from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.\nassistant\n", "label": "postulate nat_rect_CProp0 : (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_413)", "predict": "postulate nat_rect_CProp0 : (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) -> (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_413)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMonotonic_lt_times_r. For all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $t$ to $matita_arithmetics_nat.times$ applied to $c$ and $t$.\nassistant\n", "label": "postulate monotonic_lt_times_r : (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ t : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times c t))", "predict": "postulate monotonic_lt_times_r : (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ t : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.times c t))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_rect_Type0_body. Let $Q_$ be a function from elements $_x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_H_true$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_344$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_344$.\nassistant\n", "label": "axiom bool_rect_Type0_body (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 (Q_ x_344)", "predict": "axiom bool_rect_Type0_body (Q_ : (_x_344 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) (_H_true : cic.Term univs.Type0 (Q_ matita_basics_bool.true)) (_H_false : cic.Term univs.Type0 (Q_ matita_basics_bool.false)) (x_344 : cic.Term univs.Type0 matita_basics_bool.bool) : cic.Term univs.Type0 (Q_ x_344)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_Sn_m. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "minus_Sn_m : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus n m))) .", "predict": "minus_Sn_m : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le m n) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_nat.minus n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTimesACdef. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.timesAC$ and $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "timesACdef : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_sigma_pi.timesAC n m) (matita_arithmetics_nat.times n m)) .", "predict": "timesACdef : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_sigma_pi.timesAC n m) (matita_arithmetics_nat.times n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMap_body. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $B$.\nassistant\n", "label": "axiom map_body (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_lists_list.list B)", "predict": "axiom map_body (A B : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) : cic.Term univs.Type0 (matita_basics_lists_list.list B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPrime_to_lt_SO. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$.\nassistant\n", "label": "axiom prime_to_lt_SO (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)", "predict": "axiom prime_to_lt_SO (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPsi. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom Psi : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom Psi : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLstar_S. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$ and $b2$.\nassistant\n", "label": "lstar_S : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) .", "predict": "lstar_S : B : cic.Univ univs.Type0 -> R : cic.Term univs.Type0 (matita_basics_relations.relation B) -> b1 : cic.Term univs.Type0 B -> b : cic.Term univs.Type0 B -> __ : cic.Term cic.prop (R b1 b) -> l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b2 : cic.Term univs.Type0 B -> __1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2) -> cic.Term cic.prop (matita_arithmetics_lstar.lstar B R (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1 b2) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_option. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all elements $case_None$ of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $case_Some$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.Some$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) -> (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_option : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ return_sort) -> (case_None : cic.Term return_sort (return_type (matita_basics_types.None _A))) -> (case_Some : (__ : cic.Term univs.Type0 _A) -> cic.Term return_sort (return_type (matita_basics_types.Some _A __))) -> (z : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_rect_Type0. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.\nassistant\n", "label": "Axiom Prod_rect_Type0 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) .", "predict": "Axiom Prod_rect_Type0 : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMinus_Sn_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom minus_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) .", "predict": "Axiom minus_Sn_n : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExteqR. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_R$ and $_S$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "exteqR : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> _S : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> cic.Univ cic.prop .", "predict": "exteqR : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> _S : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 B -> cic.Univ cic.prop) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nInjective_compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $B$ and $f$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $B$ and $C$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $C$ and the function that maps $x$ to $g$ applied to $f$ applied to $x$.\nassistant\n", "label": "injective_compose : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> __ : cic.Term cic.prop (matita_basics_relations.injective A B f) -> __1 : cic.Term cic.prop (matita_basics_relations.injective B C g) -> cic.Term cic.prop (matita_basics_relations.injective A C (x : cic.Term univs.Type0 A => g (f x))) .", "predict": "injective_compose : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> C : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> g : (__ : cic.Term univs.Type0 B -> cic.Term univs.Type0 C) -> __ : cic.Term cic.prop (matita_basics_relations.injective A B f) -> __1 : cic.Term cic.prop (matita_basics_relations.injective B C g) -> cic.Term cic.prop (matita_basics_relations.injective A C (x : cic.Term univs.Type0 A => g (f x))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSum_rect_Type3_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_inl$ from elements $x_537$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_537$, for all functions $_H_inr$ from elements $x_538$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_538$, for all elements $x_536$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_536$.\nassistant\n", "label": "Sum_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type3) -> _H_inl : (x_537 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> _H_inr : (x_538 : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type3 (Q_ x_536) .", "predict": "Sum_rect_Type3_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Univ univs.Type3) -> _H_inl : (x_537 : cic.Term univs.Type0 _A -> cic.Term univs.Type3 (Q_ (matita_basics_types.inl _A _B x_537))) -> _H_inr : (x_538 : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.inr _A _B x_538))) -> x_536 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B) -> cic.Term univs.Type3 (Q_ x_536) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_list. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_list (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_list (_A : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nIff_not. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $matita_basics_logic.Not$ applied to $A$ and $matita_basics_logic.Not$ applied to $B$.\nassistant\n", "label": "Axiom iff_not : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.iff A B), cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B)) .", "predict": "Axiom iff_not : forall A : cic.Univ cic.prop, forall B : cic.Univ cic.prop, forall __ : cic.Term cic.prop (matita_basics_logic.iff A B), cic.Term cic.prop (matita_basics_logic.iff (matita_basics_logic.Not A) (matita_basics_logic.Not B)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInjective_plus_r. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "axiom injective_plus_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (λ m => matita_arithmetics_nat.plus n m))", "predict": "axiom injective_plus_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (λ m => matita_arithmetics_nat.plus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSmallest_factor_to_prime. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $n$.\nassistant\n", "label": "postulate smallest_factor_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)", "predict": "postulate smallest_factor_to_prime : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n)) -> cic.Term cic.prop (matita_arithmetics_primes.prime n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_sqrt_log_n. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_log.log$ applied to $b$ and $n$ and $n$.\nassistant\n", "label": "postulate le_sqrt_log_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_log.log b n)) n)", "predict": "postulate le_sqrt_log_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_log.log b n)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nS. Assume that $Nat$. Then $Nat$.\nassistant\n", "label": "postulate s : Nat -> Nat", "predict": "postulate s : Nat -> Nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_Type0. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_nmk$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_98$, for all elements $x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_97$.\nassistant\n", "label": "Axiom Not_rect_Type0 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0), forall _H_nmk : ((x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))), forall x_97 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type0 (Q_ x_97) .", "predict": "Axiom Not_rect_Type0 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0), forall _H_nmk : ((x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))), forall x_97 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type0 (Q_ x_97) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSqrt_def. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $x$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.times$ applied to $x$ and $x$ and $n$.\nassistant\n", "label": "postulate sqrt_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))", "predict": "postulate sqrt_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLstar_r_O. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_lstar.lstar_r$ applied to $B$ and $R$ and $matita_arithmetics_nat.O$ and $b$ and $b$.\nassistant\n", "label": "Axiom lstar_r_O : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b : cic.Term univs.Type0 B, cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) .", "predict": "Axiom lstar_r_O : forall B : cic.Univ univs.Type0, forall R : cic.Term univs.Type0 (matita_basics_relations.relation B), forall b : cic.Term univs.Type0 B, cic.Term cic.prop (matita_arithmetics_lstar.lstar_r B R matita_arithmetics_nat.O b b) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_CProp4_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.\nassistant\n", "label": "axiom eq_rect_CProp4_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_22 : cic.Term univs.Type2 A) (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) : cic.Term cic.prop (Q_ x_22 x_23)", "predict": "axiom eq_rect_CProp4_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_22 : cic.Term univs.Type2 A) (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) : cic.Term cic.prop (Q_ x_22 x_23)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_Type4. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z329$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $x_124$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_123$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z330$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_124$ and $x_123$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_124$ and $x_123$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_Type4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate And_inv_rect_Type4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (x_124 : cic.Term cic.prop x1) -> (x_123 : cic.Term cic.prop x2) -> (_z330 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P (matita_basics_logic.conj x1 x2 x_124 x_123))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec_to_min. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "Axiom min_spec_to_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m) .", "predict": "Axiom min_spec_to_min : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_inv_rect_Type3. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1446$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $x_823$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_822$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1447$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_823$ and $x_822$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom div_mod_spec_inv_rect_Type3 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type3), forall _H1 : ((x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom div_mod_spec_inv_rect_Type3 : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4), forall P : ((_z1446 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type3), forall _H1 : ((x_823 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_822 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1447 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))) -> cic.Term univs.Type3 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_823 x_822))), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_upper_bound6. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "let_upper_bound6 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "let_upper_bound6 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m) -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNmk. For all elements $A$ of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $A$.\nassistant\n", "label": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)", "predict": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_rect_CProp3_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_nil$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_763$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_762$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_765$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_762$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_763$ and $x_762$, for all elements $x_761$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_761$.\nassistant\n", "label": "list_rect_CProp3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_763 : cic.Term univs.Type0 _A -> x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_765 : cic.Term cic.prop (Q_ x_762) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_761) .", "predict": "list_rect_CProp3_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Univ cic.prop) -> _H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A)) -> _H_cons : (x_763 : cic.Term univs.Type0 _A -> x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> _x_765 : cic.Term cic.prop (Q_ x_762) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A) -> cic.Term cic.prop (Q_ x_761) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_CProp2_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_110$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_110$, for all elements $x_109$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_109$.\nassistant\n", "label": "Axiom Not_rect_CProp2_body : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_110 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))), forall x_109 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_109) .", "predict": "Axiom Not_rect_CProp2_body : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_110 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))), forall x_109 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_109) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_Type2_body. For all functions $Q_$ from elements $_x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_true$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_338$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_338$.\nassistant\n", "label": "Axiom bool_rect_Type2_body : forall Q_ : ((_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2), forall _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false), forall x_338 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type2 (Q_ x_338) .", "predict": "Axiom bool_rect_Type2_body : forall Q_ : ((_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2), forall _H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true), forall _H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false), forall x_338 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term univs.Type2 (Q_ x_338) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nassistant\n", "label": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_pi_l. Let $n$ and $a$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $a$ and $n$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.times$ applied to $a$ and $f$ applied to $i$.\nassistant\n", "label": "exp_pi_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a n) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times a (f i)))) .", "predict": "exp_pi_l : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp a n) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i))) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times a (f i)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_rect_CProp5_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_843$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_842$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_843$ and $x_842$, for all elements $x_841$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_841$.\nassistant\n", "label": "axiom div_mod_spec_rect_CProp5_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_841)", "predict": "axiom div_mod_spec_rect_CProp5_body (_n _m _q _r : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Q_ : (_x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) (_H_div_mod_spec_intro : (x_843 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_842 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_843 x_842))) (x_841 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) : cic.Term cic.prop (Q_ x_841)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_inv_rect_Type3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z599$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z600$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom bool_inv_rect_Type3 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3), forall _H1 : ((_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)), forall _H2 : ((_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)), cic.Term univs.Type3 (P Hterm) .", "predict": "Axiom bool_inv_rect_Type3 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3), forall _H1 : ((_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)), forall _H2 : ((_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)), cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_inv_rect_CProp1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1356$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_773$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_772$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_775$ from elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_772$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_772$ and elements $_z1357$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_773$ and $x_772$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_773$ and $x_772$, $cic.Term$ holds for $c", "label": "axiom list_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_rect_CProp1 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_Bk_B1_B2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_bertrand.B1$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand.B2$ applied to $n$.\nassistant\n", "label": "eq_Bk_B1_B2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_chebyshev_bertrand.B2 n))) .", "predict": "eq_Bk_B1_B2 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_chebyshev_bertrand.B2 n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nR1. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.\nassistant\n", "label": "R1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_19 : cic.Term univs.Type2 A -> _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0) -> _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) -> x_19 : cic.Term univs.Type2 A -> x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Term univs.Type0 (Q_ x_19 x_20) .", "predict": "R1 : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_19 : cic.Term univs.Type2 A -> _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0) -> _H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) -> x_19 : cic.Term univs.Type2 A -> x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Term univs.Type0 (Q_ x_19 x_20) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_801$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$,", "label": "Axiom Aop_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_801) .", "predict": "Axiom Aop_rect_CProp2_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_801 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_801) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNat_rect_Type0_body. Let $Q_$ be a function from elements $_x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_H_O$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_390$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_392$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $x_390$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_390$, for all elements $x_389$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_389$.\nassistant\n", "label": "nat_rect_Type0_body : Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : cic.Term univs.Type0 (Q_ x_390) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (Q_ x_389) .", "predict": "nat_rect_Type0_body : Q_ : (_x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0) -> _H_O : cic.Term univs.Type0 (Q_ matita_arithmetics_nat.O) -> _H_S : (x_390 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _x_392 : cic.Term univs.Type0 (Q_ x_390) -> cic.Term univs.Type0 (Q_ (matita_arithmetics_nat.S x_390))) -> x_389 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (Q_ x_389) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNext. Assume that $Sort$. Then $Sort$.\nassistant\n", "label": "axiom next (x : Sort) : Sort", "predict": "axiom next (x : Sort) : Sort"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nConfluent1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$.\nassistant\n", "label": "confluent1 : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Term univs.Type0 (matita_basics_relations.predicate A) .", "predict": "confluent1 : A : cic.Univ univs.Type0 -> __ : cic.Term univs.Type0 (matita_basics_relations.relation A) -> cic.Term univs.Type0 (matita_basics_relations.predicate A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1674$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1675$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom range_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom range_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1), forall P : ((_z1674 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop), forall _H1 : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1675 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_divides_to_p_ord_O. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.nth_prime$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "Axiom not_divides_to_p_ord_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n)) .", "predict": "Axiom not_divides_to_p_ord_O : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides (matita_arithmetics_primes.nth_prime i) n)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n (matita_arithmetics_primes.nth_prime i)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFound_min_spec. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) .", "predict": "found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTrue. $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom True : cic.Univ cic.prop .", "predict": "Axiom True : cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1034. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$ and $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "postulate let_clause_1034 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))", "predict": "postulate let_clause_1034 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posp : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod x2515 x2516) (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_rect_Type0_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_702$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_702$.\nassistant\n", "label": "Axiom Prod_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) .", "predict": "Axiom Prod_rect_Type0_body : forall _A : cic.Univ univs.Type0, forall _B : cic.Univ univs.Type0, forall Q_ : ((_x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type0), forall _H_mk_Prod : ((_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))), forall x_702 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B), cic.Term univs.Type0 (Q_ x_702) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nConfluent. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $matita_basics_relations.relation$ applied to $A$.\nassistant\n", "label": "axiom confluent (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))", "predict": "axiom confluent (A : cic.Univ univs.Type0) : cic.Term univs.Type0 (matita_basics_relations.predicate (matita_basics_relations.relation A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z593$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom bool_inv_rect_Type4 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z593 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4), forall _H1 : ((_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type4 (P matita_basics_bool.true)), forall _H2 : ((_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type4 (P matita_basics_bool.false)), cic.Term univs.Type4 (P Hterm) .", "predict": "Axiom bool_inv_rect_Type4 : forall Hterm : cic.Term univs.Type0 matita_basics_bool.bool, forall P : ((_z593 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type4), forall _H1 : ((_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type4 (P matita_basics_bool.true)), forall _H2 : ((_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type4 (P matita_basics_bool.false)), cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMem_filter_true. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $S$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $S$ and $a$ and $matita_basics_lists_list.filter$ applied to $S$ and $f$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $a$ and $matita_basics_bool.true$.\nassistant\n", "label": "axiom mem_filter_true (S : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) (a : cic.Term univs.Type0 S) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f a) matita_basics_bool.true)", "predict": "axiom mem_filter_true (S : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) (a : cic.Term univs.Type0 S) (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) (__ : cic.Term cic.prop (matita_basics_lists_list.mem S a (matita_basics_lists_list.filter S f l))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f a) matita_basics_bool.true)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nTransitive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom transitive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop", "predict": "axiom transitive (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1575. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_ar", "label": "let_clause_1575 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_ar", "predict": "let_clause_1575 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _dclearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nRange_rect_CProp4. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_929$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_929$.\nassistant\n", "label": "postulate range_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_929)", "predict": "postulate range_rect_CProp4 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_929 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_929)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPermut_S_to_permut_transpose. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $matita_arithmetics_permutation.transpose$ applied to $f$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $m$ and $f$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom permut_S_to_permut_transpose : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m)), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m) .", "predict": "Axiom permut_S_to_permut_transpose : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f (matita_arithmetics_nat.S m)), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun n => matita_arithmetics_permutation.transpose (f (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.S m) (f n)) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_max_n. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $n$.\nassistant\n", "label": "axiom le_max_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) n)", "predict": "axiom le_max_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInjn_Sn_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.injn$ applied to $f$ and $n$.\nassistant\n", "label": "axiom injn_Sn_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)", "predict": "axiom injn_Sn_n (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.injn f (matita_arithmetics_nat.S n))) : cic.Term cic.prop (matita_arithmetics_permutation.injn f n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_congruent. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "axiom divides_to_congruent (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)", "predict": "axiom divides_to_congruent (n m p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m n)) (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m))) : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_CProp1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_911$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_911$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_911$.\nassistant\n", "label": "ACop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_911) .", "predict": "ACop_rect_CProp1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ cic.prop) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_911 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term cic.prop (Q_ x_911) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNil_cons. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "axiom nil_cons (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))", "predict": "axiom nil_cons (A : cic.Univ univs.Type0) (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.cons A a l) (matita_basics_lists_list.nil A)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_CProp5. For all functions $Q_$ from elements $_x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_74$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_74$.\nassistant\n", "label": "False_rect_CProp5 : Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_74) .", "predict": "False_rect_CProp5 : Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ cic.prop) -> x_74 : cic.Term cic.prop matita_basics_logic.False -> cic.Term cic.prop (Q_ x_74) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_694$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_694$.\nassistant\n", "label": "Prod_rect_Type5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type5) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type5 (Q_ x_694) .", "predict": "Prod_rect_Type5_body : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type5) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type5 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_694 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type5 (Q_ x_694) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNth_body. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $H$ of $cic.Univ$ of $univs.Type0$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $H$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "Axiom nth_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall H : cic.Univ univs.Type0, forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __2 : cic.Term univs.Type0 H, cic.Term univs.Type0 H .", "predict": "Axiom nth_body : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall H : cic.Univ univs.Type0, forall __1 : cic.Term univs.Type0 (matita_basics_lists_list.list H), forall __2 : cic.Term univs.Type0 H, cic.Term univs.Type0 H ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_div. Let $n$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $d$ and $d$.\nassistant\n", "label": "Axiom div_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_div_and_mod.div n d)) d) .", "predict": "Axiom div_div : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_div_and_mod.div n d)) d) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nB1_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.B1$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_psi_bounds.bool_to_nat$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom B1_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_bertrand.k n p))))) .", "predict": "Axiom B1_def : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.B1 n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_bertrand.k n p))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.\nassistant\n", "label": "postulate divides_to_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)", "predict": "postulate divides_to_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nList_inv_rect_Type3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1314$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_733$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_732$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_735$ from elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $x_732$ and elements $_z1315$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_733$ and $x_732$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_73", "label": "list_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type3) -> _H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_733 : cic.Term univs.Type0 x1 -> x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732) -> cic.Term univs.Type3 (P x_732)) -> _z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732)) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P Hterm) .", "predict": "list_inv_rect_Type3 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> cic.Univ univs.Type3) -> _H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1)) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> _H2 : (x_733 : cic.Term univs.Type0 x1 -> x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1) -> _x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732) -> cic.Term univs.Type3 (P x_732)) -> _z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732)) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFalse_rect_Type1_body. For all functions $Q_$ from elements $_x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $x_71$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_71$.\nassistant\n", "label": "False_rect_Type1_body : Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type1) -> x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type1 (Q_ x_71) .", "predict": "False_rect_Type1_body : Q_ : (_x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Univ univs.Type1) -> x_71 : cic.Term cic.prop matita_basics_logic.False -> cic.Term univs.Type1 (Q_ x_71) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_min. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $i$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "lt_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) .", "predict": "lt_min : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.le b i) (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_893$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_893$.\nassistant\n", "label": "axiom ACop_rect_Type5_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type5 (Q_ x_893)", "predict": "axiom ACop_rect_Type5_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type5) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_893 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type5 (Q_ x_893)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_O_S. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "lt_O_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_nat.S n)) .", "predict": "lt_O_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_nat.S n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_to_not_le. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nassistant\n", "label": "postulate lt_to_not_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))", "predict": "postulate lt_to_not_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n m)) -> cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le m n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt4n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $le4m$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $Hind$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lea$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $Hinda$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied", "label": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m) -> Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a) -> Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat", "predict": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lt4n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) n) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> le4m : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) m) -> Hind : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S m) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> lea : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) a) -> Hinda : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.plus (matita_ar"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSplit_exists. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l1$ to $matita_basics_logic.ex$ applied to $matita_basics_lists_list.list$ applied to $A$ and the function that maps $l2$ to $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l1$ and $n$.\nassistant\n", "label": "postulate split_exists : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n))))", "predict": "postulate split_exists : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.ex (matita_basics_lists_list.list A) (\\ l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l (matita_basics_lists_list.append A l1 l2)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l1) n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_inv_rect_Type0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, for all functions $P$ from elements $_z936$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z937$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom unit_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z936 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) (_H1 : (_z937 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type0 (P matita_basics_types.it)) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom unit_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_basics_types.unit) (P : (_z936 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type0) (_H1 : (_z937 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type0 (P matita_basics_types.it)) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp0_body. Let $Q_$ be a function from elements $_x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_416$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, for all elements $x_413$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_413$.\nassistant\n", "label": "axiom nat_rect_CProp0_body (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_413)", "predict": "axiom nat_rect_CProp0_body (Q_ : (_x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : cic.Term cic.prop (Q_ x_414)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_414))) (x_413 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_413)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_S_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $m$.\nassistant\n", "label": "lt_S_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) .", "predict": "lt_S_to_lt : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_inv_rect_Type1. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z996$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $x_547$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inl$ applied to $x1$ and $x2$ and $x_547$, for all functions $_H2$ from elements $x_548$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z997$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sum$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.inr$ applied to $x1$ and $x2$ and $x_548$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sum_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom Sum_inv_rect_Type1 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) (P : (_z996 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ univs.Type1) (_H1 : (x_547 : cic.Term univs.Type0 x1) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_547))) -> cic.Term univs.Type1 (P (matita_basics_types.inl x1 x2 x_547))) (_H2 : (x_548 : cic.Term univs.Type0 x2) -> (_z997 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_548))) -> cic.Term univs.Type1 (P (matita_basics_types.inr x1 x2 x_548))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_CProp5. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_931$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_931$.\nassistant\n", "label": "range_rect_CProp5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) .", "predict": "range_rect_CProp5 : _A : cic.Univ univs.Type0 -> Q_ : (_x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ cic.prop) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_931 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term cic.prop (Q_ x_931) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type1_r. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $a$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $P$ from elements $x$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$ to elements of $cic.Univ$ of $univs.Type1$, for all elements $__$ of $cic.Term$ of $univs.Type1$ and $P$ applied to $a$ and $matita_basics_logic.refl$ applied to $A$ and $a$, for all elements $x$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $p$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x$ and $a$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $x$ and $p$.\nassistant\n", "label": "axiom eq_rect_Type1_r (A : cic.Univ univs.Type2) (a : cic.Term univs.Type2 A) (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type1) (__ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a))) (x : cic.Term univs.Type2 A) (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) : cic.Term univs.Type1 (P x p)", "predict": "axiom eq_rect_Type1_r (A : cic.Univ univs.Type2) (a : cic.Term univs.Type2 A) (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type1) (__ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a))) (x : cic.Term univs.Type2 A) (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) : cic.Term univs.Type1 (P x p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1569. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arith", "label": "Axiom let_clause_1569 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))),", "predict": "Axiom let_clause_1569 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_exp_to_divides. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.\nassistant\n", "label": "divides_exp_to_divides : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n) .", "predict": "divides_exp_to_divides : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.prime p) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_exp.exp n m)) -> cic.Term cic.prop (matita_arithmetics_primes.divides p n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBijn_fg. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom bijn_fg : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n), forall __1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n), cic.Term cic.prop (matita_arithmetics_permutation.bijn (fun p => f (g p)) n) .", "predict": "Axiom bijn_fg : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n), forall __1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n), cic.Term cic.prop (matita_arithmetics_permutation.bijn (fun p => f (g p)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMax. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom max (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom max (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z311$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_113$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z312$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_113$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_113$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Not_inv_rect_CProp1 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_113 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Not_inv_rect_CProp1 (x1 : cic.Univ cic.prop) (Hterm : cic.Term cic.prop (matita_basics_logic.Not x1)) (P : (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop) (_H1 : (x_113 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z312 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_113))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_hd. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "postulate option_hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option A)", "predict": "postulate option_hd : (A : cic.Univ univs.Type0) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 (matita_basics_types.option A)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_max_to_false. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$.\nassistant\n", "label": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)", "predict": "postulate lt_max_to_false : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_899$.\nassistant\n", "label": "ACop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type1) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type1 (Q_ x_899) .", "predict": "ACop_rect_Type1 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Univ univs.Type1) -> _H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> _comm : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> cic.Term univs.Type1 (Q_ x_899) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAbsurd. Let $A$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.False$.\nassistant\n", "label": "Axiom absurd : forall A : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, forall __1 : cic.Term cic.prop (matita_basics_logic.Not A), cic.Term cic.prop matita_basics_logic.False .", "predict": "Axiom absurd : forall A : cic.Univ cic.prop, forall __ : cic.Term cic.prop A, forall __1 : cic.Term cic.prop (matita_basics_logic.Not A), cic.Term cic.prop matita_basics_logic.False ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLstar_Conf3. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $A$ and $B$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $R$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.Conf3$ applied to $A$ and $B$ and $S$ and $matita_arithmetics_lstar.lstar$ applied to $A$ and $R$ and $l$.\nassistant\n", "label": "postulate lstar_Conf3 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B)) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l))", "predict": "postulate lstar_Conf3 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (S : cic.Term univs.Type0 (matita_basics_relations.relation2 A B)) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.Conf3 A B S R)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.Conf3 A B S (matita_arithmetics_lstar.lstar A R l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMonotonic_iter. For all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ and $b$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $g$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $b$.\nassistant\n", "label": "monotonic_iter : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le a b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b)) .", "predict": "monotonic_iter : g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le a b) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPlus_minus_associative. Let $x$ and $y$ and $z$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $z$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $y$ and $z$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$.\nassistant\n", "label": "postulate plus_minus_associative : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x y) z))", "predict": "postulate plus_minus_associative : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le z y)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x y) z))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_minus_gcd. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $b$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $m$ and $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.\nassistant\n", "label": "eq_minus_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) .", "predict": "eq_minus_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (a : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.ex matita_arithmetics_nat.nat (b : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd n m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times b m) (matita_arithmetics_nat.times a n)) (matita_arithmetics_gcd.gcd n m))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNot_rect_Type0_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_nmk$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_98$, for all elements $x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_97$.\nassistant\n", "label": "Not_rect_Type0_body : _A : cic.Univ cic.prop -> Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type0) -> _H_nmk : (x_98 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type0 (Q_ x_97) .", "predict": "Not_rect_Type0_body : _A : cic.Univ cic.prop -> Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Univ univs.Type0) -> _H_nmk : (x_98 : (__ : cic.Term cic.prop _A -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) -> cic.Term univs.Type0 (Q_ x_97) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAllr_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "postulate Allr_body : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop", "predict": "postulate Allr_body : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10336. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Hind$ from elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.pred$ applied to $p$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat", "label": "let_clause_10336 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics", "predict": "let_clause_10336 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt p m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) -> cic.Term cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_chebyshev_chebyshev_psi.Psi m) a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_maxr. Let $i$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$.\nassistant\n", "label": "le_maxr : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) -> cic.Term cic.prop (matita_arithmetics_nat.le m i) .", "predict": "le_maxr : i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i) -> cic.Term cic.prop (matita_arithmetics_nat.le m i) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInjective_plus_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "axiom injective_plus_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (λ m => matita_arithmetics_nat.plus n m))", "predict": "axiom injective_plus_r (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (λ m => matita_arithmetics_nat.plus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFold_filter. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $_a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $p$ applied to $i$ and the function that maps $i$ to $f$ applied to $i$ and $l$ and $matita_basics_lists_list.fold$ applied to $A$ and $B$ and $op$ and $nil$ and the function that maps $i$ to $matita_basics_bool.true$ and the function that maps $i$ to $f$ applied to $i$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.\nassistant\n", "label": "fold_filter : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> nil : cic.Term univs.Type0 B -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => p i) (i : cic.Term univs.Type0 A => f i) l) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.filter A p l))) .", "predict": "fold_filter : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> p : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> nil : cic.Term univs.Type0 B -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => p i) (i : cic.Term univs.Type0 A => f i) l) (matita_basics_lists_list.fold A B op nil (i : cic.Term univs.Type0 A => matita_basics_bool.true) (i : cic.Term univs.Type0 A => f i) (matita_basics_lists_list.filter A p l))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_rect_CProp2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.\nassistant\n", "label": "axiom range_rect_CProp2_body (_A : cic.Univ univs.Type0) (Q_ : (_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_935)", "predict": "axiom range_rect_CProp2_body (_A : cic.Univ univs.Type0) (Q_ : (_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) (x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) : cic.Term cic.prop (Q_ x_935)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_CProp1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_803$ of $c", "label": "Aop_rect_CProp1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_803) .", "predict": "Aop_rect_CProp1_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) -> cic.Term cic.prop (Q_ x_803) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBool_rect_Type5_body. For all functions $Q_$ from elements $_x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_true$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_332$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_332$.\nassistant\n", "label": "postulate bool_rect_Type5_body : (Q_ : (_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5) -> (_H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false)) -> (x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ x_332)", "predict": "postulate bool_rect_Type5_body : (Q_ : (_x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type5) -> (_H_true : cic.Term univs.Type5 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type5 (Q_ matita_basics_bool.false)) -> (x_332 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ x_332)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUpto_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom upto_body : forall A : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom upto_body : forall A : cic.Univ univs.Type0, forall _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A), cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_inv_rect_Type2. Let $x1$ and $x2$ and $x3$ and $x4$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1452$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $x_827$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_826$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1453$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_827$ and $x_826$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_827$ and $x_826$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "div_mod_spec_inv_rect_Type2 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1452 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type2) -> _H1 : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1453 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_827 x_826)) -> cic.Term univs.Type2 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_827 x_826))) -> cic.Term univs.Type2 (P Hterm) .", "predict": "div_mod_spec_inv_rect_Type2 : x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> P : (_z1452 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4) -> cic.Univ univs.Type2) -> _H1 : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2) -> x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4)) -> _z1453 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_827 x_826)) -> cic.Term univs.Type2 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_827 x_826))) -> cic.Term univs.Type2 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nIff_trans. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $B$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.iff$ applied to $B$ and $C$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.iff$ applied to $A$ and $C$.\nassistant\n", "label": "axiom iff_trans (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) : cic.Term cic.prop (matita_basics_logic.iff A C)", "predict": "axiom iff_trans (A B C : cic.Univ cic.prop) (__ : cic.Term cic.prop (matita_basics_logic.iff A B)) (__1 : cic.Term cic.prop (matita_basics_logic.iff B C)) : cic.Term cic.prop (matita_basics_logic.iff A C)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_fact_pi_p. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and the function that maps $i$ to the function that maps $i0$ to $matita_basics_bool.true$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to the function that maps $i0$ to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) .", "predict": "eq_fact_pi_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => (i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat => i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1410$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and", "label": "Axiom Aop_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Aop_inv_rect_CProp3 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2), forall P : ((_z1410 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2)) -> cic.Univ cic.prop), forall _H1 : ((op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1411 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_rect_Type5_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_919$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type5$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_919$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_919$.\nassistant\n", "label": "range_rect_Type5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type5) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type5 (Q_ x_919) .", "predict": "range_rect_Type5_body : _A : cic.Univ univs.Type0 -> Q_ : (_x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type5) -> _H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 _A) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> x_919 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Term univs.Type5 (Q_ x_919) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nGcd_aux_body. Let $_p$ and $_m$ and $_n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "gcd_aux_body : _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "gcd_aux_body : _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_divides_body. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "postulate list_divides_body : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate list_divides_body : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPair_elim. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $T$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $C$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $lft$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $rgt$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $p$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $lft$ and $rgt$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $lft$ and $rgt$ and $T$ applied to $lft$ and $rgt$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $p$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $_0$ to $C$ and the function that maps $lft$ and $rgt$ to $T$ applied to $lft$ and $rgt$ and $p$.\nassistant\n", "label": "postulate pair_elim : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) p))", "predict": "postulate pair_elim : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) p))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_869$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and", "label": "Aop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_869) .", "predict": "Aop_rect_Type2 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term univs.Type2 (Q_ x_869) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEx2_intro. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ and $Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $x$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $Q$ applied to $x$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $P$ and $Q$.\nassistant\n", "label": "Axiom ex2_intro : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 A, forall __ : cic.Term cic.prop (P x), forall __1 : cic.Term cic.prop (Q x), cic.Term cic.prop (matita_basics_logic.ex2 A P Q) .", "predict": "Axiom ex2_intro : forall A : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall x : cic.Term univs.Type0 A, forall __ : cic.Term cic.prop (P x), forall __1 : cic.Term cic.prop (Q x), cic.Term cic.prop (matita_basics_logic.ex2 A P Q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nInjective_compose. For all elements $A$ and $B$ and $C$ of $cic.Univ$ of $univs.Type0$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $C$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $B$ and $f$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.injective$ applied to $B$ and $C$ and $g$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $A$ and $C$ and the function that maps $x$ to $g$ applied to $f$ applied to $x$.\nassistant\n", "label": "Axiom injective_compose : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall g : ((__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall __ : cic.Term cic.prop (matita_basics_relations.injective A B f), forall __1 : cic.Term cic.prop (matita_basics_relations.injective B C g), cic.Term cic.prop (matita_basics_relations.injective A C (fun x => g (f x))) .", "predict": "Axiom injective_compose : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall C : cic.Univ univs.Type0, forall f : ((__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B), forall g : ((__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C), forall __ : cic.Term cic.prop (matita_basics_relations.injective A B f), forall __1 : cic.Term cic.prop (matita_basics_relations.injective B C g), cic.Term cic.prop (matita_basics_relations.injective A C (fun x => g (f x))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nIter. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "Axiom iter : forall H : cic.Univ univs.Type0, forall __ : ((__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 H, cic.Term univs.Type0 H .", "predict": "Axiom iter : forall H : cic.Univ univs.Type0, forall __ : ((__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H), forall __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __2 : cic.Term univs.Type0 H, cic.Term univs.Type0 H ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_O_to_eq_O. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom permut_O_to_eq_O (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O)", "predict": "axiom permut_O_to_eq_O (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h matita_arithmetics_nat.O)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h matita_arithmetics_nat.O) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_to_eq2. For all elements $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $r1$.\nassistant\n", "label": "Axiom div_mod_spec_to_eq2 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r), forall __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1) .", "predict": "Axiom div_mod_spec_to_eq2 : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r), forall __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNil_to_nil. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$.\nassistant\n", "label": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))", "predict": "postulate nil_to_nil : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 (matita_basics_lists_list.nil A)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l2 (matita_basics_lists_list.nil A)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSameF_p. Let $__$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $__1$ from elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__2$ to $A$.\nassistant\n", "label": "sameF_p : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat => A))) .", "predict": "sameF_p : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat => A))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nRange_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1668$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1669$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "range_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1668 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1669 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) .", "predict": "range_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> P : (_z1668 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1) -> cic.Univ cic.prop) -> _H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 x1) -> _upto : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> _z1669 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_15311. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $d$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $eqm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $n$ and $p$.\nassistant\n", "label": "Axiom let_clause_15311 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p))) .", "predict": "Axiom let_clause_15311 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides n m), forall d : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times n (matita_arithmetics_nat.S p))), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times n p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nProd_discr. Let $a1$ and $a2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ to $matita_basics_types.match_Prod$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $a1$ and $matita_basics_logic.R0$ applied to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and the function that maps $x0$ and $p", "label": "Axiom Prod_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((fun x0 => fun p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x0 => fun p0 => a2) t1 u0 e0) u1) (fun _e1 => P))) (fun _z45 => P))) y) x) .", "predict": "0Axiom Prod_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Univ univs.Type0, forall x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y), cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (fun e0 => cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((fun x0 => fun p0 => a2) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (fun x0 => fun p0 => a2) t1 u0 e0) u1) (fun _e1 => P))) (fun _z43 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_ord_sigma_p. Let $n$ and $m$ and $x$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $x$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $m$ and $n$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $n$ and $x$ and $matita_arithmetics_bigops.bigop$ applied to $m$ and the function that maps $i$ to $matita_arithmetics_primes.dividesb$ applied to $matita_arithmetics_exp.exp$ applied to $x$ and $matita_arithmetics_nat.S$ applied to $i$ and $n$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "eq_ord_sigma_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime x) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp x m) n) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord n x) (matita_arithmetics_bigops.bigop m (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S i)) n) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O))) .", "predict": "eq_ord_sigma_p : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.prime x) -> __2 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp x m) n) -> __3 : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord n x) (matita_arithmetics_bigops.bigop m (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp x (matita_arithmetics_nat.S i)) n) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_rect_Type2_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and", "label": "Dop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) .", "predict": "Dop_rect_Type2_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Univ univs.Type2) -> _H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) -> prod : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _null : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> _distr : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil) -> cic.Term univs.Type2 (Q_ x_951) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nP_ord_aux_false. For all elements $p$ and $n$ and $m$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $a$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $m$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "p_ord_aux_false : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) (matita_arithmetics_nat.S a)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n)) .", "predict": "p_ord_aux_false : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) (matita_arithmetics_nat.S a)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n m) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat matita_arithmetics_nat.O n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "DPair_rect_CProp4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) .", "predict": "DPair_rect_CProp4 : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ cic.prop) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSig_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1212$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1213$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nInjective_transpose. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.injective$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$.\nassistant\n", "label": "Axiom injective_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_permutation.transpose i j)) .", "predict": "Axiom injective_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.injective matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_permutation.transpose i j)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$.\nassistant\n", "label": "axiom le_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))", "predict": "axiom le_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nAppend_l1_injective_r. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l1$ and $l2$ and $l3$ and $l4$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $l3$ and $matita_basics_lists_list.length$ applied to $A$ and $l4$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l3$ and $matita_basics_lists_list.append$ applied to $A$ and $l2$ and $l4$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $l1$ and $l2$.\nassistant\n", "label": "axiom append_l1_injective_r (A : cic.Univ univs.Type0) (l1 l2 l3 l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)", "predict": "axiom append_l1_injective_r (A : cic.Univ univs.Type0) (l1 l2 l3 l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l1 l2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTimes_Sn_m. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$.\nassistant\n", "label": "postulate times_Sn_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus m (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) m))", "predict": "postulate times_Sn_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus m (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S n) m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_to_dividesb_true1. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_primes.dividesb$ applied to $n$ and $m$ and $matita_basics_bool.true$.\nassistant\n", "label": "divides_to_dividesb_true1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) .", "predict": "divides_to_dividesb_true1 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.true) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_divides. For all elements $_n$ and $_m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $_n$ and $_m$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_divides : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z) .", "predict": "filter_divides : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1572 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)) -> (auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1562. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of", "label": "axiom let_clause_1562 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita", "predict": "axiom let_clause_1562 (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ d => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nCongruent_to_divides. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $p$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom congruent_to_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m)) .", "predict": "Axiom congruent_to_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p), forall __1 : cic.Term cic.prop (matita_arithmetics_congruence.congruent n m p), cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.minus n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPermut_fg. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $m$ to $f$ applied to $g$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom permut_fg : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n), forall __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun m => f (g m)) n) .", "predict": "Axiom permut_fg : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n), forall __1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n), cic.Term cic.prop (matita_arithmetics_permutation.permut (fun m => f (g m)) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $m$.\nassistant\n", "label": "le_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div m n) m) .", "predict": "le_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div m n) m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_n_8_to_le_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_n_8_to_le_Psi_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "Axiom le_n_8_to_le_Psi_exp : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTimes_pi. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_nat.times$ applied to $f$ applied to $i$ and $g$ applied to $i$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $g$ applied to $i$.\nassistant\n", "label": "Axiom times_pi : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_nat.times (f i) (g i))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => f i)) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => g i)))) .", "predict": "Axiom times_pi : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_nat.times (f i) (g i))) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => f i)) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => g i)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_861$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_861$ of $cic", "label": "Aop_ind_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_861) .", "predict": "Aop_ind_body : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_861 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_861) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_sqrt_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $n$ and $n$.\nassistant\n", "label": "le_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_sqrt.sqrt n) n) .", "predict": "le_sqrt_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_sqrt.sqrt n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSubR. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ and $_S$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom subR : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _S : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom subR : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), forall _S : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nGcd_SO_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate gcd_SO_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate gcd_SO_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_SO_smallest_factor. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$ and $n$.\nassistant\n", "label": "Axiom le_SO_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) .", "predict": "Axiom le_SO_smallest_factor : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.smallest_factor n) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1422$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$", "label": "Aop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) .", "predict": "Aop_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> P : (_z1422 : cic.Term univs.Type0 (matita_basics_lists_list.Aop x1 x2) -> cic.Univ cic.prop) -> _H1 : (op : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _nill : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> _nilr : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> _assoc : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> _z1423 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop x1 x2)) Hterm (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc)) -> cic.Term cic.prop (P (matita_basics_lists_list.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqb_elim. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $__1$ from elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $matita_arithmetics_nat.eqb$ applied to $n$ and $m$.\nassistant\n", "label": "eqb_elim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) -> cic.Term cic.prop (P matita_basics_bool.true)) -> __1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m)) .", "predict": "eqb_elim : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> P : (__ : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> __ : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) -> cic.Term cic.prop (P matita_basics_bool.true)) -> __1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.eqb n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_B_Bk. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$.\nassistant\n", "label": "Axiom eq_B_Bk : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n)) .", "predict": "Axiom eq_B_Bk : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_bertrand.Bk n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSplit_rev_eq. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $l$ and $acc$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $acc$ and $l$ and $matita_basics_lists_list.append$ applied to $A$ and $matita_basics_lists_list.reverse$ applied to $A$ and $matita_basics_types.fst$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$ and $matita_basics_types.snd$ applied to $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.split_rev$ applied to $A$ and $l$ and $acc$ and $n$.\nassistant\n", "label": "split_rev_eq : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A acc) l) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n)))) .", "predict": "split_rev_eq : A : cic.Univ univs.Type0 -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> acc : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_basics_lists_list.length A l)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A acc) l) (matita_basics_lists_list.append A (matita_basics_lists_list.reverse A (matita_basics_types.fst (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n))) (matita_basics_types.snd (matita_basics_lists_list.list A) (matita_basics_lists_list.list A) (matita_basics_lists_list.split_rev A l acc n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$.\nassistant\n", "label": "mod_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m))) .", "predict": "mod_S : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m)) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S n) m) (matita_arithmetics_nat.S (matita_arithmetics_div_and_mod.mod n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProd_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1278$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1279$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1278 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1279 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nSig_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1224$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1225$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Sig_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) .", "predict": "Sig_inv_rect_CProp1 : x1 : cic.Univ univs.Type0 -> x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) -> Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> P : (_z1224 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2) -> cic.Univ cic.prop) -> _H1 : (pi1 : cic.Term univs.Type0 x1 -> _pi2 : cic.Term cic.prop (x2 pi1) -> _z1225 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2)) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMinus_n_O. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "minus_n_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus n matita_arithmetics_nat.O)) .", "predict": "minus_n_O : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.minus n matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTech. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and", "label": "tech : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "tech : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_to_nat_body. For all elements $_b$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "bool_to_nat_body : _b : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "bool_to_nat_body : _b : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_CProp1_body. For all functions $Q_$ from elements $_x_517$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_517$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_517$.\nassistant\n", "label": "postulate unit_rect_CProp1_body : (Q_ : (_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_517)", "predict": "postulate unit_rect_CProp1_body : (Q_ : (_x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) -> (x_517 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term cic.prop (Q_ x_517)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type3_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_867$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and", "label": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)", "predict": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_867 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_867)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_bertrand_to_le2. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_log.log$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\n", "label": "postulate not_bertrand_to_le2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))", "predict": "postulate not_bertrand_to_le2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_log.log (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_discr. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $P$ and the function that maps $_z19$ to $P$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $y$ and $matita_basics_bool.match_bool$ applied to $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $P$ and $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to", "label": "bool_discr : x : cic.Term univs.Type0 matita_basics_bool.bool -> y : cic.Term univs.Type0 matita_basics_bool.bool -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) x y) -> cic.Term univs.Type2 (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z19 : cic.Term univs.Type1 P => P))) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z20 : cic.Term univs.Type1 P => P))) y) x) .", "predict": "bool_discr : x : cic.Term univs.Type0 matita_basics_bool.bool -> y : cic.Term univs.Type0 matita_basics_bool.bool -> _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) x y) -> cic.Term univs.Type2 (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z19 : cic.Term univs.Type1 P => P))) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) y) (matita_basics_bool.match_bool (cic.succ univs.Type2) (__ : cic.Term univs.Type0 matita_basics_bool.bool => cic.univ univs.Type2) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => P)) (cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (P : cic.Univ univs.Type1 => cic.prod univs.Type1 univs.Type1 P (_z20 : cic.Term univs.Type1 P => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_rect_CProp3. Let $Q_$ be a function from elements $_x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_513$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_513$.\nassistant\n", "label": "Axiom unit_rect_CProp3 : forall Q_ : ((_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_513 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_513) .", "predict": "Axiom unit_rect_CProp3 : forall Q_ : ((_x_513 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop), forall _H_it : cic.Term cic.prop (Q_ matita_basics_types.it), forall x_513 : cic.Term univs.Type0 matita_basics_types.unit, cic.Term cic.prop (Q_ x_513) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nExp_sigma_l. For all elements $n$ and $a$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $a$ and $f$ applied to $i$ and $matita_arithmetics_exp.exp$ applied to $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $i$ to $f$ applied to $i$.\nassistant\n", "label": "Axiom exp_sigma_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp a (f i))) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => f i)))) .", "predict": "Axiom exp_sigma_l : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp a (f i))) (matita_arithmetics_exp.exp a (matita_arithmetics_bigops.bigop n (fun i => p i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (fun i => f i)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_to_eq2. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $a$ and $b$ and $q1$ and $r1$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $r$ and $r1$.\nassistant\n", "label": "div_mod_spec_to_eq2 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r) -> __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1) .", "predict": "div_mod_spec_to_eq2 : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r) -> __1 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) r r1) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_ind. For all functions $Q_$ from elements $_x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_66$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_66$.\nassistant\n", "label": "postulate False_ind : (Q_ : (_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_66)", "predict": "postulate False_ind : (Q_ : (_x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_66 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_66)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBijn. For all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom bijn (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop", "predict": "axiom bijn (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMinus_le. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $x$ and $y$ and $x$.\nassistant\n", "label": "postulate minus_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x)", "predict": "postulate minus_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus x y) x)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_inv_rect_Type2. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z605$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z606$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom bool_inv_rect_Type2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) (_H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type2 (P matita_basics_bool.true)) (_H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type2 (P matita_basics_bool.false)) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom bool_inv_rect_Type2 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z605 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) (_H1 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type2 (P matita_basics_bool.true)) (_H2 : (_z606 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type2 (P matita_basics_bool.false)) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_ind. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_le_n$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$, for all functions $_H_le_S$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $x_419$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ and elements $_x_421$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $m$ and $x_419$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $x_419$, for all elements $x_417$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $x_418$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $x_417$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_417$ and $x_418$.\nassistant\n", "label": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)", "predict": "postulate le_ind : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Univ cic.prop) -> (_H_le_n : cic.Term cic.prop (Q_ _n (matita_arithmetics_nat.le_n _n))) -> (_H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> (_x_421 : cic.Term cic.prop (Q_ m x_419)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m x_419))) -> (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop (matita_arithmetics_nat.le _n x_417)) -> cic.Term cic.prop (Q_ x_417 x_418)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMod_p_ord_inv. Let $p$ and $m$ and $x$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_ord.ord$ applied to $x$ and $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_ord.p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ and $matita_arithmetics_ord.ord$ applied to $x$ and $p$.\nassistant\n", "label": "mod_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) .", "predict": "mod_p_ord_inv : p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_ord.ord x p) m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_ord.p_ord_inv p m x) m) (matita_arithmetics_ord.ord x p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_eq_true_false. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_basics_bool.true$ and $matita_basics_bool.false$.\nassistant\n", "label": "Axiom not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) .", "predict": "Axiom not_eq_true_false : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_rect_CProp1. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_164$ and $x_163$, for all elements $x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_162$.\nassistant\n", "label": "postulate And_rect_CProp1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)", "predict": "postulate And_rect_CProp1 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBertrand. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.bertrand$ applied to $n$.\nassistant\n", "label": "Axiom bertrand : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) .", "predict": "Axiom bertrand : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.bertrand n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nRange_rect_CProp2. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_935$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_935$.\nassistant\n", "label": "Axiom range_rect_CProp2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_935) .", "predict": "Axiom range_rect_CProp2 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop), forall _H_mk_range : ((_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))), forall x_935 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A), cic.Term cic.prop (Q_ x_935) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLeb_body. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_bool.bool$.\nassistant\n", "label": "axiom leb_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool", "predict": "axiom leb_body (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMatch_div_mod_spec. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_div_mod_spec_intro$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $__$ and $__1$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "match_div_mod_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ return_sort) -> case_div_mod_spec_intro : (__ : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term return_sort (return_type (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r __ __1))) -> z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term return_sort (return_type z) .", "predict": "match_div_mod_spec : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ return_sort) -> case_div_mod_spec_intro : (__ : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term return_sort (return_type (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r __ __1))) -> z : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_Type4. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_nmk$ from functions $x_83$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_83$, for all elements $x_82$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_82$.\nassistant\n", "label": "Axiom Not_rect_Type4 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4), forall _H_nmk : ((x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))), forall x_82 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type4 (Q_ x_82) .", "predict": "Axiom Not_rect_Type4 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type4), forall _H_nmk : ((x_83 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))), forall x_82 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term univs.Type4 (Q_ x_82) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPlus_minus. For all elements $m$ and $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $n$ and $p$ and $m$.\nassistant\n", "label": "axiom plus_minus (m n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))", "predict": "axiom plus_minus (m n p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_k. For all elements $n$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom le_k : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_log.log p n)) .", "predict": "Axiom le_k : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_log.log p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBk_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.Bk$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $n$ and $p$.\nassistant\n", "label": "postulate Bk_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p))))", "predict": "postulate Bk_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.Bk n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_chebyshev_bertrand.k n p))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMin0. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate min0 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate min0 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPrimes_below_lop. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_chebyshev_bertrand256.primes_below$ applied to $matita_arithmetics_chebyshev_bertrand256.list_of_primes$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate primes_below_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate primes_below_lop : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below (matita_arithmetics_chebyshev_bertrand256.list_of_primes n) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_Prod : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z) .", "predict": "filter_Prod : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> return_sort : cic.Sort -> return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ return_sort) -> return : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z)) -> z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDistr_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $nil$ and $matita_arithmetics_bigops.sum$ applied to $A$ and $nil$ and $xxx$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $c$.\nassistant\n", "label": "axiom distr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a b c : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))", "predict": "axiom distr_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) (a b c : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_gcd_SO_to_not_divides. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom eq_gcd_SO_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) .", "predict": "Axiom eq_gcd_SO_to_not_divides : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPi1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $f$, $cic.Term$ holds for $univs.Type0$ and $A$.\nassistant\n", "label": "postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A", "predict": "postulate pi1 : (A : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (_xxx : cic.Term univs.Type0 (matita_basics_types.Sig A f)) -> cic.Term univs.Type0 A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOption_rect_Type0. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_None$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_611$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_611$, for all elements $x_610$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_610$.\nassistant\n", "label": "axiom option_rect_Type0 (_A : cic.Univ univs.Type0) (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type0 (Q_ x_610)", "predict": "axiom option_rect_Type0 (_A : cic.Univ univs.Type0) (Q_ : (_x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type0) (_H_None : cic.Term univs.Type0 (Q_ (matita_basics_types.None _A))) (_H_Some : (x_611 : cic.Term univs.Type0 _A) -> cic.Term univs.Type0 (Q_ (matita_basics_types.Some _A x_611))) (x_610 : cic.Term univs.Type0 (matita_basics_types.option _A)) : cic.Term univs.Type0 (Q_ x_610)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_949$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$", "label": "axiom Dop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type3 (Q_ x_949)", "predict": "axiom Dop_rect_Type3 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type3) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type3 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_949 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term univs.Type3 (Q_ x_949)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1704$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$", "label": "postulate Dop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate Dop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1704 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1705 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_Type4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z593$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z594$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_Type4 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> _H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm) .", "predict": "bool_inv_rect_Type4 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z593 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H1 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term univs.Type4 (P matita_basics_bool.true)) -> _H2 : (_z594 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term univs.Type4 (P matita_basics_bool.false)) -> cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBceq. Let $n$ and $k$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.bc$ applied to $n$ and $k$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_factorial.fact$ applied to $k$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $k$.\nassistant\n", "label": "postulate bceq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n k) (matita_arithmetics_div_and_mod.div (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))))", "predict": "postulate bceq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.bc n k) (matita_arithmetics_div_and_mod.div (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.times (matita_arithmetics_factorial.fact k) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.minus n k)))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDop_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1734$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__", "label": "Dop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) .", "predict": "Dop_inv_rect_CProp4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> P : (_z1734 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2) -> cic.Univ cic.prop) -> _H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> prod : (__ : cic.Term univs.Type0 x1 -> __1 : cic.Term univs.Type0 x1 -> cic.Term univs.Type0 x1) -> _null : (a : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> _distr : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> c : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> _z1735 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr)) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_plus. For all elements $n1$ and $n2$ and $m1$ and $m2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n1$ and $n2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m1$ and $m2$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $n1$ and $m1$ and $matita_arithmetics_nat.plus$ applied to $n2$ and $m2$.\nassistant\n", "label": "postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))", "predict": "postulate le_plus : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n1 n2)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m1 m2)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus n1 m1) (matita_arithmetics_nat.plus n2 m2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrime_to_nth_prime. For all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_primes.nth_prime$ applied to $i$ and $p$.\nassistant\n", "label": "Axiom prime_to_nth_prime : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime i) p)) .", "predict": "Axiom prime_to_nth_prime : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_primes.prime p), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun i => matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_primes.nth_prime i) p)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec. For all elements $_n$ and $_b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom min_spec : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _b : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1545. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $q1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q1$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $q2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $H2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "let_clause_1545 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n) -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1)) -> _clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m) -> q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) .", "predict": "let_clause_1545 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O) -> _clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n) -> q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1)) -> _clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m) -> q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_rect_Type3. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_644$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_644$.\nassistant\n", "label": "axiom DPair_rect_Type3 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)", "predict": "axiom DPair_rect_Type3 (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) (Q_ : (_x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type3) (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) (x_644 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) : cic.Term univs.Type3 (Q_ x_644)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProj1. Let $A$ and $B$ be elements of $cic.Univ$ of $cic.prop$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $A$.\nassistant\n", "label": "postulate proj1 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop A", "predict": "postulate proj1 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop A"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_SO_smallest_factor. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_primes.smallest_factor$ applied to $n$.\nassistant\n", "label": "axiom lt_SO_smallest_factor (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))", "predict": "axiom lt_SO_smallest_factor (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_Type2_body. Let $Q_$ be a function from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nassistant\n", "label": "postulate unit_rect_Type2_body : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)", "predict": "postulate unit_rect_Type2_body : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_transpose. Let $i$ and $j$ and $k$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $k$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $matita_arithmetics_permutation.transpose$ applied to $k$ and $j$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $n$.\nassistant\n", "label": "Axiom eq_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i)), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k)), forall __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n)))) .", "predict": "Axiom eq_transpose : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i)), forall __1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k)), forall __2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTrue_rect_CProp3. Let $Q_$ be a function from elements $_x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_58$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_58$.\nassistant\n", "label": "postulate True_rect_CProp3 : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)", "predict": "postulate True_rect_CProp3 : (Q_ : (_x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_58 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_58)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMax. Assume that $Sort$. Then if $Sort$, then $Sort$.\nassistant\n", "label": "Axiom max : Sort -> Sort -> Sort .", "predict": "Axiom max : Sort -> Sort -> Sort ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_22$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_23$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_22$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_22$ and $x_23$.\nassistant\n", "label": "Axiom eq_rect_CProp4 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_22 : cic.Term univs.Type2 A, forall x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22), cic.Term cic.prop (Q_ x_22 x_23) .", "predict": "Axiom eq_rect_CProp4 : forall A : cic.Univ univs.Type2, forall _x : cic.Term univs.Type2 A, forall Q_ : ((x_22 : cic.Term univs.Type2 A) -> (_x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22)) -> cic.Univ cic.prop), forall _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)), forall x_22 : cic.Term univs.Type2 A, forall x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22), cic.Term cic.prop (Q_ x_22 x_23) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_O_log. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_log.log$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom lt_O_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le p n), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n)) .", "predict": "Axiom lt_O_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le p n), cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_inv_rect_CProp3. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1740$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$", "label": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_rect_CProp2_body. Let $Q_$ be a function from elements $_x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_76$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_76$.\nassistant\n", "label": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)", "predict": "postulate False_rect_CProp2_body : (Q_ : (_x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_76 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_76)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_minus_S_pred. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "eq_minus_S_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))) .", "predict": "eq_minus_S_pred : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.minus n m))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nOption_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$, for all functions $P$ from elements $_z1068$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z1069$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.None$ applied to $x1$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.None$ applied to $x1$, for all functions $_H2$ from elements $x_611$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_z1069$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $x1$ and $Hterm$ and $matita_basics_types.Some$ applied to $x1$ and $x_611$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.Some$ applied to $x1$ and $x_611$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDPair_rect_Type4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.\nassistant\n", "label": "postulate DPair_rect_Type4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)", "predict": "postulate DPair_rect_Type4 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type4) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type4 (Q_ x_640)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNot_rect_Type0_body. Let $_A$ be an element of $cic.Univ$ of $cic.prop$. Then for all functions $Q_$ from elements $_x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_nmk$ from functions $x_98$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_98$, for all elements $x_97$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_97$.\nassistant\n", "label": "postulate Not_rect_Type0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) -> (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type0 (Q_ x_97)", "predict": "postulate Not_rect_Type0_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ univs.Type0) -> (_H_nmk : (x_98 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) -> (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term univs.Type0 (Q_ x_97)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLog_exp. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $n$ and $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $matita_arithmetics_log.log$ applied to $p$ and $m$.\nassistant\n", "label": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))", "predict": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMinus_pred_pred. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.pred$ applied to $n$ and $matita_arithmetics_nat.pred$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))", "predict": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_sigma_p_div. Let $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $m$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $matita_arithmetics_primes.dividesb$ applied to $q$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.plus$ and the function that maps $m$ to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$.\nassistant\n", "label": "eq_sigma_p_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n q)) .", "predict": "eq_sigma_p_div : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n q)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNill_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ and $a$.\nassistant\n", "label": "axiom nill_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)", "predict": "axiom nill_body (A : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 A) (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) (a : cic.Term univs.Type0 A) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx nil a) a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_rect_Type2. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_", "label": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)", "predict": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_B_Psi. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "le_B_Psi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) .", "predict": "le_B_Psi : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBi_symmetric. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.bi_relation$ applied to $A$ and $B$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "bi_symmetric : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Univ cic.prop .", "predict": "bi_symmetric : A : cic.Univ univs.Type0 -> B : cic.Univ univs.Type0 -> _R : cic.Term univs.Type0 (matita_basics_relations.bi_relation A B) -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_divides_true. For all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_chebyshev_bertrand256.list_divides$ applied to $l$ and $n$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $p$ to $matita_basics_logic.And$ applied to $matita_basics_lists_list.mem$ applied to $matita_arithmetics_nat.nat$ and $p$ and $l$ and $matita_arithmetics_primes.divides$ applied to $p$ and $n$.\nassistant\n", "label": "Axiom list_divides_true : forall l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun p => matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n))) .", "predict": "Axiom list_divides_true : forall l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.list_divides l n) matita_basics_bool.true), cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (fun p => matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l) (matita_arithmetics_primes.divides p n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTo_max. Let $i$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $i$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.max$ applied to $n$ and $m$ and $i$.\nassistant\n", "label": "postulate to_max : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)", "predict": "postulate to_max : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le m i)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.max n m) i)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInr. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.\nassistant\n", "label": "axiom inr (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_basics_types.Sum A B)", "predict": "axiom inr (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 B) : cic.Term univs.Type0 (matita_basics_types.Sum A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDivides_to_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.\nassistant\n", "label": "axiom divides_to_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)", "predict": "axiom divides_to_div (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_max_f_max_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $g$ applied to $i$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $matita_arithmetics_minimization.max$ applied to $n$ and $g$.\nassistant\n", "label": "le_max_f_max_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) .", "predict": "le_max_f_max_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt i n) -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) (matita_arithmetics_minimization.max n g)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "And_inv_rect_CProp3 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_156 : cic.Term cic.prop x1 -> x_155 : cic.Term cic.prop x2 -> _z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm) .", "predict": "And_inv_rect_CProp3 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_156 : cic.Term cic.prop x1 -> x_155 : cic.Term cic.prop x2 -> _z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExp_exp_times. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $q$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $p$ and $q$.\nassistant\n", "label": "postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))", "predict": "postulate exp_exp_times : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_exp.exp n p) q) (matita_arithmetics_exp.exp n (matita_arithmetics_nat.times p q)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nVoid_rect_Type0. Let $Q_$ be a function from elements $_x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $x_488$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_488$.\nassistant\n", "label": "void_rect_Type0 : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) .", "predict": "void_rect_Type0 : Q_ : (_x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Univ univs.Type0) -> x_488 : cic.Term univs.Type0 matita_basics_types.void -> cic.Term univs.Type0 (Q_ x_488) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFound_min_spec. Let $n$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.true$, for all functions $__3$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $m$.\nassistant\n", "label": "found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) .", "predict": "found_min_spec : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b m) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus n b)) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.true) -> __3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __3 : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMin_spec_inv_ind. For all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univ", "label": "Axiom min_spec_inv_ind : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4), forall P : ((_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic", "predict": "Axiom min_spec_inv_ind : forall x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x3 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4), forall P : ((_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop), forall _H1 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_minimization.min x1 x2 x3 x4))), forall _H2 : ((m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1081 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> cic.Term cic.prop (P m)), cic.Term cic.prop (P (matita_arithmetics_minimization.min"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_minl. For all elements $i$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $matita_arithmetics_nat.min$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$.\nassistant\n", "label": "axiom le_minl (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) : cic.Term cic.prop (matita_arithmetics_nat.le i n)", "predict": "axiom le_minl (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m))) : cic.Term cic.prop (matita_arithmetics_nat.le i n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15622. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $", "label": "let_clause_15622 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_ar", "predict": "let_clause_15622 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _dclearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_elim_left. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ to elements of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $S$, for all functions $__1$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $S$ and elements $tl$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $P$ applied to $tl$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.append$ applied to $S$ and $tl$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $S$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$.\nassistant\n", "label": "Axiom list_elim_left : forall S : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)), forall __1 : ((a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), cic.Term cic.prop (P l) .", "predict": "Axiom list_elim_left : forall S : cic.Univ univs.Type0, forall P : ((__ : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> cic.Univ cic.prop), forall __ : cic.Term cic.prop (P (matita_basics_lists_list.nil S)), forall __1 : ((a : cic.Term univs.Type0 S) -> (tl : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__1 : cic.Term cic.prop (P tl)) -> cic.Term cic.prop (P (matita_basics_lists_list.append S tl (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))))), forall l : cic.Term univs.Type0 (matita_basics_lists_list.list S), cic.Term cic.prop (P l) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMatch_Not. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_nmk$ from functions $__$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $__$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Not : (_A : cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ return_sort) -> (case_nmk : (__ : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) -> (z : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBc. For all elements $_n$ and $_k$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom bc : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _k : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom bc : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _k : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_10331. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "let_clause_10331 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDop_rect_CProp1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_965$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and", "label": "axiom Dop_rect_CProp1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_965)", "predict": "axiom Dop_rect_CProp1 (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) (x_965 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) : cic.Term cic.prop (Q_ x_965)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSum_rect_CProp4_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_557$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_557$, for all functions $_H_inr$ from elements $x_558$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_558$, for all elements $x_556$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_556$.\nassistant\n", "label": "axiom Sum_rect_CProp4_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_556)", "predict": "axiom Sum_rect_CProp4_body (_A _B : cic.Univ univs.Type0) (Q_ : (_x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) (_H_inl : (x_557 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_557))) (_H_inr : (x_558 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_558))) (x_556 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) : cic.Term cic.prop (Q_ x_556)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $cic.prop$. Then for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$, for all functions $P$ from elements $_z293$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $x_101$ from elements $__$ of $cic.Term$ of $cic.prop$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ and elements $_z294$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.Not$ applied to $x1$ and $Hterm$ and $matita_basics_logic.nmk$ applied to $x1$ and $x_101$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.nmk$ applied to $x1$ and $x_101$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom Not_inv_rect_CProp4 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z293 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_101 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z294 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_101))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_101))), cic.Term cic.prop (P Hterm) .", "predict": "Axiom Not_inv_rect_CProp4 : forall x1 : cic.Univ cic.prop, forall Hterm : cic.Term cic.prop (matita_basics_logic.Not x1), forall P : ((_z293 : cic.Term cic.prop (matita_basics_logic.Not x1)) -> cic.Univ cic.prop), forall _H1 : ((x_101 : (__ : cic.Term cic.prop x1) -> cic.Term cic.prop matita_basics_logic.False) -> (_z294 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1)) Hterm (matita_basics_logic.nmk x1 x_101))) -> cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_101))), cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nOr. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Then $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom Or (_A _B : cic.Univ cic.prop) : cic.Univ cic.prop", "predict": "axiom Or (_A _B : cic.Univ cic.prop) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAllr_fwd_cons. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l$.\nassistant\n", "label": "postulate Allr_fwd_cons : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.cons A a l))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l)", "predict": "postulate Allr_fwd_cons : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (a : cic.Term univs.Type0 A) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.cons A a l))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nR0. For all elements $T$ of $cic.Univ$ of $univs.Type0$, for all elements $_t$ of $cic.Term$ of $univs.Type0$ and $T$, $cic.Term$ holds for $univs.Type0$ and $T$.\nassistant\n", "label": "R0 : T : cic.Univ univs.Type0 -> _t : cic.Term univs.Type0 T -> cic.Term univs.Type0 T .", "predict": "R0 : T : cic.Univ univs.Type0 -> _t : cic.Term univs.Type0 T -> cic.Term univs.Type0 T ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_B_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "le_B_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) .", "predict": "le_B_exp : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFact_pi_p3. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_ar", "label": "Axiom fact_pi_p3 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (mat", "predict": "Axiom fact_pi_p3 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_found_min_spec. For all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$.\nassistant\n", "label": "axiom not_found_min_spec (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b))", "predict": "axiom not_found_min_spec (n b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.false)) : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nNot_rect_CProp5. For all elements $_A$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_nmk$ from functions $x_104$ from elements $__$ of $cic.Term$ of $cic.prop$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.nmk$ applied to $_A$ and $x_104$, for all elements $x_103$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_103$.\nassistant\n", "label": "Axiom Not_rect_CProp5 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))), forall x_103 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_103) .", "predict": "Axiom Not_rect_CProp5 : forall _A : cic.Univ cic.prop, forall Q_ : ((_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop), forall _H_nmk : ((x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))), forall x_103 : cic.Term cic.prop (matita_basics_logic.Not _A), cic.Term cic.prop (Q_ x_103) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSome. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "Axiom Some : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 A, cic.Term univs.Type0 (matita_basics_types.option A) .", "predict": "Axiom Some : forall A : cic.Univ univs.Type0, forall __ : cic.Term univs.Type0 A, cic.Term univs.Type0 (matita_basics_types.option A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMinus_plus_plus_l. Let $x$ and $y$ and $h$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $h$ and $matita_arithmetics_nat.plus$ applied to $y$ and $h$ and $matita_arithmetics_nat.minus$ applied to $x$ and $y$.\nassistant\n", "label": "Axiom minus_plus_plus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y)) .", "predict": "Axiom minus_plus_plus_l : forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall y : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall h : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus x h) (matita_arithmetics_nat.plus y h)) (matita_arithmetics_nat.minus x y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNone. For all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $A$.\nassistant\n", "label": "None : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_types.option A) .", "predict": "None : A : cic.Univ univs.Type0 -> cic.Term univs.Type0 (matita_basics_types.option A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMod_n_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "axiom mod_n_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)", "predict": "axiom mod_n_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_plus_comm_23. For all elements $x$ and $y$ and $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $z$ and $y$.\nassistant\n", "label": "plus_plus_comm_23 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y)) .", "predict": "plus_plus_comm_23 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x y) z) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus x z) y)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.\nassistant\n", "label": "Axiom DPair_ind_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_638) .", "predict": "Axiom DPair_ind_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_638) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDivides_to_div. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $n$ and $m$.\nassistant\n", "label": "postulate divides_to_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)", "predict": "postulate divides_to_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div m n) n) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_to_minus. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $matita_arithmetics_nat.plus$ applied to $p$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nassistant\n", "label": "Axiom le_plus_to_minus : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p) .", "predict": "Axiom le_plus_to_minus : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m)), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_rect_CProp0. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_714$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_714$.\nassistant\n", "label": "axiom Prod_rect_CProp0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_714)", "predict": "axiom Prod_rect_CProp0 (_A _B : cic.Univ univs.Type0) (Q_ : (_x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) (x_714 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term cic.prop (Q_ x_714)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nK1. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $p$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$ and $mat", "label": "postulate k1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p) matita_arithmetics_nat.O)", "predict": "postulate k1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nList_inv_rect_CProp0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$, for all functions $P$ from elements $_z1362$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.nil$ applied to $x1$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $x1$, for all functions $_H2$ from elements $x_778$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $x_777$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $x1$ and functions $_x_780$ from elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $x_777$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_777$ and elements $_z1363$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $x1$ and $Hterm$ and $matita_basics_lists_list.cons$ applied to $x1$ and $x_778$ and $x_777$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.cons$ applied to $x1$ and $x_778$ and $x_777$, $cic.Term$ holds for $c", "label": "axiom list_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1362 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_778 : cic.Term univs.Type0 x1) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_780 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_777)) -> cic.Term cic.prop (P x_777)) -> (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_778 x_777))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_778 x_777))) : cic.Term cic.prop (P Hterm)", "predict": "axiom list_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) (P : (_z1362 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) (_H1 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) (_H2 : (x_778 : cic.Term univs.Type0 x1) -> (x_777 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_780 : (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_777)) -> cic.Term cic.prop (P x_777)) -> (_z1363 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_778 x_777))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_778 x_777))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_inv_rect_CProp3. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1608$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1609$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate ACop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1608 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1609 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nK. For all elements $_n$ and $_p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "k : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "k : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "postulate decidable_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.le n m))", "predict": "postulate decidable_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.le n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDop_inv_rect_CProp2. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1746$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$", "label": "postulate Dop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1746 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1747 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_rect_CProp2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1746 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1747 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_B1_theta. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_chebyshev_bertrand.not_bertrand$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_bertrand.B1$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_B1_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B1 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) .", "predict": "Axiom le_B1_theta : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))))))))))))) n), forall __1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand.not_bertrand n), cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_bertrand.B1 (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_Aop. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $", "label": "axiom match_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom match_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ return_sort) (case_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLt_times_n. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "lt_times_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.times n m)) .", "predict": "lt_times_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.times n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_inv_plus_l. Let $x$ and $y$ and $z$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $z$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $x$ and $matita_arithmetics_nat.minus$ applied to $z$ and $y$ and $matita_arithmetics_nat.le$ applied to $y$ and $z$.\nassistant\n", "label": "le_inv_plus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) .", "predict": "le_inv_plus_l : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> z : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nBigop_prod. For all elements $k1$ and $k2$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p1$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $x$ to $p1$ applied to $x$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $x$ to $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $x$ and $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $x$ and $i$", "label": "postulate bigop_prod : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 x) B nil (matita_arithmetics_bigops.op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x i))) (matita_ar", "predict": "postulate bigop_prod : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k1 (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 x) B nil (matita_arithmetics_bigops.op B nil op) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 x i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f x i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.times k1 k2) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (p1 (matita_arithmetics_div_and_mod.div i k2)) (p2 (matita_arithmetics_div_and_mod.div i k2) (matita_arithmetics_div_and_mod.mod i k2)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nReverse_single. For all elements $S$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $S$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $S$ and $matita_basics_lists_list.reverse$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$ and $matita_basics_lists_list.cons$ applied to $S$ and $a$ and $matita_basics_lists_list.nil$ applied to $S$.\nassistant\n", "label": "Axiom reverse_single : forall S : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 S, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) .", "predict": "Axiom reverse_single : forall S : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 S, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list S)) (matita_basics_lists_list.reverse S (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) (matita_basics_lists_list.cons S a (matita_basics_lists_list.nil S))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1704. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $a$ and $x1029$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1029$ and $matita_arithmetics_bigops.aop__o__op$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_sigma_pi.plusAC$ and $x1029$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom let_clause_1704 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) .", "predict": "Axiom let_clause_1704 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x1029 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1029 (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x1029 matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_lt_times_r. For all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $t$ to $matita_arithmetics_nat.times$ applied to $c$ and $t$.\nassistant\n", "label": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) .", "predict": "Axiom monotonic_lt_times_r : forall c : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c), cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun t => matita_arithmetics_nat.times c t)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMin. Let $__$ and $__1$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom min (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom min (__ __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDiv_mod_spec_rect_Type4_body. For all elements $_n$ and $_m$ and $_q$ and $_r$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $Q_$ from elements $_x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_div_mod_spec_intro$ from elements $x_815$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_814$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$, for all elements $x_813$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_813$.\nassistant\n", "label": "postulate div_mod_spec_rect_Type4_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4) -> (_H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> (x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type4 (Q_ x_813)", "predict": "postulate div_mod_spec_rect_Type4_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type4) -> (_H_div_mod_spec_intro : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_815 x_814))) -> (x_813 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type4 (Q_ x_813)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nVoid_rect_CProp0. For all functions $Q_$ from elements $_x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_494$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_494$.\nassistant\n", "label": "Axiom void_rect_CProp0 : forall Q_ : ((_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_494 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_494) .", "predict": "Axiom void_rect_CProp0 : forall Q_ : ((_x_494 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop), forall x_494 : cic.Term univs.Type0 matita_basics_types.void, cic.Term cic.prop (Q_ x_494) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nProd_inv_rect_CProp2. Let $x1$ and $x2$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1284$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1285$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Prod_inv_rect_CProp2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Prod_inv_rect_CProp2 (x1 x2 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) (P : (_z1284 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1285 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInv. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, for all elements $_a$ and $_b$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "axiom inv (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_a _b : cic.Term univs.Type0 A) : cic.Univ cic.prop", "predict": "axiom inv (A : cic.Univ univs.Type0) (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) (_a _b : cic.Term univs.Type0 A) : cic.Univ cic.prop"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPosition_of_aux_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_found$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $_acc$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.option$ applied to $matita_arithmetics_nat.nat$.\nassistant\n", "label": "position_of_aux_body : A : cic.Univ univs.Type0 -> _found : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _acc : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) .", "predict": "position_of_aux_body : A : cic.Univ univs.Type0 -> _found : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_basics_bool.bool) -> _l : cic.Term univs.Type0 (matita_basics_lists_list.list A) -> _acc : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_types.option matita_arithmetics_nat.nat) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFalse_rect_Type0_body. For all functions $Q_$ from elements $_x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $x_72$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_72$.\nassistant\n", "label": "Axiom False_rect_Type0_body : forall Q_ : ((_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0), forall x_72 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type0 (Q_ x_72) .", "predict": "Axiom False_rect_Type0_body : forall Q_ : ((_x_72 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type0), forall x_72 : cic.Term cic.prop matita_basics_logic.False, cic.Term univs.Type0 (Q_ x_72) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBool_rect_CProp3_body. For all functions $Q_$ from elements $_x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_true$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_353$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_353$.\nassistant\n", "label": "Axiom bool_rect_CProp3_body : forall Q_ : ((_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_353 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_353) .", "predict": "Axiom bool_rect_CProp3_body : forall Q_ : ((_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop), forall _H_true : cic.Term cic.prop (Q_ matita_basics_bool.true), forall _H_false : cic.Term cic.prop (Q_ matita_basics_bool.false), forall x_353 : cic.Term univs.Type0 matita_basics_bool.bool, cic.Term cic.prop (Q_ x_353) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_inv_rect_CProp4. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z689$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_394$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_396$ from elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_394$ and elements $_z690$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_394$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_394$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom nat_inv_rect_CProp4 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z689 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (_H2 : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_394)) -> cic.Term cic.prop (P x_394)) -> (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_394))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_394))) : cic.Term cic.prop (P Hterm)", "predict": "axiom nat_inv_rect_CProp4 (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : (_z689 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H1 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) (_H2 : (x_394 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_396 : (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_394)) -> cic.Term cic.prop (P x_394)) -> (_z690 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_394))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_394))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDistributive_times_plus_r. Let $a$ and $b$ and $c$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.plus$ applied to $b$ and $c$ and $a$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $b$ and $a$ and $matita_arithmetics_nat.times$ applied to $c$ and $a$.\nassistant\n", "label": "distributive_times_plus_r : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.plus b c) a) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times b a) (matita_arithmetics_nat.times c a))) .", "predict": "distributive_times_plus_r : a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.plus b c) a) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times b a) (matita_arithmetics_nat.times c a))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nProj2. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $A$ and $B$, $cic.Term$ holds for $cic.prop$ and $B$.\nassistant\n", "label": "postulate proj2 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop B", "predict": "postulate proj2 : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.And A B)) -> cic.Term cic.prop B"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_transpose. For all elements $i$ and $j$ and $k$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $i$ and $k$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $j$ and $k$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $matita_arithmetics_permutation.transpose$ applied to $k$ and $j$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $k$ and $n$.\nassistant\n", "label": "postulate eq_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))", "predict": "postulate eq_transpose : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j i))) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) i k))) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) j k))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose i k (matita_arithmetics_permutation.transpose k j (matita_arithmetics_permutation.transpose i k n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1033. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1p$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $m$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_1033 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall lt1p : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nOption_rect_Type3. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type3$, for all elements $_H_None$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.None$ applied to $_A$, for all functions $_H_Some$ from elements $x_599$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.Some$ applied to $_A$ and $x_599$, for all elements $x_598$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $_A$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_598$.\nassistant\n", "label": "Axiom option_rect_Type3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3), forall _H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))), forall x_598 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type3 (Q_ x_598) .", "predict": "Axiom option_rect_Type3 : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_598 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type3), forall _H_None : cic.Term univs.Type3 (Q_ (matita_basics_types.None _A)), forall _H_Some : ((x_599 : cic.Term univs.Type0 _A) -> cic.Term univs.Type3 (Q_ (matita_basics_types.Some _A x_599))), forall x_598 : cic.Term univs.Type0 (matita_basics_types.option _A), cic.Term univs.Type3 (Q_ x_598) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDiv_mod_spec_inv_rect_CProp3. For all elements $x1$ and $x2$ and $x3$ and $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1476$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x4$ and $x2$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x1$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x3$ and $x2$ and $x4$ and elements $_z1477$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $Hterm$ and $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $x1$ and $x2$ and $x3$ and $x4$ and $x_847$ and $x_846$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom div_mod_spec_inv_rect_CProp3 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) : cic.Term cic.prop (P Hterm)", "predict": "axiom div_mod_spec_inv_rect_CProp3 (x1 x2 x3 x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) (P : (_z1476 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ cic.prop) (_H1 : (x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1477 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) -> cic.Term cic.prop (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_847 x_846))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDiv_mod_spec_rect_CProp1. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_855$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_854$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_855$ and $x_854$, for all elements $x_853$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_853$.\nassistant\n", "label": "div_mod_spec_rect_CProp1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_853) .", "predict": "div_mod_spec_rect_CProp1 : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _r : cic.Term univs.Type0 matita_arithmetics_nat.nat -> Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Univ cic.prop) -> _H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m) -> x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r)) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r) -> cic.Term cic.prop (Q_ x_853) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nB1. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom B1 (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom B1 (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDPair_rect_Type4_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_640$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_640$.\nassistant\n", "label": "DPair_rect_Type4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type4) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type4 (Q_ x_640) .", "predict": "DPair_rect_Type4_body : A : cic.Univ univs.Type0 -> _f : (__ : cic.Term univs.Type0 A -> cic.Univ univs.Type0) -> Q_ : (_x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Univ univs.Type4) -> _H_mk_DPair : (dpi1 : cic.Term univs.Type0 A -> _dpi2 : cic.Term univs.Type0 (_f dpi1) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> x_640 : cic.Term univs.Type0 (matita_basics_types.DPair A _f) -> cic.Term univs.Type4 (Q_ x_640) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLePsi_r2. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "Axiom lePsi_r2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) .", "predict": "Axiom lePsi_r2 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_nat.times (matita_arithmetics_chebyshev_chebyshev_psi.Psi n) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPrimes_all. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "primes_all : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "primes_all : _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat) -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nPlus_le_0. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $x$ and $y$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x$ and $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $y$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "plus_le_0 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) .", "predict": "plus_le_0 : x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) matita_arithmetics_nat.O) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x matita_arithmetics_nat.O) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) y matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDop_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $", "label": "Axiom Dop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type1 (P Hterm) .", "predict": "Axiom Dop_inv_rect_Type1 : forall x1 : cic.Univ univs.Type0, forall x2 : cic.Term univs.Type0 x1, forall Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2), forall P : ((_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1), forall _H1 : ((sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))), cic.Term univs.Type1 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_times_n_to_lt_r. Let $n$ and $p$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.times$ applied to $n$ and $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $q$.\nassistant\n", "label": "Axiom lt_times_n_to_lt_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q)), cic.Term cic.prop (matita_arithmetics_nat.lt p q) .", "predict": "Axiom lt_times_n_to_lt_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n p) (matita_arithmetics_nat.times n q)), cic.Term cic.prop (matita_arithmetics_nat.lt p q) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_rect_Type4. For all functions $Q_$ from elements $_x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_true$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.true$, for all elements $_H_false$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_329$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_329$.\nassistant\n", "label": "bool_rect_Type4 : Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false) -> x_329 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type4 (Q_ x_329) .", "predict": "bool_rect_Type4 : Q_ : (_x_329 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ univs.Type4) -> _H_true : cic.Term univs.Type4 (Q_ matita_basics_bool.true) -> _H_false : cic.Term univs.Type4 (Q_ matita_basics_bool.false) -> x_329 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Term univs.Type4 (Q_ x_329) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_797$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all", "label": "Axiom Aop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_797) .", "predict": "Axiom Aop_rect_CProp5 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_797 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_797) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCr_pair1. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chinese_reminder.cr_pair$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate cr_pair1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.O matita_arithmetics_nat.O) matita_arithmetics_nat.O)", "predict": "postulate cr_pair1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chinese_reminder.cr_pair (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.O matita_arithmetics_nat.O) matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nBigop_sum. Let $k1$ and $k2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and $matita_arithmetics_bigops.bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to", "label": "Axiom bigop_sum : forall k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall p2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (fun i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i)) (matita_arithmetics_bigops.bigop k2 (fun i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (fun i => matita_basics_bool.match_bool univs.Type0 (fun __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (fun i => matita_basics_bool.match_bool univs.Type0 (fun __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_arithmetics_nat.leb k2 i)))) .", "predict": "Axiom bigop_sum : forall k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall p1 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall p2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall B : cic.Univ univs.Type0, forall nil : cic.Term univs.Type0 B, forall op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil), forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), forall g : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (fun i => p1 i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => f i)) (matita_arithmetics_bigops.bigop k2 (fun i => p2 i) B nil (matita_arithmetics_bigops.op B nil op) (fun i => g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (fun i => matita_basics_bool.match_bool univs.Type0 (fun __ => matita_basics_bool.bool) (p1 (matita_arithmetics_nat.minus i k2)) (p2 i) (matita_arithmetics_nat.leb k2 i)) B nil (matita_arithmetics_bigops.op B nil op) (fun i => matita_basics_bool.match_bool univs.Type0 (fun __ => B) (f (matita_arithmetics_nat.minus i k2)) (g i) (matita_basics_bool.andb (p1 (matita_arithmetics_nat.min"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDPair_rect_CProp4. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_652$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_652$.\nassistant\n", "label": "Axiom DPair_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) .", "predict": "Axiom DPair_rect_CProp4 : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0), forall Q_ : ((_x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop), forall _H_mk_DPair : ((dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))), forall x_652 : cic.Term univs.Type0 (matita_basics_types.DPair A _f), cic.Term cic.prop (Q_ x_652) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nList_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.\nassistant\n", "label": "postulate list_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)", "predict": "postulate list_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2) -> (_H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))) -> (x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term univs.Type2 (Q_ x_736)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nM. If $Nat$, then if $Nat$, then $Nat$.\nassistant\n", "label": "Axiom m : nat -> nat -> nat .", "predict": "Axiom m : nat -> nat -> nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIter. For all elements $H$ of $cic.Univ$ of $univs.Type0$, for all functions $__$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $H$ to elements of $cic.Term$ of $univs.Type0$ and $H$, for all elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__2$ of $cic.Term$ of $univs.Type0$ and $H$, $cic.Term$ holds for $univs.Type0$ and $H$.\nassistant\n", "label": "postulate iter : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate iter : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMake_list. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$.\nassistant\n", "label": "make_list : A : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list A) .", "predict": "make_list : A : cic.Univ univs.Type0 -> _a : cic.Term univs.Type0 A -> _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_basics_lists_list.list A) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPair_destruct_1. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $A$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a$ and $b$ and $c$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $matita_basics_types.fst$ applied to $A$ and $B$ and $c$.\nassistant\n", "label": "Axiom pair_destruct_1 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 B, forall c : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c)) .", "predict": "Axiom pair_destruct_1 : forall A : cic.Univ univs.Type0, forall B : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall b : cic.Term univs.Type0 B, forall c : cic.Term univs.Type0 (matita_basics_types.Prod A B), forall __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a b) c), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a (matita_basics_types.fst A B c)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nNat_rect_CProp1_body. For all functions $Q_$ from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "postulate nat_rect_CProp1_body : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)", "predict": "postulate nat_rect_CProp1_body : (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) -> (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_409)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPair_eq1. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $a1$ and $a2$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $b1$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $A$ and $B$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a1$ and $b1$ and $matita_basics_types.mk_Prod$ applied to $A$ and $B$ and $a2$ and $b2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a1$ and $a2$.\nassistant\n", "label": "postulate pair_eq1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2)", "predict": "postulate pair_eq1 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 A) -> (a2 : cic.Term univs.Type0 A) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) (matita_basics_types.mk_Prod A B a1 b1) (matita_basics_types.mk_Prod A B a2 b2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a1 a2)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLt_sigma_p. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $g1$ and $g2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p2$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p1$ applied to $i$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $g1$ applied to $i$ and $g2$ applied to $i$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_ar", "label": "axiom lt_sigma_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) (__2 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And", "predict": "axiom lt_sigma_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (g1 g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) (__2 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ i => matita_basics_logic.And (matita_basics_logic.Not (p1 i)) (p2 i)))) : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_bigops.bigop n (λ i => p1 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g1 i)) (matita_arithmetics_bigops.bigop n (λ i => p2 i) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (λ i => g2 i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_exp_primr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom le_exp_primr : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) .", "predict": "Axiom le_exp_primr : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n (matita_arithmetics_chebyshev_chebyshev_psi.prim n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMatch_Prod. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $return_sort$, for all functions $case_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom match_Prod (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term return_sort (return_type z)", "predict": "axiom match_Prod (_A _B : cic.Univ univs.Type0) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_max_n. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $n$.\nassistant\n", "label": "Axiom lt_max_n : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n) .", "predict": "Axiom lt_max_n : forall f : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool), forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_680$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_680$.\nassistant\n", "label": "axiom Sig_rect_CProp5_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_680)", "predict": "axiom Sig_rect_CProp5_body (A : cic.Univ univs.Type0) (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) (Q_ : (_x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) (x_680 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) : cic.Term cic.prop (Q_ x_680)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTranspose_i_j_j_i. For all elements $i$ and $j$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $matita_arithmetics_permutation.transpose$ applied to $j$ and $i$ and $n$.\nassistant\n", "label": "Axiom transpose_i_j_j_i : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n)) .", "predict": "Axiom transpose_i_j_j_i : forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall j : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j n) (matita_arithmetics_permutation.transpose j i n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSameF_upto. For all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $A$ of $cic.Univ$ of $univs.Type0$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__1$ to $A$.\nassistant\n", "label": "Axiom sameF_upto : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __1 => A))) .", "predict": "Axiom sameF_upto : forall __ : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall A : cic.Univ univs.Type0, cic.Term univs.Type0 (matita_basics_relations.relation (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (fun __1 => A))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_Type5. For all functions $Q_$ from elements $_x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type5$, for all elements $_H_it$ of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_499$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type5$ and $Q_$ applied to $x_499$.\nassistant\n", "label": "axiom unit_rect_Type5 (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) (x_499 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type5 (Q_ x_499)", "predict": "axiom unit_rect_Type5 (Q_ : (_x_499 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type5) (_H_it : cic.Term univs.Type5 (Q_ matita_basics_types.it)) (x_499 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term univs.Type5 (Q_ x_499)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDivides_mod_gcd. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_gcd.gcd$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $m$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$.\nassistant\n", "label": "Axiom divides_mod_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n)) .", "predict": "Axiom divides_mod_gcd : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n (matita_arithmetics_div_and_mod.mod m n)) (matita_arithmetics_gcd.gcd m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nIrreflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom irreflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop .", "predict": "Axiom irreflexive : forall A : cic.Univ univs.Type0, forall _R : cic.Term univs.Type0 (matita_basics_relations.relation A), cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_upper_bound4. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_upper_bound4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nCongruent_ab_lt. Let $m$ and $n$ and $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.\nassistant\n", "label": "axiom congruent_ab_lt (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ x => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))", "predict": "axiom congruent_ab_lt (m n a b : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (λ x => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLength_tail. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_arithmetics_nat.pred$ applied to $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "Axiom length_tail : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_arithmetics_nat.pred (matita_basics_lists_list.length A l))) .", "predict": "Axiom length_tail : forall A : cic.Univ univs.Type0, forall l : cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_arithmetics_nat.pred (matita_basics_lists_list.length A l))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBijn_fg. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to the function that maps $p$ to $f$ applied to $g$ applied to $p$ and $n$.\nassistant\n", "label": "axiom bijn_fg (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)) : cic.Term cic.prop (matita_arithmetics_permutation.bijn (λ p => f (g p)) n)", "predict": "axiom bijn_fg (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) (__1 : cic.Term cic.prop (matita_arithmetics_permutation.bijn g n)) : cic.Term cic.prop (matita_arithmetics_permutation.bijn (λ p => f (g p)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCongruent_n_mod_n. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_congruence.congruent$ applied to $n$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $p$ and $p$.\nassistant\n", "label": "postulate congruent_n_mod_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p)", "predict": "postulate congruent_n_mod_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_arithmetics_congruence.congruent n (matita_arithmetics_div_and_mod.mod n p) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAop_rect_CProp5. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_877$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_877$", "label": "Aop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_877) .", "predict": "Aop_rect_CProp5 : A : cic.Univ univs.Type0 -> _nil : cic.Term univs.Type0 A -> Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Univ cic.prop) -> _H_mk_Aop : (op : (__ : cic.Term univs.Type0 A -> __1 : cic.Term univs.Type0 A -> cic.Term univs.Type0 A) -> _nill : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> _nilr : (a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> _assoc : (a : cic.Term univs.Type0 A -> b : cic.Term univs.Type0 A -> c : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) -> cic.Term cic.prop (Q_ x_877) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nP_ord_degenerate. For all elements $p$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord_aux$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $p$ and $n$.\nassistant\n", "label": "Axiom p_ord_degenerate : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n)) .", "predict": "Axiom p_ord_degenerate : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_aux p n (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat p n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nSum_rect_CProp2. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_inl$ from elements $x_572$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_572$, for all functions $_H_inr$ from elements $x_573$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_573$, for all elements $x_571$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_571$.\nassistant\n", "label": "postulate Sum_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)", "predict": "postulate Sum_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_572 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_572))) -> (_H_inr : (x_573 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_573))) -> (x_571 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_571)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_rect_CProp0_body. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_37$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_38$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_37$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_37$ and $x_38$.\nassistant\n", "label": "eq_rect_CProp0_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_37 : cic.Term univs.Type2 A -> _x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_37 : cic.Term univs.Type2 A -> x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) -> cic.Term cic.prop (Q_ x_37 x_38) .", "predict": "eq_rect_CProp0_body : A : cic.Univ univs.Type2 -> _x : cic.Term univs.Type2 A -> Q_ : (x_37 : cic.Term univs.Type2 A -> _x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) -> cic.Univ cic.prop) -> _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) -> x_37 : cic.Term univs.Type2 A -> x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) -> cic.Term cic.prop (Q_ x_37 x_38) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEq_f2. Let $A$ and $B$ and $C$ be elements of $cic.Univ$ of $univs.Type2$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type2$ and $B$ to elements of $cic.Term$ of $univs.Type2$ and $C$, for all elements $x1$ and $x2$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $y1$ and $y2$ of $cic.Term$ of $univs.Type2$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $x1$ and $x2$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $B$ and $y1$ and $y2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $C$ and $f$ applied to $x1$ and $y1$ and $f$ applied to $x2$ and $y2$.\nassistant\n", "label": "eq_f2 : A : cic.Univ univs.Type2 -> B : cic.Univ univs.Type2 -> C : cic.Univ univs.Type2 -> f : (__ : cic.Term univs.Type2 A -> __1 : cic.Term univs.Type2 B -> cic.Term univs.Type2 C) -> x1 : cic.Term univs.Type2 A -> x2 : cic.Term univs.Type2 A -> y1 : cic.Term univs.Type2 B -> y2 : cic.Term univs.Type2 B -> __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) -> __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) -> cic.Term cic.prop (matita_basics_logic.eq C (f x1 y1) (f x2 y2)) .", "predict": "eq_f2 : A : cic.Univ univs.Type2 -> B : cic.Univ univs.Type2 -> C : cic.Univ univs.Type2 -> f : (__ : cic.Term univs.Type2 A -> __1 : cic.Term univs.Type2 B -> cic.Term univs.Type2 C) -> x1 : cic.Term univs.Type2 A -> x2 : cic.Term univs.Type2 A -> y1 : cic.Term univs.Type2 B -> y2 : cic.Term univs.Type2 B -> __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) -> __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) -> cic.Term cic.prop (matita_basics_logic.eq C (f x1 y1) (f x2 y2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMdef. For all elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_binomial.M$ applied to $m$ and $matita_arithmetics_binomial.bc$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and $m$.\nassistant\n", "label": "postulate Mdef : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m))", "predict": "postulate Mdef : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_binomial.M m) (matita_arithmetics_binomial.bc (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m)) m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_CProp2. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z371$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_160$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_159$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z372$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_160$ and $x_159$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEq_gcd_times_1. Let $p$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom eq_gcd_times_1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) .", "predict": "Axiom eq_gcd_times_1 : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), forall __3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_d_gcd. Let $m$ and $n$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $d$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$.\nassistant\n", "label": "divides_d_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides d m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m)) .", "predict": "divides_d_gcd : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_primes.divides d m) -> __1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_15623. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $pnm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $c$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $d$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.times$ applied to $d$ and $m$ and $matita_arithmetics_nat.times$ applied to $c$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $mat", "label": "let_clause_15623 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_ar", "predict": "let_clause_15623 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (d : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme2 : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $p1$ and $p2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$, for all functions $f1$ and $f2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, for all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$ and $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n1$ and the function that maps $__$ to $cic.prod$ applied to $cic.prop$ and", "label": "axiom let_clause_10471 (n1 n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f1 f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (λ __ => matita_arithmetics_nat.nat)) (λ k => matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (λ i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (λ __ => cic.prod cic.prop cic.prop (matita_basics_logic.eq (", "predict": "axiom let_clause_10471 (n1 n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p1 p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) (B : cic.Univ univs.Type0) (nil : cic.Term univs.Type0 B) (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) (f1 f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (λ __ => matita_arithmetics_nat.nat)) (λ k => matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (λ i => cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt i n1) (λ __ => cic.prod cic.prop cic.prop (matita_basics_logic.eq (matita_basics_bool.andb (p1 i) (p2 (matita_arithmetics_nat.S i))) matita_basics_bool.true) (λ __ => cic.prod cic.prop cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_bigops.op B nil op f1 (matita_arithmetics_nat.S i)) (matita_arithmetics_bigops.op B nil op f2 i) (h (matita_arithmetics_nat.S i))) (λ __ => matita_basics_logic.eq (matita_arithmetics_bigops.op B nil op f1 n1) (matita_arithmetics_bigops.op B nil op"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLt_max_to_pi_p_primeb. Let $q$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $m$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $i$ and $matita_arithmetics_primes.dividesb$ applied to $i$ and $m$ and $q$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_bigops.bigop$ applied to $q$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_primes.dividesb$ applied to $p$ and $m$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_ord.ord$ applied to $m$ and $p$.\nassistant\n", "label": "Axiom lt_max_to_pi_p_primeb : forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max (matita_arithmetics_nat.S m) (fun i => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i m))) q), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop q (fun p => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p)))) .", "predict": "Axiom lt_max_to_pi_p_primeb : forall q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max (matita_arithmetics_nat.S m) (fun i => matita_basics_bool.andb (matita_arithmetics_primes.primeb i) (matita_arithmetics_primes.dividesb i m))) q), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop q (fun p => matita_basics_bool.andb (matita_arithmetics_primes.primeb p) (matita_arithmetics_primes.dividesb p m)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_exp.exp p (matita_arithmetics_ord.ord m p)))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nDPair_inv_rect_Type1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1128$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1129$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom DPair_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type1 (P Hterm)", "predict": "axiom DPair_inv_rect_Type1 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) : cic.Term univs.Type1 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nProd_rect_Type3. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H_mk_Prod$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_types.mk_Prod$ applied to $_A$ and $_B$ and $_fst$ and $_snd$, for all elements $x_696$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_696$.\nassistant\n", "label": "Prod_rect_Type3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) .", "predict": "Prod_rect_Type3 : _A : cic.Univ univs.Type0 -> _B : cic.Univ univs.Type0 -> Q_ : (_x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Univ univs.Type3) -> _H_mk_Prod : (_fst : cic.Term univs.Type0 _A -> _snd : cic.Term univs.Type0 _B -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> x_696 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B) -> cic.Term univs.Type3 (Q_ x_696) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp. For all elements $__$ and $__1$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "exp : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "exp : __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLe_plus_to_le. Let $a$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $a$ and $n$ and $matita_arithmetics_nat.plus$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom le_plus_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) .", "predict": "Axiom le_plus_to_le : forall a : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus a n) (matita_arithmetics_nat.plus a m)), cic.Term cic.prop (matita_arithmetics_nat.le n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAop_rect_Type0. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_793$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill", "label": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)", "predict": "postulate Aop_rect_Type0 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type0) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type0 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_793 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type0 (Q_ x_793)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFalse_rect_CProp4. Let $Q_$ be a function from elements $_x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_73$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_73$.\nassistant\n", "label": "axiom False_rect_CProp4 (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_73 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_73)", "predict": "axiom False_rect_CProp4 (Q_ : (_x_73 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) (x_73 : cic.Term cic.prop matita_basics_logic.False) : cic.Term cic.prop (Q_ x_73)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nEx2_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_P$ and $_Q$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex2_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_276$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ and elements $x_275$ of $cic.Term$ of $cic.prop$ and $_Q$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex2_intro$ applied to $A$ and $_P$ and $_Q$ and $x$ and $x_276$ and $x_275$, for all elements $x_274$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex2$ applied to $A$ and $_P$ and $_Q$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_274$.\nassistant\n", "label": "Axiom ex2_ind : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop), forall _H_ex2_intro : ((x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))), forall x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term cic.prop (Q_ x_274) .", "predict": "Axiom ex2_ind : forall A : cic.Univ univs.Type0, forall _P : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall _Q : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q)) -> cic.Univ cic.prop), forall _H_ex2_intro : ((x : cic.Term univs.Type0 A) -> (x_276 : cic.Term cic.prop (_P x)) -> (x_275 : cic.Term cic.prop (_Q x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))), forall x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q), cic.Term cic.prop (Q_ x_274) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTranspose_i_j_i. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $i$ and $j$.\nassistant\n", "label": "postulate transpose_i_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j i) j)", "predict": "postulate transpose_i_j_i : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_permutation.transpose i j i) j)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLeb_true_to_le. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "postulate leb_true_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "postulate leb_true_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nExp_1_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "axiom exp_1_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n))", "predict": "axiom exp_1_n (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_transpose_r. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $m$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $n$ to $f$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$ and $m$.\nassistant\n", "label": "axiom permut_transpose_r (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => f (matita_arithmetics_permutation.transpose i j n)) m)", "predict": "axiom permut_transpose_r (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (m i j : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.le i m)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j m)) (__2 : cic.Term cic.prop (matita_arithmetics_permutation.permut f m)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ n => f (matita_arithmetics_permutation.transpose i j n)) m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_exp_to_le1. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $n$ and $p$ and $matita_arithmetics_exp.exp$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "postulate le_exp_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "postulate le_exp_to_le1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp n p) (matita_arithmetics_exp.exp m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nUnit_rect_CProp0_body. For all functions $Q_$ from elements $_x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_it$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_519$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_519$.\nassistant\n", "label": "axiom unit_rect_CProp0_body (Q_ : (_x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_519 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_519)", "predict": "axiom unit_rect_CProp0_body (Q_ : (_x_519 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) (_H_it : cic.Term cic.prop (Q_ matita_basics_types.it)) (x_519 : cic.Term univs.Type0 matita_basics_types.unit) : cic.Term cic.prop (Q_ x_519)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nFilter_False. Let $return_sort$ be an element of $cic.Sort$. Then for all functions $return_type$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "filter_False : return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z) .", "predict": "filter_False : return_sort : cic.Sort -> return_type : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Univ return_sort) -> return : (z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z)) -> z : cic.Term cic.prop matita_basics_logic.False -> cic.Term return_sort (return_type z) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nSig_rect_Type1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Sig$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$, for all elements $x_674$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_674$.\nassistant\n", "label": "Axiom Sig_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type1 (Q_ x_674) .", "predict": "Axiom Sig_rect_Type1_body : forall A : cic.Univ univs.Type0, forall _f : ((__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop), forall Q_ : ((_x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type1), forall _H_mk_Sig : ((pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type1 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))), forall x_674 : cic.Term univs.Type0 (matita_basics_types.Sig A _f), cic.Term univs.Type1 (Q_ x_674) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nMinus_S_S. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$.\nassistant\n", "label": "axiom minus_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))", "predict": "axiom minus_S_S (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S m)) (matita_arithmetics_nat.minus n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nBool_inv_rect_Type0. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $P$ from elements $_z617$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $_H1$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z618$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom bool_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z617 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) (_H1 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type0 (P matita_basics_bool.true)) (_H2 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type0 (P matita_basics_bool.false)) : cic.Term univs.Type0 (P Hterm)", "predict": "axiom bool_inv_rect_Type0 (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) (P : (_z617 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type0) (_H1 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type0 (P matita_basics_bool.true)) (_H2 : (_z618 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type0 (P matita_basics_bool.false)) : cic.Term univs.Type0 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nTimes_n_O. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ applied to $n$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate times_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O))", "predict": "postulate times_n_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O (matita_arithmetics_nat.times n matita_arithmetics_nat.O))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBertrand. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "bertrand : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop .", "predict": "bertrand : _n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPermut_to_bijn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$.\nassistant\n", "label": "postulate permut_to_bijn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)", "predict": "postulate permut_to_bijn : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFalse_rect_CProp1. For all functions $Q_$ from elements $_x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_77$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_77$.\nassistant\n", "label": "postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)", "predict": "postulate False_rect_CProp1 : (Q_ : (_x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_77 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_77)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBool_inv_rect_CProp2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all functions $P$ from elements $_z635$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.true$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.true$, for all functions $_H2$ from elements $_z636$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $Hterm$ and $matita_basics_bool.false$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "bool_inv_rect_CProp2 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) .", "predict": "bool_inv_rect_CProp2 : Hterm : cic.Term univs.Type0 matita_basics_bool.bool -> P : (_z635 : cic.Term univs.Type0 matita_basics_bool.bool -> cic.Univ cic.prop) -> _H1 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true) -> cic.Term cic.prop (P matita_basics_bool.true)) -> _H2 : (_z636 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1626$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1627$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom ACop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)", "predict": "axiom ACop_inv_rect_CProp0 (x1 : cic.Univ univs.Type0) (x2 : cic.Term univs.Type0 x1) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) (P : (_z1626 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1627 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nDecidable_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_arithmetics_nat.lt$ applied to $n$ and $m$.\nassistant\n", "label": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))", "predict": "postulate decidable_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_arithmetics_nat.lt n m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nNull. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $nil$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.prod$ applied to $A$ and $nil$ and $xxx$ and $a$ and $nil$ and $nil$.\nassistant\n", "label": "null : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil) .", "predict": "null : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a nil) nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nList_rect_Type2_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $Q_$ from elements $_x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all elements $_H_nil$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.nil$ applied to $_A$, for all functions $_H_cons$ from elements $x_738$ of $cic.Term$ of $univs.Type0$ and $_A$ and elements $x_737$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$ and elements $_x_740$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $x_737$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_lists_list.cons$ applied to $_A$ and $x_738$ and $x_737$, for all elements $x_736$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_736$.\nassistant\n", "label": "Axiom list_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2), forall _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))), forall x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type2 (Q_ x_736) .", "predict": "Axiom list_rect_Type2_body : forall _A : cic.Univ univs.Type0, forall Q_ : ((_x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ univs.Type2), forall _H_nil : cic.Term univs.Type2 (Q_ (matita_basics_lists_list.nil _A)), forall _H_cons : ((x_738 : cic.Term univs.Type0 _A) -> (x_737 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_740 : cic.Term univs.Type2 (Q_ x_737)) -> cic.Term univs.Type2 (Q_ (matita_basics_lists_list.cons _A x_738 x_737))), forall x_736 : cic.Term univs.Type0 (matita_basics_lists_list.list _A), cic.Term univs.Type2 (Q_ x_736) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMonotonic_le_times_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and the function that maps $m$ to $matita_arithmetics_nat.times$ applied to $n$ and $m$.\nassistant\n", "label": "monotonic_le_times_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times n m)) .", "predict": "monotonic_le_times_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le (m : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_nat.times n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nPermut_n_to_eq_n. For all functions $h$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $h$ and $n$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $h$ applied to $n$ and $n$.\nassistant\n", "label": "postulate permut_n_to_eq_n : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h n) n)", "predict": "postulate permut_n_to_eq_n : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h n) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_CProp5. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_25$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_26$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_25$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_25$ and $x_26$.\nassistant\n", "label": "postulate eq_rect_CProp5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)", "predict": "postulate eq_rect_CProp5 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_25 : cic.Term univs.Type2 A) -> (_x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_25 : cic.Term univs.Type2 A) -> (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25)) -> cic.Term cic.prop (Q_ x_25 x_26)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nInl. For all elements $A$ and $B$ of $cic.Univ$ of $univs.Type0$, for all elements $__$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_types.Sum$ applied to $A$ and $B$.\nassistant\n", "label": "axiom inl (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 A) : cic.Term univs.Type0 (matita_basics_types.Sum A B)", "predict": "axiom inl (A B : cic.Univ univs.Type0) (__ : cic.Term univs.Type0 A) : cic.Term univs.Type0 (matita_basics_types.Sum A B)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nTech_log. Let $p$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $p$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_log.log$ applied to $p$ and $n$ and $matita_arithmetics_minimization.max$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $x$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $x$ and $n$.\nassistant\n", "label": "Axiom tech_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (fun x => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) .", "predict": "Axiom tech_log : forall p : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (fun x => matita_arithmetics_nat.leb (matita_arithmetics_exp.exp p x) n))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEqb_true_to_eq. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)", "predict": "postulate eqb_true_to_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLstar_ind_l_aux. For all elements $B$ of $cic.Univ$ of $univs.Type0$, for all functions $R$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $cic.prop$, for all elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b2$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b1$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b1$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b1$ and $b$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b2$, $cic.Term$ holds for $cic.prop$ and $P$ applied", "label": "axiom lstar_ind_l_aux (B : cic.Univ univs.Type0) (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) (b2 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) : cic.Term cic.prop (P l b1)", "predict": "axiom lstar_ind_l_aux (B : cic.Univ univs.Type0) (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) (b2 : cic.Term univs.Type0 B) (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) (b1 b : cic.Term univs.Type0 B) (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) : cic.Term cic.prop (P l b1)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $len$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $lep$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $p$, for all elements $ltp$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $Hc$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_chebyshev_bertrand.k$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n", "label": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) mat", "predict": "axiom let_clause_1033 (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)) matita_basics_bool.true)) : cic.Term cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n) p)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBijn_transpose. For all elements $n$ and $i$ and $j$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $matita_arithmetics_permutation.transpose$ applied to $i$ and $j$ and $n$.\nassistant\n", "label": "bijn_transpose : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n) .", "predict": "bijn_transpose : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le i n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.le j n) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (matita_arithmetics_permutation.transpose i j) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nCommutative_plus. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.commutative$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.plus$.\nassistant\n", "label": "postulate commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)", "predict": "postulate commutative_plus : cic.Term cic.prop (matita_basics_relations.commutative matita_arithmetics_nat.nat matita_arithmetics_nat.plus)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nExists_append. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$.\nassistant\n", "label": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))", "predict": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $a2$ of $cic.Term$ of $univs.Type0$ and $a1$, for all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$, for all elements $_e$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.Aop$ applied to $a1$ and $a2$ and $x$ and $y$, $cic.Term$ holds for $univs.Type2$ and $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $t0$ and $t1$ and $t2$ and $t3$ to $matita_basics_lists_list.match_Aop$ applied to $a1$ and $a2$ and $cic.succ$ applied to $univs.Type2$ and the function that maps $__$ to $cic.univ$ applied to $univs.Type2$ and the function that maps $u0$ and $u1$ and $u2$ and $u3$ to $cic.prod$ applied to $cic.succ$ applied to $univs.Type1$ and $univs.Type1$ and $cic.univ$ applied to $univs.Type1$ and the function that maps $P$ to $cic.prod$ applied to $univs.Type1$ and $univs.Type1$ and $cic.prod$ applied to $cic.prop$ and $univs.Type1$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__1$ to $a1$ and $matita_basics_logic.R0$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $a1$ and the function that maps $__$ to $cic.prod$ applied to $univs.Type0$", "label": "Axiom Aop_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Term univs.Type0 a1, forall x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => fun t2 => fun t3 => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => fun u2 => fun u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1))))", "predict": "Axiom Aop_discr : forall a1 : cic.Univ univs.Type0, forall a2 : cic.Term univs.Type0 a1, forall x : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall y : cic.Term univs.Type0 (matita_basics_lists_list.Aop a1 a2), forall _e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.Aop a1 a2)) x y), cic.Term univs.Type2 (matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun t0 => fun t1 => fun t2 => fun t3 => matita_basics_lists_list.match_Aop a1 a2 (cic.succ univs.Type2) (fun __ => cic.univ univs.Type2) (fun u0 => fun u1 => fun u2 => fun u3 => cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (fun P => cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1)))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 a1 (fun __ => cic.prod univs.Type0 univs.Type0 a1 (fun __1 => a1))) t0) u0) (fun e0 => P))) (fun _e0 => P))) y) x) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMonotonic_iter. Let $g$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $a$ and $b$ and $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $g$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $a$ and $matita_arithmetics_iteration.iter$ applied to $matita_arithmetics_nat.nat$ and $g$ and $i$ and $b$.\nassistant\n", "label": "postulate monotonic_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))", "predict": "postulate monotonic_iter : (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le g)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i a) (matita_arithmetics_iteration.iter matita_arithmetics_nat.nat g i b))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_CProp1_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_803$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_", "label": "Axiom Aop_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_803) .", "predict": "Axiom Aop_rect_CProp1_body : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term cic.prop (Q_ x_803) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nUnit_rect_Type4_body. For all functions $Q_$ from elements $_x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$, for all elements $_H_it$ of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_497$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type4$ and $Q_$ applied to $x_497$.\nassistant\n", "label": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)", "predict": "postulate unit_rect_Type4_body : (Q_ : (_x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4) -> (_H_it : cic.Term univs.Type4 (Q_ matita_basics_types.it)) -> (x_497 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type4 (Q_ x_497)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLet_clause_1559. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "let_clause_1559 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) .", "predict": "let_clause_1559 : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m) -> H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_CProp3_body. For all elements $A$ of $cic.Univ$ of $univs.Type2$, for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.\nassistant\n", "label": "axiom eq_rect_CProp3_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_28 : cic.Term univs.Type2 A) (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) : cic.Term cic.prop (Q_ x_28 x_29)", "predict": "axiom eq_rect_CProp3_body (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) (x_28 : cic.Term univs.Type2 A) (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) : cic.Term cic.prop (Q_ x_28 x_29)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLe_Psi_exp. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $n$.\nassistant\n", "label": "postulate le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))", "predict": "postulate le_Psi_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nF_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.\nassistant\n", "label": "f_ind : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.predicate A) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (P a) .", "predict": "f_ind : A : cic.Univ univs.Type0 -> f : (__ : cic.Term univs.Type0 A -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> P : cic.Term univs.Type0 (matita_basics_relations.predicate A) -> __ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (a : cic.Term univs.Type0 A -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n) -> cic.Term cic.prop (P a)) -> a : cic.Term univs.Type0 A -> cic.Term cic.prop (P a) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1033. For all elements $n$ and $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nassistant\n", "label": "Axiom let_clause_1033 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) .", "predict": "Axiom let_clause_1033 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMod_S_fact. Let $n$ and $i$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_factorial.fact$ applied to $n$ and $i$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom mod_S_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)) i) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) .", "predict": "Axiom mod_S_fact : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall i : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) i), forall __1 : cic.Term cic.prop (matita_arithmetics_nat.le i n), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.S (matita_arithmetics_factorial.fact n)) i) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_le_to_lt. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_nat.le$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$.\nassistant\n", "label": "axiom not_le_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) : cic.Term cic.prop (matita_arithmetics_nat.lt m n)", "predict": "axiom not_le_to_lt (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) : cic.Term cic.prop (matita_arithmetics_nat.lt m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nIso. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.relation$ applied to $matita_arithmetics_bigops.range$ applied to $A$.\nassistant\n", "label": "postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate iso : (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nB2. For all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "axiom B2 (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "axiom B2 (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nMin_f_g. For all functions $f$ and $g$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $n$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $__$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $b$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $matita_arithmetics_nat.plus$ applied to $n$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $g$ applied to $i$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $f$ and $matita_arithmetics_minimization.min$ applied to $n$ and $b$ and $g$.\nassistant\n", "label": "min_f_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) .", "predict": "min_f_g : f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 matita_basics_bool.bool) -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.le b i) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) (g i))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) (matita_arithmetics_minimization.min n b g)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAop_rect_Type1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_791$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_n", "label": "Axiom Aop_rect_Type1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type1 (Q_ x_791) .", "predict": "Axiom Aop_rect_Type1 : forall A : cic.Univ univs.Type0, forall _nil : cic.Term univs.Type0 A, forall Q_ : ((_x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type1), forall _H_mk_Aop : ((op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type1 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))), forall x_791 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil), cic.Term univs.Type1 (Q_ x_791) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_upper_bound3. Let $n$ and $m$ and $x$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nassistant\n", "label": "Axiom let_upper_bound3 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat .", "predict": "Axiom let_upper_bound3 : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall x : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 matita_arithmetics_nat.nat ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPrimes_all. Let $_l$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $matita_arithmetics_nat.nat$. Then for all elements $_n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Univ$ holds for $cic.prop$.\nassistant\n", "label": "Axiom primes_all : forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop .", "predict": "Axiom primes_all : forall _l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat), forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Univ cic.prop ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_rect_Type0. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_H_refl$ of $cic.Term$ of $univs.Type0$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_19$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_20$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_19$, $cic.Term$ holds for $univs.Type0$ and $Q_$ applied to $x_19$ and $x_20$.\nassistant\n", "label": "axiom eq_rect_Type0 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) (x_19 : cic.Term univs.Type2 A) (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) : cic.Term univs.Type0 (Q_ x_19 x_20)", "predict": "axiom eq_rect_Type0 (A : cic.Univ univs.Type2) (_x : cic.Term univs.Type2 A) (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) (x_19 : cic.Term univs.Type2 A) (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) : cic.Term univs.Type0 (Q_ x_19 x_20)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nDiv_mod_spec_rect_CProp3. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $Q_$ from elements $_x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_div_mod_spec_intro$ from elements $x_847$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_846$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_847$ and $x_846$, for all elements $x_845$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_845$.\nassistant\n", "label": "Axiom div_mod_spec_rect_CProp3 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))), forall x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_845) .", "predict": "Axiom div_mod_spec_rect_CProp3 : forall _n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _q : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall _r : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall Q_ : ((_x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop), forall _H_div_mod_spec_intro : ((x_847 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_846 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_847 x_846))), forall x_845 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r), cic.Term cic.prop (Q_ x_845) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nUnit_inv_rect_Type4. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Then for all functions $P$ from elements $_z912$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $_z913$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_basics_types.it$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "Axiom unit_inv_rect_Type4 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z912 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4), forall _H1 : ((_z913 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type4 (P matita_basics_types.it)), cic.Term univs.Type4 (P Hterm) .", "predict": "Axiom unit_inv_rect_Type4 : forall Hterm : cic.Term univs.Type0 matita_basics_types.unit, forall P : ((_z912 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type4), forall _H1 : ((_z913 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type4 (P matita_basics_types.it)), cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nRange_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1650$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1651$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom range_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1650 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type2) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1651 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type2 (P Hterm)", "predict": "axiom range_inv_rect_Type2 (x1 : cic.Univ univs.Type0) (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) (P : (_z1650 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type2) (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1651 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) : cic.Term univs.Type2 (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nPermut_fg. Let $f$ and $g$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $g$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to the function that maps $m$ to $f$ applied to $g$ applied to $m$ and $n$.\nassistant\n", "label": "axiom permut_fg (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ m => f (g m)) n)", "predict": "axiom permut_fg (f g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut g n)) : cic.Term cic.prop (matita_arithmetics_permutation.permut (λ m => f (g m)) n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMem_append. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l1$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $l2$.\nassistant\n", "label": "Axiom mem_append : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2)), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A a l1) (matita_basics_lists_list.mem A a l2)) .", "predict": "Axiom mem_append : forall A : cic.Univ univs.Type0, forall a : cic.Term univs.Type0 A, forall l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A), forall __ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.append A l1 l2)), cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.mem A a l1) (matita_basics_lists_list.mem A a l2)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nFilter_Aop. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $return_sort$ of $cic.Sort$, for all functions $return_type$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $return_sort$, for all functions $return$ from elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$, for all elements $z$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nassistant\n", "label": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term return_sort (return_type z)", "predict": "axiom filter_Aop (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (return_sort : cic.Sort) (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) : cic.Term return_sort (return_type z)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLt_SO_to_le_B_exp. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.pred$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "postulate lt_SO_to_le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate lt_SO_to_le_B_exp : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nEq_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Then for all elements $_x$ of $cic.Term$ of $univs.Type2$ and $A$, for all functions $Q_$ from elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_refl$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_28$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_29$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_28$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_28$ and $x_29$.\nassistant\n", "label": "postulate eq_rect_CProp3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)", "predict": "postulate eq_rect_CProp3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_28 : cic.Term univs.Type2 A) -> (_x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_28 : cic.Term univs.Type2 A) -> (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28)) -> cic.Term cic.prop (Q_ x_28 x_29)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nEq_fact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $i$ to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $i$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $i$.\nassistant\n", "label": "axiom eq_fact_pi_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ i => matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => i)))", "predict": "axiom eq_fact_pi_p (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (λ i => matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) i) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (λ i => i)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nMonotonic_Psi. $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.le$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$.\nassistant\n", "label": "postulate monotonic_Psi : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_chebyshev_chebyshev_psi.Psi)", "predict": "postulate monotonic_Psi : cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.le matita_arithmetics_chebyshev_chebyshev_psi.Psi)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nFilter_true. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $a$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $l$ and $matita_basics_lists_list.cons$ applied to $A$ and $a$ and $matita_basics_lists_list.filter$ applied to $A$ and $p$ and $l$.\nassistant\n", "label": "postulate filter_true : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.cons A a (matita_basics_lists_list.filter A p l)))", "predict": "postulate filter_true : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (a : cic.Term univs.Type0 A) -> (p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p a) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.filter A p (matita_basics_lists_list.cons A a l)) (matita_basics_lists_list.cons A a (matita_basics_lists_list.filter A p l)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNot_eq_n_Sn. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $n$.\nassistant\n", "label": "axiom not_eq_n_Sn (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n)))", "predict": "axiom not_eq_n_Sn (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (matita_basics_logic.Not (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S n)))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nLet_clause_1572. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$, for all elements $auto'$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom let_clause_1572 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O), forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O), forall auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) .", "predict": "Axiom let_clause_1572 : forall m : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, forall posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n), forall H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O), forall auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O), forall auto' : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n matita_arithmetics_nat.O), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLet_clause_1532. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nassistant\n", "label": "postulate let_clause_1532 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1532 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nLength_tail1. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_basics_lists_list.length$ applied to $A$ and $l$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_basics_lists_list.length$ applied to $A$ and $matita_basics_lists_list.tail$ applied to $A$ and $l$ and $matita_basics_lists_list.length$ applied to $A$ and $l$.\nassistant\n", "label": "postulate length_tail1 : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))", "predict": "postulate length_tail1 : (A : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_lists_list.length A l))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_basics_lists_list.length A (matita_basics_lists_list.tail A l)) (matita_basics_lists_list.length A l))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nAnd_inv_rect_CProp0. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z383$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_168$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_167$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z384$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_168$ and $x_167$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "And_inv_rect_CProp0 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_168 : cic.Term cic.prop x1 -> x_167 : cic.Term cic.prop x2 -> _z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm) .", "predict": "And_inv_rect_CProp0 : x1 : cic.Univ cic.prop -> x2 : cic.Univ cic.prop -> Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> P : (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2) -> cic.Univ cic.prop) -> _H1 : (x_168 : cic.Term cic.prop x1 -> x_167 : cic.Term cic.prop x2 -> _z384 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_168 x_167)) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) -> cic.Term cic.prop (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1595. For all elements $p$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $posn$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $posm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $primepn$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $primepm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, for all elements $lt1gcd$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_primes.smallest_factor$ applied to $matita_arithmetics_gcd.gcd$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $n$ and $m$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $n$ and $matita_arithmetics_gcd.gcd$ applied to $p$ and $m$.\n", "label": "axiom let_clause_1595 (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)))) (H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m))", "predict": "axiom let_clause_1595 (p n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) (primepn : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (primepm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (lt1gcd : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m)))) (H : cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_primes.smallest_factor (matita_arithmetics_gcd.gcd p (matita_arithmetics_nat.times n m))) m)) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p n) (matita_arithmetics_gcd.gcd p m))"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nBigop_false. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $matita_basics_bool.false$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $nil$.\nassistant\n", "label": "bigop_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.false) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) nil) .", "predict": "bigop_false : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> B : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 B -> op : (__ : cic.Term univs.Type0 B -> __1 : cic.Term univs.Type0 B -> cic.Term univs.Type0 B) -> f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_bool.false) B nil op (i : cic.Term univs.Type0 matita_arithmetics_nat.nat => f i)) nil) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLet_clause_1559. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $divnm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $H$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.O$ and $n$, for all elements $d$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $auto$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $n$.\nassistant\n", "label": "axiom let_clause_1559 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)", "predict": "axiom let_clause_1559 (n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (divnm : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) (auto : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O d))) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m n)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nVoid_rect_CProp4. Let $Q_$ be a function from elements $_x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $x_489$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.void$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_489$.\nassistant\n", "label": "axiom void_rect_CProp4 (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)", "predict": "axiom void_rect_CProp4 (Q_ : (_x_489 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) (x_489 : cic.Term univs.Type0 matita_basics_types.void) : cic.Term cic.prop (Q_ x_489)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nLe_times_to_le. For all elements $a$ and $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $n$ and $matita_arithmetics_nat.times$ applied to $a$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $n$ and $m$.\nassistant\n", "label": "axiom le_times_to_le (a n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) : cic.Term cic.prop (matita_arithmetics_nat.le n m)", "predict": "axiom le_times_to_le (a n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) (__1 : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times a m))) : cic.Term cic.prop (matita_arithmetics_nat.le n m)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nAnd_rect_CProp1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_conj$ from elements $x_164$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_163$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_164$ and $x_163$, for all elements $x_162$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_162$.\nassistant\n", "label": "Axiom And_rect_CProp1_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))), forall x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_162) .", "predict": "Axiom And_rect_CProp1_body : forall _A : cic.Univ cic.prop, forall _B : cic.Univ cic.prop, forall Q_ : ((_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop), forall _H_conj : ((x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))), forall x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B), cic.Term cic.prop (Q_ x_162) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nNat_rect_CProp1. Let $Q_$ be a function from elements $_x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $_H_O$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.O$, for all functions $_H_S$ from elements $x_410$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_412$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $x_410$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_nat.S$ applied to $x_410$, for all elements $x_409$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_409$.\nassistant\n", "label": "axiom nat_rect_CProp1 (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)", "predict": "axiom nat_rect_CProp1 (Q_ : (_x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) (_H_S : (x_410 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_412 : cic.Term cic.prop (Q_ x_410)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_410))) (x_409 : cic.Term univs.Type0 matita_arithmetics_nat.nat) : cic.Term cic.prop (Q_ x_409)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_rect_CProp5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_905$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_905$.\nassistant\n", "label": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)", "predict": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nSig_inv_rect_CProp4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $x2$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1206$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $x2$ applied to $pi1$ and elements $_z1207$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Sig$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Sig$ applied to $x1$ and $x2$ and $pi1$ and $_pi2$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "axiom Sig_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)", "predict": "axiom Sig_inv_rect_CProp4 (x1 : cic.Univ univs.Type0) (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) (P : (_z1206 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1207 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) : cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nF_ind_aux. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $P$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$, for all functions $__$ from elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $__$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$ and elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $a$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $a$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $n$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $a$.\nassistant\n", "label": "axiom f_ind_aux (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (a : cic.Term univs.Type0 A) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) : cic.Term cic.prop (P a)", "predict": "axiom f_ind_aux (A : cic.Univ univs.Type0) (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) (P : cic.Term univs.Type0 (matita_basics_relations.predicate A)) (__ : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (a : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (f a) n)) -> cic.Term cic.prop (P a)) -> (a : cic.Term univs.Type0 A) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) -> cic.Term cic.prop (P a)) (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) (a : cic.Term univs.Type0 A) (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) n)) : cic.Term cic.prop (P a)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nLe_plus_n_r. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $m$ and $n$.\nassistant\n", "label": "le_plus_n_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n)) .", "predict": "le_plus_n_r : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le m (matita_arithmetics_nat.plus m n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nFact_pi_p. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_factorial.fact$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$.\nassistant\n", "label": "Axiom fact_pi_p : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) .", "predict": "Axiom fact_pi_p : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (fun p => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun p => matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p n) (fun i => matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (fun i => matita_arithmetics_exp.exp p (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nACop_inv_rect_Type4. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nassistant\n", "label": "ACop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm) .", "predict": "ACop_inv_rect_Type4 : x1 : cic.Univ univs.Type0 -> x2 : cic.Term univs.Type0 x1 -> Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ univs.Type4) -> _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2) -> _comm : (a : cic.Term univs.Type0 x1 -> b : cic.Term univs.Type0 x1 -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> _z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm)) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nACop_inv_rect_CProp1. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $x2$ of $cic.Term$ of $univs.Type0$ and $x1$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1621$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Agda.\nAnd_inv_rect_CProp3. For all elements $x1$ and $x2$ of $cic.Univ$ of $cic.prop$, for all elements $Hterm$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z365$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $x_156$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_155$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z366$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_156$ and $x_155$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nassistant\n", "label": "postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_156 : cic.Term cic.prop x1) -> (x_155 : cic.Term cic.prop x2) -> (_z366 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nTheta_def. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applied to $n$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$.\nassistant\n", "label": "theta_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p))) .", "predict": "theta_def : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (p : cic.Term univs.Type0 matita_arithmetics_nat.nat => p))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nPsi_2. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nassistant\n", "label": "Axiom Psi_2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) .", "predict": "Axiom Psi_2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_psi.Psi (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nExp_1_n. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "exp_1_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) .", "predict": "exp_1_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Coq.\nMonotonic_lt_plus_r. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.monotonic$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.lt$ and the function that maps $m$ to $matita_arithmetics_nat.plus$ applied to $n$ and $m$.\nassistant\n", "label": "Axiom monotonic_lt_plus_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun m => matita_arithmetics_nat.plus n m)) .", "predict": "Axiom monotonic_lt_plus_r : forall n : cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (fun m => matita_arithmetics_nat.plus n m)) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nEqb_true_to_eq. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.eqb$ applied to $n$ and $m$ and $matita_basics_bool.true$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $m$.\nassistant\n", "label": "eqb_true_to_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) .", "predict": "eqb_true_to_eq : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.eqb n m) matita_basics_bool.true) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nDivides_SO_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$.\nassistant\n", "label": "divides_SO_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) .", "predict": "divides_SO_n : n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) ."}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Lean.\nACop_rect_Type1_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_mk_ACop$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$, for all elements $x_899$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_899$.\nassistant\n", "label": "axiom ACop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)", "predict": "axiom ACop_rect_Type1_body (A : cic.Univ univs.Type0) (_nil : cic.Term univs.Type0 A) (Q_ : (_x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type1) (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) (x_899 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) : cic.Term univs.Type1 (Q_ x_899)"}
{"prompt": "system\nYou are a helpful assistant.\nuser\nTranslate the following English statement into Dedukti.\nCongruent_ab_lt. For all elements $m$ and $n$ and $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $n$ and $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $x$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $matita_arithmetics_congruence.congruent$ applied to $x$ and $a$ and $m$ and $matita_arithmetics_congruence.congruent$ applied to $x$ and $b$ and $n$ and $matita_arithmetics_nat.lt$ applied to $x$ and $matita_arithmetics_nat.times$ applied to $m$ and $n$.\nassistant\n", "label": "congruent_ab_lt : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n)))) .", "predict": "congruent_ab_lt : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> __ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (x : cic.Term univs.Type0 matita_arithmetics_nat.nat => matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n)))) ."}