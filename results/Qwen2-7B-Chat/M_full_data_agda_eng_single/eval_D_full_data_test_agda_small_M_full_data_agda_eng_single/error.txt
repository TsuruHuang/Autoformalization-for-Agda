ERROR: n1)= truepostulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> true) -> Leq g1 i g2 i) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> Leq g1 i g2 i) -> (H3 : Eq p2 n1) -> (H4 : Eq p1 n1) -> (H5 : Eq (g1 n1) (g2 n1)) -> (H6 : Eq (g1 n1) (plus (g1 n1) (g2 n1))) -> (H7 : Eq (g2 n1) (plus (g1 n1) (g2 n1))) -> (H8 : Eq (g1 n1) (plus (g1 n1) (g2 n1))) -> (H9 : Eq (g2 n1) (plus (g1 n1) (g2 n1))) -> (H10 : Eq (g1 n1) (plus (g1 n1) (g2 n1))) -> (H11 : Eq (g2 n1) (plus (g1 n1) (g2 n1))) -> (H12 : Eq (g1 n1) (plus (g1 n1) (g2 n1))) -> (H13 : Eq (g2 n1) (plus (g1 n1) (g2 n1))) -> (H14 : Eq (g1 n1) (plus (g1 n1) (g2 n1))) -> (H15 : Eq (g2 n1
ERROR: postulate k1 : (n : Nat) -> (p : Nat) -> (_ : And (Geq 18 n) (Leq p n)) -> (__1 : Lt (div 2 n) p) -> Eq (k (2 n, p)) 0
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (f a = i) (Leq a n)) -> (f a = i) -> (b : Nat) -> (_ : and (Leq b n) (f b = j) (Leq b n)) -> (f b = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> f a = j
ERROR: postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : Eq (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (l : (_ : Nat) -> Nat) -> (_clearme2 : Eq (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)) -> (_clearme3 : Eq (f1 (l k)) (f2 (h (l k)))) -> (x : Nat) -> (_clearme4 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n
ERROR: postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ __ : Nat -> Nat)) (\ k : (_ : Nat) -> Nat -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ __ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (Eq (p1 (n1 k)) true)) (Eq (f1 (n1 k)) (f2 (h (n1 k)))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))))) -> mk_range B f2 n2 p2 (mk_range B f1 n1 p1) (mk_range B f2 n2 p2) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))
ERROR: postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut (n , f , f m)) m
ERROR: postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (_q * _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857
ERROR: postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (_ : Eq (plus l0 1) l) -> ex2 B (\ b : B -> R (b1 , b)) (\ b : B -> lstar (B , R , l0 , b , b2))
ERROR: postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (n + 1)) -> (f (n + 1) : Eq n + 1) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (n + 1)) (Eq (f a) i)) -> (lean : Leq a (n + 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (n + 1)) -> Eq i a
ERROR: postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (p + 1 , m , n)) (gcd_aux (p , n , mod m n))
ERROR: postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (lebn : cic.Term cic.prop (matita_arithmetics_nat.le b n)) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a b)) -> cic.Term cic.prop (mat
ERROR: 1335$ ochpostulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335
ERROR: postulate eq_Psi_2_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (times (primeb (plus (times 2 n) 1)) (times (primeb (plus (times 2 n) 1)) (plus (times 2 n) 1))) (Psi (2 * n))
ERROR: postulate le_theta_M_theta : (m : Nat) -> Leq (theta (2 * m + 1)) (M m) (theta (m + 1))
ERROR: postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : p_ord (n , nth_prime (p)) = mk_Prod Nat Nat q r) -> not (Eq r 0)
ERROR: postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\ t0 : (__ : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_types.Sig a1 a2) t0)) (\ t1 : (x0 : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.succ univs.Type2) (matita_basics_types.match_Sig a1 a2 univs.Type2 (\ __ : cic.Term univs.Type0 a1 -> cic.univ univs.Type2) (\ u0 : (__ : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_types.Sig a1 a2) u0)) (\ u1 : (x00 : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.succ univs.Type2) (matita_basics_types.match_Sig a1 a2 univs.Type2 (\ __ : cic.Term univs.Type0 a1 -> cic.univ univs.Type2) (\ v0 : (__ : cic.Term univs.Type0 a1) -> cic.Term cic.prop (matita_basics
ERROR: postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (matita_basics_types.mk_Prod A B lft rgt) (T' lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B p (\ x0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> T x0 (\ x1 : cic.Term univs.Type0 B -> matita_basics_types.match_Prod A B p (\ x0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> \ t0 : cic.Term cic.prop (P x0 (\ x1 : cic.Term univs.Type0 B -> matita_basics_types.match_Prod A B x0 (\ x00 : cic.Term univs.Type0 A -> \ x10 : cic.Term univs.Type0 B -> T x00 x10)) (\ x00 : cic.Term univs.Type0 A -> \ x10 : cic.Term univs.Type0 B -> matita_basics_types.match_Prod A B p (\ x00 : cic.Term univ
ERROR: postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\ t : Nat -> c * t)
ERROR: postulate prop110 : (a : Int) -> (c : Int) -> even a -> even c -> even (a * b + b * c)
ERROR: postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (Type2 + 1) (\ _ : range a1 -> univ Type2) (\ t0 : Nat -> \ t1 : Nat -> \ t2 : Nat -> match_range a1 (plus Type2 1) (\ _ : range a1 -> univ Type2) (\ u0 : Nat -> \ u1 : Nat -> \ u2 : Nat -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\ _ : Nat -> a1) t0) u0) (\ e0 : Eq t0 u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1) t0) u0 e0) (\ e1 : Eq (R0 (prod Set Set Nat (\ _ : Nat -> a1) t0) u0) e0 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\ _ : Nat -> a1) t0 u0 e0) (\ _ : Nat -> a1) t1 u1 e1) (\ e2 : Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1) t0 u0 e0) (\ _ : Nat -> a1) t1 u1 e1) e1 -> prod Prop Type1 (Eq (R3 (prod Set Set Nat (\ _ : Nat -> a1) t0 u0 e0) (\ _ : Nat -> a1) t1 u1 e1) (\ _ : Nat -> a1) t2 u2 e2) (\ e3 : Eq (R2 (prod Set Set Nat (\ _ : Nat -> a1) t0 u0 e0) (\ _ : Nat -> a1) t1 u1 e1) (\ _ : Nat -> a1) t2 u2 e2 -> univ Type1))))) (\ _ : Nat -> a1) t0 u0 e0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\ _ : Nat -> a1) t0 u0 e0) (\ _ : Nat -> a1) t1
ERROR: postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (Eq m (2 * a)) (Eq m (2 * a + 1))) -> (__1 : Lt 1 (2 * a + 1)) -> (__2 : Lt 0 a) -> Eq (pred m) (plus a a)
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i)) -> (_ : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_ : and (Leq b n) (Eq (f b) j)) -> (_ : Leq b n) -> (fb : Eq (f b) j) -> (_ : (_ : i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
ERROR:  (m , n))$.postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq1 : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))
ERROR: postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) -> (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2
ERROR: postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R)) f a)) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))) a))
ERROR: postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (p ^ m , p)) m
ERROR: postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op (x2 , a)) a) -> (_nilr : (a : x1) -> Eq (op (a , x2)) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op (a , op (b , c))) (op (op (a , b), c))) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
ERROR: postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n ((n div m) + 1) m
ERROR: postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (x3 * x2 + x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854))) -> P (div_mod_spec_intro (x1 , x2 , x3 , x4 , x_855 , x_854))) -> P Hterm
ERROR: postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\ p : Nat -> transpose (i , j , f p)) n
ERROR: postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (and (Eq m (2 * a)) (Eq m (2 * a + 1))) (and (Eq m (2 * a + 1)) (Eq m (2 * a + 1)))) -> (__1 : and (Lt 1 (2 * a + 1)) (Lt (2 * a) 1)) -> (__2 : Lt a 1) -> Eq (pred m) (plus a a)
ERROR:  true$.postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> true) -> Leq g1 i g2 i) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> Leq g1 i g2 i) -> (p2n1 : true) -> (p1n1 : true) -> Eq (Hind (\ i : Nat -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) (\ i : Nat -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> true) (\ i : Nat -> Leq g1 i g2 i)) (Hind (\ i : Nat -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> true) (\ i : Nat -> (__1 : Lt i (n1 + 1)) -> (__2 : Eq p1 i) -> true) (\ i : Nat -> Leq g1 i g2 i))
ERROR: postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (l + 1) b1 b2) -> ex2 B (\ b : B -> lstar (B , R , l , b1 , b)) (\ b : B -> R (b , b2))
ERROR: postulate let_clause_15692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c m) (matita_arithmetics_nat.times d n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times c (matita_arithmetics_nat.minus n m)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (mat
ERROR: postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (return_type (matita_arithmetics_minimization.found_min_spec _n _b _f m __ __1 __2 __3))) -> (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b x)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt x (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool
ERROR: postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term cic.prop (Q_ m (matita_arithmetics_minimization.mk_min_spec _n _b _f m x_1077))) -> (x_1074 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1075 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1074)) -> cic.Term cic.prop (Q_ x_1074
ERROR: lspostulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> Eq (Hind (\ i : Nat -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) H1 H2) (let Hind' : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) in Hind' H1 H2
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (Eq m (2 * a)) (Eq m (2 * a + 1))) -> (__1 : Eq m (2 * a + 1)) -> (__2 : Lt 1 (2 * a + 1)) -> (__3 : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (div x2515 x2516) + mod x2515 x2516
ERROR: postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose (i , j , n)) (transpose (i , k , transpose (k , j , transpose (i , k , n))))
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (Eq m (2 * a)) (Eq m (2 * a + 1))) -> (x2515 : Nat) -> (x2516 : Nat) -> (Hind1 : Lt 1 (2 * a + 1)) -> (Hind2 : Lt 0 a) -> Eq x2515 (x2516 (div x2515 x2516) + mod x2515 x2516)
ERROR: postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (Eq m (2 * a)) (Eq m (2 * a + 1))) -> (__1 : and (Lt 1 (2 * a + 1)) (Lt (2 * a + 1) 2)) -> (__2 : Lt 1 a) -> Eq (pred m) (plus a a)
ERROR: postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> Eq (f1 (k n1)) (f2 (h (k n1)))
ERROR: postulate plus_minus : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Leq m n) -> Eq (minus n m) p) (plus n p) (minus m)
ERROR: postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (2 n)) (2 ^ pred (2 n))
ERROR: postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op (x2 , a)) a) -> (_nilr : (a : x1) -> Eq (op (a , x2)) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op (a , op (b , c))) (op (op (a , b), c))) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
ERROR: postulate min_spec_to_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min (n , b , f)) m
ERROR:  true$.postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> true) -> Leq (g1 i) (g2 i)) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq p1 i) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq p2 n1) -> (p1n1 : Eq p1 n1) -> Eq (Hind (\ i : Nat -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) (\ i : Nat -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> true) (\ i : Nat -> Leq (g1 i) (g2 i))) (H1 n1) (H2 n1)
ERROR: postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posn : Lt 0 q) -> (n1 : Nat) -> (H : Eq (plus (sum n1 1) (andb (leb 1) m (dividesb q m) Nat 0 plus (\ m : Nat -> 1) q (mod n1 q))) n1) -> (divn1 : divisible q (n1 + 1)) -> (Hn1 : Eq (n1 + 1) (times (div (n1 + 1) q) (plus 1 q))) -> (auto : Eq (n1 + 1) (plus q (times (div (n1 + 1) q) (plus 1 q))))
ERROR: postulate theta_pi_p_theta : (m : Nat) -> Eq (times (bigop (plus (times 2 m) 2) (\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\ p : Nat -> p)) (theta (m + 1))) (theta (2 * m + 1))
ERROR: postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (pow b n) 1) -> Eq (pow b (b^n)) 1
ERROR: postulate transpose_i_j_j_i : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose (i , j , n)) (transpose (j , i , n))
ERROR: postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i)) -> (_ : Leq a n) -> (f a = i) -> (b : Nat) -> (__1 : and (Leq b n) (Eq (f b) j)) -> (__2 : Leq b n) -> (f b = j) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
ERROR: postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi a) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred a) (matita_arithmetics_exp.exp (mat
ERROR: postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose (i , j , transpose (i , j , n))) n
ERROR: atpostulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop B nil R f a)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop B nil R f a)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i)))) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop B nil R f a)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil
ERROR: postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod (A , nil , xxx , a , nil)) nil
ERROR: postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op (A , _nil , aop , a , b)) (op (A , _nil , aop , b , a))) -> Q_ (mk_ACop (A , _nil , aop , _comm))) -> (x_897 : ACop A _nil) -> Q_ x_897
ERROR: postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (n \div (n \div d)) d
ERROR: _natpostulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_nat.times a b) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.times qa qb) (matita_arithmetics_nat.times
ERROR:  appliceratpostulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_arithmetics_nat.le b (matita_arithmetics_nat.times p (matita_arithmetics_div_and_mod.div m n)) (matita_arithmetics_nat.le (matita_arithmetics_nat.times p (matita_arithmetics_div_and_mod.div m n)) b)) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times c m) (matita_arithmetics_nat.le (matita_arithmetics_nat.times c m) b))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c m) (matita_ar
ERROR: postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (2 ^ (2 * n - 3))
ERROR: icpostulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\ _ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\ p : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> \ t : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x p) -> \ u : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) y p) -> matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\ _ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\ q : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> \ v : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x q) -> \ w : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) y q) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type
ERROR: postulate Aop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op (x2 , a)) a) -> (_nilr : (a : x1) -> Eq (op (a , x2)) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op (a , op (b , c))) (op (op (a , b), c))) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
ERROR: postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim (n , i , acc)) (n + i)
ERROR: postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_ : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 Type2 + 1 (\ __ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ t0 : Lt a4 a2 -> t1 : Eq a1 (plus (times a3 a2) a4)) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\ __ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ u0 : Lt a4 a2 -> u1 : Eq a1 (plus (times a3 a2) a4)) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 t1) u1) (\ e1 : Eq (R1 (Lt a4 a2) t0 t1) u1 -> P))))
ERROR: postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod (a , aop__o__op (A , _nil , sum , b , c)) (aop__o__op (A , _nil , sum , prod (a , b) , prod (a , c)))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (__2 : and (Leq a n) (Eq (f a) i)) -> (__3 : Leq a n) -> (f a = i) -> (b : Nat) -> (__4 : and (Leq b n) (Eq (f b) j)) -> (__5 : Leq b n) -> (f b = j) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j
ERROR: postulate let_clause_10331 : (n : Nat) -> (5 : Lt 5 n) -> (m : Nat) -> (6 : Leq m) -> (_ : Leq (plus 1 (square m)) (pow 2 m)) -> (a : Nat) -> (6 : Leq a) -> (2 (plus 1 a) + 1 : Leq pow 2 a) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (div x2515 x2516) + mod x2515 x2516
ERROR: postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\ t : Nat -> c * t)
ERROR: postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (H : Leq n (plus q 1)) -> (_clearme : not (divisible n m)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n)))) -> (b : Nat) -> (_clearme1 : disjunktion (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n))) -> (H0 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q m n)) -> (H1 : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n)) -> Eq (gcd a b) (gcd (plus a (mod m n)) (plus b n))
ERROR: postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : p_ord (n , p) = mk_Prod Nat Nat a b) -> (__5 : p_ord (m , p) = mk_Prod Nat Nat c d) -> and (divisible b d) (Leq a c)
ERROR: postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i) (Leq a n)) -> (f a = i) -> (b : Nat) -> (_ : and (Leq b n) (Eq (f b) j) (Leq b n)) -> (f b = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
ERROR: postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c m) (matita_arithmetics_nat.times d n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> cic.Term univs.Type0 (matita_arithmetics_nat.nat)
ERROR:  quipostulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i)) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i)) J) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i)))
ERROR: postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n ((n div m) + 1) * m
ERROR: postulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppostulate aop : Aoppost
ERROR: postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (pow p q r)) -> p_ord (n , p) = mk_Prod Nat Nat q r
ERROR: postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n m)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n m)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n m)))) -> (Hc : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n m)) -> Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n m)
ERROR: postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.times i b)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.big
ERROR: postulate assoc : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (op (A , nil , xxx , a , op (A , nil , xxx , b , c))) (op (A , nil , xxx , op (A , nil , xxx , a , b), c))
ERROR: postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i) (Leq a n)) -> (f a = i) -> (b : Nat) -> (_ : and (Leq b n) (Eq (f b) j) (Leq b n)) -> (f b = j) -> (_ : Eq (f b) j) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
ERROR:  , n))$,postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq1 : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (auto : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))
ERROR: postulate noLabel_64 : (n : Int) -> (_ : odd (3*n - 5)) -> even n
ERROR: postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op (x2 , a)) a) -> (_nilr : (a : x1) -> Eq (op (a , x2)) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op (a , op (b , c))) (op (op (a , b), c))) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
ERROR: postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (c * m)) -> (__5 : divisible d (c * n)) -> divisible d (c * gcd_aux p m n)
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (f a = i)) -> (__1 : Leq a n) -> (__2 : f a = i) -> (b : Nat) -> (_ : and (Leq b n) (f b = j)) -> (__3 : Leq b n) -> (__4 : f b = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> f a = j
ERROR: postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (l + 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type _ __1 __2 z
ERROR: postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod (_ : cic.Univ univs.Type0) (\ T : cic.Univ univs.Type0 -> cic.prod (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) (p : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h x) y)) -> cic.prod (a : cic.Term univs.Type0 B) (b : cic.Term univs.Type0 B) (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift un
ERROR: postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (p ^ n) m) (plus n (log p m))
ERROR:  , n))$.postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (auto : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i) (Leq a n)) -> (f a = i) -> (b : Nat) -> (_ : and (Leq b n) (Eq (f b) j) (Leq b n)) -> (f b = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (a = b) -> f a = j
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (Eq m (2 * a)) (Eq m (2 * a + 1))) -> (Hind0 : Lt 1 (2 * a + 1)) -> (Hind1 : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod (x2515, x2516))
ERROR: postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod (a , aop__o__op (A , _nil , sum , b , c)) (aop__o__op (A , _nil , sum , prod (a , b), prod (a , c)))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
ERROR: 2postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.op B nil op (p1 i) (f (matita_arithmetics_nat.plus i (matita_arithmetics_nat.succ k1)))) (matita_arithmetics_bigops.big
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (_ : and (Leq a n) (f a = i) (Leq a n)) -> (f a = i) -> (b : Nat) -> (_ : and (Leq b n) (f b = j) (Leq b n)) -> (f b = j) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> f a = j
ERROR: postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op (x2 , a)) a) -> (_nilr : (a : x1) -> Eq (op (a , x2)) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op (a , op (b , c))) (op (op (a , b), c))) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
ERROR: postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S b))) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S b)))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S b))) B nil (matita_arithmetics_bigops.aop__o__op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S b))) (\ i
ERROR: postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : checker l = true) -> (__1 : l = cons Nat a tl) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
ERROR: postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (pow p q r)) -> p_ord (n , p) = mk_Prod Nat Nat q r
ERROR: postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.aop__o__op x1 x2 sum prod a) (matita_arithmetics_bigops.aop__o__op x1 x2 sum prod (matita_arithmetics_bigops.aop__o__op x1 x2 sum prod a) x2))) -> (_
ERROR: postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> dividesb (n , m) true
ERROR: postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ t0 : Lt a4 a2 -> \ t1 : Eq a1 (plus (times a3 a2) a4) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ u0 : Lt a4 a2 -> \ u1 : Eq a1 (plus (times a3 a2) a4) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\ x : Lt a4 a2 -> \ p : Eq t0 x -> Eq a1 (plus (times a3 a2) a4)) t1 u0 e0) u1) (\ _e1 : Eq (R1 (Lt a4 a2) t0 (\ x : Lt a4 a2 -> \ p : Eq t0 x -> Eq a1 (plus (times a3 a2) a4)) t1 u0 e0) u1 -> P))) (\ _e1 : Eq (R1 (Lt a4 a2) t0 (\ x : Lt a4 a2 -> \ p : Eq t0 x -> Eq a1 (plus (times a3 a2) a4)) t1 u0 e0) u1 -> P))) (\ _e1 : Eq (R1 (Lt a4 a2) t0 (\ x : Lt a4 a2 -> \ p : Eq t0 x -> Eq a1 (plus (times a
ERROR: postulate le_priml1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (2 * n) (div ((plus (log 2 n) 2) 1)) (prim (2 * n))
ERROR: postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i g2 i) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H3 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H4 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H5 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H6 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H7 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H8 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H9 : (i : Nat) -> (_ : Lt i (plus
ERROR: postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (leq : Lt n k) -> (j : Nat) -> (_ : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq p i) -> (Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (j + 1)) -> Eq p i) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (x2572 (x2571 \div x2572) + mod x2571 x2572)
ERROR: urliga talpostulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> (Hindm : Hind m n) -> (n : Nat) -> (_clearme : ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n))))) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n)))) -> (b : Nat) -> (_clearme1 : disjunktion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q m n))) -> (Hindn : Hind a b) -> (Hindab : Hind a b) -> (Hinda : Hind a b) -> (Hindb : Hind a b) -> (Hinda0 : Hind a b) -> (Hindb0 : Hind a b) -> (Hinda1 : Hind a b) -> (Hindb1 : Hind a b) -> (Hinda2 : Hind a b) -> (Hindb2 : Hind a b) -> (Hinda3 : Hind a b) -> (Hindb3 : Hind a b) -> (Hinda4 : Hind
ERROR: postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (n \div (n \div d)) d
ERROR: postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> true) (plus i b)) Nat 1 times (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (times (a ^ (c - b)) (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> true) (plus i b)) Nat 1 times (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))))
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_ : or (and (Eq m (2 * a)) (Eq m (2 * a + 1))) (and (Eq m (2 * a + 1)) (Eq m (2 * a + 1)))) -> (and (Lt 1 (2 * a + 1)) (Lt (2 * a + 1) a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516) + mod x2515 x2516)
ERROR: postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))
ERROR: postulate example1 : smallest_factor 3 = 3
ERROR: postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arith
ERROR count: 113