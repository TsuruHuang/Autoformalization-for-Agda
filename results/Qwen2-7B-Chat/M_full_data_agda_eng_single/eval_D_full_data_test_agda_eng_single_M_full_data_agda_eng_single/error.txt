ERROR: postulate divides_gcd_nm : (n : Nat) -> (m : Nat) -> divisible (gcd n m) m /\ divisible (gcd n m) n
ERROR:  postconditions).\n\npostulate foo : (x : Nat) -> Nat -> Natpostulate bar : (x : Nat) -> Natpostulate baz : (x : Nat) -> Natpostulate quux : (x : Nat) -> Natpostulate qux : (x : Nat) -> Natpostulate quuxx : (x : Nat) -> Natpostulate quuxxx : (x : Nat) -> Natpostulate quuxxxx : (x : Nat) -> Natpostulate quuxxxxx : (x : Nat) -> Natpostulate quuxxxxxx : (x : Nat) -> Natpostulate quuxxxxxxx : (x : Nat) -> Natpostulate quuxxxxxxxx : (x : Nat) -> Natpostulate quuxxxxxx :postulate quuxxxxxx :postulate quuxxxxxxx :postulate quuxxxxxxxx :postulate quuxxxxxx :postulate quuxxxxxxx :postulate quuxxxxxxxx :postulate quuxxxxxx :postulate quuxxxxxxx :postulate quuxxxxxxxx :postulate quuxxxxxx :postulate quuxxxxxxx :postulate quuxxxxxxxx :postulate quuxxxxxxpostulate quuxxxxxxxpostulate quuxxxxxxxxpostulate quuxxxxxpostulate quuxxxxxxxpostulate quuxxxxxxxxpostulate quuxxxxxpostulate quuxxxxxxxpostulate quuxxxxxxxxpostulate quuxxxxxpostulate quuxxxxxxxpostulate quuxxxxxxxxpostulatepostulate quuxxxxxpostulatepostulate quuxxxxxxxpostulatepostulate quuxxxxxxxxpostulatepostulate quuxxxxxpostulatepostulate quuxxxxxxxpostulatepostulate quuxxxxxxxxpostulatepostulate quuxxxxxpostulatepostulate quuxxxxxxxpostulatepostulate quuxxxxxxxxpostulatepostulate quuxxxxxpostulatepostulate quuxxxxxxxpostulatepostulate quuxxxxxxxxpostulatepostulatepostulate quuxxxxxpostulatepostulatepostulate quuxxxxxxxpostulatepostulatepostulate quuxxxxxxxxpostulatepostulatepostulatepostulate quuxxxxxpostulatepostulatepostulatepostulate quuxxxxxxxpostulatepostulatepostulatepostulate quuxxxxxxxxpostulatepostulatepostulatepostulatepostulate quuxxxxxpostulatepostulatepostulatepostulatepostulate quuxxxxxxxpostulatepostulatepostulatepostulatepostulatepostulate qu
ERROR: postulate extract_pair : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (D : cic.Univ univs.Type0) -> (u : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (Q : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 (matita_basics_types.Prod C D)) -> (x : cic.Term univs.Type0 C) -> (y : cic.Term univs.Type0 D) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod A B univs.Type0 (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> matita_basics_types.Prod C D) (\ a : cic.Term univs.Type0 A -> \ b : cic.Term univs.Type0 B -> Q a b) u) (matita_basics_types.mk_Prod C D x y))) -> cic.Term cic.prop (matita_basics_logic.ex A (\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\ b : cic.Term univs.Type0 B -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) u (matita_basics_types.mk_Prod A B a b))))) -> cic.Term cic.prop (matita_basics_logic.ex A (\ a : cic.Term univs.Type0 A -> matita_basics_logic.ex B (\ b : cic.Term univs.Type0 B -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod C D)) (matita_basics_types.match_Prod C D univs.Type0 (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod C D) -> matita_basics_types.Prod A B) (\ c : cic.Term univs.Type0 C -> \ d : cic
ERROR: postulate noLabel_20 : all Int (\ b -> all Int (\ a -> all Int (\ c -> if (odd a) && (odd c)) (even (plus (times a b) (times b c)))))
ERROR: postulate exists_max_forall_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> or (ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true))) (f (max n f)) = true or (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ _ : Lt i n -> Eq (f i) false))) (Eq (max n f) 0)
ERROR: postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> \ t1 : (__ : cic.Term univs.Type0 a1) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (\ __ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 t1) -> cic.prod cic.prop univs.Type1 (\ _z49 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 t1) -> cic.prod cic.prop univs.Type1 (\ _z50 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 t1) -> cic.prod cic.prop univs.Type1 (\ _z51 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 t1) -> cic.prod cic.prop univs.Type1 (\ _z52 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univ
ERROR: postulate prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> \ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a1 -> \ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 univs.Type2 (\ P : cic.Univ univs.Type1 -> cic.function univs.Type1 (cic.prod univs.Type0 univs.Type0 univs.Type1 (\ x0 : cic.Term univs.Type0 a1 -> \ x1 : cic.Term univs.Type0 a2 -> P (cic.succ univs.Type1) x0 x1)) (\ f : (__ : cic.Term univs.Type0 a1) -> \ g : (__ : cic.Term univs.Type0 a2) -> cic.prod univs.Type1 univs.Type1 univs.Type2 (\ _ : cic.Univ univs.Type1 -> cic.function univs.Type1 (cic.prod univs.Type0 univs.Type0 univs.Type1 (\ x0 : cic.Term univs.Type0 a1 -> \ x
ERROR: postulate let_clause_1648 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posq : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n1) (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S matita_arithmetics_nat.O) m) (matita_arithmetics_primes.dividesb q m)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)) q (matita_arithmetics_div_and_mod.mod n1 q)))) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides q (matita_arithmetics_nat.S n1)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_div_and_mod.div n1 q)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n1 (matita_arithmetics_div_and_mod.div n1 q))
ERROR: postulate B_SSSSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S
ERROR: postulate sum_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> matita_basics_types.match_Sum a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 (matita_basics_types.Sum a1 a2) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (\ _ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) (matita_basics_types.match_Sum a1 a2 univs.Type2 t0 u0) (matita_basics_types.match_Sum a1 a2 univs.Type2 x y)) -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (\ _ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum a1 a2)) (matita_basics_types.match_Sum a
ERROR: Output: Axiom prop80 : even 2 . \nExample3: \nInput: Translate the following English statement into Agda. prop100. We can prove that $3$ is odd. \nOutput: Axiom prop100 : odd 3 . \nInput: Translate the following English statement into Agda. We can prove that $4$ is even. \nOutput: Axiom even4 : even 4
ERROR: postulate eq_fact_pi_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact n) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S n) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> i0) (matita_arithmetics_nat.plus i (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
ERROR: postulate min_prim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt n p) (matita_arithmetics_primes.prime p)) (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ q : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop cic.prop (matita_arithmetics_primes.prime q) (\ __ : cic.Term cic.prop (matita_arithmetics_primes.prime q) -> cic.prod cic.prop cic.prop (matita_arithmetics_nat.lt q p) (\ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt q p) -> matita_arithmetics_nat.le q n)))))
ERROR: postulate let_clause_15624 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c m) (matita_arithmetics_nat.times d n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> cic.Term univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))
ERROR: postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\ y : cic.Term univs.Type0 A -> cic.prod (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) (\ e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A y)) -> Q (P y))))))
ERROR: postulate primes_below_to_bertrand : (pm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime pm)) -> (__1 : cic.Term cic.prop (matita_arithmetics_chebyshev_bertrand256.primes_below l (matita_arithmetics_nat.S pm))) -> (__2 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat p l)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p)) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ pp : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_basics_lists_list.mem matita_arithmetics_nat.nat pp l) (matita_arithmetics_nat.lt pp p)) (matita_arithmetics_nat.le p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pp))))) -> (__3 : cic.Term cic.prop (matita_basics_lists_list.mem matita_arithmetics_nat.nat pm l)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pm)) -> (__4' : cic.Term cic.prop (matita_arithmetics_nat.le pm (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) pm))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))
ERROR count: 16