postulate prop80 : even 2
postulate let_clause_1063 : \n  (∀ (f : Nat -> Nat) -> ∀ (n : Nat) -> ∀ (permf : Permut f n) -> ∀ (i j : Nat) -> \n    (i ≤ n) -> (j ≤ n) -> ∀ (a : Nat) -> \n      (a ≤ n) -> (f a ≡ i) -> \n      (a ≤ n) -> (f a ≡ i) -> ∀ (b : Nat) -> \n        (b ≤ n) -> (f b ≡ j) -> \n        (b ≤ n) -> (f b ≡ j) -> \n        (∀ (i0 : Nat) -> ∀ (l : Leq i0 n) -> ∀ (fi : Nat) -> ∀ (lf : Leq fi (f i0)) -> \n          (∀ (a : Nat) -> (a ≤ i0) -> (f a ≡ i) -> \n            (∀ (b : Nat) -> (b ≤ i0) -> (f b ≡ j) -> \n              (∀ (l : Leq a n) -> ∀ (lb : Leq b n) -> \n                (∀ (p : Permut f n) -> (∀ (k : Nat) -> (k ≤ n) -> (p k ≡ l k)) -> \n                  (∀ (q : Nat) -> (q ≤ n) -> (p q ≡ lb q)) -> \n                  (f a ≡ f b)))) -> \n          (∀ (k : Nat) -> (k ≤ i0) -> (f k ≡ l k)) -> \n          (∀ (k : Nat) -> (k ≤ fi) -> (f k ≡ lf k)))) -> \n        (∀ (a : Nat) -> (a ≡ b) -> (f a ≡ j)).
 och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $g1$ applicerat på $i$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $g2$ applicerat på $i$ och $matita_basics_bool.true$. Låt $f$ vara en funktion från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $f$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $n$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ applicerat på $p1$ applicerat på $i$ och $matita_basics_bool.true$ och $g1$ applicerat på $i$ och $matita_basics_bool.true$. \n\nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput: \nOutput:
postulate let_clause_16001 : \n  (m n a b : Nat) -> \n  (Z < n) -> \n  (Z < m) -> \n  (gcd n m == 1) -> \n  (c : Nat) -> \n  (forall (x : Nat) -> \n    (let f d = Eq (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (Z (
postulate bigop_sumI : {Aop : Set} {B : Set} {a b c : ℕ} {p : ℕ → Bool} {f : ℕ → B} → (a ≤ b) → (b ≤ c) → bigop (c - a) (\i → λ i0 → p i0 (i + a)) B nil (op B nil op (\i → λ i0 → f i0 (i + a))) ≡ op B nil op (bigop (c - b) (\i → λ i0 → p i0 (i + b)) B nil (op B nil op (\i → λ i0 → f i0 (i + b)))) ≡ op B nil op (bigop (b - a) (\i → λ i0 → p i0 (i + a)) B nil (op B nil op (\i → λ i0 → f i0 (i + a))))
let_clause_1063 : ∀ {f : ℕ → ℕ} {n : ℕ} {permf : permut f n} {i j : ℕ} → (i ≤ n) → (j ≤ n) → ∀ {a : ℕ} → (a ≤ n) → (f a ≡ i) → (a ≤ n) → (f a ≡ i) → ∀ {b : ℕ} → (b ≤ n) → (f b ≡ j) → (b ≤ n) → (f b ≡ j) → ∀ {i0 : ℕ} → (i0 ≤ n) → (i0 ∈ Leq n) → (f i0 ∈ Leq n) → (a ≡ b) → (f a ≡ j)
postulate prop80 : even 2
postulate Fact_pi_p3 : \n  (∀ n : Nat) → \n  (bigop (λ p → (even? (2 * p + 1)) * (primeb p * Nat * 1 * times (λ p → bigop (log p * (2 * n)))) * (λ i → true * Nat * 1 * times (λ i → (p ^ (2 * n) ^ (p ^ i) ^ (i + 1) ^ (2 * n + 1) * (λ p → (primeb p * Nat * 1 * times (λ p → bigop (log p * (2 * n)))) * (λ i → (true * Nat * 1 * times (λ i → (p ^ (mod (2 * n) ^ (p ^ i) ^ (i + 1) ^ 2))))))))) ≡ ((2 * n)!) .
postulate prop80 : even 2
ithmetics_bigops.Dop$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$ et $prod$ applicerat sur $b$ et $c$ et $prod$ applicerat sur $a$
postulate Permut_transpose : (i j n : ℕ) -> (i ≤ n) -> (j ≤ n) -> permut (transpose i j) n
postulate false_to_lt_max : (f : N -> Bool) (n m : N) -> 0 < n -> f n == False -> (max m (f n) <= n) -> max m (f n) < n
postulate Prop50 : forall (n : Nat), not (even n) (not (odd n))
postulate let_clause_10331 : \n  {n : Nat} (p : Nat -> Bool) (g1 g2 : Nat -> Nat) (n1 : Nat) (Hind : (i : Nat) (Lt : Eq i n1) (n2 : Nat) (Eq : Eq (p i) true) -> Eq (Hind (i) (Lt) (n2) (Eq) true) (Leq (g1 i) (g2 i))) (Hle : (i : Nat) (Lt : Eq i (suc n1)) (n2 : Nat) (Eq : Eq (p i) true) -> Eq (Hle (i) (Lt) (n2) (Eq) true) (Leq (g1 i) (g2 i))) (P : Bool) -> P -> \n  {x2515 x2516 : Nat} -> Eq x2515 (x2516 (div x2515 x2516) + mod x2515 x2516)
postulate Range_rect_CProp1_body : {A : Set} -> (Q : (x : range A) -> Prop) -> (H : (mk_range : (enum : (n : Nat) -> A) -> (upto : Nat) -> (filter : (n : Nat) -> Bool) -> mk_range A enum upto filter)) -> (x : range A) -> Q x
postulate le_minl : (i n m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__) : cic.Term cic.prop matita_arithmetics_nat.le i (matita_arithmetics_nat.min n m) -> cic.Term cic.prop matita_arithmetics_nat.le i n
postulate le_max_n : {n : ℕ} (f : ℕ → Bool) → (max n (λ x → f x) ≤ n)
postulate Filter_lstar : {B : Set} {_R : B -> Set} {__ : Nat} -> (forall z (lstar : B -> _R -> Nat -> B -> B -> Set) -> (forall z (return_sort : Set) (return_type : (z : lstar B _R __ 1 2) -> return_sort) -> (forall z (return : (z : lstar B _R __ 1 2) -> return_type z) -> (z : lstar B _R __ 1 2) -> return_type z)) -> Prop
 $__$ to $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $h$ and $k$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$, then $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to
postulate Aop : (A : Set) -> (nil : A) -> (forall (x : A) -> Aop x nil) -> Aop A nil
postulate let_clause_10336 : \n  (n : Nat) -> (m : Nat) -> (Lt : (p : Nat) -> (m : Nat) -> (Lt : (p : Nat) -> (p : Nat) -> (Lt : (p : Nat) -> (m : Nat) -> (Lt : (p : Nat) -> (1 : Nat) -> (Lt : (p : Nat) -> (p : Nat) -> (Leq : (Psi : (p : Nat) -> (pred (p) * (2 ^ (2 * p - 3))))))) -> (Nat))) -> (Nat)) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) -> (Nat) ->
postulate match_le : (n : ℕ) -> (return_sort : Sort) -> (return_type : ℕ -> Leq n -> __ -> return_sort) -> (case_le_n : return_type n n le_n) -> (case_le_S : (m : ℕ) -> (le : Leq n) -> (m : ℕ) -> return_type (m + 1) (le_S n m le) -> (__) -> return_type __ z) -> (n : ℕ) -> (le : Leq n) -> (__) -> return_type __ z
 function that maps $i$ to $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $i$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ is true, then $k$ must be equal to $n1$.\n\nOutput: \nLet_clause_10471 : ∀ {B : Set} {n1 n2 : Nat} {p1 p2 : Nat → Bool} {f1 f2 : Nat → B} {op : ACop B nil} {B0 : B} {f1' f2' : Nat → B} {op' : ACop B nil} {B1 : B} {f1'' f2'' : Nat → B} {op'' : ACop B nil} {B2 : B} {f1''' f2''' : Nat → B} {op''' : ACop B nil} {B3 : B} {f1'''' f2'''' : Nat → B} {op'''' : ACop B nil} {B4 : B} {f1''''' f2''''' : Nat → B} {op''''' : ACop B nil} {B5 : B} {f1'''''' f2'''''' : Nat → B} {op'''''' : ACop B nil} {B6 : B} {
postulate Eq_rect_CProp2 : {A : Univ} -> (x : Term A) -> (Q : (x31 : Term A) -> (x32 : prop) -> eq A x x31) -> (H_refl : prop) -> (x31 : Term A) -> (x32 : prop) -> eq (Q x31 x32) (Q_refl x H_refl) where\n  refl : Eq_rect_CProp2 A x Q H_refl x31 x32\n  refl = refl
postulate let_clause_1063 : {i0 n : Nat} (f : Nat -> Nat) (permf : Perm f n) (i j : Nat) (i_leq_n : i <= n) (j_leq_n : j <= n) (a : Nat) (a_leq_n : a <= n) (f_a_eq_i : f a = i) (b : Nat) (b_leq_n : b <= n) (f_b_eq_j : f b = j) -> (b <= n) -> (f_b_eq_j) -> (forall (injf : (Nat -> Leq n)) -> injf a = injf b -> injf i = injf j) -> f a = j.
postulate split_rev : {univs : Universe} -> {cic : Universe} -> {H : univs.Type0} -> {__ : Term univs.Type0} -> {__1 : list H} -> {__2 : Term univs.Type0} -> {nat : Type0} -> even (__2)
postulate let_clause_1033 : \n  (n : Nat) -> (2^7 <= n) -> \n  (p : Nat) -> (sqrt (2 * n) + 1 <= p) -> \n  (p < 2 * n + 1) -> \n  (leb 2 (k (2 * n , p)) == True) -> \n  (2 * n < p^2) -> \n  (forall (x2515 x2516 : Nat) -> x2515 == x2516 * (x2515 div x2516) + mod (x2515 , x2516))
postulate Eq_length_to_mem_all : \n  (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) \n  (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) \n  -> (__) : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat (matita_basics_lists_list.length matita_arithmetics_nat.nat l) n)) \n  -> (__)1 : cic.Term cic.prop (matita_basics_lists_list.unique matita_arithmetics_nat.nat l) \n  -> (__)2 : (x : univs.Type0 matita_arithmetics_nat.nat) -> (__)2 : cic.Term cic.prop (matita_arithmetics_nat.lt x n) \n  -> (i : matita_arithmetics_nat.nat) \n  -> (__)3 : cic.Term cic.prop (matita_arithmetics_nat.lt i n) \n  -> (cic.Term) holds for (cic.prop) and (matita_basics_lists_list.mem matita_arithmetics_nat.nat i l)
postulate Lt_exp_to_lt1 : (a : ℕ) -> (n m : ℕ) -> (0 < a) -> (a ^ n < a ^ m) -> n < m
postulate max_prime : ∀ n : ℕ -> (ℕ -> Bool) -> ℕ -> Bool  \nnat : ∀ n : ℕ -> Bool
postulate prop80 : even 2
postulate let_clause_1033 : \n  (∀ n → Nat n → n > 1 → \n   (Prime (2 * n) → \n    (1 < 2 * n → \n     (∀ H1 → (→ Nat m → (→ Divisible m (2 * n) → (→ Lt 1 m) → (→ Eq m (2 * n)) → Bool)) → \n      (∀ x2515 x2516 → x2515 = x2516 * (x2515 div x2516) + mod x2515 x2516))))))
postulate List_rect_CProp1_body : (A : univers.Type0) -> (Q_ : (x : Term) -> (list A) -> univers.Univ -> prop) -> (H_nil : Term -> prop -> Q_ x nil A) -> (H_cons : (x : Term) -> A -> (x' : Term) -> (list A) -> (x'' : prop) -> Q_ x' x'' A -> Q_ x (cons x'' x' x) A) -> (x : Term) -> (list A) -> prop -> prop
postulate let_clause_16002 : \n  (m n a b : Nat) -> (Z < n) -> (Z < m) -> (gcd n m == 1) -> \n  (c : Nat) -> (ex : Eq (c * n - d * m) Z) -> (Eq (d * m - c * n) Z) -> \n  (Eq (d * m - c * n) Z) -> (gcd m n == (m * d - n * c))
postulate True_inv_rect_CProp2 : \n  (Hterm : cic.Term (cic.prop) (matita_basics_logic.True)) ->\n  (P : (_z173 : cic.Term (cic.prop) (matita_basics_logic.True)) -> \n   cic.Univ (cic.prop)) ->\n  (forall (_H1 : (cic.Term (cic.prop) (matita_basics_logic.eq (cic.lift (cic.prop) (univs.Type2) matita_basics_logic.True Hterm matita_basics_logic.I))) -> \n           (P (matita_basics_logic.I))), \n   cic.Term (cic.prop) (P Hterm))
postulate propTrue_min : (f : Nat -> Bool) (b : Nat) -> (f b == true) -> (forall (n : Nat), min n b f == b)
$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and functions $_assocr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$.\n\nOutput: \npostulate Aop_rect_Type2_body : \n  {A : univs.Type0} \n  (Q_ : (x : univs.Type0) (A : A) -> Aop A (cic.lift univs.Type0 univs.Type2 A) -> \n   univs.Type2) \n  (H_mk_Aop : (op : (x : univs.Type0) (A : A) -> (x1 : univs.Type0) (A : A) -> \n   univs.Type0) \n   (nill : (a : univs.Type0) (A : A) -> prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) A) \n   (cic.lift univs.Type0 univs.Type2 A) (op (cic.lift univs.Type0 univs.Type2 A) (cic.lift univs.Type0 univs.Type2 A) a))) \n  (nilr : (a : univs.Type0) (A : A) -> prop (matita_basics_logic.eq (cic.Term) (cic.Term A)) \n   (cic.lift univs.Type0 univs.Type2 A) (op (cic.lift univs.Type0 univs.Type2
postulate let_clause_1068 : \n  (∀ (f : Nat -> Nat) -> \n   (∀ (n : Nat) -> \n    (∀ (permf : Permut f n) -> \n     (∀ (i j : Nat) -> \n      (i ≤ n) -> \n      (j ≤ n) -> \n      (∀ (a : Nat) -> \n       (a ≤ n) -> \n       (f a == i) -> \n       (∀ (b : Nat) -> \n        (b ≤ n) -> \n        (f b == j) -> \n        (∀ (i0 : Nat) -> \n         (∀ (leq : Leq i0 n) -> \n          (∀ (elem : Leq (f i0) n) -> \n           (∀ (f_elem : (λ (x : Nat) -> Leq x (f x)) i0) -> \n            (∀ (injf : Injn f n) -> \n             (a == b) -> \n             (f a == i))))))))))))
postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (x_891 : ACop A) -> _nil -> Type4) -> (H_mk_ACop : (aop : Aop A) -> _nil -> (comm : (a : A) -> (b : A) -> Eq (op A) (op A) aop a b) -> (Q_ (mk_ACop aop _nil comm) (aop _nil) (comm a b))) -> (x_891 : ACop A) -> _nil -> Q_ x_891
postulate let_clause_1575 : \n  {m n a b : Nat} -> \n  (0 < n) -> \n  (0 < m) -> \n  (1 == gcd n m) -> \n  (let {c : Nat; _clearme : ex Nat (NatEq (n * c - m * d) 1)) in \n   let {d : Nat} in \n   (if (c * n - d * m) == 1 then \n    (forall (x : Nat), x == x (n * c - m * d)) \n    else \n    false))
postulate psi_1 : even 2
postulate let_clause_1549 : \n  (∀ m n ∈ Nat) → (0 < n) → (0 ≡ m) → ∃ x ∈ Nat (x ≡ (x - m))
postulate true_to_le_min : (f : Nat -> Bool) -> (n m : Nat) -> (b : Nat) -> (H : b <= m) -> (H' : f m == true) -> min n b f <= m
postulate Ord_O_to_not_divides : {m : ℕ} {p : ℕ} -> (0 < m) -> (prime p) -> (ord m p == 0) -> ¬(divides p m)
$ and $B$ and $nil$ and $aop__o__op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $j$. \n\nOutput: \nbigop_commute : (n m : Nat) -> (p11 : Nat -> Bool) -> (p12 : Nat -> Nat -> Bool) -> (p21 : Nat -> Bool) -> (p22 : Nat -> Nat -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : Nat -> Nat -> B) -> (H1 : 0 < n) -> (H2 : 0 < m) -> (H3 : (i j : Nat) -> (Lt i n) -> (Lt j m) -> (Eq (andb (p11 i) (p12 i j)) (andb (p21 j) (p22 i j))) -> (bigop n (\i -> p11 i B nil (aop__o__op B nil op)) (\i -> bigop m (\j -> p12 i j B nil (aop__o__op B nil op)) (\j -> f i j)) == bigop m (\j -> p21 j B nil (aop__o__op B nil op)) (\j -> bigop n (\i -> p22 i j B nil (aop__o__op B nil op)) (\i -> f i j))) \n\nThe translation should be accurate, and the output should be in the exact same format as the given examples.\nbigop_commute : (n m : Nat) -> (p11 : Nat -> Bool) -> (p12 : Nat -> Nat -> Bool) -> (p21 : Nat -> Bool) -> (p22 : Nat -> Nat -> Bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : Nat -> Nat -> B) -> (H1 : 0 < n) -> (H2 : 0 < m) -> (H3 : (i j : Nat) -> (Lt i n) -> (Lt j m) -> (Eq (andb (p11 i) (p12 i j)) (andb (p
postulate Nat_rect_CProp2 : {Q : Nat -> Prop} -> (H_O : Q zero) -> (H_S : (n : Nat) -> (x : Q n) -> Q (suc n)) -> (n : Nat) -> Q n
postulate True_rect_CProp5 : (Q : (x_56 : cic.Term (cic.prop)) -> matita_basics_logic.True -> cic.Univ (cic.prop)) -> (H_I : cic.Term (cic.prop) (Q _I)) -> (x_56 : cic.Term (cic.prop) matita_basics_logic.True) -> cic.Term (cic.prop) (Q x_56)
postulate let_clause_1033 : \n  (n : Nat) -> \n  (one < n) -> \n  (two * n) is prime -> \n  (one < (two * n)) -> \n  (forall (H1 : Nat -> Divisible -> Nat -> Lt -> Eq -> Nat) (m : Nat) (div : Divisible) (prod : Nat) (less : Lt) (eq : Eq) -> \n    (forall (x2515 : Nat) (x2516 : Nat) -> \n      x2515 ≡ (two * (x2516 * (x2515 / x2516)) + (mod x2515 x2516)))).
postulate Divides_to_p_ord : {p a b c d n m : N} -> (0 < n) -> (0 < m) -> (prime p) -> (divides n m) -> (p_ord n p == mk_Prod Nat Nat a b) -> (p_ord m p == mk_Prod Nat Nat c d) -> (divides d b) /\ (a <= c)
postulate congruent_ab : (m n a b : ℕ) -> (0 < n) -> (0 < m) -> (gcd n m == 1) -> (ex Nat (\x -> (congruent x a m) && (congruent x b n)))
Output: \npostulate let_clause_1553 : \n  {n n0 : Nat} {ex : Vec Nat 1} {f : Nat -> Bool} \n  -> (f 0 = (Eq n0 (2 * 0)) || (f 0 = (Eq n0 ((2 * 0) + 1))) && (f 1 = (Eq n0 (2 * 1)) || (f 1 = (Eq n0 ((2 * 1) + 1)))))\n  -> ((n0 = (a + (a + 1))) -> True)
postulate Enum : ∀ {univs : Type} -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> univs.Type0 -> un
postulate ACop_rect_Type3_body : \n  (A : Set) -> (A_0 : A) -> \n  (Q : (x_895 : ACop A A_0) -> Set3) -> \n  (H_mk_ACop : (aop : Aop A A_0) -> (comm : Eq (op A A_0 aop) (op A A_0 (op A A_0 a b))) -> \n  Q (mk_ACop A A_0 aop comm)) -> \n  (x_895 : ACop A A_0) -> Q x_895
postulate f : Nat -> Bool\npostulate b : Nat\npostulate f_b_true : f b ≡ true\npostulate n : Nat\nlemma : min n b f ≡ b\nproof : lemma = refl
postulate Mk_Aop : {A : Set} -> A -> (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c) -> Aop A nil.
postulate Pair_destruct_2 : \n  ∀ {univs : Universe} {A B : univs.Type0} (a : A) (b : B) (c : univs.Type0) (P : (A × B) → Prop) (Q : (cic.prop univs.Type0) → (cic.eq univs.Type0 univs.Type2 (A × B) (snd (A × B))) → Prop) →\n  ((matita_basics_types.mk_Prod A B a b) ≡ c) →\n  P (matita_basics_types.Prod A B a b) →\n  Q (cic.lift univs.Type0 univs.Type2) (matita_basics_types.snd (A × B)) (matita_basics_types.Prod A B a b c).
postulate Range_inv_rect_CProp2 : (x1 : cic.Univ) -> (Hterm : cic.Term) -> (matita_arithmetics_bigops.range x1) -> (P : (z1680 : cic.Term) -> (matita_arithmetics_bigops.range x1) -> cic.Univ -> cic.prop) -> (H1 : (enum : (__) -> cic.Term) -> (__) -> cic.Term -> (upto : cic.Term) -> (filter : (__) -> cic.Term -> matita_basics_bool.bool) -> (z1681 : cic.Term) -> (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1) Hterm (matita_arithmetics_bigops.mk_range x1 enum upto filter))) -> cic.Term) -> (cic.Term) -> (P (matita_arithmetics_bigops.mk_range x1 enum upto filter) Hterm) -> cic.prop (P z1680 (matita_arithmetics_bigops.range x1) (matita_arithmetics_bigops.mk_range x1 enum upto filter))
postulate let_clause_1561 : \n  (p m n : ℕ) → (0 < p) → (1 ≡ gcd p m) → (p ∣ m * n) → \n  (c : ℕ) → (m * n ≡ p * c) → \n  (a : ℕ) → \n  (let { x = ex Nat (λ b → Eq (a * p - b * m) (gcd p m)) (λ b → Eq (b * m - a * p) (gcd p m)) in \n    ex Nat λ b → Eq (a * p - b * m) (gcd p m) ∨ Eq (b * m - a * p) (gcd p m)) → \n  (if (gcd p m ≡ a * p - b * m) then (a * p - m * b ≡ 1) else (b * m - a * p ≡ 1)).
postulate let_mop : (n : Nat) -> (p : Nat -> Bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : Nat -> B) -> (a : B) -> (x_969 : B) -> (x_970 : B) -> B
let_clause_1562 : ∀ (m n a b : ℕ) -> (0 < n) -> (0 < m) -> (gcd n m == 1) -> ∀ (c : ℕ) -> (∀ (ex : _clearme) -> (Nat) -> (λ d -> (Eq (n * c - m * d) 1) ⊎ (Eq (m * d - n * c) 1))) -> ∀ (d : ℕ) -> (Eq (n * c - m * d) 1) ∨ (Eq (m * d - n * c) 1) -> (Eq (n * c - m * d) 1) -> (Eq (n * a - m * b) 1)
postulate Range_rect_Type2_body : (A : univs.Type0) -> (Q : (x : Term univs.Type0) -> (range A) -> Term univs.Type0) -> (H_mk_range : (enum : (x : Term univs.Type0) -> nat -> Term univs.Type0) -> (A : Term univs.Type0) -> (upto : nat) -> (filter : (x : Term univs.Type0) -> nat -> Term univs.Type0) -> (bool) -> Term univs.Type2) -> (Q (mk_range A) (enum A upto) (filter x upto)) = (x : Term univs.Type0) -> (range A) -> Q x
postulate Eq_length_to_mem_all : {n : ℕ} {l : List ℕ} (len-eq : length (Nat , l) ≡ n) {x : ℕ} {mem-x-l : x ∈ l} (f : (i : ℕ) → (x : ℕ) → (mem-x-l : x ∈ l) → (Lt i n)) → (∀ (i : ℕ) → i < n → mem (Nat , x) l)
postulate propK : (n p : Nat) -> Nat
postulate NoLabel_8 : (n : ℕ) -> (natPred n + 1 / n < 2) -> (n ^ 2 + 1 / (n ^ 2) < 4)
postulate le_exp_to_le : (b n m : N) -> (1 < b) -> (b ^ n <= b ^ m) -> n <= m
t$ and $p$ and $P$ applied to $p$ and $matita_basics_types.match_Prod$ applied to $A$ and $B$ and $univs.Type0$ and the function that maps $0$ to $C$ and the function that maps $lft$ and $rgt$ to $T$ applied to $lft$ and $rgt$.\nOutput: \nOutput: \nPair_elim. Axiom example : (forall (A B : univ) (C : univ) (T : (Term -> A -> (Term -> B -> Term)) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> A -> Term -> Prop) -> (Term -> A -> Term -> Prop) -> (Term -> A -> Term -> Prop) -> Term -> Prop) -> (forall (p : Term) (matita_basics_types.Prod A B) -> (forall (P : (Term -> Prod A B -> Term -> Prop)) -> (forall (lft : Term) (rgt : Term) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> Term -> Prop) -> (forall (lft : Term) (rgt : Term) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> Term -> Prop) -> (forall (lft : Term) (rgt : Term) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> Term -> Prop) -> (forall (lft : Term) (rgt : Term) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> (Term -> Prod A B -> Term -> Prop) -> Term -> Prop)) -> Prop) -> Prop) -> Prop) -> Prop) -> Prop) ->
postulate ACop_rect_CProp5_body : (A : univ) -> (nil : term) -> (A : univ) -> (Q_ : (x : term) -> (A : univ) -> (acop : matita_arithmetics_bigops.ACop) -> term -> prop) -> (forall (aop : term) (A : matita_arithmetics_bigops.Aop) (comm : (a : term) -> (A : univ) -> (b : term) -> (A : univ) -> term -> prop) -> (forall (x : term) -> (acop : matita_arithmetics_bigops.ACop) -> term -> prop) -> Q_ (matita_arithmetics_bigops.mk_ACop A nil aop comm)) -> (forall (x : term) -> (acop : matita_arithmetics_bigops.ACop) -> (A : univ) -> prop) -> prop.
postulate prop80 : even 2
postulate To_max : forall {univs : Type} {matita_arithmetics_nat : Type} (cic : Type) (Term : cic -> Type) (prop : cic -> Type) (le : nat -> nat -> prop) (i : nat) (n : Term nat) (m : Term nat), (n le i) -> (m le i) -> le (max n m) i
postulate le_ind : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop matita_arithmetics_nat.le n x) -> cic.Univ cic.prop) -> (H_le_n : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> Q n (matita_arithmetics_nat.le_n n)) -> (H_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_419 : cic.Term cic.prop matita_arithmetics_nat.le n m) -> (x_421 : cic.Term cic.prop Q m x_419) -> (x : cic.Term cic.prop Q (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S n m x_419))) -> (forall (x_417 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_418 : cic.Term cic.prop matita_arithmetics_nat.le n x_417) -> Q x_417 x_418)
postulate let_previous_prime7 : \n  (n m : cic.Term univs.Type0 (matita_arithmetics_nat.nat))\n  -> (ltml : cic.Term (cic.prop) (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n m))) \n  -> cic.Term univs.Type0 (matita_arithmetics_nat.nat)
postulate B1_def : (n : cic.Term univs.Type0) -> matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat (matita_arithmetics_chebyshev_bertrand.B1 n (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\p -> matita_arithmetics_primes.primeb p matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\p -> matita_arithmetics_exp.exp p matita_arithmetics_nat.times (matita_arithmetics_chebyshev_psi_bounds.bool_to_nat (matita_arithmetics_nat.leb (matita_arithmetics_chebyshev_bertrand.k n p) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k n p)))))))).
postulate Le_plus : (n1 n2 : Nat) (m1 m2 : Nat) -> (n1 <= n2) -> (m1 <= m2) -> (n1 + m1) <= (n2 + m2)
postulate prop80 : even 2
postulate Eq_rect_CProp1 : {A : cic.Univ} -> (x : cic.Term) -> (Q_ : (x_34 : cic.Term) -> (x_35 : cic.Term) -> (x_34 : A) -> (x_35 : A) -> (cic.Term) -> (cic.prop)) -> (x_34 : A) -> (x_35 : A) -> (x : A) -> (H_refl : cic.Term) -> (Q_ x x x x H_refl x) -> (x_34 : A) -> (x_35 : A) -> (x : A) -> (x_34 : A) -> (x_35 : A) -> (cic.Term) -> (cic.prop) -> (Q_ x_34 x_35 x x_34 (matita_basics_logic.refl A x) x)
postulate let_clause_15621 : \n  (∀ m n a b : ℕ) → (0 < n) → (0 < m) → (gcd n m ≡ 1) → \n  (∀ c : ℕ) → (∃ ex : ℕ) → (∀ d : ℕ) → \n  (Eq (product c n - product d m) 1) ∨ (Eq (product d m - product c n) 1) → \n  (Eq (product n c - product m d) 1)
postulate prop80 : even 2
postulate Range_rect_CProp5 : \n  {A : cic.Univ} \n  {Q_ : (x : cic.Term) (r : matita_arithmetics_bigops.range A) → univs.Type0}\n  → (∀ enum : (x : cic.Term) (n : matita_arithmetics_nat.nat) → univs.Type0 → cic.Term)\n  → (∀ upto : (x : cic.Term) (n : matita_arithmetics_nat.nat) → univs.Type0 → cic.Term)\n  → (∀ filter : (x : cic.Term) (n : matita_arithmetics_nat.nat) → univs.Type0 → matita_basics_bool.bool → cic.Term)\n  → (∀ (r : matita_arithmetics_bigops.range A) → cic.Term → cic.prop → Q_ _ _ _)\n  → (∀ (x : cic.Term) (r : matita_arithmetics_bigops.range A) → cic.Term → cic.prop → Q_ _ _ _)
postulate let_clause_73 : (x y z x134 x135 x136 : ℕ) → (x134 + (x135 + x136)) ≡ (x135 + (x134 + x136))
postulate Square_double : forall (n : matita_arithmetics_nat.nat), matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) n n.
postulate Iff_or_l : {A B C : cic.Univ} -> (A -> B -> cic.Term cic.prop) -> (matita_basics_logic.iff A B -> cic.Term cic.prop) -> (C -> matita_basics_logic.Or C A -> matita_basics_logic.Or C B -> cic.Term cic.prop)
postulate let_clause_1078 : \n  ∀ {a b q r q1 r1 : ℕ} (_clearme : div_mod_spec a b q r) (h1 : r < b) (h2 : a ≡ q * b + r) (_clearme0 : div_mod_spec a b q1 r1) (h3 : r1 < b) (h4 : a ≡ q1 * b + r1) (h5 : q ≤ q1) (h6 : q < q1) -> a ≡ r + b * q
postulate Sum_rect_Type4 : forall (A B : cic.Univ) (Q_ : (x : cic.Term) -> (matita_basics_types.Sum A B) -> cic.Univ -> univs.Type0) (H_inl : (x : cic.Term) -> A -> cic.Term -> Q_ (matita_basics_types.inl A B) x) (H_inr : (x : cic.Term) -> B -> cic.Term -> Q_ (matita_basics_types.inr A B) x) (x_526 : (matita_basics_types.Sum A B)), (x_526 : cic.Term) -> univs.Type4 -> Q_ x_526 (x_526 : matita_basics_types.Sum A B).
postulate Lt_max_n : (f : ℕ → Bool) → (n : ℕ) → (n > 0) → max n (f n) < n
postulate Lstar_lstar_r : (B : cic.Univ) -> (R : cic.Term) -> (l : cic.Term) -> (b1 : cic.Term) -> (b2 : cic.Term) -> (__) -> (cic.Term) -> (cic.prop) -> (matita_arithmetics_lstar.lstar_r B R l b1 b2) .
postulate not_found_max_spec : (n : Nat) -> (f : Nat -> Bool) -> ((i : Nat) -> (Lt : Eq i n) -> (Eq : Eq (f i) absurdity)) -> (max_spec n f 0)
postulate Comm_body : (A : cic.Univ) -> (nil : Term) -> (A) -> (xxx : Term) -> (matita_arithmetics_bigops.ACop) -> (A) -> (nil) -> (A) -> (matita_basics_logic.eq) -> (cic.prop) -> (A) -> (matita_arithmetics_bigops.op) -> (A) -> (nil) -> (matita_arithmetics_bigops.aop) -> (A) -> (nil) -> (xxx) -> (a) -> (b) -> (matita_arithmetics_bigops.op) -> (A) -> (nil) -> (matita_arithmetics_bigops.aop) -> (A) -> (nil) -> (xxx) -> (b) -> (a)
postulate let_clause_10131 : {f : Nat -> Bool} {n m n0 : Nat} -> (max (n0 + 1 , f) = m) -> (absurdity = f m) -> (forall i j -> j + 1 < n0 + 1 -> forall x7 -> x7 = m + x7))
postulate Minus_minus_associative : forall (x y z : cic.Term univs.Type0) (l1 : matita_arithmetics_nat.le z y) (l2 : matita_arithmetics_nat.le y x), matita_basics_logic.eq (matita_arithmetics_nat.eq nat (matita_arithmetics_nat.minus x (matita_arithmetics_nat.minus y z)) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus x y) z)) .
postulate let_clause_10331 : \n  {n : ℕ}\n  (two_to_eight_leq_n : 2 ^ 8 ≤ n)\n  {m : ℕ}\n  (three_leq_m : 3 ≤ m)\n  ((log_base_two_m_plus_two_leq_m : (log_base_2 m) + 2 ≤ m)\n  -> x2515 x2516 : ℕ\n  -> x2515 = x2516 * (x2515 ÷ x2516) + mod x2515 x2516)
postulate le_to_lt_to_lt : {n m p : ℕ} -> (n ≤ m) -> (m < p) -> (n < p)
postulate let_clause_16001 : \n  (m n a b : Nat) -> \n  (nat_gt 0 n) -> \n  (nat_gt 0 m) -> \n  (eq 1 (gcd n m)) -> \n  (c : Nat) -> \n  (ex : Ex Nat) -> \n  (Eq (sub (mult c n) (mult d m)) 1) -> \n  (Eq (sub (mult d m) (mult c n)) 1) -> \n  (eq (sub (mult n c) (mult m d)) (gcd m n))
postulate prop80 : even 2
postulate P_ord_to_exp1 : \n  ∀ p n q r : cic.Term univs.Type0 (matita_arithmetics_nat.nat) → \n  ∀ __ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) → \n  ∀ __1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) → \n  ∀ __2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod (matita_arithmetics_nat.nat) (matita_arithmetics_nat.nat) (matita_arithmetics_ord.p_ord n p (matita_basics_types.mk_Prod (matita_arithmetics_nat.nat) (matita_arithmetics_nat.nat) q r)))) (matita_arithmetics_nat.nat)) → \n  (cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.Not (matita_arithmetics_primes.divides p r)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_nat.nat)) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))))
$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n
postulate Div_mod_spec_rect_CProp4_body : (n m q r : univs.Type0) (Q : (x : cic.Term (cic.prop)) -> (matita_arithmetics_div_and_mod.div_mod_spec n m q r) -> cic.Univ (cic.prop)) -> (forall (H_div_mod_spec_intro : (x : cic.Term (cic.prop)) -> (matita_arithmetics_nat.lt r m) -> (x : cic.Term (cic.prop)) -> (matita_basics_logic.eq (cic.lift (univs.Type0) (univs.Type2) (matita_arithmetics_nat.nat) n) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q m) r)) -> (x : cic.Term (cic.prop)) -> Q x (matita_arithmetics_div_and_mod.div_mod_spec_intro n m q r x (matita_arithmetics_nat.lt r m))) -> (forall (x : cic.Term (cic.prop)) -> (matita_arithmetics_div_and_mod.div_mod_spec n m q r) -> cic.Term (cic.prop) (Q x (matita_arithmetics_div_and_mod.div_mod_spec n m q r))))
module Example1063 where\n\npostulate \n  f : (ℕ -> ℕ)\n  n : ℕ\n  permf : Permutation f n\n  i j : ℕ\n  i_leq_n : i ≤ n\n  j_leq_n : j ≤ n\n  a : ℕ\n  a_leq_n : a ≤ n\n  f_a_i : f a = i\n  f_a_i' : f a = i\n  b : ℕ\n  b_leq_n : b ≤ n\n  f_b_j : f b = j\n  f_b_j' : f b = j\n\nforall_injective : (g : (ℕ -> ℕ)) -> (leq_g : (ℕ -> Leq) -> (ℕ -> Leq)) -> (injf : Permutation g (f i0)) -> (injn : Permutation f (f i0)) -> (a_eq_b : a = b) -> f a = j\n  where\n    open Permutation using (perm)\n    open Leq using (≤)
postulate Le_ind_body : \n  ∀ n : Nat -> \n  (∀ x : Nat -> Le n x -> Bool -> Bool) -> \n  (n , Le n n) -> \n  (∀ m : Nat -> x : Nat -> Le n m -> x -> (m , Le m (suc m)) -> (n , Le n (suc m))) -> \n  (∀ x : Nat -> Le n x -> Bool) -> \n  (∀ x : Nat -> Le n x -> Bool) -> \n  (∀ x : Nat -> Le n x -> Bool).
postulate let_clause_16001 : \n  (∀ (m n a b : ℕ) → (0 < n) → (0 < m) → (1 ≡ gcd n m) → (∀ (c : ℕ) → (∃ (ex : ℕ → Prop) → (ex c) ≡ ((c * n) - (d * m)) ∨ ((d * m) - (c * n)) ≡ 1) → (∀ (d : ℕ) → ((c * n) - (d * m) ≡ 1 ∨ (d * m) - (c * n) ≡ 1) → ((c * n) - (d * m) ≡ 1) → (n * c - m * d) ≡ (gcd m n)))
postulate F_false_to_le_max : \n  (f : (cic.Term univs.Type0) -> (matita_arithmetics_nat.nat) -> (cic.Term univs.Type0) -> (matita_basics_bool.bool)) -> \n  (forall n p : (cic.Term univs.Type0) -> (matita_arithmetics_nat.nat), \n   forall i : (cic.Term univs.Type0) -> (matita_basics_logic.ex) matita_arithmetics_nat.nat f i, \n   forall i : (cic.Term univs.Type0) -> (matita_basics_bool.true), \n   forall m : (cic.Term univs.Type0) -> (matita_arithmetics_nat.nat), \n   forall i : (cic.Term univs.Type0) -> (matita_arithmetics_nat.lt) p m -> (cic.prop) -> (matita_basics_logic.eq) (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) f i, \n   forall i : (cic.Term univs.Type0) -> (matita_basics_bool.false), \n   (cic.Term univs.Type0) (cic.prop) (matita_arithmetics_nat.le) (matita_arithmetics_minimization.max n) f p)
postulate let_clause_15611 : \n  (p m n : Nat) ->\n  (0 < p) ->\n  (gcd p m == 1) ->\n  (p %* m == p %* n) ->\n  (m * n == p * c) ->\n  (a : Nat) ->\n  (∀ (_clearme0 : ex (Nat)) (b : Nat) ->\n  ((p * a - m * b == gcd p m) || (m * b - p * a == gcd p m)) ||\n  (m * b - p * a == gcd p m)) ->\n  ((m * b - p * a == 1)) ->\n  (m * n - p * a == 1)
postulate prime_nth_prime : (n : ℕ) → prime (nth_prime n)
 to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $op$ applied to $x2$ and $a$ and $a$, there exists a function $f$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $y$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ such that for all elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and $b$ of $cic.Term$ of $univs.Type0$ and $x1$, $f$ applied to $a$ and $b$ is equal to $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P$ applied to $f$ applied to $a$ and $b$ and $Hterm$ applied to $a$ and $b$ and $P
postulate le_div : {n m : ℕ} → (0 < n) → (m ≤ ((m / n) * n + m % n))
postulate Prod_inv_rect_Type3 : \n  (x1 x2 : cic.Univ) -> \n  (Hterm : cic.Term) -> \n  (matita_basics_types.Prod x1 x2) -> \n  (P : forall (_z1248 : cic.Term) (matita_basics_types.Prod x1 x2), cic.Univ) -> \n  (forall (_fst : cic.Term) (_snd : cic.Term) (_z1249 : cic.Term (cic.prop)) (eq : matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) (P (matita_basics_types.mk_Prod x1 x2 _fst _snd)), cic.Term univs.Type3 P (matita_basics_types.mk_Prod x1 x2 _fst _snd)) -> \n  cic.Term univs.Type3 (P Hterm).
postulate let_clause_1047 : \n  (k n : ℕ) (p : ℕ → Bool) (B : Set) (nil : B) (op : B → B → B) (f : ℕ → B) →\n  (Hind : (i : ℕ) → (leq : Leq n i) → (lt : Lt i j) → Eq (p i) (bigop (op (f i) (bigop nil (λ _ → op (f i) (op (f i) ...)))))) →\n  (Hfalse : (i : ℕ) → (leq : Leq n i) → (lt : Lt i (plus j one)) → Eq (p i) (contr (Eq (bigop (f i) (λ _ → ...)) (Eq (p i) B nil (op (f i) ...)))) →\n  (∀ x2571 x2572, Eq x2571 (plus (mult x2572 (quot x2571 x2572)) (mod x2571 x2572)))
postulate bigop_diff : {B : Set} {nil : B} {op : ACop B nil} {f : Nat -> B} {i n : Nat} -> (p : Nat -> Bool) -> (i < n) -> (p i = true) -> bigop n (\x -> andb (notb (eqb i x)) (p x) B nil (aop__o__op B nil op) (\x -> f x)) = (aop__o__op B nil op) (f i) (bigop n (\x -> f x) (\x -> andb (notb (eqb i x)) (p x) B nil (aop__o__op B nil op) (\x -> f x)))
postulate let_mop : \n  {n : cic.Term univs.Type0 (matita_arithmetics_nat.nat)}\n  {p : (__) -> cic.Term univs.Type0 (matita_basics_bool.bool)}\n  {B : cic.Univ univs.Type0}\n  {nil : cic.Term univs.Type0 B}\n  {R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)}\n  -> (f : (__) -> cic.Term univs.Type0 B)\n  -> (a : cic.Term univs.Type0 B)\n  -> (x_969 : cic.Term univs.Type0 B)\n  -> (x_970 : cic.Term univs.Type0 B)\n  -> (cic.Term univs.Type0 B)
postulate let_clause_1617 : \n  (p m n : Nat) -> (p > zero) -> (m gcd p) -> (p % m * n) -> (c : Nat) -> (m * n == p * c) -> \n  (a : Nat) -> \n  (ex : (b : Nat) -> Eq (a * p - b * m) (gcd p m) \/ Eq (b * m - a * p) (gcd p m)) -> \n  (d : Nat) -> \n  (Eq (gcd p m) (a * p - b * m) \/ Eq (gcd p m) (b * m - a * p)) -> \n  (Eq (gcd p m) (a * p - b * m)) -> \n  (Eq (p * a - m * b) (gcd p m))
postulate Not_rect_CProp4_body : (A : Universe) -> Prop -> (x100 : Term) -> (not A) -> (H_nmk : (x101 : Term) -> (A -> Term) -> False -> Term -> (Q (nmk A x101))) -> (forall x100 (not A) -> Term -> Prop -> Q x100)
postulate Range_rect_CProp3_body : (A : cic.Univ) -> (Q_ : (x_933 : cic.Term) -> (matita_arithmetics_bigops.range A) -> Univ) -> (\forall (H_mk_range : (enum : (__) -> (matita_arithmetics_nat.nat)) -> (A : Univ) -> (upto : cic.Term) -> (matita_arithmetics_nat.nat) -> (filter : (__) -> (matita_arithmetics_nat.nat) -> (cic.Term) -> (matita_basics_bool.bool)) -> (Q_ (matita_arithmetics_bigops.mk_range A (enum _) A upto filter))) -> (\forall (x_933 : cic.Term) -> (matita_arithmetics_bigops.range A) -> (cic.Term) -> (cic.prop) -> (Q_ x_933)))
let_clause_1068 : ∀ (f : ℕ → ℕ) → (n : ℕ) → (permf : permut f n) → (i j : ℕ) → (i ≤ n) → (j ≤ n) → (a : ℕ) → (a ≤ n) → (f a = i) → (a ≤ n) → (f a = i) → (b : ℕ) → (b ≤ n) → (f b = j) → (b ≤ n) → (f b = j) → (∀ (i0 : ℕ) → (injf : i0 ≤ n) → (injn : f i0 ≤ n) → (inj : (a = b) → (f a = i)) → (a = b) → (f a = i))
postulate noLabel_8 : {n : N} -> (n + 1) / n < 2 -> (n ^ 2 + 1) / (n ^ 2) < 4
postulate Divides_to_mod_O : {n m : ℕ} -> (0 < n) -> (divides m n) -> (mod m n ≡ 0)
postulate ord_times : {p m n : ℕ} -> (0 < m) -> (0 < n) -> prime p -> ord (m * n , p) ≡ (ord m , p) + (ord n , p)
postulate Option_inv_rect_CProp0 : {univs : Type} -> {x1 : univs} -> {Hterm : univs} -> (P : (z1098 : Term univs) -> (option (x1)) -> univs) -> (H1 : (z1099 : Term (prop univs)) -> (eq (lift univs.Type0 univs.Type2) (option (x1)) (Hterm))) -> (H2 : (x635 : Term univs.Type0) -> (x1) -> (z1099) -> (eq (lift univs.Type0 univs.Type2) (option (x1)) (Hterm))) -> (Term (prop univs) (P (lift univs.Type0 univs.Type2) (option (x1)) (Hterm))) -> (Term (prop univs) (P (option (x1)) (Hterm))).
postulate prop80 : even 2
postulate prop80 : even 2
postulate Aop_rect_CProp3_body : (A : Set) -> (A -> Set) -> (A -> A -> A) -> (A -> Eq A) -> (A -> Eq A) -> (A -> A -> A -> Eq A -> Eq A -> Set) -> (x : Aop A) -> (nil : A) -> (Q : (x : A) -> (op : A -> A) -> (nill : A -> Eq A) -> (nilr : A -> Eq A) -> (assoc : A -> A -> A -> Eq A -> Eq A -> Set) -> (mk_Aop : A -> Set) -> Set) -> (forall (x : Aop A) -> (nil : A) -> (Q nil (λ x y -> x) (λ a -> Eq_refl a) (λ a -> Eq_refl a) (λ a b c eq_ab eq_bc -> Eq_trans eq_ab eq_bc) λ mk_Aop -> Set) x nil) -> Set
postulate Not_found_min_spec : {n : cic.Term univs.Type0} {b : matita_arithmetics_nat.nat} {f : (i : cic.Term univs.Type0) -> (j : cic.Term univs.Type0) -> (k : matita_arithmetics_nat.le) -> (l : matita_arithmetics_nat.lt) -> (m : matita_arithmetics_nat.plus) -> (o : matita_basics_logic.eq) -> (p : cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) -> (q : matita_basics_bool.false) -> cic.Term (cic.prop) (matita_arithmetics_minimization.min_spec n b f (matita_arithmetics_nat.plus n b)) .
postulate lstar_r_ind_body : (B : Set) (relation : B -> B -> Set) (Q_ : (x_1337 : Nat) -> (x_1336 x_1335 : B) -> (x_1338 : Lstar_r B relation x_1337 x_1336 x_1335) -> Set) (H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B relation b)) (H_lstar_r_S : (l : Nat) (b1 b : B) (x_1340 : Lstar_r B relation l b b) -> Q_ (l + 1) b1 b (lstar_r_S B relation l b1 b x_1340)) -> (x_1337 : Nat) -> (x_1336 x_1335 : B) -> (x_1338 : Lstar_r B relation x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338
postulate prop80 : even 2
postulate PropComm : forall (A : cic.Univ) -> (nil : Term A) -> (xxx : (ACop A nil) : matita_arithmetics_bigops.ACop A) -> forall (a b : Term A) -> prop (eq (lift univs.Type0 univs.Type2 A) (bigops.ACop A nil) (bigops.aop A nil xxx) a b) .
postulate let_clause_10331 : \n  (∀ p n n1 q p1 p2 qa ra -> p_ord_aux (n1 + 1 , n1 + 1 , p2 + 2) = mk_Prod (Nat , Nat , qa , ra)) ->\n  (∀ x2515 x2516 -> x2515 ∈ N -> x2516 ∈ N -> x2515 = x2516 * (x2515 div x2516) + mod (x2515 , x2516))
postulate mod_cr_pair : (m n a b : ℕ) -> (gcd m n == 1) -> (mod (cr_pair m n) (cr_pair a b m) == a) -> (mod (cr_pair m n) (cr_pair a b n) == b)
postulate max_spec_ind : (n : Nat) -> (f : Nat -> Bool) -> (Q : (x : Nat) -> (m : MaxSpec n f) -> x -> Prop) -> (H_found_max_spec : (m : Nat) -> (x : Lt m) -> (n : Nat) -> (f_m : Eq (f m) true) -> (H : (i : Nat) -> (x_i : Lt i) -> (n_i : Nat) -> (f_i : Eq (f i) absurdity) -> (H_i : (i_i : Lt i_i) -> (n_i_i : Nat) -> (f_i_i : Eq (f i_i) absurdity) -> Q i (found_max_spec n f m x))) -> (H_not_found_max_spec : (i : Nat) -> (x_i : Lt i) -> (n : Nat) -> (f_i : Eq (f i) absurdity) -> Q 0 (not_found_max_spec n f i x_i)) -> (forall (x_971 : Nat) -> (forall (x_972 : MaxSpec n f) -> Q x_971 x_972))
postulate prop80 : even 2  \ndiv_mod_spec_rect_Type5 : ∀ (n m q r : ℕ) → (r < m) → (n == (q * m + r)) → (div_mod_spec n m q r) → Type5
 to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x2$ applied to $i$ and $matita_basics_bool.true$, if $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and $x3$ and $_Hterm$ and $P$ applied to $m$ and $_x_975$ and $_x_974$ and $_x_973$ and $i$ and
let_clause_1532 : ∀ {n m : ℕ} → (n mod m == 0) → (0 == n) → ∀ {d : ℕ} → (m == (0 * d)) → m == 0
postulate prop80 : even 2
postulate Divides_gcd_aux : \n  (p m n d : ℕ) → \n  (0 < n) → \n  (n ≤ m) → \n  (n ≤ p) → \n  (d mod m == 0) → \n  (d mod n == 0) → \n  (d mod (gcd_aux p m n) == 0)
postulate dividesb_true_to_divides : (n m : Nat) -> (dividesb n m ≡ True) -> Divisible n m
postulate Sig_rect_CProp4 : \n  ∀ (A : cic.Univ) → (∀ (x : cic.Term) → (A → cic.Univ → cic.prop)) → \n  (∀ (x : cic.Term) → (matita_basics_types.Sig A x f → cic.prop)) → \n  (∀ (pi1 : cic.Term) → (A → (f pi1 → cic.prop)) → \n  (∀ (pi2 : cic.prop) → (f pi1 pi2 → cic.prop)) → \n  (cic.Term → cic.prop → (Q_ pi1 A f pi2 → cic.prop))) → \n  (∀ (x : matita_basics_types.Sig A f) → cic.Term x → cic.prop (Q_ x A f x))
postulate bigop_body : (N -> Prop) -> (N -> N -> N -> N -> N -> N) -> (N -> N -> N) -> (N -> N) -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N -> N ->
postulate commutative_gcd : (n m : Nat) -> gcd m n ≡ gcd n m
mod$ applicerat på $m$ och $n$. Anta att $_clearme$ är delbart med $q$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Anta att $_clearme$ inte är delbart med $gcd_aux$ applicerat på $q$
$ et $comm$ et $a$ et $b$ et $comm$ et $aop$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $comm$ et $b$ et $a$ et $
postulate Match_Dop : \n  {A : Set} \n  -> (_nil : A) \n  -> (return_sort : Set) \n  -> (return_type : (z : Dop A _nil) -> return_sort) \n  -> (case_mk_Dop : (sum : ACop A _nil) -> (_ : A) -> return_sort) \n  -> (_null : (a : A) -> Eq (prod a _nil) _nil) \n  -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod (a , aop__o__op (A , _nil , sum , b , c))) (aop__o__op (A , _nil , sum , prod (a , b), prod (a , c)))) \n  -> (mk_Dop : (A : Set) -> (_nil : A) -> (sum : ACop A _nil) -> (prod : A -> A -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod (a , aop__o__op (A , _nil , sum , b , c))) (aop__o__op (A , _nil , sum , prod (a , b), prod (a , c)))) -> Dop A _nil sum prod _null _distr) \n  -> (z : Dop A _nil) \n  -> (return_type z)
postulate let_clause_15692 : ∀ (m n a b : Nat) (mn0 : 0 < n) (nm0 : 0 < m) (one : gcd n m = 1) (c : Nat) (ex : (Nat × (Eq (c * n - d * m) 1) × Eq (d * m - c * n) 1)) -> Eq (m * d - n * c) 1.
let_clause_15591 : ∀ (n m : ℕ) → (0 < m) → (0 ≡ n) → (0 ∣ m) → ∀ (q : ℕ) → (m ≡ (0 × q)) → m ≡ n
postulate Permut_n_to_eq_n : (h : Nat -> Nat) -> (n : Nat) -> (p : Permut h) -> (forall (m : Nat) (x : Lt m n) -> Eq (h m) (h n)) -> h n == n
postulate let_clause_1009 : \n  (f : Nat -> Bool) -> \n  (n m : Nat) -> \n  (0 < n) -> \n  (contradiction : f n) -> \n  (max (m , f) <= n) -> \n  (max (m , f) == n) -> \n  (prod : Set) -> \n  (Prop : Set) -> \n  (Nat : Set) -> \n  (g : Nat -> Prop * Prop -> Lt (Nat i) (Nat m) -> Eq (f (Nat i)) (Prop contradiction) -> Prop) -> \n  (max (m , f) == 0) -> \n  (0 == n)
523$. Låt $base$ vara en element av $P$ applicerat på $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_522$ och $matita_basics_logic.eq_refl$ applicerat på $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_522$. Låt $ind$ vara en element av $P$ applicerat på $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_523$ och $matita_basics_logic.eq_sym$ applicerat på $matita_basics_logic.eq_refl$ applicerat på $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inl$ applicerat på $x1$ och $x2$ och $x_522$ och $matita_basics_logic.eq_sym$ applicerat på $matita_basics_logic.eq_refl$ applicerat på $matita_basics_types.Sum$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_types.inr$ applicerat på $x1$ och $x2$ och $x_523$. \n\nOutput: \npostulate \n  sum_inv_ind : \n    (x1 x2 : cic.Univ) -> \n    (Hterm : cic.Term) -> \n    (sum : matita_basics_types.Sum x1 x2) -> \n    (P : (z972 : cic.Term) -> (sum : matita_basics_types.Sum x1 x2) -> cic.prop) -> \n    (H1 : (x522 : cic.Term) -> (x522 : x1) -> (z973 : cic.Term) -> \n      (eq : matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2) (sum x1 x2 Hterm (matita_basics_types.inl x1 x2) x522)) ->
postulate lt_nth_prime_to_not_prime : forall (n m : Nat), nth_prime n < m -> m < nth_prime (n + 1) -> ~prime m
postulate dividesb_true_to_lt_O : {n m : N} -> (0 < n) -> divides n m -> 0 < m
postulate divides_mod_gcd : (m n : ℕ) → (n > 0) → gcd n (mod m n) ≡ 0 * gcd m n
postulate Permut_transpose_r : (f : ∀ (x y : matita_arithmetics_nat.nat) → (x , y) → (x , y)) → (m : matita_arithmetics_nat.nat) → (i j : matita_arithmetics_nat.nat) → (P : ∀ (x : matita_arithmetics_nat.nat) → (x ≤ m) → (P1 : ∀ (x : matita_arithmetics_nat.nat) → (x ≤ m) → (P2 : ∀ (x : matita_arithmetics_permutation.permut) → (x m) → (P3 : ∀ (x : matita_arithmetics_nat.nat) → (x ≤ m) → (x ≤ m) → (P4 : ∀ (x : matita_arithmetics_permutation.permut) → (x m) → (x m) → (x m) → (x m)))))) → (x : matita_arithmetics_permutation.permut) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x m) → (x
postulate let_clause_1033 : \n  (n : matita_arithmetics_nat.nat) -> \n  (lt1n : matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n) -> \n  (x2515 x2516 : matita_arithmetics_nat.nat) -> \n  matita_basics_logic.eq (matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 x2515) (matita_arithmetics_div_and_mod.div x2515 x2516) (matita_arithmetics_div_and_mod.mod x2515 x2516)) n
postulate Le_plus_to_minus : (n m p : ℕ) -> (n ≤ (p + m)) -> (n - m ≤ p)
postulate Eq_f2 : {A B C : cic.Univ.univ} {f : (__) -> (__) -> (__)} {x1 x2 : cic.Term.term A} {y1 y2 : cic.Term.term B} {eqA : matita_basics_logic.eq A x1 x2} {eqB : matita_basics_logic.eq B y1 y2} -> matita_basics_logic.eq (cic.Term.term C) (f eqA eqB) (f eqA eqB)
postulate Lstar_r_S : {B : Set} -> {R : Relation B} -> (l : Nat) -> (b1 b : B) -> (lstar_r : lstar R B) -> (b1, b) -> (b2 : B) -> (R b b2) -> lstar R B (suc l) b1 b2
postulate True_to_le_min : (f : ℕ → Bool) → (n m b : ℕ) → (b ≤ m) → (f m ≡ true) → (min n b ≤ m)
postulate Le_sqrt_log : {n b : cic.Term (univs.Type0)} -> {__ : cic.Term (cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O) b) n)) (matita_arithmetics_log.log b n)) -> matita_arithmetics_sqrt.sqrt n
postulate checker_spec : {Nat : Set} -> {tl : List Nat} -> {a : Nat} -> {l : List Nat} -> (checker l = true) -> (l = cons Nat a tl) -> (forall p : Nat, mem Nat p tl) -> (forall x2 : (Nat -> (mem Nat x2 Nat) && (Lt Nat x2 p) && (Leq Nat p (2 * x2))) -> ex Nat (\pp -> ((mem Nat pp l) && (Lt Nat pp p) && (Leq Nat p (2 * pp))))
postulate le_sqrt_to_le_times_l : (m n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (___ : cic.Term cic.prop matita_arithmetics_nat.le n (matita_arithmetics_sqrt.sqrt m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times n n) m)
postulate Nat_rect_Type2_body : (Q : Nat -> Type2) -> Q zero -> (x : Nat) -> Q x -> (x' : Nat) -> Q x' .
matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $q$ och $n$ och $m$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $r$ och $n$ och $m$ och $p$ och $q$ och $r$ och $matita_arithmetics_div_and_mod.Smod$ applicerat på $n$ och $m$ och $m$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $p$ och $n$ och $m$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $q$ och $n$ och $m$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $r$ och $n$ och $m$ och $p$ och $q$ och $r$ och $matita_arithmetics_div_and_mod.Smod$ applicerat på $n$ och $m$ och $m$ och $matita_basics_types.mk_Prod$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_ord.p_ord_aux$ applicerat på $matita_arithmetics_nat.S$ applicerat på $p$ och $n$ och $m$ och $matita_basics_types.mk_Prod$ applicerat
postulate NoLabel_18 : (x : ℤ) -> odd x -> even ((9 * x) + 5)
postulate let_clause_15625 : \n  (m n a b : ℕ) -> \n  (0 < n) -> \n  (0 < m) -> \n  (gcd n m == 1) -> \n  (c : ℕ) -> \n  (ex : Nat) -> \n  (λ d -> Eq (c * n - d * m) 1) -> \n  (λ d -> Eq (d * m - c * n) 1) -> \n  (Eq (m - d) 1) .
postulate Le_n_Sm_elim : (n m : N) -> (n <= m + 1) -> (forall P : (n + 1) Leq (m + 1) -> P) -> (forall P : (n == m + 1) -> P) -> P
postulate Increasing_to_le : {f : Nat -> Nat} -> (increasing f) -> (forall m : Nat, (forall i : Nat, Leq (m , f i)))
erat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. \n\nOutput: \n```\ndata Let_clause_15622 : Type where\n  let_def : {m n a b : Term} -> {posn : prop} -> {posm : prop} -> {pnm : prop} -> {c : Type0} -> {d : nat} -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d : nat) -> (d
postulate Lt_to_div_O : (n m : Nat) -> n < m -> n / m ≡ O
postulate let_clause_16004 : (m n a b : ℕ) -> (0 < n) -> (0 < m) -> (1 ≡ gcd n m) -> (c : ℕ) -> (ex : Nat -> Prop) -> (d : ℕ) -> (Eq (c * n - d * m) 1) ∨ (Eq (d * m - c * n) 1) -> Eq (d * m - c * n) 1 -> (m * d - n * c) ≡ gcd m n
postulate Plus_le_0 : \n  {x y : ℕ} → (x + y ≤ 0) → x ≡ 0 × y ≡ 0
postulate Div_mod_spec_rect_CProp1 : (n m q r : ℕ) (Q : div_mod_spec n m q r → Prop) (H_div_mod_spec_intro : r < m → n ≡ q * m + r → Q (div_mod_spec_intro n m q r x)) (x : div_mod_spec n m q r) → Q x
 $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Prod$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs
postulate Sig_rect_Type0_body : (A : cic.Univ) -> (f : (x : univs.Type0) -> A -> cic.Univ) -> (Q_ : (x : univs.Type0) -> matita_basics_types.Sig A f -> cic.Univ) -> (H_mk_Sig : (pi1 : univs.Type0) -> A -> (pi2 : cic.Term) -> f pi1 A -> Q_ pi1 (matita_basics_types.mk_Sig A f pi1 pi2)) -> (x_676 : univs.Type0) -> (sig : matita_basics_types.Sig A f) -> (cic.Term) (univs.Type0) -> Q_ x_676 sig
postulate let_clause_15625 : \n  (m n a b : N) -> (0 < n) -> (0 < m) -> (1 ≡ gcd n m) -> \n  (c : N) -> (ex : Nat) -> (d : N) -> \n  (Eq (c * n - d * m) 1) ∨ (Eq (d * m - c * n) 1) -> \n  (Eq (d * m - c * n) 1) -> (m * d - n * c) ≡ 1
univs.Type0$ och $T2$ till element av $cic.Univ$ av $cic.prop$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $tl1$ applicerat på $T1$ och $tl2$ applicerat på $T2$ och $hd1$ applicerat på $T1$ och $hd2$ applicerat på $T2$, det finns ett element $n$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $T1$ och ett element $m$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $T2$ så att $P$ applicerat på $n$ applicerat på $l1$ och $m$ applicerat på $l2$ är lika med $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.add$ applicerat på $n$ applicerat på $l1$ och $m$ applicerat på $l2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.mul$ applicerat på $n$ applicerat på $l1$ och $m$ applicerat på $l2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_ar
postulate ACop_rect_CProp4 : forall (A : Set) (_nil : A) (Q_ : (x : ACop A _nil) -> Prop) (H_mk_ACop : (aop : Aop A) (comm : (a : A) (b : A) -> Eq (op A _nil aop) (op A _nil aop a b)) -> (x : A) -> Q_ (mk_ACop A _nil aop) -> Q_ (comm a b)) -> forall (x : ACop A _nil), Q_ x
postulate le_maxl : (i : ℕ) → (n m : ℕ) → (max n m ≤ i) → n ≤ i
$ av $Eq$ av $x5$ och $b$ och $_H1$ och $_H2$ och $_Hterm$ till element av $P$ av summan av $l$ och $1$ och $b1$ och $b$ och $_H1$ och $_H2$ och $_Hterm$, har vi $P$ av $x3$ och $x4$ och $x5$ och $_H1$ och $_H2$ och $_Hterm$.\n\nOutput: \npostulate lstar_inv_ind : {x1 : Set} -> (x2 : x1 -> Set) -> (x3 : Nat) -> (x4 x5 : x1) -> (Hterm : (x1 -> x2 x1 -> x3 -> x4 -> x5 -> lstar x1 x2 x3 x4 x5)) -> (P : Nat -> x1 -> x1 -> (Eq x3 0 -> Eq x4 x -> Eq x5 x -> _) -> _) -> (_H1 : x1 -> Eq x3 0 -> Eq x4 x -> Eq x5 x -> _) -> (_H2 : x1 -> x -> x -> Eq x3 l -> Eq x4 b -> Eq x5 b2 -> _) -> (Hterm x1 x2 x3 x4 x5) -> P x3 x4 x5 _H1 _H2 Hterm.
postulate F2_ind_aux : \n  ∀ (A1 A2 : Set) (f : A1 → A2 → Nat) (P : A1 → A2 → A1 → A2 → Set) (f' : Nat → A1 → A2 → Nat) (a1 a2 : A1) (a1' a2' : A2) (n : Nat) → \n  (f a1 a2 ≡ n) → P a1 a2 a1' a2' a1 a2 a2' n (f' n a1 a2) → P a1 a2 a1' a2' a1 a2 a1' (f' n a1 a2) .
postulate Minus_plus_plus_l : (x y h : ℕ) → x + h - (y + h) ≡ x - y
postulate Bijn_transpose_r : (f : Nat -> Nat) -> (n i j : Nat) -> (i <= n) -> (j <= n) -> (p : Bijn f n) -> Bijn (\p' => f (transpose (i , j , p))) n
postulate gcd_times : (m n p : ℕ) → (0 < p) → gcd m (n * p) ≤ gcd m n
postulate And_inv_rect_Type2 : (x1 : cic.Univ) (x2 : cic.Univ) -> cic.prop -> (x1 , x2) -> (x1 -> x2 -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x2) -> (x1 , x
postulate Congruent_ab_lt : ∀ (m n a b : Nat) -> 0 < n -> (0 < m) -> (1 ≡ gcd m n) -> (ex Nat) -> ((congruent x a m) && (congruent x b n) && (Lt x (m * n)))
postulate let_clause_16002 : \n  (m n a b : Nat)\n  -> (0 < n) -> (0 < m) -> \n  (1 ≡ gcd n m) -> \n  (forall (c : Nat), \n   (let clearme : ex Nat (λ d → (Eq (c * n - d * m) 1) ⊎ (Eq (d * m - c * n) 1) ⊎ (Eq (d * m - c * n) 1)) in \n    (let d : Nat in \n     (if (Eq (c * n - d * m) 1) ∨ (Eq (d * m - c * n) 1) ∨ (Eq (d * m - c * n) 1) then \n      (Eq (m * d - n * c) (gcd m n)) \n      else undefined))) \n   -> undefined)
postulate Sum_body : {univs : Type} -> (A : univs) -> (nil : Term univs) -> (A.xxx : Term univs (Dop A nil)) -> Term univs (ACop A nil)
postulate Sub0_to_false : (h k : Nat -> Nat) -> (A : Set) -> (I J : Range A) -> (upto : A -> I) -> 0 -> ((x : sub_hk h k A J I) -> (i : Nat) -> i < upto A J -> filter A J i ≡ contradiction)
postulate op_body : {A : Set} -> A -> (A -> A) -> A -> A -> A
postulate Dop_rect_Type0 : \n  {A : Set} {_nil : A} (Q_ : Dop A _nil -> Set) (H_mk_Dop : ACop A _nil (A -> A -> A) _nil _null _distr) -> \n  (sum : ACop A _nil (A -> A) _nil) (prod : (a : A) -> A -> A) (null : (a : A) -> Eq (prod a _nil) (prod _nil a)) (distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod (prod a b) c) (prod a (prod b c))) -> \n  (x_955 : Dop A _nil) -> Q_ x_955
postulate Le_sqrt_n1 : (n : ℕ) → (n - (2 * √n)) ≤ (√n ^ 2)
postulate divides_gcd_nm : (n m : Nat) -> Gcd n m `divides` m * Gcd n m `divides` n
let_clause_1033 : \n  p n q r : ℕ →\n  (0 < p) →\n  ¬(divides r p) →\n  n ≡ p ^ q * r →\n  (∀ q0 q1 : ℕ →\n    (q1 + 1 ≤ p ^ (q1 + 1)) →\n    ∀ x2515 x2516 : ℕ →\n      x2515 ≡ x2516 * (x2515 div x2516) + mod (x2515 , x2516))
postulate let_clause_10331 : (n : Nat) -> (2^8 <= n) -> (3 <= m) -> (logBase 2 m + 2 <= m) -> (forall (x2515 x2516 : Nat), x2515 == (x2516 * (x2515 / x2516) + mod x2515 x2516))
postulate max_exists : (f : Nat -> Bool) -> (n m : Nat) -> (m < n) -> (f m == true) -> (forall i : Nat -> (Lt m i -> Lt i n -> Eq (f i) -> Contr)) -> (n , f) == m
postulate Commutative : {A : univs.Type0} -> (f : (__) -> (__) -> A) -> (x y : A) -> f x y ≡ f y x
postulate Ord_O_to_not_divides : (p : cic.Term univs.Type0) -> (m : matita_arithmetics_nat.nat) -> (__) : cic.Term cic.prop -> (p : matita_arithmetics_primes.prime) -> (__)1 : cic.Term cic.prop -> (m : matita_basics_logic.eq) -> (univs.Type0) -> (univs.Type2) -> (matita_arithmetics_nat.nat) -> (matita_arithmetics_ord.ord) -> (m) -> (p) -> (matita_arithmetics_nat.O) -> cic.Term cic.prop -> matita_basics_logic.Not -> matita_arithmetics_primes.divides -> p -> m
postulate Range_rect_CProp3 : (A : Set) -> (Q : (x : range A) -> Prop) -> (H : (enum : Nat -> A) -> (upto : Nat) -> (filter : Nat -> Bool) -> mk_range A enum upto filter) -> (x : range A) -> Q x
postulate square_double : {n : Nat} -> (2 < n) -> (n + 1) + (n + 1) <= (2 * n) * (2 * n)
postulate fact_minus : {n k : ℕ} → k < n → (n - (k + 1))! * (n - k) ≡ (n - k)!
postulate let_clause_1047 : \n  (k n : Nat) -> (p : Nat -> Bool) -> (B : Set) -> (nil : B) -> \n  (op : B -> B -> B) -> (f : Nat -> B) -> (n <= k) -> \n  (j : Nat) -> (n <= j) -> \n  (Hind : (i : Nat) -> (leq : Leq n i) -> (lt : Lt i j) -> Eq (p i) absurdity -> Eq (bigop n (\i -> p i) B nil op (\i -> f i) (\i -> bigop j (\i -> p i) B nil op (\i -> f i))) -> \n  (Hfalse : (i : Nat) -> (leq : Leq n i) -> (lt : Lt i (j + 1)) -> Eq (p i) absurdity) -> \n  (\x2571 x2572 : Nat) -> Eq (x2571) (x2571 div x2572 + mod x2571 x2572)
postulate prime_to_not_divides_fact : (p : ℕ) -> prime p -> (n : ℕ) -> n < p -> ¬(divides (fact n) p)
postulate primes_below_to_bertrand : (pm : Nat) -> (l : List Nat) -> (pm_prime : Prime pm) -> (f : (p : Nat) -> (x : mem Nat p l) -> (p < pm + 1)) -> (g : (p : Nat) -> (x : mem Nat p l) -> (p < pm) -> (p < 2 * p) -> (ex : mem Nat (2 * p) l)) -> (forall (n : Nat) -> (0 < n) -> (n < pm) -> (bertrand n))
postulate let_clause_1063 : {f : Nat -> Nat} -> {n : Nat} -> {permf : Permut f n} -> {i j : Nat} -> (i ≤ n) -> (j ≤ n) -> {a : Nat} -> (a ≤ n) -> (f a = i) -> {b : Nat} -> (b ≤ n) -> (f b = j) -> {i0 : Nat} -> {a : Leq i0 n} -> {b : Leq i0 n} -> {c : Leq (f a) n} -> {d : Leq (f b) n} -> (a = b) -> (c = d).
 éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $f$ appliqué à $a1$ et $a2$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $f$ appliqué à $a1$ et $a2$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $f$ appliqué à $a1$ et $a2$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $a1$ et $a2$ et des éléments $a1$ de $cic.Term$ de $univs.Type0$ et de $A1$ et des éléments $a2$ de $cic.Term$ de $univs.Type0$ et de $A2$ et des éléments $f$ appliqué à $a1$ et $a2$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P
postulate F_ind_aux : \n  {A : Set} \n  {f : A → ℕ} \n  {P : A → Set} \n  {a : A} \n  {Lt : (a : A) → (n : ℕ) → f a → ℕ → Set} \n  {__ : (a : A) → (n : ℕ) → (f a → ℕ) → (a : A) → (Eq (f a) n) → P a} \n  (n : ℕ) \n  (a : A) \n  (H : f a ≡ n) \n  → P a
postulate le_min_r : (f : N -> Bool) (n b : N) -> min n b f <= n + b
postulate le_div_S_S_div : (n m : N) -> 0 < m -> (n + 1) / m <= n / m + 1
postulate let_clause_1617 : \n  {p m n : Nat} ->\n  (zero < p) ->\n  (gcd p m ≡ 1) ->\n  (p % (m * n) ≡ zero) ->\n  (∀ c : Nat) ->\n  ((m * n) ≡ (p * c)) ->\n  (∀ a : Nat) ->\n  (∀ _clearme0 : ex Nat) ->\n  (λ b : Nat ->\n    Eq (gcd p m) (Eq (b * m - a * p) (gcd p m)) * Eq (b * m - a * p) (Eq (a * p - b * m) (gcd p m))) ->\n  (∀ b : Nat) ->\n  (Eq (b * m - a * p) (gcd p m) ≡ (b * m - a * p) ≡ (a * p - b * m) ≡ (gcd p m)) ->\n  (Eq (b * m - a * p) (gcd p m) ≡ zero) ->\n  (gcd p m ≡ (p * a - m * b))
postulate let_clause_1648 : \n  (n q : Nat)\n  -> (0 < q)\n  -> (n1 : Nat)\n  -> (n1 == (bigop (sum n1 1) (λ m -> andb (leb 1 m) (dividesb q m))) + Nat 0 plus (1 q (mod n1 q)))\n  -> (dividesb q (n1 + 1))\n  -> (n1 + 1 == (sum (div n1 q 1) q))\n  -> (dividesb q (n1 + 1))\n  -> (n1 + 1 == (sum (div n1 q 1) q))\n  -> (n1 + 1 == (sum q (q * (div n1 q))))
postulate Void_rect_CProp1 : (Q_ : forall x_493 : cic.Term (univs.Type0) matita_basics_types.void, cic.Univ (cic.prop)) -> (x_493 : cic.Term (univs.Type0) matita_basics_types.void) -> cic.Term (cic.prop) (Q_ x_493)
postulate let_clause_15621 : \n  (m n a b : Nat) -> (0 < n) -> (0 < m) -> (1 == gcd n m) -> \n  (forall c : Nat) -> (forall (x : Ex) -> (Nat)) -> \n  (forall (f : Nat -> Eq (c * n - d * m) 1) -> \n   (forall d : Nat) -> ((c * n - d * m) == 1) || ((d * m - c * n) == 1) -> \n   ((c * n - d * m) == 1) -> \n   (forall d : Nat) -> ((n * c - m * d) == 1))
postulate congruent_times : {n n1 : ℕ} {m m1 : ℕ} {p : ℕ} (hn : 0 < p) (c1 : congruent n n1 p) (c2 : congruent m m1 p) -> congruent (n * m) (n1 * m1) p
postulate Divides_ind : \n  (n m : Term univs.Type0 nat) (Q : (x : Term univs.Type0 nat) -> divides n m -> Prop) -> \n  (∀ (q : nat) (x : Term univs.Type0 nat) -> eq (lift univs.Type0 univs.Type2 nat) m (times n q)) -> \n  (∀ (x : Term univs.Type0 nat) -> divides n m -> Prop) -> \n  (∀ (x : Term univs.Type0 nat) -> divides n m -> Prop)
postulate Range_inv_rect_CProp0 : \n  x1 : cic.Univ \n  Hterm : cic.Term \n  range_x1 : matita_arithmetics_bigops.range x1 \n  (forall P : (z1692 : cic.Term) -> (matita_arithmetics_bigops.range x1) -> cic.Univ -> cic.prop, \n   (forall H1 : (enum : (___ : cic.Term) -> (matita_arithmetics_nat.nat) -> cic.Term) -> \n    (upto : cic.Term) -> (filter : (___ : cic.Term) -> (matita_arithmetics_nat.nat) -> cic.Term -> matita_basics_bool.bool) -> \n    (z1693 : cic.Term) -> (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1) Hterm (matita_arithmetics_bigops.mk_range x1 (enum _) (upto) (filter _ _)))) -> \n    (cic.Term cic.prop) -> \n    (P (matita_arithmetics_bigops.mk_range x1 (enum _) (upto) (filter _ _)) (Hterm))))
postulate List_rect_Type1 : {univs : Universe} -> {A : univs.Type0} -> (Q : (x : univs.Type0) -> (A : univs.Type0) -> univs.Type1) -> (H_nil : (A : univs.Type0) -> Q (matita_basics_lists_list.nil) A) -> ((x : univs.Type0) -> (A : univs.Type0) -> (B : univs.Type0) -> (Q x A) -> (Q B A) -> (Q (matita_basics_lists_list.cons x A B)) -> (forall (x : univs.Type0) -> (B : univs.Type0) -> (Q x B)))
postulate let_clause_10336 : \n  (∀ n m : ℕ) → (Hind : (p : ℕ) → (Lt : (p : ℕ) → (m : ℕ) → (n : ℕ)) → (m1 : (p : ℕ) → (1 : ℕ) → (Lt : (1 : ℕ) → (p : ℕ) → (n : ℕ))) → (Leq : (Psi (p) : ℕ) → (pred (p) × (2 ^ (2 p - 3))) → (n : ℕ))) →\n  (a : ℕ) →\n  (m = (2 * a) ∨ (m = (2 * a) + 1)) →\n  (m = (2 * a) + 1) →\n  (1 < (2 * a) + 1) →\n  ((0 < a) →\n  (∀ x2515 x2516 : ℕ) →\n  (x2515 = x2516 * (x2515 / x2516) + mod (x2515 , x2516)))
postulate Divides_to_p_ord : \n  {p a b c d n m : N}\n  (n m : N) -> (0 < n) -> (0 < m) -> \n  (prime p) -> \n  (divides p n m) -> \n  (p_ord n p = mk_Prod (Nat , Nat , a , b)) -> \n  (p_ord m p = mk_Prod (Nat , Nat , c , d)) -> \n  (divides d b) /\ (a <= c)
postulate prop80 : even 2
postulate prop80 : even 2
postulate Prod : (A : Set) -> (A -> Set) -> Set\npostulate setA : Set\npostulate elementNil : setA\npostulate elementDop : (setA -> setA) -> setA\npostulate forAll : (setA -> setA -> Set) -> setA -> Set
postulate Div_mod_spec_ind : (n : univs.Type0) (m : univs.Type0) (q : univs.Type0) (r : univs.Type0) (Q : (x : cic.Term (cic.prop)) -> (div_mod_spec n m q r) -> cic.Univ (cic.prop)) -> (H_div_mod_spec_intro : (x : cic.Term (cic.prop)) -> (lt r m) -> (x_810 : cic.Term (cic.prop)) -> (eq (lift (univs.Type0, univs.Type2, matita_arithmetics_nat.nat) n) (plus (times q m) (times r))) -> (Q x (div_mod_spec_intro n m q r x x_810))) -> (forall (x : cic.Term (cic.prop)) -> (div_mod_spec n m q r) -> cic.Term (cic.prop) (Q x (div_mod_spec n m q r)))
postulate eq_times_div_minus_mod : (a b : Nat) -> (a / b) * b + (a mod b) ≡ a
postulate P_ord_O_to_not_divides : {n i r : ℕ} → (0 < n) → (p_ord n (nth_prime i) ≡ mk_Prod Nat Nat 0 r) → ¬(divides (nth_prime i) n)
postulate prop80 : even 2
postulate let_clause_1033 : \n  (n : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  (lt1n : cic.Term cic.prop matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)\n  (x2515 x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat)\n  -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516) (matita_arithmetics_div_and_mod.div x2515 x2516) (matita_arithmetics_div_and_mod.mod x2515 x2516))))
postulate let_clause_15611 : \n  (p m n : Nat) -> (zero < p) -> (gcd p m == 1) -> (p %* m * n) ->\n  (m * n == p * (c : Nat)) ->\n  (a : Nat) ->\n  (ex : (b : Nat) -> (Eq (p * a - m * b) (gcd p m) \/ Eq (m * b - p * a) (gcd p m))) ->\n  (Eq (m * b - p * a) (gcd p m)) ->\n  (Eq (m * (zero) - p * a) (one)).
postulate DPair_ind_body : \n  {A : Univ} -> \n  {univs : Type0} -> \n  {f : Term univs Type0 -> Univ univs Type0} -> \n  {Q_ : Term x638 univs Type0 -> DPair A f -> Prop} -> \n  {H_mk_DPair : Term dpi1 univs Type0 -> A -> Term dpi2 univs Type0 -> f dpi1 -> Prop} -> \n  {x_638 : Term univs Type0} -> \n  (dpair : DPair A f) -> \n  (Q_ x_638 dpair) .
postulate let_clause_1075 : {f : Nat -> Nat} -> {n : Nat} -> {bijf : f n -> n + 1} -> (f (n + 1) = n + 1) -> {i : Nat} -> (i <= n) -> {a : Nat} -> (a <= n + 1) -> (f a = i) -> (a <= n + 1) -> (f a = i) -> (if a == n + 1 then i == a else _)
postulate let_clause_15621 : (m n a b : Nat) -> (0 < n) -> (0 < m) -> (gcd n m == 1) -> (c : Nat) -> (ex : N -> (Eq (c * n - d * m) 1) || (Eq (d * m - c * n) 1)) -> (\d : Nat) -> (Eq (c * n - d * m) 1) -> (Eq (n * c - m * d) 1)
postulate bigop_0 : {n : Nat} {B : Set} {nil : B} {Aop : Set} {op : Aop -> B} {f : Nat -> B} -> (op (bigop (plus n 1) (λ i -> true))) ≡ (op (op nil (op (op nil (λ i -> (op (f i) (plus i 1)))) (f 0))))
postulate Not_inv_rect_CProp2 : {x1 : cic.Univ} -> (Hterm : cic.Term) -> (not_x1 : matita_basics_logic.Not x1) -> (P : {z305 : cic.Term} -> (not_x1) -> cic.Univ) -> (H1 : (x_110 : {x : cic.Term} -> (x1) -> cic.Term) -> matita_basics_logic.False -> {z306 : cic.Term} -> (eq_cic.lift (cic.prop) (univs.Type2) (not_x1) Hterm (matita_basics_logic.nmk x1 x_110)) -> cic.Term) -> P (matita_basics_logic.nmk x1 x_110)
postulate prop40 : forall (n : Nat), isEven n ∨ isOdd n
postulate Sig_rect_CProp4 : (univs : Type) (A : univs.Type0) (f : Term univs.Type0 -> A -> univs.Type0) (Q : (x : Term univs.Type0) -> Sig A f -> univs.Type0) -> (H_mk_Sig : (pi1 : Term univs.Type0) -> A -> (pi2 : Term univs.Type0) -> f pi1 A -> Sig A f -> (x : Term univs.Type0) -> Sig A f -> univs.Type0) -> (x : Term univs.Type0) -> Sig A f -> univs.Type0
postulate divides_minus : ∀ n p q → even n → even p → even q → even (p - q)
postulate Aop_inv_rect_Type2 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (z1518 : Aop x1 x2) -> Set2) -> (H1 : (op : x1 -> x1) -> (op1 : x1) -> Set) -> (P1 : (a : x1) -> Eq (op x2 a) a -> Eq (a op x2) a -> (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c) -> Eq (Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) (P (mk_Aop x1 x2 op _nill _nilr _assoc))) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)
postulate Square_S : (a : matita_arithmetics_nat.nat) -> cic.Term (univs.Type0) (matita_arithmetics_nat.nat) -> cic.prop (matita_basics_logic.eq (cic.lift (univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S a) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))) (matita_arithmetics_nat.plus (matita_arithmetics_nat.plus (matita_arithmetics_exp.exp a (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))) (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.O))) (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))))) a (matita_arithmetics_nat.S (matita_arithmetics_nat.O)))).
postulate Void_rect_Type5_body : (Q_ : ∀ (x_484 : cic.Term univs.Type0 matita_basics_types.void) → cic.Term univs.Type5) → ∀ (x_484 : cic.Term univs.Type0 matita_basics_types.void) → cic.Term univs.Type5 (Q_ x_484)
postulate Filter_list : (A : univ) -> (return_sort : sort) -> (z : term) -> (list : list (univ -> univ)) -> A -> (return : term) -> (return_type : sort) -> (z -> (return_sort -> return_type)) -> (z -> term) -> (list (univ -> term)) -> (z -> term) -> (return_sort -> return_type) -> (z -> term) -> (univ -> sort) -> (z -> term) -> (univ -> term) -> (univ -> sort) -> (z -> term) -> (univ -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z -> term) -> (univ -> term) -> (z ->
postulate DPair_rect_CProp2_body : ∀ {univs : Type} {cic : Universe} {A : cic.univ univs.type0} {f : ∀ _, univs.type0 -> cic.univ univs.type0} {Q_ : ∀ x658 _, univs.type0 -> DPair A f -> cic.univ (cic.prop univs.type0)} {H_mk_DPair : ∀ dpi1 _, univs.type0 -> A -> univs.type0 -> cic.term (cic.prop univs.type0) -> Q_ x658 dpi1 (DPair A f)} -> ∀ x658 _, univs.type0 -> DPair A f -> cic.term (cic.prop univs.type0) -> Q_ x658.
let_clause_1607 : Soient m n a b : ℕ. Alors si 0 < n, alors si 0 < m, alors si gcd n m ≡ 1, alors (∀ c : ℕ, ∀ _clearme : ex, ∀ f : ℕ → Bool, (∀ d : ℕ, (c * n - d * m ≡ 1) ⊢ (d * m - c * n ≡ 1) ⊢ (d * m - c * n ≡ 1)) ⊢ (gcd m n ≡ m * d - n * c)).
postulate Max_O : (f : ℕ → Bool) → max 0 (f 0) ≡ 0
postulate Div_mod_spec_inv_rect_CProp2 : (x1 x2 x3 x4 : ℕ) (Hterm : div_mod_spec x1 x2 x3 x4) (P : ∀ _z1482 : div_mod_spec x1 x2 x3 x4 → Prop) (P_rect : ∀ x_851 : Lt x4 x2 → Eq x1 (x3 + x2 * x4) → Eq (Hterm) (div_mod_spec_intro x1 x2 x3 x4 x_851 x_850)) → P Hterm
postulate Exp_fact_2 : (n : Nat) -> (pow (fact n) 2) ≡ (bigop (sum n 1) (λ p -> primeb p (Nat 1) (times (bigop (log p n) (λ i -> true (Nat 1) (times (bigop p (quotient n (pow p (times 2 (sum i 1)))) i)))))))
postulate Times_Sn_m : {m n : ℕ} → m + n * m ≡ (n + 1) * m
postulate Dop_rect_Type5_body : (A : Set) -> (nil : A) -> (Q_ : (x_947 : Dop A) -> nil -> A) -> (H_mk_Dop : (sum : ACop A) -> (nil : A) -> (prod : (a : A) -> (_1 : A) -> A) -> (null : (a : A) -> Eq (prod a nil) (nil nil)) -> (distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (prod a (aop__o__op A nil sum prod a b) (prod a (aop__o__op A nil sum prod a c)))) -> (x_947 : Dop A) -> A) -> (x_947 : Dop A) -> Q_ x_947 nil
let_clause_1068 : \n  (∀ (f : ℕ → ℕ) → \n   (∀ (n : ℕ) → \n    (∀ (permf : permut f n) → \n     (∀ (i j : ℕ) → \n      (i ≤ n) → \n      (j ≤ n) → \n      (∀ (a : ℕ) → \n       (a ≤ n) → \n       (f a == i) → \n       (∀ (b : ℕ) → \n        (b ≤ n) → \n        (f b == j) → \n        (b ≤ n) → \n        (f b == j) → \n        (∀ (i0 : ℕ) → \n         (∀ (injf : Leq i0 (f i0) n) → \n          (∀ (injn : permut f n) → \n           (injf permf) → \n           (∀ (a : ℕ) → \n            (a ≤ n) → \n            (f a == i) → \n            (a == b) → \n            (f a == i)))))))))))))
postulate Divides_gcd_r : {n m : univs.Type0} -> matita_arithmetics_nat.nat n -> matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd n m) m -> cic.Term cic.prop.
postulate let_clause_15611 : \n  (∀ p m n → \n    (0 < p) → \n    (1 ≡ gcd p m) → \n    (p ∣ m * n) → \n    (∀ c → (m * n ≡ p * c) → \n      (∀ a → \n        (∀ _clearme0 → \n          (ex Nat) → \n          (∀ b → \n            (gcd p m ≡ a * p - b * m) ∨ (gcd p m ≡ b * m - a * p)) → \n          ((gcd p m ≡ b * m - a * p) → \n            ((b * m - a * p ≡ 1) → (m * b - p * a ≡ 1))))))))
postulate div_mod_spec_rect_Type4 : \n  (n m q r : ℕ) (Q : div_mod_spec n m q r → Type4) (H_div_mod_spec_intro : \n    (Lt r m) × (Eq n (q * m + r))) → \n  (∀ x_813 → Q (div_mod_spec_intro n m q r x_813))