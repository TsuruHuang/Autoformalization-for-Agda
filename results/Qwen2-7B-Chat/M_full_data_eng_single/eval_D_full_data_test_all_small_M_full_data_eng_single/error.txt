ERROR: postulate lt_sigma_p : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (g2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p2 i) matita_basics_bool.true)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p1 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (g1 i) (g2 i))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \times (pow 2 (minus (times p 2) 3)))) -> (a : Nat) -> (auto : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (auto' : Eq m (plus (times 2 a) 1)) -> (auto'' : and (Lt 1 (plus (times 2 a) 1)) (Lt 0 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (plus (div x2515 x2516) (mod x2515 x2516))
ERROR: postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (x2515 : B) -> (x2516 : B) -> Eq x2515 (op x2516 (f1 (plus n1 (div x2515 (f2 (plus n2 (div x2516 (f1 (plus n1 (div x2515 (f2 (
ERROR: postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (__1 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> and (forall __ : ((i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> forall injf : injn f n -> Eq a b -> Eq (f a) j)
ERROR: postulate let_clause_1033 : (n : Nat) -> (le_n : Leq (pow 2 7) n) -> (p : Nat) -> (le_p : Leq (plus (sqrt (times 2 n)) 1) p) -> (lt_p : Lt p (plus (times 2 n) 1)) -> (Hc : Leb 2 (k (times 2 n) p) == true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (plus (div x2515 x2516) (mod x2515 x2516))
ERROR: postulate eq_length_to_mem_all : (n : Nat) -> (l : list Nat) -> (_ : Eq (length (Nat , l)) n) -> (__1 : unique Nat l) -> (__2 : (x : Nat) -> (__2 : mem Nat x l) -> Lt x n) -> (i : Nat) -> (__3 : Lt i n) -> mem Nat i l
ERROR: postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (x__ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> p i == false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> p i == false) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
ERROR: postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (m n , p) (plus (ord (m , p)) (ord (n , p))))
ERROR: postulate let_clause_10331 : (p : Nat) -> (n : Nat) -> (n1 : Nat) -> (q : Nat) -> (p1 : Nat) -> (p2 : Nat) -> (qa : Nat) -> (ra : Nat) -> (H : Eq (p_ord_aux (n1 + 1 , n1 + 1 , p2 + 2)) (mk_Prod Nat Nat qa ra)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (plus (div x2515 x2516) (mod x2515 x2516))
ERROR: postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times a n) (times b m)) (gcd_aux q m n)
ERROR: postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : true) -> (x__ : l == cons Nat a tl) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))
ERROR: postulate let_clause_15622 : m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m) -> pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) -> c : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> _clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ e : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita
ERROR: postulate Prod_discr : (a1 : cic.Univ univs.Type0) -> (a2 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ t0 : cic.Term univs.Type0 a1 -> \ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Prod a1 a2 (cic.succ univs.Type2) (\ __ : cic.Term univs.Type0 (matita_basics_types.Prod a1 a2) -> cic.univ univs.Type2) (\ u0 : cic.Term univs.Type0 a1 -> \ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\ x0 : cic.Term univs.Type0 a1 -> \ p0 : cic.Term cic.prop (matita
ERROR: postulate sum_body : A : cic.Univ univs.Type0 -> nil : cic.Term univs.Type0 A -> _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil) -> cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A nil)
ERROR: postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (posp : Lt 0 p) -> (ndivpr : not (divisible p r)) -> (Hn : Eq n (pow p q * r)) -> (q0 : Nat) -> (q1 : Nat) -> (Hind : Leq (plus 1 q1) (pow p (plus 1 q1))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (div x2515 x2516) + mod x2515 x2516
ERROR: postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n
ERROR: postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p * (pow 2 (minus (times 2 a) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (auto : Eq m (plus (times 2 a) 1)) -> (auto' : Lt 1 (plus (times 2 a) 1)) -> (auto'' : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (plus (div x2515 x2516) (mod x2515 x2516))
ERROR: postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : p_ord (n , p) = mk_Prod Nat Nat a b) -> (__5 : p_ord (m , p) = mk_Prod Nat Nat c d) -> and (divisible b d) (Leq a c)
ERROR count: 18