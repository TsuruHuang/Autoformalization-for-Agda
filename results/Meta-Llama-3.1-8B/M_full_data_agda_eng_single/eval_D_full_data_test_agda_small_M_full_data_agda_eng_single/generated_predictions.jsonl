{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_false. Låt $n$ vara ett naturligt tal. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, är $nil$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som kontradiktion och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i)) nil", "predict": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq nil (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Då för alla naturliga tal $b$, om $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$, så om $b$ är mindre än eller lika med $n$, så om $f$ applicerat på $b$ är lika med $j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (__2 : Leq a n) -> (__3 : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (__4 : Leq b n) -> (__5 : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_false. Let $n$ be a natural number. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, $nil$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to absurdity and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i)) nil", "predict": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq nil (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16004. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $d m - c n = 1$. Då är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEx_prime. Soit $n$ un nombre naturel. Supposons que $1 \\leq n$. Alors $ex$ tient pour $Nat$ et la fonction qui envoie $m$ à la conjonction de la conjonction de $Lt$ appliqué à $n$ et $m$ et de $Leq$ appliqué à $m$ et la somme de la factorielle de $n$ et de $1$ et de $prime$ appliqué à $m$.\nAssistant:", "label": "postulate ex_prime : (n : Nat) -> (_ : Leq 1 n) -> ex Nat (\\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))", "predict": "postulate ex_prime : (n : Nat) -> (_ : Lt 1 n) -> ex Nat (\\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_ind_body. Soient $_n$ et $_b$ des nombres naturels. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_1075$ et des éléments $_x_1076$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $x_1075$ à des propositions. Soit $_H_found_min_spec$ une fonction des nombres naturels $m$ et des éléments $x_1080$ de $Leq$ de $_b$ et de $m$ et des éléments $x_1079$ de $Lt$ de $m$ et de $_n + _b$ et des éléments $x_1078$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_1077$ des nombres naturels $i$ et des éléments de $Leq$ de $_b$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_min_spec (_n, _b, _f, m, x_1080, x_1079, x_1078, x_1077)$. Soit $_H_not_found_min_spec$ une fonction des fonctions $x_1081$ des nombres naturels $i$ et des éléments de $Leq$ de $_b$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n + _b$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $_n + _b$ et de $not_found_min_spec (_n, _b, _f, x_1081)$. Soit $x_1075 \\in N$. Alors pour tous les éléments $x_1076$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $x_1075$, $Q_$ tient pour $x_1075$ et $x_1076$.\nAssistant:", "label": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (_n + _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (_n + _b)) -> Eq (_f i) false) -> Q_ (_n + _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides. För alla element $_n$ och $_m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_CProp0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_inl$ une fonction des éléments $x_582$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_582$. Soit $_H_inr$ une fonction des éléments $x_583$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_583$. Alors pour tous les éléments $x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1620$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H1$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $b$ et $a$ et des éléments $_z1621$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_ACop$ une fonction des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$. Alors pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_Psil1. För alla naturliga tal $n$, är $bigop$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $n$ mindre än eller lika med $Psi (n)$.\nAssistant:", "label": "postulate le_Psil1 : (n : Nat) -> Leq (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> n))", "predict": "postulate le_Psil1 : (n : Nat) -> Eq (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> Leq n (Psi n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPermut_n_to_eq_n. För alla funktioner $h$ från naturliga tal till naturliga tal, för alla naturliga tal $n$, för alla element $__$ av $permut$ av $h$ och $n$, för alla funktioner $__1$ från naturliga tal $m$ och element $__1$ av $Lt$ av $m$ och $n$ till element av $Eq$ av $h$ applicerat på $m$ och $m$, är $h$ applicerat på $n$ lika med $n$.\nAssistant:", "label": "postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n", "predict": "postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$. Supposons que $a p - b m = 1$. Alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) (Eq (gcd p m) (minus (times a p) (times b m)))) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_inv_rect_CProp3. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$, för alla funktioner $P$ från element $_z1344$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.nil$ applicerat på $x1$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_lists_list.nil$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_763$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $x_762$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ och funktioner $_x_765$ från element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $x_762$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_762$ och element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_763$ och $x_762$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_763$ och $x_762$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant", "label": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__op. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$ et $x2$, pour tous les éléments $_x_887$ et $_x_888$ de $cic.Term$ de $univs.Type0$ et de $x0$, $cic.Term$ tient pour $univs.Type0$ et $x0$.\nAssistant:", "label": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0", "predict": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_p_ord_inv. Let $p, m, x \\in N$. Then if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.\nAssistant:", "label": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)", "predict": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb. Låt $m, n, p \\in N$. Anta att $0 < n$ och $p$ är primt. Då om $p$ inte är delbart med $n$, så är $bigop$ applicerat på $m$ och funktionen som avbildar $i$ som $dividesb$ applicerat på potensen av $p$ och summan av $i$ och $1$ och produkten av potensen av $p$ och $m$ och $n$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $1$ lika med $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_i_j_i. För alla naturliga tal $i$ och $j$, är $transpose$ applicerat på $i$ och $j$ och $i$ lika med $j$.\nAssistant:", "label": "postulate transpose_i_j_i : (i : Nat) -> (j : Nat) -> Eq (transpose i j i) j", "predict": "postulate transpose_i_j_i : (i : Nat) -> (j : Nat) -> Eq (transpose i j i) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_DPair$ be a function from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$. Then for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.\nAssistant:", "label": "postulate DPair_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)", "predict": "postulate DPair_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMonotonic_iter2. Let $g$ be a function from natural numbers to natural numbers. Let $a$ and $i$ and $j$ be natural numbers. Let $__$ be a function from natural numbers $x$ to elements of $Leq$ of $x$ and $g (x)$. Assume that $i \\leq j$. Then $iter (Nat, g, i, a)\\leq iter (Nat, g, j, a)$.\nAssistant:", "label": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)", "predict": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBool_to_decidable_eq. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.\nAssistant:", "label": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))", "predict": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1600. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Då om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så är $n c - m d$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPi_1. Låt $n \\in N$. Då för alla funktioner $p$ från naturliga tal till sanningsvärden, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $1$ lika med $1$.\nAssistant:", "label": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1", "predict": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> Prop) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec_inv_ind. Låt $x1$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $x3$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $x1$ och $x2$ och $x3$. Låt $P$ vara en funktion från element $_z1769$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_975$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $x1$ och element $_x_974$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x2$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $_x_973$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x2$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1770$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicer", "label": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq", "predict": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P x1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_sqrt. Soit $n$ un nombre naturel. Alors $n$ est inférieur à la puissance de la somme de la racine carrée de $n$ et de $1$ et de $2$.\nAssistant:", "label": "postulate lt_sqrt : (n : Nat) -> Lt n (pow (plus (sqrt n) 1) 2)", "predict": "postulate lt_sqrt : (n : Nat) -> Lt n (pow (plus (sqrt n) 1) 2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be a natural number. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1$ be a natural number. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$ and $p1 (n1)= true$. Let $x2515, x2516 \\in N$. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_divides_to_gcd_aux. Låt $p, m, n \\in N$. Då om $0 < n$ och $n$ inte är delbart med $m$, så $gcd_aux (p + 1, m, n)= gcd_aux (p, n, mod (m, n))$.\nAssistant:", "label": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))", "predict": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (p + 1) m n) (gcd_aux p n (mod m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind_body. Soit $_n$ un nombre naturel. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Alors pour toutes les fonctions $_H_not_found_max_spec$ des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$, pour tous les nombres naturels $x_971$, pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_diff. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f$ vara en funktion från naturliga tal till element av $B$. Låt $i$ och $n$ vara naturliga tal. Anta att $i < n$ och $p (i)= true$. Då är $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och $f$ applicerat på $i$ och $bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $andb$ applicerat på $notb$ applicerat på $eqb$ applicerat på $i$ och $x$ och $p$ applicerat på $x$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $p$ applicerat på $x$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$.\nAssistant:", "label": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))", "predict": "postulate bigop_diff : (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x))) (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMake_list_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_a$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour tous les éléments $_n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $A$.\nAssistant:", "label": "postulate make_list_body : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)", "predict": "postulate make_list_body : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I. Let $n$ be a natural number. Let $p$ be a function from natural numbers to booleans. Then for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to the difference of $n$ and $0$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $0$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $0$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_times_l. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om $1$ är mindre än $p$, så är summan av logaritmen av $p$ och $n$ och logaritmen av $p$ och $m$ mindre än eller lika med logaritmen av $p$ och produkten av $n$ och $m$.\nAssistant:", "label": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))", "predict": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSum_rect_CProp1_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_576$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_inl$ från element $x_577$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_577$, för alla funktioner $_H_inr$ från element $x_578$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_578$, för alla element $x_576$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_576$.\nAssistant:", "label": "postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)", "predict": "postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_Type3_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_867$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type3$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a, _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ à des éléments de $Q_$ de $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Soit $x_867$ un élément de $Aop$ de $A$ et de $_nil$. Alors $Q_$ tient pour $x_867$.\nAssistant:", "label": "postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867", "predict": "postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_fg. Låt $f$ och $g$ vara funktioner från naturliga tal till naturliga tal. Låt $n \\in N$. Då för alla element $__$ av $bijn$ av $f$ och $n$, för alla element $__1$ av $bijn$ av $g$ och $n$, håller $bijn$ för funktionen som avbildar $p$ som $f (g (p))$ och $n$.\nAssistant:", "label": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : Nat -> f (g p)) n", "predict": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : Nat -> f (g p)) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1544. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $n$ est inférieur ou ágal à $m$. Supposons que $n$ est inférieur ou ágal à la somme de $q$ et de $1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Supposons que la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ est égale à $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ ou la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appl", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "iqué àpostulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_inv_rect_Type4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1044$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des éléments $_z1045$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_591$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1045$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_591$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_591$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n \\in N$. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n$ applied to $_n$. Let $case_le_S$ be a function from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$. Let $__$ be a natural number. Assume that $_n$ is less than or equal to $__$. Then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : N) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nUnit. $cic.Univ$ håller för $univs.Type0$.\nAssistant:", "label": "postulate unit : cic.Univ univs.Type0", "predict": "postulate Unit : cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLeb. Soient $__$ et $__1$ des nombres naturels. Alors $bool$.\nAssistant:", "label": "postulate leb : (_ : Nat) -> (__1 : Nat) -> bool", "predict": "postulate leb : (_ : Nat) -> (__1 : Nat) -> bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.\nAssistant:", "label": "postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)", "predict": "postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_rect_CProp1_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_conj$ des éléments $x_164$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_163$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_164$ et $x_163$, pour tous les éléments $x_162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_162$.\nAssistant:", "label": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)", "predict": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_lt_n. Låt $i$ och $n$ vara naturliga tal. Då om $1$ är mindre än $n$, så om $i$ är mindre än eller lika med $n$, så om det största gemensama delaret av $i$ och $n$ är lika med $1$, så är $i$ mindre än $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n", "predict": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l_aux. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Alors pour toutes les fonctions $__1$ des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de $l + 1$ et de $b1$, pour tous les nombres naturels $l$, pour tous les éléments $b1$ et $b$ de $B$, pour tous les éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$, si $b = b2$, alors $P$ tient pour $l$ et $b1$.\nAssistant:", "label": "postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1", "predict": "postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1"}
{"prompt": "Human: Translate the following English statement into Agda.\nTimesAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Då om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_pi. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ mindre än eller lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_O_gcd. Pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$.\nAssistant:", "label": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))", "predict": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nAssistant:", "label": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "Human: Translate the following English statement into Agda.\nPrime_to_divides_M. Let $m$ and $p$ be natural numbers. Assume that $p$ is prime. Assume that $m + 1 < p$. Assume that $p \\leq 2 m + 1$. Then $p$ is divisible by $M (m)$.\nAssistant:", "label": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)", "predict": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (m + 1) p) -> (__2 : Leq p (2 m + 1)) -> divisible p (M m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nK1. Soient $n$ et $p$ des nombres naturels. Supposons que $18 \\leq n$ et $p \\leq n$. Supposons que $2 n \\div 3 < p$. Alors $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : and (Leq 18 n) (Leq p n)) -> (__1 : Lt (div (times 2 n) 3) p) -> Eq (k (2 n) p) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$ och $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Då om $b \\leq n$ och $f (b)= j$ och $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (Eq (f a) i) (Leq a n))) -> (H : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (Eq (f b) j) (Leq b n))) -> (H0 : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nAllr_fwd_append_sn. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$. Let $l1$ and $l2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l1$.\nAssistant:", "label": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)", "predict": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp0_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nAssistant:", "label": "postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "Human: Translate the following French statement into Agda.\nProd. Soient $s1$ et $s2$ des éléments de $Sort$. Alors pour tous les éléments $a$ de $Univ$ de $s1$, pour toutes les fonctions $b$ des éléments de $Term$ de $s1$ et de $a$ à des éléments de $Univ$ de $s2$, $Univ$ tient pour $rule$ appliqué à $s1$ et $s2$.\nAssistant:", "label": "postulate prod : (s1 : Sort) -> (s2 : Sort) -> (a : Univ s1) -> (b : Term s1 a -> Univ s2) -> Univ (rule s1 s2)", "predict": "postulate Prod : (s1 : Sort) -> (s2 : Sort) -> (a : Univ s1) -> (b : Term s1 a -> Univ s2) -> Univ (rule s1 s2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nProd_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1236$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1237$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15692. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Then if $0 < n$, then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_Psi2. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nAssistant:", "label": "postulate le_exp_Psi2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))", "predict": "postulate le_exp_Psi2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDPair_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_650$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_mk_DPair$ vara en funktion från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$. Då för alla element $x_650$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_650$.\nAssistant:", "label": "postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)", "predict": "postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_O_f. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les nombres naturels $b$, $min (0, b, f)= b$.\nAssistant:", "label": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b", "predict": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (H1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H2 : Eq (gcd p m) (minus (times a p) (times b m))) -> (H3 : Eq b m) -> Eq 1 (minus (times b m) (times a p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnit_inv_rect_CProp1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Soit $P$ une fonction des éléments $_z960$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $_z961$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.it$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_ind. Let $_n$ and $_m$ be natural numbers. Let $Q_$ be a function from elements $_x_1192$ of $divisible$ of $_n$ and $_m$ to propositions. Then for all functions $_H_quotient$ from natural numbers $q$ and elements $x_1193$ of $Eq$ of $_m$ and the product of $_n$ and $q$ to elements of $Q_$ of $quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, if $_n$ is divisible by $_m$, then $Q_$ holds for $x_1192$.\nAssistant:", "label": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192", "predict": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (_x_1192 : divisible _n _m) -> Q_ x_1192"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type5_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_919$ av $range$ av $_A$ till element av $Type5$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Låt $x_919$ vara ett element av $range$ av $_A$. Då håller $Q_$ för $x_919$.\nAssistant:", "label": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919", "predict": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10131. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m, n0 \\in N$. Anta att $max$ applicerat på summan av $n0$ och $1$ och $f$ är lika med $m$. Anta att $f$ applicerat på $m$ är lika med kontradiktion. Låt $i, j \\in N$. Anta att summan av $j$ och $1$ är mindre än summan av $n0$ och $1$. Låt $x7$ vara ett naturligt tal. Då är $x7$ lika med summan av $m$ och $x7$.\nAssistant:", "label": "postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)", "predict": "postulate let_clause_10131 : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eq_max : Eq (max (plus n0 1) f) m) -> (eq_fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (lt : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)"}
{"prompt": "Human: Translate the following French statement into Agda.\nVoid_rect_CProp1. Soit $Q_$ une fonction des éléments $_x_493$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $x_493$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_493$.\nAssistant:", "label": "postulate void_rect_CProp1 : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)", "predict": "postulate void_rect_CProp1 : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)"}
{"prompt": "Human: Translate the following English statement into Agda.\nExp_to_fact1. Let $n$ be a natural number. Assume that $0$ is less than $n$. Then the product of the product of the exponentiation of $2$ and the product of $2$ and $n$ and the factorial of $n$ and the factorial of $n$ is less than the factorial of the sum of the product of $2$ and $n$ and $1$.\nAssistant:", "label": "postulate exp_to_fact1 : (n : Nat) -> (_ : Lt 0 n) -> Lt (times (times (pow 2 (times 2 n)) (factorial n)) (factorial n)) (factorial (plus (times 2 n) 1))", "predict": "postulate exp_to_fact1 : (n : Nat) -> (_ : Lt 0 n) -> Lt (times (times (pow 2 (times 2 n)) (factorial n)) (factorial n)) (factorial (plus (times 2 n) 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Let $P$ be a function from elements $_z185$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H1$ from elements $_z186$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_mop. Let $n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $R$ be an element of $Dop$ of $B$ and $nil$. Then for all functions $f$ from natural numbers to elements of $B$, for all elements $a$ and $_x_969$ and $_x_970$ of $B$, $B$.\nAssistant:", "label": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B", "predict": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_exp1. Låt $n$ och $m$ och $a$ vara naturliga tal. Anta att $0 < a$. Anta att $n \\leq m$. Då $n ^ a \\leq m ^ a$.\nAssistant:", "label": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)", "predict": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nR1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_refl$ vara ett element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Då för alla element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_19$ och $x_20$.\nAssistant:", "label": "postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)", "predict": "postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLength_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate length_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate length_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_CProp2_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $Q_$ be a function from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_div_mod_spec_intro$ be a function from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$. Then for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)", "predict": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (f a) i) (Leq a n)) -> (f_a : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (f b) j) (Leq b n)) -> (f_b : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1, n2 \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Assume that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_hk$ holds for $h$ and $k$ and $B", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i", "predict": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind. Let $_n$ and $_b$ be natural numbers. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075 \\in N$. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following French statement into Agda.\nFact_pi_p. Soit $n \\in N$. Alors la factorielle de $n$ est égale à $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$.\nAssistant:", "label": "postulate fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (div n (pow p (plus i 1))))))", "predict": "postulate fact_pi_p : (n : Nat) -> Eq (factorielle n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (div n (pow p (plus i 1))))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10471. Låt $n1, n2 \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f1$ och $f2$ vara funktioner från naturliga tal till element av $B$. Låt $_clearme$ vara ett element av $iso$ av $B$ och $mk_range (B, f1, n1, p1)$ och $mk_range (B, f2, n2, p2)$. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Låt $_clearme0$ vara ett element av $ex$ av $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $Nat$ och funktionen som avbildar $k$ som konjunktionen av konjunktionen av $prod$ applicerat på $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och funktionen som avbildar $__1$ som $Eq$ applicerat på $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $sub_hk$ applicerat på $h$ och $k$ och $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $sub_hk$ applicerat på $k$ och $h$ och $B$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$. Låt $k$ vara en funktion från naturliga tal till naturliga tal. Anta att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applic", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1", "predict": "erat påpostulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (_clearme2 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nAb_times_cd. Let $a$ and $b$ and $c$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $matita_arithmetics_nat.times$ applied to $c$ and $d$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $d$.\nAssistant:", "label": "postulate ab_times_cd : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a b) (matita_arithmetics_nat.times c d)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))", "predict": "postulate ab_times_cd : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a b) (matita_arithmetics_nat.times c d)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nInvert_permut_f. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n$ et $m$, si $m \\leq n$, alors pour tous les éléments $__1$ de $injn$ de $f$ et de $n$, $invert_permut (n, f, f (m))= m$.\nAssistant:", "label": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m", "predict": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_minus_to_plus. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $m$.\nAssistant:", "label": "postulate le_minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))", "predict": "postulate le_minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin. Soient $__$ et $__1$ des nombres naturels. Alors pour toutes les fonctions $__2$ des nombres naturels $__2$ à des valeurs booléennes, $Nat$.\nAssistant:", "label": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat", "predict": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_leb_true. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to $true$.\nAssistant:", "label": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true", "predict": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_ind_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_889$ de $ACop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_889$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_889$.\nAssistant:", "label": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889", "predict": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp0_body. Soit $_n, _m, _q, _r \\in N$. Soit $Q_$ une fonction des éléments $_x_857$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_859$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_858$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n, _m, _q, _r, x_859, x_858)$. Soit $x_857$ un élément de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$. Alors $Q_$ tient pour $x_857$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857", "predict": "postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_of_primes_def. Soit $n \\in N$. Alors $list_of_primes$ appliqué à $n$ est égal à $lprim$ appliqué à $n$ et $2$ et $nil$ appliqué à $Nat$.\nAssistant:", "label": "postulate list_of_primes_def : (n : Nat) -> Eq (list_of_primes n) (lprim n 2 (nil Nat))", "predict": "postulate list_of_primes_def : (n : Nat) -> Eq (list_of_primes n) (lprim n 2 (nil Nat))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Pour tous les nombres naturels $m$ et $n$ et $a$ et $b$, si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors si le diviseur commun plus grand de $n$ et de $m$ est égal à $1$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divisor_common_max n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (divisor_common_max m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_inv_rect_Type3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1314$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type3$. Då för alla funktioner $_H1$ från element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.nil$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_lists_list.nil$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_733$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $x_732$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ och funktioner $_x_735$ från element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $x_732$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $x_732$ och element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_733$ och $x_732$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_733$ och $", "label": "postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> (z1313 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.rev x1 x_732))) -> cic.Term univs.Type3 (P x_732)"}
{"prompt": "Human: Translate the following French statement into Agda.\nSub_comp_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soient $R$ et $R1$ et $R2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_relations.subR$ appliqué à $A$ et $R1$ et $R2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.subR$ appliqué à $A$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R$ et $R1$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R$ et $R2$.\nAssistant:", "label": "postulate sub_comp_r : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))", "predict": "postulate sub_comp_r : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrime_nth_prime. Soit $n \\in N$. Alors $nth_prime (n)$ est premier.\nAssistant:", "label": "postulate prime_nth_prime : (n : Nat) -> prime (nth_prime n)", "predict": "postulate prime_nth_prime : (n : Nat) -> prime (nth_prime n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_divides_ord_rem. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $p$ est premier. Alors si $n$ est divisible par $m$, alors $ord_rem (n, p)$ est divisible par $ord_rem (m, p)$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_CProp2. Let $_A$ be a set. Let $Q_$ be a function from elements $_x_935$ of $range$ of $_A$ to propositions. Then for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range (_A, _enum, _upto, _filter)$, for all elements $x_935$ of $range$ of $_A$, $Q_$ holds for $x_935$.\nAssistant:", "label": "postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935", "predict": "postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_CProp2_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_909$ av $ACop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_909$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_909$.\nAssistant:", "label": "postulate ACop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_909 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_909 : ACop A _nil) -> Q_ x_909", "predict": "postulate ACop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_909 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_909 : ACop A _nil) -> Q_ x_909"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb1. Låt $m$ och $n$ och $p$ och $k$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$, för alla element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $k$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $matita_arithmetics_primes.dividesb$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $i$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $m$ och $n$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate sigma_p_dividesb1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate sigma_p_dividesb1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1560. Let $n$ and $m$ be natural numbers. Assume that $n$ is divisible by $m$. Assume that $0$ is equal to $n$. Let $d$ be a natural number. Assume that $m$ is equal to the product of $0$ and $d$. Then $n$ is equal to $0$.\nAssistant:", "label": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0", "predict": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (eqn0 : Eq 0 n) -> (d : Nat) -> (eqm : Eq m (times 0 d)) -> Eq n 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_rect_CProp5. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_conj$ be a function from elements $x_152$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_151$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_152$ and $x_151$. Then for all elements $x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_150$.\nAssistant:", "label": "postulate And_rect_CProp5 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)", "predict": "postulate And_rect_CProp5 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPrimes_below_to_bertrand. Låt $pm \\in N$. Låt $l$ vara en lista av naturliga tal. Anta att $pm$ är primt. Låt $__1$ vara ett element av $primes_below$ av $l$ och $pm + 1$. Låt $__2$ vara en funktion från naturliga tal $p$ och element $__2$ av $mem$ av $Nat$ och $p$ och $l$ och element $__3$ av $Lt$ av $2$ och $p$ till element av $ex$ av $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$. Låt $n \\in N$. Anta att $0 < n$. Då om $n < pm$, så håller $bertrand$ för $n$.\nAssistant:", "label": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n", "predict": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (pm + 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n"}
{"prompt": "Human: Translate the following English statement into Agda.\nSub0_to_false. Let $h$ and $k$ be functions from natural numbers to natural numbers. Let $A$ be a set. Let $I$ and $J$ be elements of $range$ of $A$. Assume that $upto$ applied to $A$ and $I$ is equal to $0$. Let $__1$ be an element of $sub_hk$ of $h$ and $k$ and $A$ and $J$ and $I$. Let $i \\in N$. Assume that $i$ is less than $upto$ applied to $A$ and $J$. Then $filter$ applied to $A$ and $J$ and $i$ is equal to absurdity.\nAssistant:", "label": "postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false", "predict": "postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n$ un nombre naturel. Supposons que $5$ est inférieur à $n$. Soit $m$ un nombre naturel. Supposons que $6$ est inférieur ou ágal à $m$. Supposons que la puissance de la somme de $m$ et de $1$ et de $2$ est inférieure ou ágale à la puissance de $2$ et de $m$. Soit $a \\in N$. Supposons que $6$ est inférieur ou ágal à $a$. Supposons que la somme du produit de $2$ et de la somme de $a$ et de $1$ et de $1$ est inférieure ou ágale à la puissance de $2$ et de $a$. Alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (lt6m : Leq 6 m) -> (Hind : Lt (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lt6a : Leq 6 a) -> (Hind1 : Lt (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type2. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$, pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_603$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_603$, pour tous les éléments $x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_602$.\nAssistant:", "label": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)", "predict": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_divides_to_dividesb_false. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nAssistant:", "label": "postulate not_divides_to_dividesb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)", "predict": "postulate not_divides_to_dividesb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_inv_S. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l \\in N$. Alors pour tous les éléments $b1$ et $b2$ de $B$, pour tous les éléments $__$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b2$, pour tous les nombres naturels $l0$, si $l0 + 1 = l$, alors $ex2$ tient pour $B$ et la fonction qui envoie $b$ à $R (b1, b)$ et la fonction qui envoie $b$ à $lstar (B, R, l0, b, b2)$.\nAssistant:", "label": "postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\\ b : B -> R b1 b) (\\ b : B -> lstar B R l0 b b2)", "predict": "postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (l0 + 1) l) -> ex2 B (\\ b : B -> R b1 b) (\\ b : B -> lstar B R l0 b b2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_plus. Soit $n, p, q \\in N$. Supposons que $n$ est et divisible par $p$ et divisible par $q$. Alors $n$ est divisible par $p + q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : and (divisible n p) (divisible n q)) -> divisible n (plus p q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEqb_sym. Let $a, b \\in N$. Then $eqb (a, b)= eqb (b, a)$.\nAssistant:", "label": "postulate eqb_sym : (a : Nat) -> (b : Nat) -> Eq (eqb a b) (eqb b a)", "predict": "postulate eqb_sym : (a : Nat) -> (b : Nat) -> Eq (eqb (a, b)) (eqb (b, a))"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_607$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_607$, pour tous les éléments $x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_606$.\nAssistant:", "label": "postulate option_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)", "predict": "postulate option_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_ind. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1233$ och element $x_1232$ av $B$ och element $x_1231$ av $B$ och element $_x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$ till påståenden. Låt $_H_lstar_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $_H_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element $x_1236$ av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $x_1235$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ och element $_x_1238$ av $Q_$ av $l$ och $b$ och $b2$ och $x_1235$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Då för alla naturliga tal $x_1233$, för alla element $x_1232$ och $x_1231$ av $B$, för alla element $x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$, håller $Q_$ för $x_1233$ och $x_1232$ och $x_1231$ och $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following French statement into Agda.\nS_mod. Pour tous les nombres naturels $_n$ et $_m$, $Nat$.\nAssistant:", "label": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat", "predict": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $bijf$ vara ett element av $bijn$ av $f$ och $n + 1$. Anta att $f (n + 1)= n + 1$. Låt $i \\in N$. Anta att $i \\leq n$. Låt $a \\in N$. Anta att $a \\leq n + 1$ och $f (a)= i$. Anta att $a \\leq n + 1$. Anta att $f (a)= i$. Då om $a = n + 1$, så $i = a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (n + 1)) -> (fn1 : Eq (f (n + 1)) (n + 1)) -> (i : Nat) -> (le : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (n + 1)) (Eq (f a) i)) -> (Hc : Leq a (n + 1)) -> (Ha : Eq (f a) i) -> (eqn0 : Eq a (n + 1)) -> Eq i a"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_divides_to_gcd_aux. Soit $p, m, n \\in N$. Supposons que $0 < n$ et $n$ n'est pas divisible par $m$. Alors $gcd_aux (p + 1, m, n)= gcd_aux (p, n, mod (m, n))$.\nAssistant:", "label": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))", "predict": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (p + 1) m n) (gcd_aux p n (mod m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nFound_max_spec. Soit $n$ un nombre naturel. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m$ un nombre naturel. Supposons que $m < n$ et $f (m)= true$. Alors pour toutes les fonctions $__2$ des nombres naturels $i$ et des éléments $__2$ de $Lt$ de $m$ et de $i$ et des éléments $__3$ de $Lt$ de $i$ et de $n$ à des éléments de $Eq$ de $f (i)$ et de contradiction, $max_spec$ tient pour $n$ et $f$ et $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_prim_n1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $n$.\nAssistant:", "label": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)", "predict": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb. Låt $m, n, p \\in N$. Då om $0 < n$ och $p$ är primt, så om $p$ inte är delbart med $n$, så är $bigop$ applicerat på $m$ och funktionen som avbildar $i$ som $dividesb$ applicerat på potensen av $p$ och summan av $i$ och $1$ och produkten av potensen av $p$ och $m$ och $n$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $1$ lika med $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nTrue_inv_ind. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour toutes les fonctions $P$ des éléments $_z125$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z126$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate True_inv_ind : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z125 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z126 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_ind : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z125 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z126 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_DPair. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$. Alors pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_plus_mod. Soient $m$ et $n$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $m$ et $n$ et $q$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $q$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $q$.\nAssistant:", "label": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))", "predict": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $permf$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lein$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $lejn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$", "label": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type", "predict": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (fb : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j)) -> (Hc : cic.Term cic.prop (matita_arithmetics_nat.eq i j)) -> cic.Term cic.prop (matita_arithmetics_nat.eq (matita_arithmetics_nat.suc (matita_arithmetics_nat.suc (matita_arithmetics_nat.suc (matita_arithmetics_nat.suc (mat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nVoid_rect_Type4. Låt $Q_$ vara en funktion från element $_x_483$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $univs.Type4$. Låt $x_483$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$. Då håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_483$.\nAssistant:", "label": "postulate void_rect_Type4 : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)", "predict": "postulate void_rect_Type4 : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_ind_body. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1337$ och element $x_1336$ av $B$ och element $x_1335$ av $B$ och element $_x_1338$ av $lstar_r$ av $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$ till påståenden. Låt $_H_lstar_r_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_r_O (B, _R, b)$. Låt $_H_lstar_r_S$ vara en funktion från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element $x_1340$ av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $x_1339$ av $_R$ av $b$ och $b2$ och element $_x_1342$ av $Q_$ av $l$ och $b1$ och $b$ och $x_1340$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_r_S (B, _R, l, b1, b, x_1340, b2, x_1339)$. Låt $x_1337$ vara ett naturligt tal. Låt $x_1336$ och $x_1335$ vara element av $B$. Låt $x_1338$ vara ett element av $lstar_r$ av $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$. Då håller $Q_$ för $x_1337$ och $x_1336$ och $x_1335$ och $x_1338$.\nAssistant:", "label": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338", "predict": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (l + 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338"}
{"prompt": "Human: Translate the following French statement into Agda.\nMod_O_to_divides. Soient $n$ et $m$ des nombres naturels. Alors si $0 < n$ et $mod (m, n)= 0$, alors $n$ est divisible par $m$.\nAssistant:", "label": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m", "predict": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_CProp4_body. För alla funktioner $Q_$ från naturliga tal $_x_393$ till påståenden, för alla element $_H_O$ av $Q_$ av $0$, för alla funktioner $_H_S$ från naturliga tal $x_394$ och element $_x_396$ av $Q_$ av $x_394$ till element av $Q_$ av summan av $x_394$ och $1$, för alla naturliga tal $x_393$, håller $Q_$ för $x_393$.\nAssistant:", "label": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393", "predict": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$. Then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_S. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Let $__$ be an element of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$. Let $b2$ be an element of $B$. Then for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nAssistant:", "label": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (l + 1) b1 b2"}
{"prompt": "Human: Translate the following English statement into Agda.\nExp_n_1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate exp_n_1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate exp_n_1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sqrt_to_lt_times_r. Låt $m, n \\in N$. Anta att kvadratroten av $m$ är mindre än $n$. Då är $m$ mindre än produkten av $n$ och $n$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> (_ : Lt (sqrt m) n) -> Lt m (times n n)", "predict": "postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> (_ : Lt (sqrt m) n) -> Lt m (times n n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_Psi_2_n. Soit $n \\in N$. Supposons que $0 < n$. Alors le produit de $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et de $bool_to_nat$ appliqué à $leb$ appliqué à la somme de $n$ et de $1$ et la puissance de $p$ et de la somme de $i$ et de $1$ et de $Psi (n)$ est égal à $Psi (2 n)$.\nAssistant:", "label": "postulate eq_Psi_2_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (Psi (times 2 n)) (times (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi n))", "predict": "postulate eq_Psi_2_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (times (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi n)) (Psi (times 2 n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_theta_M_theta. Pour tous les nombres naturels $m$, $theta (2 m + 1)\\leq M (m)theta (m + 1)$.\nAssistant:", "label": "postulate le_theta_M_theta : (m : Nat) -> Leq (theta (plus (times 2 m) 1)) (times (M m) (theta (plus m 1)))", "predict": "postulate le_theta_M_theta : (m : Nat) -> Leq (theta (2 m + 1)) (M m (theta (m + 1)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nRC_reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.reflexive$ applied to $A$ and $matita_basics_relations.RC$ applied to $A$ and $R$.\nAssistant:", "label": "postulate RC_reflexive : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))", "predict": "postulate RC_reflexive : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_inv_ind. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1698$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat", "label": "postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.op x1 x2 b c)) (matita_arithmetics_bigops.op x1 x2 (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_le_minus_r. Låt $p$ och $q$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $p$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $q$.\nAssistant:", "label": "postulate monotonic_le_minus_r : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))", "predict": "postulate monotonic_le_minus_r : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAxiom. Låt $_n$ vara ett naturligt tal. Då är $\\sqrt{ _n}$ ett naturligt tal.\nAssistant:", "label": "postulate sqrt : (_n : Nat) -> Nat", "predict": "postulate sqrt : (_n : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Assume that $m n = p c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H2 : Eq (gcd p m) (minus (times b m) (times a p))) -> (H3 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times a p)) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCongruent_ab_lt. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $x$ som $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $a$ och $m$ och $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $b$ och $n$ och $matita_arithmetics_nat.lt$ applicerat på $x$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$.\nAssistant:", "label": "postulate congruent_ab_lt : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))", "predict": "postulate congruent_ab_lt : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_O_to_not_divides. Soient $n$ et $i$ et $r$ des nombres naturels. Alors si $0$ est inférieur à $n$, alors si $p_ord$ appliqué à $n$ et $nth_prime$ appliqué à $i$ est égal à $mk_Prod$ appliqué à $Nat$ et $Nat$ et $0$ et $r$, alors $nth_prime$ appliqué à $i$ n'est pas divisible par $n$.\nAssistant:", "label": "postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)", "predict": "postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$ and $n \\leq m$. Assume that $n \\leq q + 1$ and $n$ is not divisible by $m$. Let $a \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$ and $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then $n b - a mod (m, n)= gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : N) -> (q : N) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq : Leq n q) -> (ndivnm : not (divisible n m)) -> (a : N) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_to_not_eq_O. Let $n, p, q, r \\in N$. Assume that $1 < n$ and $p_ord (n, nth_prime (p))= mk_Prod (Nat, Nat, q, r)$. Then $r$ is not equal to $0$.\nAssistant:", "label": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)", "predict": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_exists. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $t$ et $m$ des nombres naturels. Supposons que $m < t$. Supposons que $f (m)= true$. Soit $k, b \\in N$. Supposons que $b \\leq m$. Soit $__3$ une fonction des nombres naturels $i$ et des éléments $__3$ de $Leq$ de $b$ et de $i$ et des éléments $__4$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $f (i)$ et de contradiction. Alors si $t = k + b$, alors $min (k, b, f)= m$.\nAssistant:", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (_ : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Then if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (eqm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (gcd p m) (minus (times b m) (times a p))) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) (gcd p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nSubR. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_R$ and $_S$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$. Then $cic.Univ$ holds for $cic.prop$.\nAssistant:", "label": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following English statement into Agda.\nNill. Let $A$ be a set. Let $nil$ be an element of $A$. Then for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ is equal to $a$.\nAssistant:", "label": "postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a", "predict": "postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_0. Soit $n \\in N$. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Alors pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $true$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à la somme de $i$ et de $1$ et $f$ appliqué à $0$ est égal à $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $i$ à $true$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i)) (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0))", "predict": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0)) (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq d m))) -> (Hc : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que $b m - a p = 1$. Alors $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (d : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (pc c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (gcd p m) (minus (times b m) (times a p))) -> (H0 : Eq (times b m) (plus (times a p) 1)) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divisor_common_max n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_aux_body. Låt $_p, _m, _n \\in N$. Då $Nat$.\nAssistant:", "label": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat", "predict": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nProp140. Let $x, y \\in Z$. Then $x$ is equal in parity with $y$, if and only if the sum of $x$ and $y$ is even.\nAssistant:", "label": "postulate prop140 : (x : Int) -> (y : Int) -> iff (same_parity x y) (even (plus x y))", "predict": "postulate prop140 : (x : Z) -> (y : Z) -> iff (same_parity x y) (even (plus x y))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Då om $0$ är mindre än $m$, så om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEx_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_ex_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $x_236$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.ex_intro$ applicerat på $A$ och $_P$ och $x$ och $x_236$, för alla element $x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_235$.\nAssistant:", "label": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)", "predict": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_void. Pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAll_append. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soient $l1$ et $l2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l1$. Alors pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$.\nAssistant:", "label": "postulate All_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))", "predict": "postulate All_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_discr. Låt $a1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $a2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $a1$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $a1$ och $a2$, för alla element $_e$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $a1$ och $a2$ och $x$ och $y$, håller $cic.Term$ för $univs.Type2$ och $matita_basics_types.match_Sig$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Sig$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $u0$ och $u1$ som", "label": "postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term cic.prop (a2 t0) -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term cic.prop (a2 u0) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_", "predict": "postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term univs.Type0 a2 -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term univs.Type0 a2 -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 u0)) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) t0 u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a2) t1 u1)) (\\ e1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_div_mod_spec. Let $n$ and $m$ be natural numbers. Assume that $0$ is less than $n$. Assume that $n$ is divisible by $m$. Then $div_mod_spec$ holds for $m$ and $n$ and the quotient of $m$ and $n$ and $0$.\nAssistant:", "label": "postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0", "predict": "postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrime_to_lt_O. Pour tous les nombres naturels $p$, si $p$ est premier, alors $0$ est inférieur à $p$.\nAssistant:", "label": "postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p", "predict": "postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPair_elim2. Låt $A$ och $B$ och $C$ och $C'$ vara element av $cic.Univ$ av $univs.Type0$. Låt $T$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Låt $T'$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C'$. Då för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $C'$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop", "label": "postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) p) (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C') (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T' lft rgt) p))", "predict": "postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))) -> cic.Term cic.prop (P p (matita_basics_logic.lift2 univs.Type0 univs.Type2 A B C (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) (matita_basics_logic.lift2 univs.Type0 univs.Type2 A B C' (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T' lft rgt))) (matita_basics_logic.lift2 univs.Type0 univs.Type2 A B C' (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> matita_basics_logic.R0 (matita"}
{"prompt": "Human: Translate the following English statement into Agda.\nRefute_none_by_refl. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $Q$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$. Let $x$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$. Then for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $", "label": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_logic.match_False univs.Type0 (\\ _0 : cic.Term cic.prop matita_basics_logic.False -> B) (H E)) (\\", "predict": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_types.None B)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_exp_to_divides. Soit $p, n, m \\in N$. Alors si $p$ est premier, alors si $p$ est divisible par $n ^ m$, alors $p$ est divisible par $n$.\nAssistant:", "label": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n", "predict": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_times. Låt $n1$ och $n2$ och $m1$ och $m2$ vara naturliga tal. Anta att $n1$ är mindre än eller lika med $n2$. Då om $m1$ är mindre än eller lika med $m2$, så är produkten av $n1$ och $m1$ mindre än eller lika med produkten av $n2$ och $m2$.\nAssistant:", "label": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)", "predict": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_maxr. Let $i, n, m \\in N$. Assume that $max$ applied to $n$ and $m$ is less than or equal to $i$. Then $m$ is less than or equal to $i$.\nAssistant:", "label": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i", "predict": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c \\in N$. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a \\in N$. Alors pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale à $1$, alors le diviseur commun plus grand de $p$ et de $m$ est égal à la différence du produit de $p$ et de $a$ et du produit de $m$ et de $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMonotonic_lt_times_r. Let $c \\in N$. Then if $0 < c$, then $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $t$ to $c \\times t$.\nAssistant:", "label": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> times c t)", "predict": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> c * t)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1569. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hc : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type0. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Then for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.\nAssistant:", "label": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873", "predict": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSameF_p_le. Låt $A$ vara en mängd. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $f$ och $g$ vara funktioner från naturliga tal till element av $A$. Låt $n$ och $m$ vara naturliga tal. Då om $n$ är mindre än eller lika med $m$, så för alla element $__1$ av $sameF_p$ av $m$ och $p$ och $A$ och $f$ och $g$, håller $sameF_p$ för $n$ och $p$ och $A$ och $f$ och $g$.\nAssistant:", "label": "postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g", "predict": "postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> Prop) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g"}
{"prompt": "Human: Translate the following English statement into Agda.\nProp110. Let $a$ and $c$ be integers. Then if both $a$ and $c$ are odd, then $a b + b c$ is even for every integer $b$.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : (a : Int) -> (c : Int) -> if (and (odd a) (odd c)) (even (plus a b) (plus b c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPlus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nAssistant:", "label": "postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)", "predict": "postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0$ är mindre än $n$, så om $0$ är mindre än $m$, så om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDecidable_lt. För alla naturliga tal $n$ och $m$, håller $decidable$ för $Lt (n, m)$.\nAssistant:", "label": "postulate decidable_lt : (n : Nat) -> (m : Nat) -> decidable (Lt n m)", "predict": "postulate decidable_lt : (n : Nat) -> (m : Nat) -> decidable (Lt n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_73. Let $n$ and $m$ and $p$ be natural numbers. Assume that $0$ is less than $p$. Let $x134$ and $x135$ and $x136$ be natural numbers. Then the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.\nAssistant:", "label": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))", "predict": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type2. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_None$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_603$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_603$. Soit $x_602$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_602$.\nAssistant:", "label": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)", "predict": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBool_rect_Type2. Soit $Q_$ une fonction des éléments $_x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_338$.\nAssistant:", "label": "postulate bool_rect_Type2 : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)", "predict": "postulate bool_rect_Type2 : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_Sm_elim. Soit $n, m \\in N$. Supposons que $n$ est inférieur ou ágal à la somme de $m$ et de $1$. Soit $P$ une proposition. Soit $__1$ une fonction des éléments $__1$ de $Leq$ de la somme de $n$ et de $1$ et de la somme de $m$ et de $1$ à des éléments de $P$. Alors pour toutes les fonctions $__2$ des éléments $__2$ de $Eq$ de $n$ et de la somme de $m$ et de $1$ à des éléments de $P$, $P$.\nAssistant:", "label": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P", "predict": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1595. Let $p, n, m \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $1$ is less than the greatest common divisor of $p$ and the product of $n$ and $m$, then if $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $n$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)", "predict": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMod_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)", "predict": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_S_to_lt. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)", "predict": "postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_discr. For all sets $a1$, for all elements $x$ and $y$ of $range$ of $a1$, if $x = y$, then $match_range$ holds for $a1$ and $Type2 + 1$ and the function that maps $__$ to $univ (Type2)$ and the function that maps $t0$ and $t1$ and $t2$ to $match_range$ applied to $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$", "label": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : ((_ : Nat) -> a1) -> \\ t1 : Nat -> \\ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : ((_ : Nat) -> a1) -> \\ u1 : Nat -> \\ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\\ _e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\", "predict": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_ : Eq x y) -> match_range a1 (Type2 + 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : range a1 -> \\ t1 : range a1 -> \\ t2 : range a1 -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : range a1 -> \\ u1 : range a1 -> \\ u2 : range a1 -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : range a1 -> \\ p0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) x0 -> Nat) t1) u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : range a1 -> \\ p0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) x0 -> Nat) t1) u0 e0 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : range a1 -> \\ p0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) x0 -> Nat) t1 (\\ x0 : range a1 -> \\ p0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : range a1 -> \\ p00 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_d_times_gcd. Soient $m$ et $n$ et $d$ et $c$ des nombres naturels. Alors si $0 < c$ et $d$ est divisible par $c \\times m$, alors si $d$ est divisible par $c \\times n$, alors $d$ est divisible par le produit de $c$ et du diviseur commun plus grand de $n$ et de $m$.\nAssistant:", "label": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))", "predict": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (c * m)) -> (__2 : divisible d (c * n)) -> divisible d (times c (gcd n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_divides_ord_rem. Let $p, n, m \\in N$. Then if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then $ord_rem$ applied to $n$ and $p$ is divisible by $ord_rem$ applied to $m$ and $p$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_1_to_lt_n. Let $i, n \\in N$. Assume that $1$ is less than $n$. Then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n", "predict": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp5_body. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that $b m - a p = 1$. Then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) (and (Eq (gcd p m) (minus (times b m) (times a p))) (Eq 1 (minus (times b m) (times a p))))) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_mod. Soit $p, m, n \\in N$. Alors si $0$ est inférieur à $n$, alors si $p$ est divisible par $m$, alors si $p$ est divisible par $n$, alors $p$ est divisible par $mod$ appliqué à $m$ et $n$.\nAssistant:", "label": "postulate divides_mod : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)", "predict": "postulate divides_mod : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_lt_to_lt. Let $n, m, p \\in N$. Assume that $n \\leq m$ and $m < p$. Then $n < p$.\nAssistant:", "label": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p", "predict": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p"}
{"prompt": "Human: Translate the following English statement into Agda.\nEven_or_odd. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$.\nAssistant:", "label": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))", "predict": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nFalse_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.\nAssistant:", "label": "postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)", "predict": "postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLength_map. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $B$ et $matita_basics_lists_list.map$ appliqué à $A$ et $B$ et $f$ et $l$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$.\nAssistant:", "label": "postulate length_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))", "predict": "postulate length_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax'. Let $__ \\in N$. Let $__1$ be a function from natural numbers $__1$ to booleans. Let $__2$ be a natural number. Then $Nat$.\nAssistant:", "label": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat", "predict": "postulate max' : (_ : N) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_inv_rect_Type3. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$, för alla funktioner $P$ från element $_z1644$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H1$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ och element $_z1645$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ och $Hterm$ och $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$, håller $cic.Term$ för $univs.Type3$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_list. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_CProp1_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nAssistant:", "label": "postulate range_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)", "predict": "postulate range_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1686. Låt $n$ och $m$ vara naturliga tal. Låt $Hind$ vara en funktion från naturliga tal $p$ och element av $Lt$ av $p$ och $m$ och element $__1$ av $Lt$ av $1$ och $p$ till element av $Leq$ av $Psi (p)$ och $pred (p)\\times (2 ^ (2 p - 3))$. Låt $a \\in N$. Anta att $m = 2 a$ eller $m = 2 a + 1$ och $m = 2 a + 1$. Anta att $1 < 2 a + 1$ och $0 < a$. Då $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\* (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : Lt 1 (2 a + 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (a + a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_min_r. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $n$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$.\nAssistant:", "label": "postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))", "predict": "postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_inv_S_dx. Låt $B$ vara en mängd. Då för alla element $R$ av $relation$ av $B$, för alla naturliga tal $l$, för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar$ av $B$ och $R$ och summan av $l$ och $1$ och $b1$ och $b2$, håller $ex2$ för $B$ och funktionen som avbildar $b$ som $lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b$ och funktionen som avbildar $b$ som $R$ applicerat på $b$ och $b2$.\nAssistant:", "label": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)", "predict": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_inv_plus_l. Låt $x$ och $y$ och $z$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $z$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $x$ och $z$ och $matita_arithmetics_nat.lt$ applicerat på $y$ och $matita_arithmetics_nat.minus$ applicerat på $z$ och $x$.\nAssistant:", "label": "postulate lt_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))", "predict": "postulate lt_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSqrt_def. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $matita_arithmetics_minimization.max$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie $x$ à $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x$ et $x$ et $n$.\nAssistant:", "label": "postulate sqrt_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))", "predict": "postulate sqrt_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nProd. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nAssistant:", "label": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b$ be a natural number. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$. Then if $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then $n b - a mod (m, n)= gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : N) -> (q : N) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq : Leq n q) -> (ndivnm : not (divisible n m)) -> (a : N) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_or_gt. Låt $n$ vara ett naturligt tal. Då $0 = n$ eller $0 < n$.\nAssistant:", "label": "postulate eq_or_gt : (n : Nat) -> or (Eq 0 n) (Lt 0 n)", "predict": "postulate eq_or_gt : (n : Nat) -> or (Eq 0 n) (Lt 0 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Dop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på", "label": "postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFst_p_ord_times. Låt $p$ och $a$ och $b$ vara naturliga tal. Anta att $p$ är primt. Anta att $0$ är mindre än $a$. Då om $0$ är mindre än $b$, så är $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på produkten av $a$ och $b$ och $p$ lika med summan av $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $a$ och $p$ och $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $b$ och $p$.\nAssistant:", "label": "postulate fst_p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))", "predict": "postulate fst_p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_div_div_div_div. Låt $n, m, q \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då är kvoten av kvoten av $q$ och $n$ och $m$ lika med kvoten av kvoten av $q$ och $m$ och $n$.\nAssistant:", "label": "postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)", "predict": "postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFound_max_spec. Soit $n \\in N$. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m \\in N$. Alors si $m$ est inférieur à $n$, alors si $f$ appliqué à $m$ est égal à $true$, alors pour toutes les fonctions $__2$ des nombres naturels $i$ et des éléments $__2$ de $Lt$ de $m$ et de $i$ et des éléments $__3$ de $Lt$ de $i$ et de $n$ à des éléments de $Eq$ de $f$ appliqué à $i$ et de contradiction, $max_spec$ tient pour $n$ et $f$ et $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (_ : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_exp_to_lt. Soit $a, n, m \\in N$. Alors si $0 < a$, alors si $a ^ n < a ^ m$, alors $n < m$.\nAssistant:", "label": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m", "predict": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDistributive_times_plus_r. Låt $a$ och $b$ och $c$ vara naturliga tal. Då är produkten av summan av $b$ och $c$ och $a$ lika med summan av produkten av $b$ och $a$ och produkten av $c$ och $a$.\nAssistant:", "label": "postulate distributive_times_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (times (plus b c) a) (plus (times b a) (times c a))", "predict": "postulate distributive_times_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (times (plus b c) a) (plus (times b a) (times c a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_inv_rect_Type2. Låt $x1$ vara en mängd. Låt $Hterm$ vara ett element av $range$ av $x1$. Låt $P$ vara en funktion från element $_z1650$ av $range$ av $x1$ till element av $Type2$. Låt $_H1$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $x1$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden och element $_z1651$ av $Eq$ av $Hterm$ och $mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$ till element av $P$ av $mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors pour tous les nombres naturels $x1029$, $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divisor (n) (m)) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1128$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1129$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nTheta_pred. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nAssistant:", "label": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_plus_times. För alla naturliga tal $m$ och $q$ och $r$, om $r$ är mindre än $m$, så är kvoten av summan av produkten av $q$ och $m$ och $r$ och $m$ lika med $q$.\nAssistant:", "label": "postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q", "predict": "postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_divides. Pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nAssistant:", "label": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1. Soit $_A$ un ensemble. Soit $Q_$ une fonction des éléments $_x_925$ de $range$ de $_A$ à des éléments de $Type1$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range (_A, _enum, _upto, _filter)$. Soit $x_925$ un élément de $range$ de $_A$. Alors $Q_$ tient pour $x_925$.\nAssistant:", "label": "postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925", "predict": "postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.\nAssistant:", "label": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProd_ind_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_690$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_690$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_690$.\nAssistant:", "label": "postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)", "predict": "postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Då för alla funktioner $P$ från element $_z1062$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $_z1063$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_607$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1063$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_607$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_607$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nK1. Soient $n$ et $p$ des nombres naturels. Alors si $18 \\leq n$ et $p \\leq n$, alors si $2 n \\div 3 < p$, alors $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : and (Geq 18 n) (Leq p n)) -> (__1 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_exists_to_forall. Låt $P$ vara en funktion från naturliga tal till påståenden. Låt $n \\in N$. Anta att det inte är fallet att $ex$ håller för $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och $P$ applicerat på $i$. Då för alla naturliga tal $i$, om $i < n$, så är det inte fallet att $P$ håller för $i$.\nAssistant:", "label": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)", "predict": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_minus. Låt $n, p, q \\in N$. Anta att $n$ är delbart med $p$. Anta att $n$ är delbart med $q$. Då är $n$ delbart med $p - q$.\nAssistant:", "label": "postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (minus p q)", "predict": "postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (minus p q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nR2. For all elements $T0$ of $cic.Univ$ of $univs.Type0$, for all elements $a0$ of $cic.Term$ of $univs.Type0$ and $T0$, for all functions $T1$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$, for all functions $T2$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_a2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $", "label": "postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univ", "predict": "postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) -> cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1559. Låt $n, m \\in N$. Anta att $n$ är delbart med $m$. Anta att $0$ är lika med $n$. Låt $d \\in N$. Anta att $m$ är lika med produkten av $0$ och $d$. Då är $m$ lika med $n$.\nAssistant:", "label": "postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n", "predict": "postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (eqn0 : Eq 0 n) -> (d : Nat) -> (eqm : Eq m (times 0 d)) -> Eq m n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFound_min_spec. Låt $n$ och $b$ vara naturliga tal. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $m \\in N$. Anta att $b$ är mindre än eller lika med $m$. Anta att $m$ är mindre än summan av $n$ och $b$. Anta att $f$ applicerat på $m$ är lika med $true$. Då för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion, håller $min_spec$ för $n$ och $b$ och $f$ och $m$.\nAssistant:", "label": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m", "predict": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (_ : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_exp. Let $n$ and $m$ and $i$ be natural numbers. Assume that $0$ is less than $m$. Assume that $mod$ applied to $n$ and $m$ is not equal to $0$. Let $p$ be a natural number. Then if $i$ is less than or equal to $p$, then $p_ord_aux$ applied to $p$ and the product of the exponentiation of $m$ and $i$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $i$ and $n$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16004. Let $m, n, a, b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPlus_minus_m_m. For all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then $n$ is equal to the sum of the difference of $n$ and $m$ and $m$.\nAssistant:", "label": "postulate plus_minus_m_m : (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> Eq n (plus (minus n m) m)", "predict": "postulate plus_minus_m_m : (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> Eq n (plus (minus n m) m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar_r. För alla mängder $B$, för alla element $_R$ av $relation$ av $B$, för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$, för alla funktioner $case_lstar_r_O$ från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_r_O (B, _R, b)$, för alla funktioner $case_lstar_r_S$ från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $__1$ av $_R$ av $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_r_S (B, _R, l, b1, b, __, b2, __1)$, för alla naturliga tal $__$, för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (l + 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_distr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a", "label": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))))", "predict": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $A$, för alla element $_x_942$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $A$.\nAssistant:", "label": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A", "predict": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_803$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_", "label": "postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)", "predict": "postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_conj$ from elements $x_140$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_140$ and $x_139$, for all elements $x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_138$.\nAssistant:", "label": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)", "predict": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"}
{"prompt": "Human: Translate the following French statement into Agda.\nOrd_exp. Soient $p$ et $m$ des nombres naturels. Alors si $1 < p$, alors $ord (p ^ m, p)= m$.\nAssistant:", "label": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m", "predict": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_ind. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1500$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2, a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a, x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ and elements $_z1501$ of $Eq$ of $Hterm$ and $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ to elements of $P$ of $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$. Then for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita", "label": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)", "predict": "_arpostulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.ACop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.ACop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__aop. Soit $x0$ un ensemble. Soit $x1$ un élément de $x0$. Alors pour toutes les fonctions $x2$ des éléments de $ACop$ de $x0$ et de $x1$ à des ensembles, pour tous les éléments $x3$ de $DPair$ de $ACop$ appliqué à $x0$ et $x1$ et de $x2$, $Aop$ tient pour $x0$ et $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1", "predict": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_ind. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.\nAssistant:", "label": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943", "predict": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_inv_rect_Type3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z335$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H1$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z336$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_eq_to_eqb_false. For all natural numbers $n$ and $m$, if $n$ is not equal to $m$, then absurdity is equal to $eqb (n, m)$.\nAssistant:", "label": "postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq (eqb n m) false", "predict": "postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq false (eqb (n, m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_907$ of $ACop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_907$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_907$.\nAssistant:", "label": "postulate ACop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907", "predict": "postulate ACop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907"}
{"prompt": "Human: Translate the following English statement into Agda.\nSig_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Sig$ be a function from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$. Then for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.\nAssistant:", "label": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)", "predict": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"}
{"prompt": "Human: Translate the following English statement into Agda.\nPos_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nAssistant:", "label": "postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))", "predict": "postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_rect_CProp3_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_154$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_conj$ des éléments $x_156$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_155$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_156$ et $x_155$, pour tous les éléments $x_154$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_154$.\nAssistant:", "label": "postulate And_rect_CProp3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)", "predict": "postulate And_rect_CProp3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1704. Soit $m$ un nombre naturel. Supposons que $0 < m$. Alors pour tous les nombres naturels $a$ et $x1029$, $x1029 = aop__o__op (Nat, 0, plusAC, x1029, 0)$.\nAssistant:", "label": "postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)", "predict": "postulate let_clause_1704 : (m : Nat) -> (posn : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_max_to_pi_p_primeb. Soit $q, m \\in N$. Supposons que $0 < m$. Supposons que $q$ est inférieur à $max$ appliqué à la somme de $m$ et de $1$ et la fonction qui envoie $i$ à $andb$ appliqué à $primeb$ appliqué à $i$ et $dividesb$ appliqué à $i$ et $m$. Alors $bigop$ appliqué à $q$ et la fonction qui envoie $p$ à $andb$ appliqué à $primeb$ appliqué à $p$ et $dividesb$ appliqué à $p$ et $m$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à la puissance de $p$ et de $ord$ appliqué à $m$ et $p$ est égal à $m$.\nAssistant:", "label": "postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (max (plus m 1) (\\ i : Nat -> andb (primeb i) (dividesb i m))) q) -> Eq m (bigop q (\\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\\ p : Nat -> pow p (ord m p)))", "predict": "postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt q (max (plus m 1) (\\ i : Nat -> andb (primeb i) (dividesb i m)))) -> Eq (bigop q (\\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\\ p : Nat -> pow p (ord m p))) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$. Anta att $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a \\in N$. Anta att $6 \\leq a$. Anta att $2 (a + 1)+ 1 \\leq 2 ^ a$. Låt $x2515, x2516 \\in N$. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 a) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_to_le. Soient $b$ et $n$ et $m$ des nombres naturels. Supposons que $1 < b$ et $b ^ n \\leq b ^ m$. Alors $n \\leq m$.\nAssistant:", "label": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m", "predict": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_inv_rect_CProp4. För alla mängder $x1$, för alla element $x2$ av $x1$, för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1602$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op (x1, x2, aop, a, b)$ och $op (x1, x2, aop, b, a)$ och element $_z1603$ av $Eq$ av $Hterm$ och $mk_ACop (x1, x2, aop, _comm)$ till element av $P$ av $mk_ACop (x1, x2, aop, _comm)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_Type3. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_895$ of $ACop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_895$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_895$.\nAssistant:", "label": "postulate ACop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895", "predict": "postulate ACop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895"}
{"prompt": "Human: Translate the following English statement into Agda.\nSigma_p_dividesb. Let $m$ and $n$ and $p$ be natural numbers. Then if $0 < n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type4_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_917$ av $range$ av $_A$ till element av $Type4$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Låt $x_917$ vara ett element av $range$ av $_A$. Då håller $Q_$ för $x_917$.\nAssistant:", "label": "postulate range_rect_Type4_body : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917", "predict": "postulate range_rect_Type4_body : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1545. Låt $m, n \\in N$. Anta att $0$ är både lika med det största gemensama delaret av $m$ och $n$ och delbart med $n$. Låt $q1 \\in N$. Anta att $n = 0 q1$ och $0$ är delbart med $m$. Låt $q2 \\in N$. Då om $m = 0 q2$, så $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 (gcd m n)) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (eqn1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (Hind : Eq m (times 0 q2)) -> Eq m 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $p, n \\in N$. Assume that $1 < p$. Let $m$ and $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (lt1p : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (lt1p : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16001. Soit $m, n, a, b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$, alors si $c n - d m = 1$, alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_inv_ind. Soient $x1$ et $x2$ des nombres naturels. Soit $x3$ une fonction des nombres naturels à des valeurs booléennes. Soit $x4$ un nombre naturel. Soit $_Hterm$ un élément de $min_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Soit $P$ une fonction des nombres naturels $_z1890$ à des propositions. Soit $_H1$ une fonction des nombres naturels $m$ et des éléments $_x_1080$ de $Leq$ de $x2$ et de $m$ et des éléments $_x_1079$ de $Lt$ de $m$ et de $x1 + x2$ et des éléments $_x_1078$ de $Eq$ de $x3 (m)$ et de $true$ et des fonctions $_x_1077$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $m$ à des éléments de $P$ de $m$. Soit $_H2$ une fonction des fonctions $_x_1081$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $x1 + x2$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $x1 + x2$ à des éléments de $P$ de $x1 + x2$. Alors $P$ tient pour $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (x1 + x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (x1 + x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (x1 + x2)) -> P (x1 + x2)) -> P x4"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Then for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_plus_l. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.monotonic$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.lt$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.plus$ applicerat på $m$ och $n$.\nAssistant:", "label": "postulate monotonic_lt_plus_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))", "predict": "postulate monotonic_lt_plus_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_rect_Type0_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $P$ des éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $a$ et $matita_basics_logic.refl$ appliqué à $A$ et $a$, pour tous les éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $p$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $x$ et $p$.\nAssistant:", "label": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)", "predict": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_div_S. Låt $n, m \\in N$. Då om $0 < m$, så $n < (n \\div m + 1)m$.\nAssistant:", "label": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)", "predict": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n ((div n m) + 1) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_CProp1. Låt $x1, x2, x3, x4 \\in N$. Då för alla element $Hterm$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1488$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden, för alla funktioner $_H1$ från element $x_855$ av $Lt$ av $x4$ och $x2$ och element $x_854$ av $Eq$ av $x1$ och $x3 x2 + x4$ och element $_z1489$ av $Eq$ av $Hterm$ och $div_mod_spec_intro (x1, x2, x3, x4, x_855, x_854)$ till element av $P$ av $div_mod_spec_intro (x1, x2, x3, x4, x_855, x_854)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (plus (times x3 x2) x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : N) -> (x2 : N) -> (x3 : N) -> (x4 : N) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (x3 x2 + x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_log. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $1 < p$. Supposons que $n \\leq m$. Alors $\\log_ p {n}\\leq \\log_ p {m}$.\nAssistant:", "label": "postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Leq n m) -> Leq (log p n) (log p m)", "predict": "postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Leq n m) -> Leq (log p n) (log p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_pi. Låt $n$ vara ett naturligt tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ mindre än eller lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15623. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Then for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_transpose_l. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n, i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Då för alla element $__2$ av $bijn$ av $f$ och $n$, håller $bijn$ för funktionen som avbildar $p$ som $transpose (i, j, f (p))$ och $n$.\nAssistant:", "label": "postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\\ p : Nat -> transpose i j (f p)) n", "predict": "postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\\ p : Nat -> transpose (i, j, f (p)) n) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type0. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_873$ av $Aop$ av $A$ och $_nil$ till mängder. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Då för alla element $x_873$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_873$.\nAssistant:", "label": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873", "predict": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_gcd_aux. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Then if $0$ is less than $n$, then if $n$ is divisible by $m$, then $gcd_aux$ applied to $p$ and $m$ and $n$ is equal to $n$.\nAssistant:", "label": "postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n", "predict": "postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nSig_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1212$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1213$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBool_rect_CProp3_body. För alla funktioner $Q_$ från element $_x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_353$.\nAssistant:", "label": "postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)", "predict": "postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1686. Soit $n, m \\in N$. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Alors pour tous les nombres naturels $a$, si $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$, alors si $1 < 2 a + 1$ et $0 < a$, alors $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\* (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (and (Eq m (2 a + 1)) (Eq m (2 a + 1)))) -> (__1 : Lt 1 (2 a + 1)) -> (__2 : Lt 0 a) -> Eq (pred m) (plus a a)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1569. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times c n) (times d m)) 1))) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$. Alors pour tous les nombres naturels $x1029$, $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPermut_n_to_le. Låt $h$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $h$ och $n$. Låt $__2$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $h$ applicerat på $m$ och $m$. Låt $j$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__3$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $j$. Då för alla element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $h$ applicerat på $j$.\nAssistant:", "label": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))", "predict": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$. Assume that $p1 (n1)= true$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (_ : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2515 \\ x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_divides_times. Låt $p, q, n \\in N$. Anta att $p$ är primt. Anta att $p$ inte är delbart med $q$. Anta att $p$ är delbart med $n$. Då om $q$ är delbart med $n$, så är $p \\times q$ delbart med $n$.\nAssistant:", "label": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n", "predict": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp4. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_903$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_903$.\nAssistant:", "label": "postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903", "predict": "postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Supposons que $2 ^ 7 \\leq n$. Soit $p \\in N$. Supposons que $(\\sqrt{ 2 n})+ 1 \\leq p$ et $p < 2 n + 1$. Supposons que $leb (2, k (2 n, p))= true$ et $2 n < p ^ 2$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (posn : Leq (pow 2 7) n) -> (p : Nat) -> (Hind : and (Leq ((sqrt (2 n)) + 1) p) (Lt p (2 n + 1))) -> (Hind' : and (Eq (leb 2 (k 2 n p)) true) (Lt 2 n (pow p 2))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_I_gen. Soient $a$ et $b$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $Aop$ de $B$ et de $nil$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $a \\leq b$. Alors $bigop$ appliqué à $b$ et la fonction qui envoie $i$ à $andb$ appliqué à $leb$ appliqué à $a$ et $i$ et $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à la différence de $b$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$.\nAssistant:", "label": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nF_ind. Let $A$ be a set. Let $f$ be a function from elements of $A$ to natural numbers. Then for all elements $P$ of $predicate$ of $A$, for all functions $__$ from natural numbers $n$ and functions from elements $a$ of $A$ and elements of $Lt$ of $f$ applied to $a$ and $n$ to elements of $P$ of $a$ and elements $a$ of $A$ and elements $__1$ of $Eq$ of $f$ applied to $a$ and $n$ to elements of $P$ of $a$, for all elements $a$ of $A$, $P$ holds for $a$.\nAssistant:", "label": "postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a", "predict": "postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $__$ and $__1$ be natural numbers. Then $__ \\div __1$ is a natural number.\nAssistant:", "label": "postulate div : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate div : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nNext. Assume that $Sort$. Then $Sort$.\nAssistant:", "label": "postulate next : Sort -> Sort", "predict": "postulate next : Sort -> Sort"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Prod. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (Hc : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1))) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_ord_rem. Låt $p$ och $q$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Anta att $q$ är primt. Då om $q < p$, så $ord (ord_rem (m, p), q)= ord (m, q)$.\nAssistant:", "label": "postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)", "predict": "postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem (m, p), q) (ord m q))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_inv_S_dx. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l$ un nombre naturel. Alors pour tous les éléments $b1$ et $b2$ de $B$, pour tous les éléments $__$ de $lstar$ de $B$ et de $R$ et de $l + 1$ et de $b1$ et de $b2$, $ex2$ tient pour $B$ et la fonction qui envoie $b$ à $lstar (B, R, l, b1, b)$ et la fonction qui envoie $b$ à $R (b, b2)$.\nAssistant:", "label": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)", "predict": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (l + 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $bijf$ be an element of $bijn$ of $f$ and $n + 1$. Assume that $f (n + 1)= n + 1$. Let $i$ be a natural number. Assume that $i \\leq n$. Let $a \\in N$. Assume that $a \\leq n + 1$ and $f (a)= i$. Assume that $a \\leq n + 1$. Assume that $f (a)= i$. Then if $a = n + 1$, then $i = a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f n 1) -> (fn1 : Eq (f (n + 1)) (n + 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (n + 1)) (Eq (f a) i)) -> (Hc : Leq a (n + 1)) -> (fa : Eq (f a) i) -> (Hc0 : Eq a (n + 1)) -> Eq i a"}
{"prompt": "Human: Translate the following English statement into Agda.\nTimes_div. Let $a$ and $b$ and $c$ be natural numbers. Then if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.\nAssistant:", "label": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)", "predict": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_ar", "label": "postulate let_clause_15692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics", "predict": "postulate let_clause_15692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_div. Soient $n$ et $m$ et $d$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $d$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n$ et $m$ et $d$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $d$ et $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $d$.\nAssistant:", "label": "postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))", "predict": "postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nFalse_rect_Type4. Pour toutes les fonctions $Q_$ des éléments $_x_67$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $x_67$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_67$.\nAssistant:", "label": "postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)", "predict": "postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i, j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Supposons que $a$ est égal à $b$. Alors $f$ appliqué à $a$ est égal à $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (_ : and (Leq a n) (Eq (f a) i)) -> (__2 : Leq a n) -> (__3 : Eq (f a) i) -> (b : Nat) -> (__4 : and (Leq b n) (Eq (f b) j)) -> (__5 : Leq b n) -> (__6 : Eq (f b) j) -> (_ : (_ : Nat) -> Leq i0 n) -> (injf : injn f n) -> (eqab : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_min_spec. Låt $_n$ och $_b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $_n$ och $_b$ och $_f$ och $__$ till element av $cic.Univ$ av $return_sort$. Låt $case_found_min_spec$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_b$ och $m$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $_n$ och $_b$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $__3$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_b$ och $i$ och element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $return_sort$ och $", "label": "postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita", "predict": "postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (matita_basics_logic.match (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true (matita_basics_bool.false) (\\ __ : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.true) (\\ __ : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.false) (\\ t0 : cic.Term univs.Type0 matita_basics_bool.bool -> matita_basics_bool.true) (\\ t1 : cic.Term univs.Type0 matita_basics_bool.bool ->"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_4. Soit $x \\in R$. Alors si $0$ est inférieur à $x$ et $x$ est inférieur à $1$, alors la somme de la différence de la puissance de $x$ et de $2$ et du produit de $2$ et de $x$ et de $2$ est inégale à $0$.\nAssistant:", "label": "postulate noLabel_4 : (x : Real) -> if (and (Lt 0 x) (Lt x 1)) (Neq (plus (minus (pow x 2) (times 2 x)) 2) 0)", "predict": "postulate noLabel_4 : (x : R) -> (_ : Lt 0 x) -> (__1 : Lt x 1) -> Neq (plus (minus (pow x 2) (times 2 x)) 2) 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1561. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Then if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$, then if $a p - b m = 1$, then $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eq1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (eqmnc : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (gcd p m) (minus (times a p) (times b m))) -> (Hp : Eq (times a p) (times b m)) -> Eq (minus (times a p) (times b m)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15321. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $eqn0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $n$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $q$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $eqm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAxiome. Soit $__, __1 \\in N$. Alors le produit de $__$ et de $__1$ est un nombre naturel.\nAssistant:", "label": "postulate times : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate times : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_to_leb_false. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nAssistant:", "label": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $m$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $c$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $b", "label": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))", "predict": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_aux_Strue. For all natural numbers $n$ and $m$ and $p$ and $q$ and $r$, if $mod (n, m)= 0$, then if $p_ord_aux (p, n \\div m, m)= mk_Prod (Nat, Nat, q, r)$, then $p_ord_aux (p + 1, n, m)= mk_Prod (Nat, Nat, q + 1, r)$.\nAssistant:", "label": "postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (plus p 1) n m) (mk_Prod Nat Nat (plus q 1) r)", "predict": "postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (n \\ m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (p + 1) n m) (mk_Prod Nat Nat (q + 1) r)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1506$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $c", "label": "postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_ind_body. Soient $_n$ et $_b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $Q_$ une fonction des éléments $x_1075$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_1076$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $x_1075$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_found_min_spec$ une fonction des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1080$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $m$ et des éléments $x_1079$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ et des éléments $x_1078$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $m$ et $matita_basics_bool.true$ et des fonctions $x_1077$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué", "label": "postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2", "predict": "postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_basics_bool.false)) -> (x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f matita_arithmetics_nat.zero)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) matita_basics_bool.true matita_b"}
{"prompt": "Human: Translate the following French statement into Agda.\nNmk. Soit $A$ un élément de $cic.Univ$ de $cic.prop$. Soit $__$ une fonction des éléments $__$ de $cic.Term$ de $cic.prop$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $A$.\nAssistant:", "label": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)", "predict": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nB_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_log_O. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_log.log$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)", "predict": "postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1617. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ och $x2515$ och $x2516$ vara naturliga tal. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Supposons que $p2$ appliqué à $n1$ est égal à $true$. Supposons que $p1$ appliqué à $n1$ est égal à $true$. Alors pour tous les nombres naturels $x", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> (_ : Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> (Eq (p2 i) true) -> H1 i (_ : Lt i (plus n1 1)) (__1 : Eq (p1 i) true) (Eq (p2 i) true)) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hc : Eq (p2 n1) true) -> (Hp : Eq (p1 n1) true) -> (x : Nat) -> Eq (g1 x) (g2 x)"}
{"prompt": "Human: Translate the following English statement into Agda.\nOp. Let $A$ be a set. Let $nil$ be an element of $A$. Then for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.\nAssistant:", "label": "postulate op : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A", "predict": "postulate op : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10336. Let $n, m \\in N$. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$. Let $a$ be a natural number. Assume that $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$. Then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1585. Let $n$ and $m$ be natural numbers. Assume that $0 < n$. Assume that $m$ is divisible by $n$. Let $d \\in N$. Assume that $0 = m$. Assume that $n = m d$. Then $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (m d)) -> Eq 0 n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10334. Soit $n$ un nombre naturel. Supposons que $0$ est inférieur à $n$. Soit $x2515, x2516 \\in N$. Alors $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Alors pour tous les nombres naturels $a$, si $m = 2 a$ ou $m = 2 a + 1$, alors si $m = 2 a + 1$, alors si $1 < 2 a + 1$, alors si $0 < a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\* (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : Lt 1 (2 a + 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Då om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type2_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_897$ av $ACop$ av $A$ och $_nil$ till element av $Type2$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_897$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_transpose. Pour tous les nombres naturels $i$ et $j$ et $k$ et $n$, si $j$ n'est pas égal à $i$, alors si $i$ n'est pas égal à $k$, alors si $j$ n'est pas égal à $k$, alors $transpose (i, j, n)= transpose (i, k, transpose (k, j, transpose (i, k, n)))$.\nAssistant:", "label": "postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))", "predict": "postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_ord_O_to_divides. Let $p$ and $m$ be natural numbers. Assume that $0 < m$. Assume that $p$ is prime. Then if $ord (m, p)$ is not equal to $0$, then $p$ is divisible by $m$.\nAssistant:", "label": "postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m", "predict": "postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_gcd_aux_mn. Let $p, m, n \\in N$. Then if $0 < n$, then if $n \\leq m$, then if $n \\leq p$, then $gcd_aux (p, m, n)$ is divisible by $m$ and $gcd_aux (p, m, n)$ is divisible by $n$.\nAssistant:", "label": "postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)", "predict": "postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_gcd_aux_mn. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$ och $m$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$ och $n$.\nAssistant:", "label": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))", "predict": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_transpose_l. Let $f$ be a function from natural numbers to natural numbers. Let $m$ and $i$ and $j$ be natural numbers. Assume that $i \\leq m$. Assume that $j \\leq m$. Then for all elements $__2$ of $permut$ of $f$ and $m$, $permut$ holds for the function that maps $n$ to $transpose (i, j, f (n))$ and $m$.\nAssistant:", "label": "postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\\ n : Nat -> transpose i j (f n)) m", "predict": "postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\\ n : Nat -> transpose i j (f n)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_20. För alla heltal $a$, för alla heltal $c$, om $a$ är udda och $c$ är udda, så är $a b + b c$ jämnt för alla heltal $b$.\nAssistant:", "label": "postulate noLabel_20 : all Int (\\ b -> all Int (\\ a -> all Int (\\ c -> if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))", "predict": "postulate noLabel_20 : (a : Nat) -> (c : Nat) -> (_ : and (odd a) (odd c)) -> all Nat (\\ b : Nat -> even (plus a b) (times b c)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Låt $n1 \\in N$. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$ och funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n1$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$. Låt $H1$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$. Låt $H2$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$. Anta att $p2 (n1)= true$ och $p1 (n1)= true$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> Prop) -> (p2 : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 \\ div x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_minus_associative. Soit $x, y, z \\in N$. Alors si $z$ est inférieur ou ágal à $y$, alors si $y$ est inférieur ou ágal à $x$, alors la différence de $x$ et de la différence de $y$ et de $z$ est égale à la somme de la différence de $x$ et de $y$ et de $z$.\nAssistant:", "label": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)", "predict": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_inv_plus_l. Låt $x$ och $y$ och $z$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $z$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $x$ och $matita_arithmetics_nat.minus$ applicerat på $z$ och $y$ och $matita_arithmetics_nat.le$ applicerat på $y$ och $z$.\nAssistant:", "label": "postulate le_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))", "predict": "postulate le_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_body. Let $B$ be a set. Let $_R$ be an element of $relation$ of $B$. Then for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O (B, _R, b)$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of $l + 1$ and $b1$ and $b2$ and $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.\nAssistant:", "label": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_maxr. Soit $i, n, m \\in N$. Supposons que $max$ appliqué à $n$ et $m$ est inférieur ou ágal à $i$. Alors $m$ est inférieur ou ágal à $i$.\nAssistant:", "label": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i", "predict": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt (max n m) i) -> Lt m i"}
{"prompt": "Human: Translate the following English statement into Agda.\nDpi1__o__aop__o__op. Let $x0$ be a set. Let $x1$ be an element of $x0$. Let $x2$ be a function from elements of $ACop$ of $x0$ and $x1$ to sets. Then for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.\nAssistant:", "label": "postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0", "predict": "postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Supposons que la puissance de $2$ et de $7$ est inférieure ou ágale à $n$. Soit $p$ un nombre naturel. Supposons que la somme de la racine carrée du produit de $2$ et de $n$ et de $1$ est inférieure ou ágale à $p$. Supposons que $p$ est inférieur à la somme du produit de $2$ et de $n$ et de $1$. Supposons que $leb$ appliqué à $2$ et $k$ appliqué à le produit de $2$ et de $n$ et $p$ est égal à $true$. Alors si le produit de $2$ et de $n$ est inférieur à la puissance de $p$ et de $2$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (pow2n : Leq (pow 2 n) n) -> (p : Nat) -> (Hind : Leq (plus (sqrt (times 2 n)) 1) p) -> (Hltp : Lt p (plus (times 2 n) 1)) -> (H2 : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMod_mod. Pour tous les éléments $n$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $p$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $p$ et $p$.\nAssistant:", "label": "postulate mod_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p))", "predict": "postulate mod_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp1. Pour tous les éléments $_n$ et $_m$ et $_q$ et $_r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_853$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_855$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_854$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_855$ et $x_854$, pour tous les éléments $x_853$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_853$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)", "predict": "postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides_true. Låt $l$ vara en lista av naturliga tal. Låt $n$ vara ett naturligt tal. Då om $list_divides (l, n)= true$, så håller $ex$ för $Nat$ och funktionen som avbildar $p$ som konjunktionen av $mem$ applicerat på $Nat$ och $p$ och $l$ och $divisible$ applicerat på $p$ och $n$.\nAssistant:", "label": "postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) true) -> ex Nat (\\ p : Nat -> and (mem Nat p l) (divisible p n))", "predict": "postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides (l, n)) true) -> ex Nat (\\ p : Nat -> and (mem Nat p l) (divisible p n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnique. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, $cic.Univ$ tient pour $cic.prop$.\nAssistant:", "label": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop", "predict": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Soit $a \\in N$. Supposons que $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$. Supposons que $1 < 2 a + 1$ et $0 < a$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\* (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : and (Lt 1 (2 a + 1)) (Lt 0 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_S_S_to_lt. Låt $n$ och $m$ vara naturliga tal. Då om $n + 1 < m + 1$, så $n < m$.\nAssistant:", "label": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m", "predict": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (n + 1) (m + 1)) -> Lt n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_cases. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $n$ och $matita_basics_bool.true$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $f$ och $n$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $n$ och $matita_basics_bool.false$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $f$ och $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$.\nAssistant:", "label": "postulate max_cases : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) n)) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) (matita_arithmetics_minimization.max n f))))", "predict": "postulate max_cases : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) n)) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) (matita_arithmetics_minimization.max n f))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16004. Let $m, n, a, b \\in N$. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Then for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1))) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_not_exists. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Låt $__$ vara en funktion från naturliga tal $i$ och element av $Leq$ av $b$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $n$ och $b$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion. Då är $min$ applicerat på $n$ och $b$ och $f$ lika med summan av $n$ och $b$.\nAssistant:", "label": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)", "predict": "postulate min_not_exists : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_951$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$", "label": "postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)", "predict": "postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (H2 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H3 : Eq (gcd p m) (minus (times b m) (times a p))) -> (H4 : Eq 1 (minus (times b m) (times a p))) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1569. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divnm n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_fact. Let $n$ and $i$ be natural numbers. Assume that $0$ is less than $i$. Then if $i$ is less than or equal to $n$, then $i$ is divisible by the factorial of $n$.\nAssistant:", "label": "postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)", "predict": "postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1$ un nombre naturel. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Alors pour toutes les fonctions $H2$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$, si $p2 (n1)= true$, alors si $p1 (n1)= true$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15601. Let $n$ and $m$ be natural numbers. Assume that $0$ is less than $m$. Assume that $0$ is equal to $n$. Assume that $0$ is divisible by $m$. Then for all natural numbers $q$, if $m$ is equal to the product of $0$ and $q$, then $n$ is equal to $0$.\nAssistant:", "label": "postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0", "predict": "postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_exp2. Låt $p, n, m \\in N$. Anta att $1 < p$. Då om $0 < n$, så $m \\log_ p {n}\\leq \\log_ p {(n ^ m)}$.\nAssistant:", "label": "postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))", "predict": "postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (m * log_ p {n}) (log_ p {n ^ m})"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n \\in N$. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Anta att $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : and (Leq 6 m) (Leq (pow (plus m 1) 2) (pow 2 m))) -> (a : Nat) -> (lea : and (Leq 6 a) (Leq (plus (times 2 a) 1) (pow 2 a))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1686. Låt $n, m \\in N$. Låt $Hind$ vara en funktion från naturliga tal $p$ och element av $Lt$ av $p$ och $m$ och element $__1$ av $Lt$ av $1$ och $p$ till element av $Leq$ av $Psi (p)$ och $pred (p)\\times (2 ^ (2 p - 3))$. Låt $a$ vara ett naturligt tal. Anta att $m = 2 a$ eller $m = 2 a + 1$ och $m = 2 a + 1$. Anta att $1 < 2 a + 1$ och $0 < a$. Då $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\times (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : Lt 1 (2 a + 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (a + a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Låt $return$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$. Då för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_O_to_not_divides. Låt $p$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Anta att $ord (m, p)= 0$. Då är $p$ inte delbart med $m$.\nAssistant:", "label": "postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)", "predict": "postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDividesb_div_true. Let $d, n \\in N$. Then if $0 < n$ and $dividesb (d, n)= true$, then $dividesb (n \\div d, n)= true$.\nAssistant:", "label": "postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (dividesb d n) true) -> Eq (dividesb (div n d) n) true", "predict": "postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : dividesb (d, n) true) -> dividesb (n \\ div d) n true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16004. För alla naturliga tal $m$ och $n$ och $a$ och $b$, om $0 < n$, så om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a, _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a, aop__o__op (A, _nil, sum, b, c))$ and $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ to elements of $Q_$ of $mk_Dop (A, _nil, sum, prod, _null, _distr)$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.\nAssistant:", "label": "postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961", "predict": "postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec_ind. Låt $_n \\in N$. Låt $_f$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $Q_$ från naturliga tal $x_971$ och element $_x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$ till påståenden, för alla funktioner $_H_found_max_spec$ från naturliga tal $m$ och element $x_975$ av $Lt$ av $m$ och $_n$ och element $x_974$ av $Eq$ av $_f$ applicerat på $m$ och $true$ och funktioner $x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f$ applicerat på $i$ och kontradiktion till element av $Q_$ av $m$ och $found_max_spec$ applicerat på $_n$ och $_f$ och $m$ och $x_975$ och $x_974$ och $x_973$, för alla funktioner $_H_not_found_max_spec$ från funktioner $x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f$ applicerat på $i$ och kontradiktion till element av $Q_$ av $0$ och $not_found_max_spec$ applicerat på $_n$ och $_f$ och $x_976$, för alla naturliga tal $x_971$, för alla element $x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$, håller $Q_$ för $x_971$ och $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> Prop) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15625. Let $m, n, a, b \\in N$. Assume that $0 < n$. Then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $permf$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $f$ och $n$. Låt $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lein$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Låt $lejn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $a$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $lean$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $a$ och $n$, för alla element $fa$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $b$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på", "label": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita", "predict": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f b) j))) -> (matita_arithmetics_nat.eq i j)"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_rect_CProp5. For all functions $Q_$ from elements $_x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_56$.\nAssistant:", "label": "postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)", "predict": "postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_73. Let $n, m, p \\in N$. Then if $0 < p$, then for all natural numbers $x134$ and $x135$ and $x136$, $x134 + (x135 + x136)= x135 + (x134 + x136)$.\nAssistant:", "label": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))", "predict": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (x134 + (x135 + x136)) (x135 + (x134 + x136))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1545. Soient $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $q1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $H1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.O$ et $q1$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $q2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $H2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.O$ et $q2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_le_to_lt_times. Soient $n$ et $m$ et $p$ et $q$ des nombres naturels. Supposons que $n < m$ et $p \\leq q$. Supposons que $0 < q$. Alors $n p < m q$.\nAssistant:", "label": "postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Leq p q) -> (__2 : Lt 0 q) -> Lt (times n p) (times m q)", "predict": "postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Leq p q) -> (__2 : Lt 0 q) -> Lt (n p) (m q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Let $b \\in N$. Assume that $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$. Assume that $b$ is less than or equal to $n$. Assume that $f$ applied to $b$ is equal to $j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (Eq (f a) i)) -> (Hc : Leq a n) -> (Hf : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (Eq (f b) j)) -> (Hb : Leq b n) -> (Hfb : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15624. Let $m, n, a, b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1$ and $n2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range (B, f1, n1, p1)$ and $mk_range (B, f2, n2, p2)$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Assume that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_h", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B", "predict": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> (i : Nat) -> (j : Nat) -> Eq (f1 i) (f2 (h j))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type3_body. Låt $_n, _m, _q, _r \\in N$. Då för alla funktioner $Q_$ från element $_x_821$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till element av $Type3$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_823$ av $Lt$ av $_r$ och $_m$ och element $x_822$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_823$ och $x_822$, för alla element $x_821$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_821$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821", "predict": "postulate div_mod_spec_rect_Type3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821"}
{"prompt": "Human: Translate the following English statement into Agda.\nExists_append. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$.\nAssistant:", "label": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))", "predict": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))"}
{"prompt": "Human: Translate the following French statement into Agda.\nIter_body. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $__$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $H$ à des éléments de $cic.Term$ de $univs.Type0$ et de $H$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $H$, $cic.Term$ tient pour $univs.Type0$ et $H$.\nAssistant:", "label": "postulate iter_body : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate iter_body : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_n_nth_prime_n. Soit $n \\in N$. Alors $n < nth_prime (n)$.\nAssistant:", "label": "postulate lt_n_nth_prime_n : (n : Nat) -> Lt n (nth_prime n)", "predict": "postulate lt_n_nth_prime_n : (n : Nat) -> Lt n (nth_prime n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFalse_rect_CProp5_body. Pour toutes les fonctions $Q_$ des éléments $_x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_74$.\nAssistant:", "label": "postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)", "predict": "postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSub_hk. För alla funktioner $__$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $A$ av $cic.Univ$ av $univs.Type0$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $matita_arithmetics_bigops.range$ applicerat på $A$.\nAssistant:", "label": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_to_eq2. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be natural numbers. Then for all elements $__$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, $r = r1$.\nAssistant:", "label": "postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1", "predict": "postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1"}
{"prompt": "Human: Translate the following French statement into Agda.\nMonotonic_sqrt. $monotonic$ tient pour $Nat$ et $Leq$ et $sqrt$.\nAssistant:", "label": "postulate monotonic_sqrt : monotonic Nat Leq sqrt", "predict": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_minus. Soit $m, n, p \\in N$. Supposons que $m \\leq n$. Alors $n - m + p = n + p - m$.\nAssistant:", "label": "postulate plus_minus : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Leq m n) -> Eq (plus (minus n m) p) (minus (plus n p) m)", "predict": "postulate plus_minus : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Leq m n) -> Eq (n - m + p) (n + p - m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nFalse_to_lt_max. Let $f$ be a function from natural numbers to booleans. Then for all natural numbers $n$ and $m$, if $0 < n$, then if absurdity is equal to $f (n)$, then if $max (m, f)\\leq n$, then $max (m, f)< n$.\nAssistant:", "label": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n", "predict": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq false (f n)) -> (__2 : Leq (max m f) n) -> Lt (max m f) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_CProp1_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_965$ av $Dop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_965$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_965$.\nAssistant:", "label": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965", "predict": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_799$ of $cic.Term$ of $univ", "label": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)", "predict": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp5. För alla element $_A$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_nmk$ från funktioner $x_104$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_104$, för alla element $x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_103$.\nAssistant:", "label": "postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)", "predict": "postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_body. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $Q_$ une fonction des nombres naturels $x_1233$ et des éléments $x_1232$ de $B$ et des éléments $x_1231$ de $B$ et des éléments $_x_1234$ de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$ à des propositions. Soit $_H_lstar_O$ une fonction des éléments $b$ de $B$ à des éléments de $Q_$ de $0$ et de $b$ et de $b$ et de $lstar_O (B, _R, b)$. Soit $_H_lstar_S$ une fonction des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $x_1236$ de $_R$ de $b1$ et de $b$ et des nombres naturels $l$ et des éléments $b2$ de $B$ et des éléments $x_1235$ de $lstar$ de $B$ et de $_R$ et de $l$ et de $b$ et de $b2$ et des éléments $_x_1238$ de $Q_$ de $l$ et de $b$ et de $b2$ et de $x_1235$ à des éléments de $Q_$ de $l + 1$ et de $b1$ et de $b2$ et de $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Soit $x_1233 \\in N$. Soient $x_1232$ et $x_1231$ des éléments de $B$. Soit $x_1234$ un élément de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$. Alors $Q_$ tient pour $x_1233$ et $x_1232$ et $x_1231$ et $x_1234$.\nAssistant:", "label": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_plus_div. Let $m$ and $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $n$ and $q$.\nAssistant:", "label": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))", "predict": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))"}
{"prompt": "Human: Translate the following French statement into Agda.\nF_false_to_le_max. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n, p \\in N$. Alors pour tous les éléments $__$ de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$, pour toutes les fonctions $__1$ des nombres naturels $m$ et des éléments $__1$ de $Lt$ de $p$ et de $m$ à des éléments de $Eq$ de $f (m)$ et de contradiction, $max (n, f)\\leq p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p", "predict": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nFold. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $_op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_b$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Then for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.\nAssistant:", "label": "postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B", "predict": "postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_SO_smallest_factor. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$.\nAssistant:", "label": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))", "predict": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_SO_to_le_B_exp. For all natural numbers $n$, if $1 < n$, then $B (2 n)\\leq 2 ^ pred (2 n)$.\nAssistant:", "label": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))", "predict": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (2 n)) (2 ^ pred (2 n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_not_ord_O. Let $p, m \\in N$. Assume that $0 < m$ and $p$ is prime. Then if $p$ is divisible by $m$, then $ord (m, p)$ is not equal to $0$.\nAssistant:", "label": "postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)", "predict": "postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_previous_prime5. För alla naturliga tal $n$ och $m$, om $nth_prime (n)< m$, så $Nat$.\nAssistant:", "label": "postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_S_to_permut. Let $f$ be a function from natural numbers to natural numbers. Let $m \\in N$. Then for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.\nAssistant:", "label": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m", "predict": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_ord_rem. Låt $n, m \\in N$. Anta att $n$ är primt och $0 < m$. Anta att $n$ är delbart med $m$. Då $ord_rem (m, n)< m$.\nAssistant:", "label": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m", "predict": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1545. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $n$. Let $q1$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q1$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$. Let $q2$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q2$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type5. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_", "label": "postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)", "predict": "785postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, $Nat$.\nAssistant:", "label": "postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat", "predict": "postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op (x1, x2, aop, a, b)$ and $op (x1, x2, aop, b, a)$ and elements $_z1621$ of $Eq$ of $Hterm$ and $mk_ACop (x1, x2, aop, _comm)$ to elements of $P$ of $mk_ACop (x1, x2, aop, _comm)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_O_n. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nAssistant:", "label": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)", "predict": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAxiom. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då är $__ \\div __1$ ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate div : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate div : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_925$.\nAssistant:", "label": "postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)", "predict": "postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_n_times_nm. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then the greatest common divisor of $n$ and the product of $n$ and $m$ is equal to $n$.\nAssistant:", "label": "postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n", "predict": "postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_I_gen. Låt $a$ och $b$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $a \\leq b$, så är $bigop$ applicerat på $b$ och funktionen som avbildar $i$ som $andb$ applicerat på $leb$ applicerat på $a$ och $i$ och $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på skillnaden mellan $b$ och $a$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $p$ applicerat på $i0$ applicerat på summan av $i$ och $a$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $f$ applicerat på $i0$ applicerat på summan av $i$ och $a$.\nAssistant:", "label": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_CProp3. Soit $x1$ un ensemble. Alors pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $Aop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1542$ de $Aop$ de $x1$ et de $x2$ à des propositions, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_nill$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (x2, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (a, x2)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ et des éléments $_z1543$ de $Eq$ de $Hterm$ et de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ à des éléments de $P$ de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_891$ de $ACop$ de $A$ et de $_nil$ à des éléments de $Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op (A, _nil, aop, a, b)$ et de $op (A, _nil, aop, b, a)$ à des éléments de $Q_$ de $mk_ACop (A, _nil, aop, _comm)$, pour tous les éléments $x_891$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891", "predict": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891"}
{"prompt": "Human: Translate the following French statement into Agda.\nFact_to_exp. Soit $n \\in N$. Alors la factorielle du produit de $2$ et de $n$ est inférieure ou ágale au produit du produit de la puissance de $2$ et de $pred$ appliqué à le produit de $2$ et de $n$ et de la factorielle de $n$ et de la factorielle de $n$.\nAssistant:", "label": "postulate fact_to_exp : (n : Nat) -> Leq (factorial (times 2 n)) (times (times (pow 2 (pred (times 2 n))) (factorial n)) (factorial n))", "predict": "postulate fact_to_exp : (n : Nat) -> Leq (factorial (times 2 n)) (times (times (pow 2 (pred (times 2 n))) (factorial n)) (factorial n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_ind_body. Soit $_A$ un ensemble. Alors pour toutes les fonctions $Q_$ des éléments $_x_915$ de $range$ de $_A$ à des propositions, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_915$ de $range$ de $_A$, $Q_$ tient pour $x_915$.\nAssistant:", "label": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915", "predict": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1595. For all natural numbers $p$ and $n$ and $m$, if $0 < n$ and $0 < m$, then if $1$ is both equal to the greatest common divisor of $p$ and $n$ and equal to the greatest common divisor of $p$ and $m$, then if the greatest common divisor of $p$ and the product of $n$ and $m$ is less than $1$ and $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $m$ is equal to the greatest common divisor of $p$ and $n$.\nAssistant:", "label": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)", "predict": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : and (Eq 1 (gcd p n)) (Eq 1 (gcd p m))) -> (H1 : Lt (gcd p (times n m)) 1) -> (H2 : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p m) (gcd p n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPrime_to_divides_M. Låt $m, p \\in N$. Anta att $p$ är primt. Anta att summan av $m$ och $1$ är mindre än $p$. Anta att $p$ är mindre än eller lika med summan av produkten av $2$ och $m$ och $1$. Då är $p$ delbart med $M$ applicerat på $m$.\nAssistant:", "label": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)", "predict": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soit $p, m, n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (gcd p m) (minus (times a p) (times b m))) -> (H0 : Eq (times a p) (times b m)) -> Eq (minus p a) (minus (times m n) (times b m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_S_times_2. Soit $n \\in N$. Supposons que $0$ est inférieur à $n$. Alors la somme de $n$ et de $1$ est inférieure ou ágale au produit de $2$ et de $n$.\nAssistant:", "label": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)", "predict": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_to_log_r. Soient $b$ et $n$ et $m$ des nombres naturels. Supposons que $1$ est inférieur à $b$. Supposons que $n$ est inférieur à $m$. Alors si la puissance de $b$ et de $n$ est inférieure ou ágale à $m$, alors $n$ est inférieur ou ágal au logarithme de $b$ et de $m$.\nAssistant:", "label": "postulate exp_to_log_r : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Leq (pow b n) m) -> Leq n (log b m)", "predict": "postulate exp_to_log_r : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Leq (pow b n) m) -> Lt n (log b m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_15. För alla heltal $n$, om $n$ är udda, så är skillnaden mellan summan av produkten av $4$ och potensen av $n$ och $3$ och produkten av $2$ och $n$ och $1$ udda.\nAssistant:", "label": "postulate noLabel_15 : all Int (\\ n -> if (odd n) (odd (minus (plus (times 4 (pow n 3)) (times 2 n)) 1)))", "predict": "postulate noLabel_15 : (n : Nat) -> (_ : odd n) -> odd (minus (plus (times 4 (pow n 3)) (times 2 n)) 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p, m, n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att $b m - a p = 1$. Då $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (H2 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H3 : Eq (gcd p m) (minus (times b m) (times a p))) -> (H4 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_inv_rect_CProp2. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $x1$. Då för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1614$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1615$ av $Eq$ av $Hterm$ och $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $P$ av $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEx. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop", "predict": "postulate ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nChecker_abl. Soit $a, b \\in N$. Soit $l$ une liste de nombres naturels. Alors si $checker (cons (Nat, a, cons (Nat, b, l)))= true$, alors $a < b$, $b \\leq 2 a$ et $checker (cons (Nat, b, l))= true$.\nAssistant:", "label": "postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)", "predict": "postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons (Nat, a, cons (Nat, b, l))) true) true) -> and (Lt a b) (Leq b (times 2 a)) (Eq (checker (cons (Nat, b, l))) true)"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_S_mod. Let $n$ be a natural number. Then $permut$ holds for $S_mod (n + 1)$ and $n$.\nAssistant:", "label": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n", "predict": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (n + 1)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExample12. $nth_prime (3)= 7$.\nAssistant:", "label": "postulate example12 : Eq (nth_prime 3) 7", "predict": "postulate example12 : Eq (nth_prime 3) 7"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ vara ett naturligt tal. Anta att potensen av $2$ och $7$ är mindre än eller lika med $n$. Låt $p$ vara ett naturligt tal. Anta att summan av kvadratroten av produkten av $2$ och $n$ och $1$ är mindre än eller lika med $p$. Anta att $p$ är mindre än summan av produkten av $2$ och $n$ och $1$. Anta att $leb$ applicerat på $2$ och $k$ applicerat på produkten av $2$ och $n$ och $p$ är lika med $true$. Då om produkten av $2$ och $n$ är mindre än potensen av $p$ och $2$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (H : Leq (pow 2 7) n) -> (p : Nat) -> (H1 : Leq (plus (sqrt (times 2 n)) 1) p) -> (H2 : Lt p (plus (times 2 n) 1)) -> (H3 : Eq (leb 2 (k (times 2 n) p)) true) -> (H4 : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_plus_to_minus. Let $n$ and $m$ and $p$ be natural numbers. Then if $m \\leq n$ and $n < p + m$, then $n - m < p$.\nAssistant:", "label": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p", "predict": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus m p)) -> Lt (minus n m) p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_8. För alla instanser $n$ av naturliga tal, kan vi bevisa att om summan av $n$ och kvoten av $1$ och $n$ är mindre än $2$, så är summan av potensen av $n$ och $2$ och kvoten av $1$ och potensen av $n$ och $2$ mindre än $4$.\nAssistant:", "label": "postulate noLabel_8 : (n : Nat) -> if (Lt (plus n (div 1 n)) 2) (Lt (plus (pow n 2) (div 1 (pow n 2))) 4)", "predict": "postulate noLabel_8 : (n : Nat) -> if (Lt (plus n (div 1 n)) 2) (Lt (plus (pow n 2) (div 1 (pow n 2))) 4)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMem_single. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.cons$ applied to $A$ and $b$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $b$.\nAssistant:", "label": "postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)", "predict": "postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n \\in N$. Assume that the exponentiation of $2$ and $8$ is less than or equal to $n$. Let $m$ be a natural number. Assume that $3$ is less than or equal to $m$. Assume that the sum of the logarithm of $2$ and $m$ and $2$ is less than or equal to $m$. Then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : N) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp4. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.\nAssistant:", "label": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875", "predict": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"}
{"prompt": "Human: Translate the following French statement into Agda.\nGcd_times_SO_to_gcd_SO. Soient $m$ et $n$ et $p$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $m$ et du produit de $n$ et de $p$. Alors $1$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1", "predict": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq 1 (gcd m (times n p))) -> Eq 1 (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLeb_false_to_not_le. Pour tous les nombres naturels $n$ et $m$, si contradiction est égal à $leb (n, m)$, alors $n$ n'est pas inférieur ou ágal à $m$.\nAssistant:", "label": "postulate leb_false_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Eq (leb n m) false) -> not (Leq n m)", "predict": "postulate leb_false_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Eq false (leb n m)) -> not (Leq n m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Då för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_inv_rect_CProp4. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z359$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_148$ de $cic.Term$ de $cic.prop$ et de $x1$ et des éléments $x_147$ de $cic.Term$ de $cic.prop$ et de $x2$ et des éléments $_z360$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.And$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_148$ et $x_147$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_148$ et $x_147$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_inv_rect_CProp1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1356$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_773$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_772$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_775$ des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_772$ et des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$, $cic.Term$ tient pour $cic.prop", "label": "postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nK1. Låt $n, p \\in N$. Anta att $18 \\leq n$ och $p \\leq n$. Anta att $2 n \\div 3 < p$. Då $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Lt 18 n) -> (__1 : Lt p n) -> (__2 : Lt (div 2 n) 3) -> Eq (k 2 n p) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_CProp0. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $_z713$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$. Då för alla funktioner $_H2$ från element $x_414$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_x_416$ från element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $x_414$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_414$ och element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.S$ applicerat på $x_414$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_414$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTrue_to_le_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $m$ och $b$ vara naturliga tal. Då om $b \\leq m$ och $f (m)= true$, så $min (n, b, f)\\leq m$.\nAssistant:", "label": "postulate true_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__1 : Eq (f m) true) -> Leq (min n b f) m", "predict": "postulate true_to_le_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__1 : Eq (f m) true) -> Leq (min n b f) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nMem_filter_l. Pour tous les éléments $S$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $S$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $x$ de $cic.Term$ de $univs.Type0$ et de $S$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $x$ et $matita_basics_bool.true$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $S$ et $x$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $S$ et $x$ et $matita_basics_lists_list.filter$ appliqué à $S$ et $f$ et $l$.\nAssistant:", "label": "postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))", "predict": "postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNoLabel_34. For all instances $x$ of integers, we can prove that if the sum of the product of $7$ and $x$ and $4$ is even, then the difference of the product of $3$ and $x$ and $11$ is odd.\nAssistant:", "label": "postulate noLabel_34 : (x : Int) -> if (even (plus (times 7 x) 4)) (odd (minus (times 3 x) 11))", "predict": "postulate noLabel_34 : (x : Int) -> if (even (plus (times 7 x) 4)) (odd (minus (times 3 x) 11))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPi_1. Soit $n$ un nombre naturel. Alors pour toutes les fonctions $p$ des nombres naturels à des valeurs booléennes, $1$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $1$.\nAssistant:", "label": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1", "predict": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq 1 (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Dop$ be a function from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$. Let $x_961$ be an", "label": "postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)", "predict": " elementpostulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_p. Soit $p$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $p$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate p_ord_p : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate p_ord_p : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_SO_to_le_B_exp. Låt $n \\in N$. Anta att $1$ är mindre än $n$. Då är $B$ applicerat på produkten av $2$ och $n$ mindre än eller lika med potensen av $2$ och $pred$ applicerat på produkten av $2$ och $n$.\nAssistant:", "label": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))", "predict": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_exists. Let $f$ be a function from natural numbers to booleans. Let $t$ and $m$ be natural numbers. Assume that $m$ is less than $t$. Assume that $f$ applied to $m$ is equal to $true$. Let $k, b \\in N$. Then if $b$ is less than or equal to $m$, then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, if $t$ is equal to the sum of $k$ and $b$, then $min$ applied to $k$ and $b$ and $f$ is equal to $m$.\nAssistant:", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_rect_Type3_body. Let $Q_$ be a function from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_I$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$. Let $x_46$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.\nAssistant:", "label": "postulate True_rect_Type3_body : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)", "predict": "postulate True_rect_Type3_body : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b, m \\in N$. Då för alla element $__$ av $min_spec$ av $n$ och $b$ och $f$ och $m$, $min (n, b, f)= m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m", "predict": "postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Soit $_H_not_found_max_spec$ une fonction des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$. Soit $x_971 \\in N$. Soit $x_972$ un élément de $max_spec$ de $_n$ et de $_f$ et de $x_971$. Alors $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$. Assume that $p1 (n1)= true$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516) + mod (x2515, x2516))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_times. Soient $n1$ et $n2$ et $m1$ et $m2$ des nombres naturels. Supposons que $n1 \\leq n2$. Supposons que $m1 \\leq m2$. Alors $n1 m1 \\leq n2 m2$.\nAssistant:", "label": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)", "predict": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (n1 m1) (n2 m2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_Type2. Låt $Hterm \\in N$. Låt $P$ vara en funktion från naturliga tal $_z671$ till element av $Type2$. Då för alla funktioner $_H1$ från element $_z672$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$, för alla funktioner $_H2$ från naturliga tal $x_382$ och funktioner $_x_384$ från element $_z672$ av $Eq$ av $Hterm$ och $x_382$ till element av $P$ av $x_382$ och element $_z672$ av $Eq$ av $Hterm$ och summan av $x_382$ och $1$ till element av $P$ av summan av $x_382$ och $1$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type2 : (Hterm : N) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nEqb_elim. Soient $n$ et $m$ des nombres naturels. Alors pour toutes les fonctions $P$ des valeurs booléennes à des propositions, pour toutes les fonctions $__$ des éléments de $Eq$ de $n$ et de $m$ à des éléments de $P$ de $true$, pour toutes les fonctions $__1$ des éléments $__1$ de $not$ de $Eq (n, m)$ à des éléments de $P$ de contradiction, $P$ tient pour $eqb (n, m)$.\nAssistant:", "label": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)", "predict": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_transpose. For all natural numbers $n$ and $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then $bijn$ holds for $transpose$ applied to $i$ and $j$ and $n$.\nAssistant:", "label": "postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n", "predict": "postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1648. Låt $n$ och $q$ vara naturliga tal. Anta att $0 < q$. Låt $n1$ vara ett naturligt tal. Anta att summan av produkten av $bigop$ applicerat på summan av $n1$ och $1$ och funktionen som avbildar $m$ som $andb$ applicerat på $leb$ applicerat på $1$ och $m$ och $dividesb$ applicerat på $q$ och $m$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $m$ som $1$ och $q$ och $mod (n1, q)$ är lika med $n1$. Anta att $q$ är delbart med $n1 + 1$ och $n1 + 1 = (n1 \\div q + 1)q$. Anta att $q$ är delbart med $n1 + 1$. Då om $n1 + 1 = (n1 \\div q + 1)q$, så $n1 + 1 = q + q (n1 \\div q)$.\nAssistant:", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posn : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q)) n1) -> (Hind' : and (divisible q (n1 + 1)) (Eq (n1 + 1) (plus (div n1 q) 1) q)) -> (H : divisible q (n1 + 1)) -> (auto : Eq (n1 + 1) (plus q (q (div n1 q))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_minus_associative. Soient $x$ et $y$ et $z$ des nombres naturels. Alors si $z \\leq y$, alors $x + (y - z)= x + y - z$.\nAssistant:", "label": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)", "predict": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (x + (y - z)) (x + y - z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_lop. Pour tous les nombres naturels $n$, si $1 \\leq n$, alors $list_of_primes (n)= cons (Nat, 2, tail (Nat, list_of_primes (n)))$.\nAssistant:", "label": "postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))", "predict": "postulate eq_lop : (n : Nat) -> (_ : Lt 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$. Alors pour tous les éléments $x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_925$.\nAssistant:", "label": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)", "predict": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_previous_prime7. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate let_previous_prime7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_previous_prime7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nPred_Sn. Let $n$ be a natural number. Then $n$ is equal to $pred$ applied to the sum of $n$ and $1$.\nAssistant:", "label": "postulate pred_Sn : (n : Nat) -> Eq n (pred (plus n 1))", "predict": "postulate pred_Sn : (n : Nat) -> Eq n (pred (plus n 1))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound7. Soit $n, m \\in N$. Supposons que $nth_prime (n)< m$. Alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)", "predict": "postulate ACop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_ex. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_ex_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_logic.ex_intro$ applicerat på $A$ och $_P$ och $x$ och $__$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nTheta_pi_p_theta. Let $m \\in N$. Then the product of $bigop$ applied to the sum of the product of $2$ and $m$ and $2$ and the function that maps $p$ to $andb$ applied to $leb$ applied to the sum of $m$ and $2$ and $p$ and $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$ and $theta (m + 1)$ is equal to $theta (2 m + 1)$.\nAssistant:", "label": "postulate theta_pi_p_theta : (m : Nat) -> Eq (theta (plus (times 2 m) 1)) (times (bigop (plus (times 2 m) 2) (\\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\\ p : Nat -> p)) (theta (plus m 1)))", "predict": "postulate theta_pi_p_theta : (m : Nat) -> Eq (times (bigop (plus (times 2 m) 2) (\\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\\ p : Nat -> p)) (theta (m + 1))) (theta (2 m + 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_5. För alla naturliga tal $n$, om summan av absolutbeloppet av skillnaden mellan $n$ och $1$ och absolutbeloppet av summan av $n$ och $1$ är mindre än eller lika med $1$, så är absolutbeloppet av skillnaden mellan potensen av $n$ och $2$ och $1$ mindre än eller lika med $4$.\nAssistant:", "label": "postulate noLabel_5 : (n : Nat) -> if (Leq (plus (abs (minus n 1)) (abs (plus n 1))) 1) (Leq (abs (minus (pow n 2) 1)) 4)", "predict": "postulate noLabel_5 : (n : Nat) -> (_ : Leq (plus (abs (minus n 1)) (abs (plus n 1))) 1) -> Leq (abs (minus (pow n 2) 1)) 4"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_CProp2. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z701$ till påståenden. Låt $_H1$ vara en funktion från element $_z702$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$. Låt $_H2$ vara en funktion från naturliga tal $x_406$ och funktioner $_x_408$ från element $_z702$ av $Eq$ av $Hterm$ och $x_406$ till element av $P$ av $x_406$ och element $_z702$ av $Eq$ av $Hterm$ och summan av $x_406$ och $1$ till element av $P$ av summan av $x_406$ och $1$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp2 : (Hterm : Nat) -> (P : (_z701 : Nat) -> Prop) -> (_H1 : (_z702 : Eq Hterm 0) -> P 0) -> (_H2 : (x_406 : Nat) -> (_x_408 : (_z702 : Eq Hterm x_406) -> P x_406) -> (_z702 : Eq Hterm (plus x_406 1)) -> P (plus x_406 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp2 : (Hterm : Nat) -> (P : (_z701 : Nat) -> Prop) -> (_H1 : (_z702 : Eq Hterm 0) -> P 0) -> (_H2 : (x_406 : Nat) -> (_x_408 : (_z702 : Eq Hterm x_406) -> P x_406) -> (_z702 : Eq Hterm (plus x_406 1)) -> P (plus x_406 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExp_pi. Låt $n, m \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Då är potensen av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $m$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $f$ applicerat på $i$ och $m$.\nAssistant:", "label": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m)) (pow (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) m)", "predict": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> Prop) -> (f : (_ : Nat) -> Nat) -> Eq (pow (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) m) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$. Then for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.\nAssistant:", "label": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)", "predict": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Soit $_H_not_found_max_spec$ une fonction des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$. Soit $x_971$ un nombre naturel. Alors pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1551. För alla naturliga tal $m$ och $n$, om $0$ är lika med $n$, så för alla naturliga tal $x347$, är $n$ lika med produkten av $x347$ och $n$.\nAssistant:", "label": "postulate let_clause_1551 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x347 : Nat) -> Eq n (times x347 n)", "predict": "postulate let_clause_1551 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x347 : Nat) -> Eq n (times x347 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop_nil. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Leq$ av $n$ och $i$ och element $__2$ av $Lt$ av $i$ och $k$ till element av $or$ av $Eq$ applicerat på $p$ applicerat på $i$ och kontradiktion och $Eq$ applicerat på $f$ applicerat på $i$ och $nil$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (_ : nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSame_bigop. Soit $k \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$. Soient $f$ et $g$ des fonctions des nombres naturels à des éléments de $B$. Alors pour tous les éléments $__$ de $sameF_upto$ de $k$ et de $bool$ et de $p1$ et de $p2$, pour tous les éléments $__1$ de $sameF_p$ de $k$ et de $p1$ et de $B$ et de $f$ et de $g$, $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$.\nAssistant:", "label": "postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\\ i : Nat -> p1 i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p2 i) B nil op (\\ i : Nat -> g i))", "predict": "postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\\ i : Nat -> p1 i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p2 i) B nil op (\\ i : Nat -> g i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExp_to_fact2. Låt $n$ vara ett naturligt tal. Då om $0$ är mindre än $n$, så är produkten av potensen av $2$ och produkten av $2$ och $n$ och potensen av fakulteten av $n$ och $2$ mindre än eller lika med produkten av produkten av $2$ och $n$ och fakulteten av produkten av $2$ och $n$.\nAssistant:", "label": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))", "predict": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_max_n. Let $f$ be a function from natural numbers to booleans. Let $n$ be a natural number. Then $max (n, f)\\leq n$.\nAssistant:", "label": "postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n", "predict": "postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides_false. Låt $l$ vara en lista av naturliga tal. Låt $n \\in N$. Anta att kontradiktion är lika med $list_divides (l, n)$. Låt $p \\in N$. Låt $__1$ vara ett element av $mem$ av $Nat$ och $p$ och $l$. Då är $p$ inte delbart med $n$.\nAssistant:", "label": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)", "predict": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq false (list_divides (l, n))) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum. Låt $A$ vara en mängd. Låt $_xxx$ vara ett element av $range$ av $A$. Då för alla naturliga tal $_x_942$, $A$.\nAssistant:", "label": "postulate enum : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate enum : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_ind. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $Q_$ från element $_x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_889$.\nAssistant:", "label": "postulate ACop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)", "predict": "postulate ACop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Då om $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (lemm : and (Leq 6 m) (Leq (pow (plus m 1) 2) (pow 2 m))) -> (a : Nat) -> (lea : and (Leq 6 a) (Leq (plus (times 2 a) 1) (pow 2 a))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp1. Pour tous les nombres naturels $n$ et $m$ et $a$, si $0$ est inférieur à $a$, alors si $n$ est inférieur ou ágal à $m$, alors la puissance de $n$ et de $a$ est inférieure ou ágale à la puissance de $m$ et de $a$.\nAssistant:", "label": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)", "predict": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Lt (pow n a) (pow m a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divnm n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (divnm m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_exists_to_forall. Let $P$ be a function from natural numbers to propositions. Let $n \\in N$. Assume that it is not the case that $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $P$ applied to $i$. Let $i \\in N$. Then if $i < n$, then it is not the case that $P$ holds for $i$.\nAssistant:", "label": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)", "predict": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_prim_n3. Soit $n$ un nombre naturel. Supposons que $15$ est inférieur ou ágal à $n$. Alors $prim$ appliqué à $n$ est inférieur ou ágal à $pred$ appliqué à le quotient de $n$ et de $2$.\nAssistant:", "label": "postulate le_prim_n3 : (n : Nat) -> (_ : Leq 15 n) -> Leq (prim n) (pred (div n 2))", "predict": "postulate le_prim_n3 : (n : Nat) -> (_ : Lt 15 n) -> Lt (prim n) (pred (div n 2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$. Då för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (x1029 (minus (times c n) (times d m)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_n_Sn. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $__$ be an element of $bijn$ of $f$ and $n$. Then if $f (n + 1)= n + 1$, then $bijn$ holds for $f$ and $n + 1$.\nAssistant:", "label": "postulate bijn_n_Sn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f (plus n 1)", "predict": "postulate bijn_n_Sn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : Eq (f (n + 1)) (n + 1)) -> bijn f (n + 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1536$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type", "label": "postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_times. Soient $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $b$ et $b$ et $a$.\nAssistant:", "label": "postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)", "predict": "postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1258. Låt $b \\in N$. Anta att $1 < b$. Låt $n$ vara ett naturligt tal. Anta att $b ^ n b = 1$. Då $b (b ^ n)= 1$.\nAssistant:", "label": "postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (times (pow b n) b) 1) -> Eq (times b (pow b n)) 1", "predict": "postulate let_clause_1258 : (b : N) -> (lt1b : Lt 1 b) -> (n : Nat) -> (eqn1 : Eq (pow b n) 1) -> Eq (b (pow b n)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_range. Let $_A$ be a set. Let $return_sort$ be an element of $Sort$. Then for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $return_type$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.\nAssistant:", "label": "postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z", "predict": "postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1068$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H1$ vara en funktion från element $_z1069$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$. Låt $_H2$ vara en funktion från element $x_611$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1069$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_611$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_611$. Då håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z665$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_380$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $x_378$ and elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> (_H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378)) -> cic.Term univs.Type3 (P x_378)) -> (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate nat_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> (_H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378)) -> cic.Term univs.Type3 (P x_378)) -> (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_i_j_j_i. Låt $i$ och $j$ och $n$ vara naturliga tal. Då $transpose (i, j, n)= transpose (j, i, n)$.\nAssistant:", "label": "postulate transpose_i_j_j_i : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j n) (transpose j i n)", "predict": "postulate transpose_i_j_j_i : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j n) (transpose j i n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_ord_sigma_p. Soit $n, m, x \\in N$. Supposons que $0 < n$. Alors si $x$ est premier, alors si $x ^ m \\leq n$, alors si $n < x ^ (m + 1)$, alors $bigop$ appliqué à $m$ et la fonction qui envoie $i$ à $dividesb$ appliqué à la puissance de $x$ et de la somme de $i$ et de $1$ et $n$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $1$ est égal à $ord (n, x)$.\nAssistant:", "label": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1)) (ord n x)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_n_Sm_elim. För alla naturliga tal $n$ och $m$, om $n \\leq m + 1$, så för alla påståenden $P$, för alla funktioner $__1$ från element $__1$ av $Leq$ av $n + 1$ och $m + 1$ till element av $P$, för alla funktioner $__2$ från element $__2$ av $Eq$ av $n$ och $m + 1$ till element av $P$, $P$.\nAssistant:", "label": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P", "predict": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (m + 1)) -> (P : Prop) -> (__1 : (__1 : Leq (n + 1) (m + 1)) -> P) -> (__2 : (__2 : Eq n (m + 1)) -> P) -> P"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16921. Soit $m$ un nombre naturel. Supposons que $0$ est inférieur à $m$. Alors pour tous les nombres naturels $a$ et $x358$ et $x359$, $aop__o__op$ appliqué à $Nat$ et $0$ et $plusAC$ et $x358$ et le produit de $x358$ et de $x359$ est égal au produit de $x358$ et de la somme de $x359$ et de $1$.\nAssistant:", "label": "postulate let_clause_16921 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))", "predict": "postulate let_clause_16921 : (m : Nat) -> (posn : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPi_p_primeb4. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $mat", "label": "postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs", "predict": "postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_fact_to_divides. Soit $p, n \\in N$. Supposons que $p$ est premier. Alors si $p$ est divisible par $n!$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $m$ à la conjonction de la conjonction de $Lt$ appliqué à $0$ et $m$ et de $Leq$ appliqué à $m$ et $n$ et de $divisible$ appliqué à $p$ et $m$.\nAssistant:", "label": "postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))", "predict": "postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Alors si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_CProp2. Pour tous les ensembles $x1$, pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $ACop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1614$ de $ACop$ de $x1$ et de $x2$ à des propositions, pour toutes les fonctions $_H1$ des éléments $aop$ de $Aop$ de $x1$ et de $x2$ et des fonctions $_comm$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ à des éléments de $Eq$ de $op (x1, x2, aop, a, b)$ et de $op (x1, x2, aop, b, a)$ et des éléments $_z1615$ de $Eq$ de $Hterm$ et de $mk_ACop (x1, x2, aop, _comm)$ à des éléments de $P$ de $mk_ACop (x1, x2, aop, _comm)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1))) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $P$ be a function from elements $_z713$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$. Then for all functions $_H2$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_416$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_414$ and elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDPair_inv_ind. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1104$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1105$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate DPair_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate DPair_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nOr_introl. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $A$ and $B$.\nAssistant:", "label": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)", "predict": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1062. Låt $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ vara naturliga tal. Låt $_clearme$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$. Anta att $r < b$. Anta att $a = q b + r$. Låt $_clearme0$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$. Anta att $r1 < b$. Då om $a = q1 b + r1$, så om $q$ inte är mindre än eller lika med $q1$, så $a = r1 + b q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus q b) r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus q1 b) r1) -> (neqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_inv_ind. Let $x1$ and $x2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to", "label": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univ", "predict": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.true)) -> cic.Term cic.prop (P m)) -> (_z1891 : cic.Term cic.prop (matita_arithmetics_nat.lt x2 x1)) -> cic.Term cic.prop (P x1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCongruent_ab_lt. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Då håller $ex$ för $Nat$ och funktionen som avbildar $x$ som konjunktionen av konjunktionen av $congruent$ applicerat på $x$ och $a$ och $m$ och $congruent$ applicerat på $x$ och $b$ och $n$ och $Lt$ applicerat på $x$ och produkten av $m$ och $n$.\nAssistant:", "label": "postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))", "predict": "postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq 1 (gcd n m)) -> ex Nat (\\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (Hind : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hind0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSum_rect_CProp0_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_inl$ från element $x_582$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_582$, för alla funktioner $_H_inr$ från element $x_583$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_583$, för alla element $x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att $b m - a p = 1$. Då är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H2 : Eq (gcd p m) (minus (times b m) (times a p))) -> (H3 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) (gcd p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMod_times_mod. Let $n, m, p \\in N$. Then if $0 < p$, then if $0 < m$, then $mod (n, p)= mod (mod (n, m p), p)$.\nAssistant:", "label": "postulate mod_times_mod : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> Eq (mod n p) (mod (mod n (times m p)) p)", "predict": "postulate mod_times_mod : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> Eq (mod n p) (mod (mod n (m p)) p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Hind$ des éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $p$ et $m$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $p$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univ", "label": "postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univ", "predict": "postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times a (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_ar"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_Sfalse. Let $k$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $k$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSig_rect_Type0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_676$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_676$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_676$.\nAssistant:", "label": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)", "predict": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n \\in N$. Anta att $5 < n$. Låt $m$ vara ett naturligt tal. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Anta att $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (lt2m : and (Leq 6 m) (Leq ((m + 1) ^ 2) (pow 2 m))) -> (a : Nat) -> (lea : and (Leq 6 a) (Leq (plus (times 2 a) 1) (pow 2 a))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_transpose. För alla naturliga tal $i$ och $j$ och $n$, $transpose (i, j, transpose (i, j, n))= n$.\nAssistant:", "label": "postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j (transpose i j n)) n", "predict": "postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j (transpose i j n)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_distr. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $B$ och $nil$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.let_mop$ applicerat på $n$ och $p$ och $B$ och $nil$ och $R$ och $f$ och $a$ och $a$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $matita_arithmetics_bigops.let_aop$ applicerat på $n$ och $p$ och $B$ och $nil$ och $R$ och $f$ och $a$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $matita_arithmetics_bigops", "label": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))))", "predict": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i) (f a))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_Type5. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_865$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type5$. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a, _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ à des éléments de $Q_$ de $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, pour tous les éléments $x_865$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_865$.\nAssistant:", "label": "postulate Aop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865", "predict": "postulate Aop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNull_body. Låt $A$ vara en mängd. Då för alla element $nil$ av $A$, för alla element $xxx$ av $Dop$ av $A$ och $nil$, för alla element $a$ av $A$, $prod (A, nil, xxx, a, nil)= nil$.\nAssistant:", "label": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil", "predict": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Låt $b$ vara ett naturligt tal. Anta att $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$. Anta att $b$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $b$ är lika med $j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (__2 : and (Leq a n) (Eq (f a) i)) -> (__3 : Leq a n) -> (__4 : Eq (f a) i) -> (b : Nat) -> (__5 : and (Leq b n) (Eq (f b) j)) -> (__6 : Leq b n) -> (__7 : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Alors pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eq1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (times a p))) (and (Eq (gcd p m) (minus (times b m) (times a p))) (Eq (gcd p m) (times a p)))) -> (H : Eq (gcd p m) (minus (times a p) (times b m))) -> Eq (minus (times p a) (times m b)) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (x1029 : Nat) -> Eq x1029 (x1029 (minus (times c n) (times d m)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nUnit_rect_Type2. Let $Q_$ be a function from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nAssistant:", "label": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)", "predict": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_CProp0. Låt $x1$ och $x2$ och $x3$ och $x4$ vara naturliga tal. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Låt $P$ vara en funktion från element $_z1494$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden. Låt $_H1$ vara en funktion från element $x_859$ av $Lt$ av $x4$ och $x2$ och element $x_858$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1495$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type2_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_825$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_827$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_826$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_827$ och $x_826$, för alla element $x_825$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type2) -> (_H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> (x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type2 (Q_ x_825)", "predict": "postulate div_mod_spec_rect_Type2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type2) -> (_H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> (x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type2 (Q_ x_825)"}
{"prompt": "Human: Translate the following French statement into Agda.\nVoid_rect_CProp2_body. Pour toutes les fonctions $Q_$ des éléments $_x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_492$.\nAssistant:", "label": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)", "predict": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Anta att $2 ^ 7 \\leq n$. Låt $p \\in N$. Då om $\\sqrt{ (2 n)}+ 1 \\leq p$, så om $p < 2 n + 1$, så om $leb (2, k (2 n, p))= true$, så om $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (2 ^ 7 <= n) -> (p : N) -> (\\ sqrt (2 n) + 1 <= p) -> (p < 2 n + 1) -> (leb 2 (k 2 n p)) = true -> (2 n < p ^ 2) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 \\ x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNth_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $H$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $H$, håller $cic.Term$ för $univs.Type0$ och $H$.\nAssistant:", "label": "postulate nth_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate nth_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $__$ and $__1$ be natural numbers. Then $__ ^ __1$ is a natural number.\nAssistant:", "label": "postulate pow : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate pow : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSub_lt. Låt $A$ vara en mängd. Då för alla funktioner $e$ från naturliga tal till element av $A$, för alla funktioner $p$ från naturliga tal till sanningsvärden, för alla naturliga tal $n$ och $m$, om $n$ är mindre än eller lika med $m$, så håller $sub_hk$ för funktionen som avbildar $x$ som $x$ och funktionen som avbildar $x$ som $x$ och $A$ och $mk_range$ applicerat på $A$ och $e$ och $n$ och $p$ och $mk_range$ applicerat på $A$ och $e$ och $m$ och $p$.\nAssistant:", "label": "postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\\ x : Nat -> x) (\\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)", "predict": "postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\\ x : Nat -> x) (\\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_to_le_max. Let $f$ be a function from natural numbers to booleans. Let $n$ and $m$ be natural numbers. Assume that $m < n$ and $f (m)= true$. Then $m \\leq max (n, f)$.\nAssistant:", "label": "postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)", "predict": "postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type2. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_897$ av $ACop$ av $A$ och $_nil$ till element av $Type2$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$. Då för alla element $x_897$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_plus. Let $n1$ and $n2$ and $m1$ and $m2$ be natural numbers. Then if $n1$ is less than or equal to $n2$, then if $m1$ is less than or equal to $m2$, then the sum of $n1$ and $m1$ is less than or equal to the sum of $n2$ and $m2$.\nAssistant:", "label": "postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)", "predict": "postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_transpose_l. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ och $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Låt $__2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på funktionen som avbildar $p$ som $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $f$ applicerat på $p$ och $n$.\nAssistant:", "label": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)", "predict": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))", "predict": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))"}
{"prompt": "Human: Translate the following French statement into Agda.\nBijn_Sn_n. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n$, pour tous les éléments $__$ de $bijn$ de $f$ et de $n + 1$, si $f (n + 1)= n + 1$, alors $bijn$ tient pour $f$ et $n$.\nAssistant:", "label": "postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (plus n 1)) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f n", "predict": "postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (n + 1)) -> (__1 : Eq (f (n + 1)) (n + 1)) -> bijn f n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p, m, n \\in N$. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Då för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nTimes_Sn_m. Soit $n, m \\in N$. Alors $m + n m = (n + 1)m$.\nAssistant:", "label": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)", "predict": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m n) (times (plus n 1) m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nGcd_1_to_lt_O. Soient $i$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $i$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $i$.\nAssistant:", "label": "postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)", "predict": "postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_inv_rect_CProp1. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1686$ de $range$ de $x1$ à des propositions. Soit $_H1$ une fonction des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1687$ de $Eq$ de $Hterm$ et de $mk_range (x1, _enum, _upto, _filter)$ à des éléments de $P$ de $mk_range (x1, _enum, _upto, _filter)$. Alors $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_CProp1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1686 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1687 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_CProp1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1686 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1687 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nBool_rect_CProp4_body. Let $Q_$ be a function from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_true$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$. Then for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.\nAssistant:", "label": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)", "predict": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_S_to_permut. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $m$ un nombre naturel. Soit $__$ un élément de $permut$ de $f$ et de la somme de $m$ et de $1$. Supposons que $f$ appliqué à la somme de $m$ et de $1$ est égal à la somme de $m$ et de $1$. Alors $permut$ tient pour $f$ et $m$.\nAssistant:", "label": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m", "predict": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_a. Let $a$ and $b$ be natural numbers. Then for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a \\leq b$, then $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to the successor of $i0$ applied to the sum of $i$ and $a$ and $f$ applied to $a$ is equal to $bigop$ applied to the difference of the sum of $b$ and $1$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nAssistant:", "label": "postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))", "predict": "postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (op B nil op (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f (succ i0)) (plus i a))) (f a)) (bigop (minus (plus b 1) a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp5. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1600. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Then if $0 < n$ and $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times c n) (times d m)) 1))) -> Eq (minus (times n c) (times m d)) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_div. Soient $n$ et $d$ des nombres naturels. Supposons que $0 < n$. Alors si $d$ est divisible par $n$, alors $n \\div (n \\div d)= d$.\nAssistant:", "label": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d", "predict": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (n \\ (n \\ d)) d"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_gen. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ une fonction des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $i$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $n$.\nAssistant:", "label": "postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> cic.Term cic.prop (P n)", "predict": "postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> cic.Term cic.prop (P n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type4. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $Dop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1704$ of $Dop$ of $x1$ and $x2$ to elements of $Type4$. Then for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod (a, x2)$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod (a, aop__o__op (x1, x2, sum, b, c))$ and $aop__o__op (x1, x2, sum, prod (a, b), prod (a, c))$ and elements $_z1705$ of $Eq$ of $Hterm$ and $mk_Dop (x1, x2, sum, prod, _null, _distr)$ to elements of $P$ of $mk_Dop (x1, x2, sum, prod, _null, _distr)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm", "predict": "postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type3. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_867$ av $Aop$ av $A$ och $_nil$ till element av $Type3$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Låt $x_867$ vara ett element av $Aop$ av $A$ och $_nil$. Då håller $Q_$ för $x_867$.\nAssistant:", "label": "postulate Aop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867", "predict": "postulate Aop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_times. Soient $p$ et $a$ et $b$ et $qa$ et $ra$ et $qb$ et $rb$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $a$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$. Soit $__3$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $a$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $qa$ et $ra$. Soit $__4$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $b$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $qb$ et $rb$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_ar", "label": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics", "predict": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord_times a b p qa ra qb rb) (matita_arithmetics_ord.p_ord_times a b p qa ra qb rb))"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_divides_ord_rem. Soient $m$ et $p$ des nombres naturels. Supposons que $0$ est inférieur à $m$. Supposons que $1$ est inférieur à $p$. Alors $p$ n'est pas divisible par $ord_rem$ appliqué à $m$ et $p$.\nAssistant:", "label": "postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 1 p) -> not (divisible p (ord_rem m p))", "predict": "postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 1 p) -> not (divisible p (ord_rem m p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1648. Soit $n, q \\in N$. Supposons que $0$ est inférieur à $q$. Soit $n1$ un nombre naturel. Supposons que $n1$ est égal à la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod$ appliqué à $n1$ et $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$ et la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$. Supposons que la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Alors la somme de $n1$ et de $1$ est égale à la somme de $q$ et du produit de $q$ et du quotient de $n1$ et de $q$.\nAssistant:", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posn : Lt 0 q) -> (n1 : Nat) -> (eqn0 : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (divn1 : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> (divq : divisible q (plus n1 1)) -> (eqn2 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $gcd1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $nm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $p$ och $c$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $b$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.g", "label": "postulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_ar", "predict": "cdpostulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times a m) (matita_arithmetics_nat.times b p))))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMk_Dop. Låt $A$ vara en mängd. Låt $nil$ vara ett element av $A$. Låt $sum$ vara ett element av $ACop$ av $A$ och $nil$. Då för alla funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$, för alla funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod (a, nil)$ och $nil$, för alla funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod (a, aop__o__op (A, nil, sum, b, c))$ och $aop__o__op (A, nil, sum, prod (a, b), prod (a, c))$, håller $Dop$ för $A$ och $nil$.\nAssistant:", "label": "postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil", "predict": "postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMinus_pred_pred. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $n$ och $matita_arithmetics_nat.pred$ applicerat på $m$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))", "predict": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLeb_elim. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Låt $__$ vara en funktion från element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$. Då för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))", "predict": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_ind. Soit $Q_$ une fonction des nombres naturels $_x_365$ à des propositions. Soit $_H_O$ un élément de $Q_$ de $0$. Alors pour toutes les fonctions $_H_S$ des nombres naturels $x_366$ et des éléments $_x_368$ de $Q_$ de $x_366$ à des éléments de $Q_$ de la somme de $x_366$ et de $1$, pour tous les nombres naturels $x_365$, $Q_$ tient pour $x_365$.\nAssistant:", "label": "postulate nat_ind : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365", "predict": "postulate nat_ind : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1585. Låt $n, m \\in N$. Anta att $0 < n$ och $m$ är delbart med $n$. Låt $d \\in N$. Då om $0 = m$ och $n = m d$, så $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : or (Eq 0 m) (Eq n (m d))) -> Eq 0 n"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_0. Let $n$ be a natural number. Let $B$ be a set. Then for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to the sum of $i$ and $1$ and $f$ applied to $0$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i)) (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0))", "predict": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0)) (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_Type5. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type5$. Alors pour toutes les fonctions $_H_inl$ des éléments $x_532$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_532$, pour toutes les fonctions $_H_inr$ des éléments $x_533$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_533$, pour tous les éléments $x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_531$.\nAssistant:", "label": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)", "predict": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_n_8_to_le_Psi_exp. Låt $n \\in N$. Då om $n \\leq 8$, så $Psi (n)\\leq 2 ^ (2 n - 3)$.\nAssistant:", "label": "postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))", "predict": "postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (2 n - 3))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_879$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_879$.\nAssistant:", "label": "postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879", "predict": "postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Låt $__1$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nAssistant:", "label": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_elim1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $__$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $__$ från element $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $p$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $m$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $n$.\nAssistant:", "label": "postulate nat_elim1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p)) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P n)", "predict": "postulate nat_elim1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p)) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$. Assume that $a \\leq n$. Assume that $f (a)= i$. Then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (Eq (f a) i)) -> (_clearme1 : Leq a n) -> (_clearme2 : Eq (f a) i) -> (b : Nat) -> (_clearme3 : and (Leq b n) (Eq (f b) j)) -> (_clearme4 : Leq b n) -> (_clearme5 : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_Type3. Låt $x1, x2, x3, x4 \\in N$. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1446$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till element av $Type3$, för alla funktioner $_H1$ från element $x_823$ av $Lt$ av $x4$ och $x2$ och element $x_822$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1447$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_Type3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3) -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_Type3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3) -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15623. Let $m, n, a, b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $a1$. Let $_e$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $a1$ and $x$ and $y$. Then $cic.Term$ holds for $univs.Type2", "label": "postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ t1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ t2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ u1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ u2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1)) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1)) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type", "predict": "postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.range a1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1047. Let $k, n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all natural numbers $j$, if $n$ is less than or equal to $j$, then for all functions $Hind$ from functions from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and $j$ to elements of $Eq$ of $p$ applied to $i$ and absurdity to elements of $Eq$ of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $j$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$, for all functions $Hfalse$ from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $j$ and $1$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, for all natural numbers $x2571$ and $x2572$, $x2571$ is equal to the sum of the product of $x2572$ and the quotient of $x2571$ and $x2572$ and $mod$ applied to $x2571$ and $x2572$.\nAssistant:", "label": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))", "predict": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (j : Nat) -> (_clearme : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp4. För alla mängder $x1$, för alla element $x2$ av $x1$, för alla element $Hterm$ av $Aop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1536$ av $Aop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från funktioner $op$ från element av $x1$ och element $__1$ av $x1$ till element av $x1$ och funktioner $_nill$ från element $a$ av $x1$ till element av $Eq$ av $op (x2, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $x1$ till element av $Eq$ av $op (a, x2)$ och $a$ och funktioner $_assoc$ från element $a$ av $x1$ och element $b$ av $x1$ och element $c$ av $x1$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ och element $_z1537$ av $Eq$ av $Hterm$ och $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ till element av $P$ av $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (and (Eq (f a) i) (Leq a n))) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (and (Eq (f b) j) (Leq b n))) -> (fb : Eq (f b) j) -> (_ : (_ : Nat) -> i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1549. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Då om $0 = m$, så för alla naturliga tal $x1106$, $x1106 = x1106 - m$.\nAssistant:", "label": "postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (eqm0 : Eq 0 m) -> (x1106 : Nat) -> Eq x1106 (minus x1106 m)", "predict": "postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (eqm0 : Eq 0 m) -> (x1106 : Nat) -> Eq x1106 (x1106 - m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_ord_sigma_p. Let $n$ and $m$ and $x$ be natural numbers. Assume that $0$ is less than $n$. Assume that $x$ is prime. Assume that the exponentiation of $x$ and $m$ is less than or equal to $n$. Assume that $n$ is less than the exponentiation of $x$ and the sum of $m$ and $1$. Then $ord$ applied to $n$ and $x$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $x$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.\nAssistant:", "label": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H_mk_Dop$ be a function from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_", "label": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)", "predict": "distrpostulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_p_ord_q_O. Soit $p, n, q \\in N$. Supposons que $p_ord$ appliqué à $n$ et $p$ est égal à $mk_Prod$ appliqué à $Nat$ et $Nat$ et $q$ et $0$. Alors $n$ est égal à $0$ et $q$ est égal à $0$.\nAssistant:", "label": "postulate eq_p_ord_q_O : (p : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Eq (p_ord n p) (mk_Prod Nat Nat q 0)) -> and (Eq n 0) (Eq q 0)", "predict": "postulate eq_p_ord_q_O : (p : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Eq (p_ord n p) (mk_Prod Nat Nat q 0)) -> and (Eq n 0) (Eq q 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nCongruent_times. Soit $n, m, n1, m1, p \\in N$. Supposons que $0 < p$. Soit $__1$ un élément de $congruent$ de $n$ et de $n1$ et de $p$. Soit $__2$ un élément de $congruent$ de $m$ et de $m1$ et de $p$. Alors $congruent$ tient pour $n \\times m$ et $n1 \\times m1$ et $p$.\nAssistant:", "label": "postulate congruent_times : (n : Nat) -> (m : Nat) -> (n1 : Nat) -> (m1 : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent (times n m) (times n1 m1) p", "predict": "postulate congruent_times : (n : Nat) -> (m : Nat) -> (n1 : Nat) -> (m1 : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent (n * m) (n1 * m1) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_not_exists. Let $f$ be a function from natural numbers to booleans. Let $n$ and $b$ be natural numbers. Let $__$ be a function from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $n + b$ to elements of $Eq$ of $f (i)$ and absurdity. Then $min (n, b, f)= n + b$.\nAssistant:", "label": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)", "predict": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (n + b)) -> Eq (f i) false) -> Eq (min n b f) (n + b)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLprim_invariant. För alla naturliga tal $n$ och $i$, för alla listor $acc$ av naturliga tal, om $1 < i$, så för alla element $__1$ av $primes_below$ av $acc$ och $i$, håller $primes_below$ för $lprim (n, i, acc)$ och $n + i$.\nAssistant:", "label": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)", "predict": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (n + i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__aop. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ et $x2$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)", "predict": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_rect_CProp3. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_nil$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Alors pour toutes les fonctions $_H_cons$ des éléments $x_763$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_762$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_765$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_762$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_763$ et $x_762$, pour tous les éléments $x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_761$.\nAssistant:", "label": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)", "predict": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPad_bigop_nil. Soient $k$ et $n$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $n \\leq k$, alors pour toutes les fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Leq$ de $n$ et de $i$ et des éléments $__2$ de $Lt$ de $i$ et de $k$ à des éléments de $or$ de $Eq$ appliqué à $p$ appliqué à $i$ et contradiction et de $Eq (f (i), nil)$, $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_discr. Låt $a1$ och $a2$ och $a3$ och $a4$ vara naturliga tal. Då för alla element $x$ och $y$ av $div_mod_spec$ av $a1$ och $a2$ och $a3$ och $a4$, om $x = y$, så håller $match_div_mod_spec$ för $a1$ och $a2$ och $a3$ och $a4$ och $Type2 + 1$ och funktionen som avbildar $__$ som $univ (Type2)$ och funktionen som avbildar $t0$ och $t1$ som $match_div_mod_spec$ applicerat på $a1$ och $a2$ och $a3$ och $a4$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar $u0$ och $u1$ som $prod$ applicerat på summan av $Type1$ och $1$ och $Type1$ och $univ$ applicerat på $Type1$ och funktionen som avbildar $P$ som $prod$ applicerat på $Type1$ och $Type1$ och $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R0$ applicerat på $Lt$ applicerat på $a4$ och $a2$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R1$ applicerat på $Lt$ applicerat på $a4$ och $a2$ och $t0$ och funktionen som avbildar $x_19$ och $_x_20$ som funktionen som avbildar $x0$ och $p0$ som $Eq$ applicerat på $a1$ och summan av produkten av $a3$ och $a2$ och $a4$ applicerat", "label": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Lt a4 a2 -> \\ t1 : Eq a1 (plus (times a3 a2) a4) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Lt a4 a2 -> \\ u1 : Eq a1 (plus (times a3 a2) a4) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (\\ _e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P))) (\\ _z53 : ((e0 : Eq (R0 (Lt a4 a2) t0) u0) -> (_e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4", "predict": " påpostulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 Type2 1 (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Nat -> \\ t1 : Nat -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ (Type2))) (\\ u0 : Nat -> \\ u1 : Nat -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0) (a1 (plus (times a3 a2) a4) t0)) (\\ x_19 : Eq (R1 (Lt a4 a2) t0) (a1 (plus (times a3 a2) a4) t0) -> _x_20 : Eq (plus (times a3 a2) a4) (plus (times a3 a2) a4) -> Eq (R1 (Lt a4 a2) t0) u0) (\\ _x_21 : Eq (R1 (Lt a4 a2) t0) u0 -> P))) (\\ _x_22 : P -> prod Type1 Type1 (prod Prop Type1 (Eq (R1 (Lt a4 a2) t0) u1) (\\ e1 : Eq (R1 (Lt a4 a2) t0) u1 -> prod Prop Type1 (Eq (R2 (Lt a4 a2) t0) (plus (times a3 a2) a4)) (\\ x_23 : Eq (R2 (Lt a4 a2) t0) (plus (times a3 a2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp5_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk", "label": "postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_877)", "predict": "_Aoppostulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_877)"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_ind_body. Soit $Q_$ une fonction des éléments $_x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_366$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_368$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_366$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_366$, pour tous les éléments $x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_365$.\nAssistant:", "label": "postulate nat_ind_body : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)", "predict": "postulate nat_ind_body : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter_le. For all natural numbers $_n$ and $__$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_type$ of $z$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $z$.\nAssistant:", "label": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z", "predict": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1545. Låt $m, n \\in N$. Anta att $0$ är både lika med det största gemensama delaret av $m$ och $n$ och delbart med $n$. Låt $q1 \\in N$. Anta att $n = 0 q1$ och $0$ är delbart med $m$. Låt $q2 \\in N$. Anta att $m = 0 q2$. Då $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq 0 (gcd m n)) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (Hn : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (Hm : Eq m (times 0 q2)) -> Eq m 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_min_f_min_g. Soient $f$ et $g$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $n$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ une fonction des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $g$ appliqué à $i$ et $matita_basics_bool.true$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $g$ et $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$.\nAssistant:", "label": "postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))", "predict": "postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_exp_to_lt. Let $a, n, m \\in N$. Assume that $0$ is less than $a$. Assume that the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$. Then $n$ is less than $m$.\nAssistant:", "label": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m", "predict": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_rect_CProp2_body. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_768$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_767$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_770$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_767$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_768$ och $x_767$, för alla element $x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_766$.\nAssistant:", "label": "postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)", "predict": "postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15692. Soit $m, n, a, b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Alors si $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_le_min. Let $f$ be a function from natural numbers to booleans. Let $n, m \\in N$. Assume that $n \\leq m$. Then for all natural numbers $b$, $min (n, b, f)\\leq min (m, b, f)$.\nAssistant:", "label": "postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)", "predict": "postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be a natural number. Assume that $1 < n$. Assume that $2 \\times n$ is prime. Assume that $1 < 2 n$. Let $H1$ be a function from natural numbers $m$ and elements of $divisible$ of $m$ and $2 \\times n$ and elements $__1$ of $Lt$ of $1$ and $m$ to elements of $Eq$ of $m$ and $2 \\times n$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (lt1n : Lt 1 n) -> (prime2n : prime (times 2 n)) -> (lt12n : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Alors si $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $match_bool$ applicerat på $Set$ och funktionen som avbildar $_0$ som $bool$ och kontradiktion och $p$ applicerat på $i$ och $leb$ applicerat på $n$ och $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> match_bool Set (\\ _0 : bool -> bool) false (p i) (leb n i)) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (_ : nil B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> match_bool Set (\\ _0 : bool -> bool) (\\ _ : bool -> false) (p i) (leb n i)) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_ind_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_521$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_inl$ des éléments $x_522$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_522$, pour toutes les fonctions $_H_inr$ des éléments $x_523$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_523$, pour tous les éléments $x_521$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_521$.\nAssistant:", "label": "postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)", "predict": "postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_to_not_eq_O. Låt $n, p, q, r \\in N$. Då om $1$ är mindre än $n$, så om $p_ord$ applicerat på $n$ och $nth_prime$ applicerat på $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $q$ och $r$, så är $r$ inte lika med $0$.\nAssistant:", "label": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)", "predict": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_diff. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $ACop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, pour tous les nombres naturels $i$ et $n$, si $i < n$ et $p (i)= true$, alors $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et $f$ appliqué à $i$ et $bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $andb$ appliqué à $notb$ appliqué à $eqb$ appliqué à $i$ et $x$ et $p$ appliqué à $x$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $p$ appliqué à $x$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$.\nAssistant:", "label": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))", "predict": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x))) (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_times. Låt $p, a, b, qa, ra, qb, rb \\in N$. Anta att $p$ är primt. Då om $0$ är mindre än $a$, så om $0$ är mindre än $b$, så om $p_ord$ applicerat på $a$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $qa$ och $ra$, så om $p_ord$ applicerat på $b$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $qb$ och $rb$, så är $p_ord$ applicerat på produkten av $a$ och $b$ och $p$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och summan av $qa$ och $qb$ och produkten av $ra$ och $rb$.\nAssistant:", "label": "postulate p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> (__3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra)) -> (__4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb)) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb))", "predict": "postulate p_ord_times : (p : Prime) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> (_ : Lt 0 a) -> (__1 : Lt 0 b) -> (__2 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra)) -> (__3 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb)) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $return_sort$ vara ett element av $Sort$. Låt $return_type$ vara en funktion från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$. Låt $case_lstar_O$ vara en funktion från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $case_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $__1$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, __, l, b2, __1)$. Låt $__ \\in N$. Låt $__1$ och $__2$ vara element av $B$. Då för alla element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (l + 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sigma. Let $n$ be a natural number. Then for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.\nAssistant:", "label": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1561. Soit $p, m, n \\in N$. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Alors pour tous les nombres naturels $a$, pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eq1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus a p)) (Eq (minus b m) (minus a p))) (and (Eq (gcd p m) (minus b m)) (Eq (minus a p) (minus b m)))) -> (H : Eq (gcd p m) (minus a p)) -> Eq (minus p a) (minus m b)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCr_pair4. $cr_pair$ applicerat på $5$ och $7$ och $3$ och $2$ är lika med $23$.\nAssistant:", "label": "postulate cr_pair4 : Eq (cr_pair 5 7 3 2) 23", "predict": "postulate cr_pair4 : Eq (cr_pair 5 7 3 2) 23"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type4. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_945$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type4$. Alors pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a, _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a, aop__o__op (A, _nil, sum, b, c))$ et de $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ à des éléments de $Q_$ de $mk_Dop (A, _nil, sum, prod, _null, _distr)$, pour tous les éléments $x_945$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_945$.\nAssistant:", "label": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945", "predict": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_to_or_lt_eq. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $m$.\nAssistant:", "label": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))", "predict": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1585. Soient $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Alors si $m$ est divisible par $n$, alors pour tous les nombres naturels $d$, si $0 = m$, alors si $n = m d$, alors $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (m d)) -> Eq 0 n"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp1_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_853$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_855$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_854$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_855$ et $x_854$. Alors pour tous les éléments $x_853$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_853$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853", "predict": "postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements", "label": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)", "predict": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_div_O. Let $n$ and $m$ be natural numbers. Assume that $n < m$. Then $n \\div m = 0$.\nAssistant:", "label": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0", "predict": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nMatch_divides. Soit $_n, _m \\in N$. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $divisible$ de $_n$ et de $_m$ à des éléments de $return_sort$, pour toutes les fonctions $case_quotient$ des nombres naturels $q$ et des éléments de $Eq$ de $_m$ et du produit de $_n$ et de $q$ à des éléments de $return_type$ de $quotient$ appliqué à $_n$ et $_m$ et $q$ et $__$, si $_n$ est divisible par $_m$, alors $return_type$ tient pour $z$.\nAssistant:", "label": "postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z", "predict": "postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_divides_false. Soit $l$ une liste de nombres naturels. Alors pour tous les nombres naturels $n$, si $list_divides$ appliqué à $l$ et $n$ est égal à contradiction, alors pour tous les nombres naturels $p$, pour tous les éléments $__1$ de $mem$ de $Nat$ et de $p$ et de $l$, $p$ n'est pas divisible par $n$.\nAssistant:", "label": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)", "predict": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (__2 : Leq a n) -> (__3 : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (__4 : Leq b n) -> (__5 : Eq (f b) j) -> (_ : (_ : Nat) -> Nat) -> (i0 : Nat) -> (_ : Leq i0 n) -> (__6 : permut f n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_gcd. Låt $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $n$. Då om $n$ är delbart med $m$, så är det största gemensama delaret av $n$ och $m$ lika med $n$.\nAssistant:", "label": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n", "predict": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1078. Låt $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q$ och $r$. Låt $ltrb$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $r$ och $b$. Då för alla element $spec$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $a$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $q$ och $b$ och $r$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q1$ och $r1$, för alla element $ltr1b$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $r1$ och $b$, för alla element $spec1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $a$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $q1$ och $b$ och $r1$, för alla element $leqq1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $q1$, för alla element $ltqq1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $q$ och $q1$, håller", "label": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))", "predict": "postulatetpostulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_times_div_m_m. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $m$ et $n$.\nAssistant:", "label": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)", "predict": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Assume that $1 < n$. Assume that $2 \\times n$ is prime. Then if $1 < 2 n$, then for all functions $H1$ from natural numbers $m$ and elements of $divisible$ of $m$ and $2 \\times n$ and elements $__1$ of $Lt$ of $1$ and $m$ to elements of $Eq$ of $m$ and $2 \\times n$, for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : N) -> (lt1n : Lt 1 n) -> (prime2n : prime (times 2 n)) -> (lt1m : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1575. Let $m, n, a, b \\in N$. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then for all natural numbers $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times c n) (times d m)) 1))) -> (x1029 : Nat) -> Eq x1029 (x1029 (minus (times c n) (times d m)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n$ un nombre naturel. Supposons que $5 < n$. Soit $m \\in N$. Supposons que $6 \\leq m$. Supposons que $(m + 1)^ 2 \\leq 2 ^ m$. Soit $a \\in N$. Alors si $6 \\leq a$, alors si $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (posm : Leq 6 m) -> (Hind : Leq (m + 1) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (2 (a + 1)) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_sum. Let $k1$ and $k2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $Aop$ of $B$ and $nil$. Let $f$ and $g$ be functions from natural numbers to elements of $B$. Then $bigop$ applied to the sum of $k1$ and $k2$ and the function that maps $i$ to $match_bool$ applied to $Set$ and the function that maps $__$ to $bool$ and $p1$ applied to the difference of $i$ and $k2$ and $p2$ applied to $i$ and $leb$ applied to $k2$ and $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $match_bool$ applied to $Set$ and the function that maps $__$ to $B$ and $f$ applied to the difference of $i$ and $k2$ and $g$ applied to $i$ and $leb$ applied to $k2$ and $i$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$.\nAssistant:", "label": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i))) (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))", "predict": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i))) (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_nth_prime_to_not_prime. Låt $n$ och $m$ vara naturliga tal. Anta att $nth_prime (n)< m$. Då om $m < nth_prime (n + 1)$, så är $m$ inte primt.\nAssistant:", "label": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)", "predict": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (n + 1))) -> not (prime m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAnd_inv_rect_CProp2. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z371$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $x_160$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_159$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z372$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$. Då håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Då om $5$ är mindre än $n$, så för alla naturliga tal $m$, om $6$ är mindre än eller lika med $m$, så om potensen av summan av $m$ och $1$ och $2$ är mindre än eller lika med potensen av $2$ och $m$, så för alla naturliga tal $a$, om $6$ är mindre än eller lika med $a$, så om summan av produkten av $2$ och summan av $a$ och $1$ och $1$ är mindre än eller lika med potensen av $2$ och $a$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (posm : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (posa : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1078. Låt $a, b, q, r, q1, r1 \\in N$. Låt $_clearme$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$. Anta att $r$ är mindre än $b$. Anta att $a$ är lika med summan av produkten av $q$ och $b$ och $r$. Då för alla element $_clearme0$ av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$, om $r1$ är mindre än $b$, så om $a$ är lika med summan av produkten av $q1$ och $b$ och $r1$, så om $q$ är mindre än eller lika med $q1$, så om $q$ är mindre än $q1$, så är $a$ lika med summan av $r$ och produkten av $b$ och $q$.\nAssistant:", "label": "postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))", "predict": "postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$. Then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_divides_times_to_divides. Låt $p, n, m \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $n$. Anta att $p$ är delbart med $n \\times m$. Då är $p$ delbart med $m$.\nAssistant:", "label": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m", "predict": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq 1 (gcd p n)) -> (__2 : divisible p (times n m)) -> divisible p m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $", "label": "postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (mat", "predict": "postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.times a n) (matita_arithmetics_nat.times b m)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S mat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type5. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_819$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_818$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_819$ och $x_818$, för alla element $x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_817$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)", "predict": "postulate div_mod_spec_rect_Type5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_p_ord_inv. Let $p, m, x \\in N$. Assume that $ord (x, p)< m$. Then $p_ord_inv (p, m, x)\\div m = ord_rem (x, p)$.\nAssistant:", "label": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)", "predict": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_Sfalse. For all natural numbers $k$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if absurdity is equal to $p (k)$, then $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq false (p k)) -> Eq (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_inv_ind. Låt $x1$ och $x2$ vara naturliga tal. Låt $x3$ vara en funktion från naturliga tal till sanningsvärden. Låt $x4 \\in N$. Låt $_Hterm$ vara ett element av $min_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från naturliga tal $_z1890$ till påståenden, för alla funktioner $_H1$ från naturliga tal $m$ och element $_x_1080$ av $Leq$ av $x2$ och $m$ och element $_x_1079$ av $Lt$ av $m$ och summan av $x1$ och $x2$ och element $_x_1078$ av $Eq$ av $x3$ applicerat på $m$ och $true$ och funktioner $_x_1077$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och $m$ till element av $P$ av $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $x1$ och $x2$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och summan av $x1$ och $x2$ till element av $P$ av summan av $x1$ och $x2$, håller $P$ för $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Prop) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_plus_to_le_r. Pour tous les nombres naturels $a$ et $n$ et $m$, si $n + a \\leq m + a$, alors $n \\leq m$.\nAssistant:", "label": "postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n a) (plus m a)) -> Leq n m", "predict": "postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (n + a) (m + a)) -> Leq n m"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_div_O. Pour tous les nombres naturels $n$ et $m$, si $n < m$, alors $n \\div m = 0$.\nAssistant:", "label": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0", "predict": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c$ un nombre naturel. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale à $1$. Alors la différence du produit de $m$ et de $b$ et du produit de $p$ et de $a$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> Eq (minus (times b m) (times a p)) (gcd p m) -> Eq (minus (times b m) (times a p)) 1 -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p$ and $q$ be natural numbers. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m, n \\in N$. Assume that $0$ is less than $n$. Assume that $n$ is less than or equal to $m$. Assume that $n$ is less than or equal to the sum of $q$ and $1$. Assume that $n$ is not divisible by $m$. Then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_times_r. Låt $c \\in N$. Anta att $0 < c$. Då håller $monotonic$ för $Nat$ och $Lt$ och funktionen som avbildar $t$ som $c \\times t$.\nAssistant:", "label": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> times c t)", "predict": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> c * t)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1))) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nF_false_to_le_max. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)", "predict": "postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_mop. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla element $R$ av $Dop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, för alla element $a$ och $_x_969$ och $_x_970$ av $B$, $B$.\nAssistant:", "label": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B", "predict": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_fwd_plus_plus_ge. Let $m1$ and $m2$ be natural numbers. Assume that $m2 \\leq m1$. Then for all natural numbers $n1$ and $n2$, if $m1 + n1 \\leq m2 + n2$, then $n1 \\leq n2$.\nAssistant:", "label": "postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2", "predict": "postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (m1 + n1) (m2 + n2)) -> Leq n1 n2"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que $b m - a p = 1$. Alors $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eq1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1617. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Då för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_max_f_max_g. Soient $f$ et $g$ des fonctions des nombres naturels à des valeurs booléennes. Soit $n \\in N$. Soit $__$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $f$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $g$ appliqué à $i$ et de $true$. Alors $max$ appliqué à $n$ et $f$ est inférieur ou ágal à $max$ appliqué à $n$ et $g$.\nAssistant:", "label": "postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> Leq (max n f) (max n g)", "predict": "postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> Leq (max n f) (max n g)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_inv_O. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b2$ be elements of $B$. Let $__$ be an element of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$. Assume that $0 = l$. Then $b1 = b2$.\nAssistant:", "label": "postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2", "predict": "postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2"}
{"prompt": "Human: Translate the following French statement into Agda.\nProd_rect_Type4_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_692$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_692$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_692$.\nAssistant:", "label": "postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)", "predict": "postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15441. Låt $p, q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $n$ är mindre än eller lika med $m$. Då om $n$ är mindre än eller lika med summan av $q$ och $1$, så om $n$ inte är delbart med $m$, så för alla naturliga tal $a$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ är lika med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ eller skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": " påpostulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (Hind' : (H : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (b : Nat) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum_body. Låt $A$ vara en mängd. Låt $_xxx$ vara ett element av $range$ av $A$. Låt $_x_942 \\in N$. Då $A$.\nAssistant:", "label": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : N) -> A"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_Sfalse. Låt $k \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara en funktion från element av $B$ och element $__1$ av $B$ till element av $B$. Då för alla funktioner $f$ från naturliga tal till element av $B$, om kontradiktion är lika med $p (k)$, så är $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på summan av $k$ och $1$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (contradiction : Prop) (p k)) -> Eq (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if $b m - a p = 1$, then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus a p)) (Eq (minus b m) a)) (and (Eq (gcd p m) (minus b m)) (Eq (minus a p) b))) -> (H : Eq (minus b m) a) -> (H0 : Eq (minus a p) b) -> (H1 : Eq (minus b m) a) -> Eq (minus m b) p"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1062. Soit $a, b, q, r, q1, r1 \\in N$. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r$ est inférieur à $b$. Supposons que $a$ est égal à la somme du produit de $q$ et de $b$ et de $r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Alors si $r1$ est inférieur à $b$, alors si $a$ est égal à la somme du produit de $q1$ et de $b$ et de $r1$, alors si $q$ n'est pas inférieur ou ágal à $q1$, alors $a$ est égal à la somme de $r1$ et du produit de $b$ et de $q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (or (Lt q q1) (Eq q q1))) -> Eq a (plus r1 (times b q1))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $Hle$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p (n1)= true$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (p : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516) + mod (x2515, x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_smallest_factor_n. Let $n$ be a natural number. Then $smallest_factor$ applied to $n$ is less than or equal to $n$.\nAssistant:", "label": "postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n", "predict": "postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_sqrt_to_le_times_l. Låt $m, n \\in N$. Då om $n \\leq \\sqrt{ m}$, så $n n \\leq m$.\nAssistant:", "label": "postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> (_ : Leq n (sqrt m)) -> Leq (times n n) m", "predict": "postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> (_ : Leq n (sqrt m)) -> Leq (nn n) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be natural numbers. Assume that $0 < n$. Then if $0 < m$, then if $p$ is prime, then if $n$ is divisible by $m$, then if $p_ord (n, p)= mk_Prod (Nat, Nat, a, b)$, then if $p_ord (m, p)= mk_Prod (Nat, Nat, c, d)$, then $b$ is divisible by $d$ and $a \\leq c$.\nAssistant:", "label": "postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)", "predict": "postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_false_to_le_max. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, p \\in N$. Då för alla element $__$ av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och $Eq$ applicerat på $f$ applicerat på $i$ och $true$, för alla funktioner $__1$ från naturliga tal $m$ och element $__1$ av $Lt$ av $p$ och $m$ till element av $Eq$ av $f (m)$ och kontradiktion, $max (n, f)\\leq p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p", "predict": "postulate f_false_to_le_max : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nFound_max_spec. Let $n$ be a natural number. Let $f$ be a function from natural numbers to booleans. Let $m \\in N$. Then if $m < n$ and $f (m)= true$, then for all functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f (i)$ and absurdity, $max_spec$ holds for $n$ and $f$ and $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i \\leq n$ and $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b \\in N$. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (f a = i) (Leq a n))) -> (Hfa : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (f b = j) (Leq b n))) -> (Hfb : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_m. Let $f$ be a function from natural numbers to booleans. Then for all natural numbers $n$ and $b$, $Nat$.\nAssistant:", "label": "postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat", "predict": "postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Då för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_or_ge. Soit $m, n \\in N$. Alors $m$ est inférieur ou ágal à $n$ ou $n$ est inférieur ou ágal à $m$.\nAssistant:", "label": "postulate le_or_ge : (m : Nat) -> (n : Nat) -> or (Leq m n) (Leq n m)", "predict": "postulate le_or_ge : (m : Nat) -> (n : Nat) -> or (Lt m n) (Lt n m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $pnm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors pour tous les éléments", "label": "postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita", "predict": "postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.times c n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_ord. Soient $p$ et $n$ des nombres naturels. Alors si $1$ est inférieur à $p$, alors si $0$ est inférieur à $n$, alors $n$ est égal au produit de la puissance de $p$ et de $ord$ appliqué à $n$ et $p$ et de $ord_rem$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate exp_ord : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))", "predict": "postulate exp_ord : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_log2_sqrt. Soit $n$ un nombre naturel. Supposons que $2 ^ 6 \\leq n$. Alors $\\log_ 2 {n}< \\sqrt{ n}$.\nAssistant:", "label": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)", "predict": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Lt (pow 2 6) n) -> Lt (log 2 n) (sqrt n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDistr. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $nil$, pour tous les éléments $a$ et $b$ et $c$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $nil$ et $matita_arithmetics_bigops.sum$ appliqué à $A$ et $nil$ et $xxx$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $nil$ et $matita_arithmetics_bigops.sum$ appliqué à $A$ et $nil$ et $xxx$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $b$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $c$.\nAssistant:", "label": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))", "predict": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_ind_aux. Låt $A$ vara en mängd. Låt $f$ vara en funktion från element av $A$ till naturliga tal. Låt $P$ vara ett element av $predicate$ av $A$. Låt $__$ vara en funktion från naturliga tal $n$ och funktioner från element $a$ av $A$ och element av $Lt$ av $f$ applicerat på $a$ och $n$ till element av $P$ av $a$ och element $a$ av $A$ och element $__1$ av $Eq$ av $f$ applicerat på $a$ och $n$ till element av $P$ av $a$. Låt $n$ vara ett naturligt tal. Låt $a$ vara ett element av $A$. Anta att $f$ applicerat på $a$ är lika med $n$. Då håller $P$ för $a$.\nAssistant:", "label": "postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a", "predict": "postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a"}
{"prompt": "Human: Translate the following French statement into Agda.\nAxiome. Soit $__$ un nombre naturel. Alors le successeur de $__$ est un nombre naturel.\nAssistant:", "label": "postulate succ : (_ : Nat) -> Nat", "predict": "postulate succ : (_ : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAppend_l2_injective_r. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $l1$ och $l2$ och $l3$ och $l4$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l3$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l4$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l3$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l2$ och $l4$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l3$ och $l4$.\nAssistant:", "label": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)", "predict": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_881$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Aop", "label": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_881)", "predict": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_881)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFold_sum. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soient $I$ et $J$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Alors pour tous les éléments $op$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $I$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $J$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_basics_lists_list.append$ appliqué à $A$ et $I$ et $J$.\nAssistant:", "label": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))", "predict": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type0. Let $Hterm$ be a natural number. Let $P$ be a function from natural numbers $_z683$ to sets. Let $_H1$ be a function from elements $_z684$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Then for all functions $_H2$ from natural numbers $x_390$ and functions $_x_392$ from elements $_z684$ of $Eq$ of $Hterm$ and $x_390$ to elements of $P$ of $x_390$ and elements $_z684$ of $Eq$ of $Hterm$ and $x_390 + 1$ to elements of $P$ of $x_390 + 1$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm x_390 + 1) -> P x_390 + 1) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_inv_rect_Type3. Pour tous les nombres naturels $Hterm$, pour toutes les fonctions $P$ des nombres naturels $_z665$ à des éléments de $Type3$, pour toutes les fonctions $_H1$ des éléments $_z666$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_378$ et des fonctions $_x_380$ des éléments $_z666$ de $Eq$ de $Hterm$ et de $x_378$ à des éléments de $P$ de $x_378$ et des éléments $_z666$ de $Eq$ de $Hterm$ et de la somme de $x_378$ et de $1$ à des éléments de $P$ de la somme de $x_378$ et de $1$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Then for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i \\leq n$ and $j \\leq n$, then for all natural numbers $a$, if $a \\leq n$ and $f (a)= i$ and $a \\leq n$, then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$ and $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (Eq (f a) i) (Leq a n))) -> (Hc : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (Eq (f b) j) (Leq b n))) -> (Hcb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_div_S. Let $n$ and $m$ be natural numbers. Assume that $0 < m$. Then $n < (n \\div m + 1)m$.\nAssistant:", "label": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)", "predict": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n ((div n m) + 1) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_forall_to_exists. Soit $P$ une fonction des nombres naturels à des propositions. Alors pour tous les nombres naturels $n$, pour toutes les fonctions $__$ des nombres naturels $i$ à des éléments de $decidable$ de $P$ appliqué à $i$, s'il n'est pas le cas que $prod$ tienne pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n$ et la fonction qui envoie $__1$ à $P$ appliqué à $i$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de la négation de $P$ appliqué à $i$.\nAssistant:", "label": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))", "predict": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (_ : Nat) -> decidable (P _)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_log2_sqrt. Låt $n \\in N$. Då om $2 ^ 6 \\leq n$, så $\\log_ 2 {n}< \\sqrt{ n}$.\nAssistant:", "label": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)", "predict": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Lt (pow 2 6) n) -> Lt (log 2 n) (sqrt n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_inv_lstar. För alla mängder $B$, för alla element $R$ av $relation$ av $B$, för alla naturliga tal $l$, för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar_r$ av $B$ och $R$ och $l$ och $b1$ och $b2$, håller $lstar$ för $B$ och $R$ och $l$ och $b1$ och $b2$.\nAssistant:", "label": "postulate lstar_r_inv_lstar : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar_r B R l b1 b2) -> lstar B R l b1 b2", "predict": "postulate lstar_r_inv_lstar : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar_r B R l b1 b2) -> lstar B R l b1 b2"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_gcd_times_1. Let $p$ and $n$ and $m$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $p$ and $n$. Then if $1$ is equal to the greatest common divisor of $p$ and $m$, then $1$ is equal to the greatest common divisor of $p$ and the product of $n$ and $m$.\nAssistant:", "label": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1", "predict": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq 1 (gcd p n)) -> (__3 : Eq 1 (gcd p m)) -> Eq 1 (gcd p (times n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_S_times_2. Soit $n$ un nombre naturel. Supposons que $0 < n$. Alors $n + 1 \\leq 2 n$.\nAssistant:", "label": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)", "predict": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (n + 1) (times 2 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLeb_elim. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $__$ från element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$, för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))", "predict": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLhd_cons_ltl. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.append$ appliqué à $A$ et $matita_basics_lists_list.lhd$ appliqué à $A$ et $l$ et $n$ et $matita_basics_lists_list.ltl$ appliqué à $A$ et $l$ et $n$ et $l$.\nAssistant:", "label": "postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)", "predict": "postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_divides_S_fact. Let $n$ and $i$ be natural numbers. Assume that $1 < i$ and $i \\leq n$. Then $i$ is not divisible by $n! + 1$.\nAssistant:", "label": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (plus (factorial n) 1))", "predict": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (n! + 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_discr. Låt $a1$ vara en mängd. Låt $a2$ vara ett element av $a1$. Låt $x$ och $y$ vara element av $Aop$ av $a1$ och $a2$. Anta att $x$ är lika med $y$. Då håller $match_Aop$ för $a1$ och $a2$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar", "label": "postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \\ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \\ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) (\\ e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) ->", "predict": " postulate aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_ : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ _ : Aop a1 a2 -> univ Type2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_mod_to_divides. Soient $n$ et $m$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$. Alors pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $q$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $q$ et $matita_arithmetics_nat.minus$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))", "predict": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nUnit_inv_rect_Type2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Let $P$ be a function from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H1$ be a function from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$. Then $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type4. Låt $Q_$ vara en funktion från naturliga tal $_x_369$ till element av $Type4$. Låt $_H_O$ vara ett element av $Q_$ av $0$. Då för alla funktioner $_H_S$ från naturliga tal $x_370$ och element $_x_372$ av $Q_$ av $x_370$ till element av $Q_$ av summan av $x_370$ och $1$, för alla naturliga tal $x_369$, håller $Q_$ för $x_369$.\nAssistant:", "label": "postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369", "predict": "postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter_True. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$. Let $return$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$. Let $z$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nAssistant:", "label": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound5. Soit $n, m \\in N$. Alors si $nth_prime$ appliqué à $n$ est inférieur à $m$, alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound5 : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $n$.\nAssistant:", "label": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)", "predict": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p$ and $m$ and $n$ be natural numbers. Then if $0 < p$, then if $1$ is equal to the greatest common divisor of $p$ and $m$, then if $p$ is divisible by $m \\times n$, then for all natural numbers $c$, if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if $b m - a p = 1$, then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (H0 : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H1 : Eq (gcd p m) (minus (times b m) (times a p))) -> (H2 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_inv_rect_Type2. Soit $Hterm$ un nombre naturel. Alors pour toutes les fonctions $P$ des nombres naturels $_z671$ à des éléments de $Type2$, pour toutes les fonctions $_H1$ des éléments $_z672$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_382$ et des fonctions $_x_384$ des éléments $_z672$ de $Eq$ de $Hterm$ et de $x_382$ à des éléments de $P$ de $x_382$ et des éléments $_z672$ de $Eq$ de $Hterm$ et de la somme de $x_382$ et de $1$ à des éléments de $P$ de la somme de $x_382$ et de $1$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind. Let $_n, _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075$ be a natural number. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp0. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_115$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_nmk$ vara en funktion från funktioner $x_116$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_116$. Då för alla element $x_115$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_115$.\nAssistant:", "label": "postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)", "predict": "postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_to_or_lt_eq. Låt $n$ och $m$ vara naturliga tal. Anta att $n \\leq m$. Då $n < m$ eller $n = m$.\nAssistant:", "label": "postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)", "predict": "postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_times_gcd_aux. Soient $p$ et $m$ et $n$ et $d$ et $c$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$. Soit $__3$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $p$. Soit $__4$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $m$. Soit $__5$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $p$ et $m$ et $n$.\nAssistant:", "label": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))", "predict": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLength_unique_le. Let $n$ be a natural number. Let $l$ be a list of natural numbers. Then for all elements $__$ of $unique$ of $Nat$ and $l$, for all functions $__1$ from natural numbers $x$ and elements $__1$ of $mem$ of $Nat$ and $x$ and $l$ to elements of $Lt$ of $x$ and $n$, $length (Nat, l)\\leq n$.\nAssistant:", "label": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n", "predict": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_exp1. Pour tous les nombres naturels $p$ et $n$ et $q$ et $r$, si $0 < p$ et $p$ n'est pas divisible par $r$, alors si $n = p ^ q r$, alors $p_ord (n, p)= mk_Prod (Nat, Nat, q, r)$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)", "predict": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times p q r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1544. Låt $p$ och $q$ vara naturliga tal. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m, n \\in N$. Anta att $0$ är mindre än $n$. Anta att $n$ är mindre än eller lika med $m$. Anta att $n$ är mindre än eller lika med summan av $q$ och $1$. Anta att $n$ inte är delbart med $m$. Låt $a$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Anta att skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ är lika med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ eller skillnaden mellan produkten av $b$ och $n$ och produkten av $", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (Lt0n : Lt 0 n) -> (Leqnm : Leq n m) -> (LeqnS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_not_le. Soient $n$ et $m$ des nombres naturels. Supposons que $n$ est inférieur à $m$. Alors $m$ n'est pas inférieur ou ágal à $n$.\nAssistant:", "label": "postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Leq m n)", "predict": "postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Leq m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16002. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (p : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16171. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Alors pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$, alors si $b m - a p = 1$, alors $m b - p a$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus a p)) (Eq b m)) (and (Eq (gcd p m) (minus b m)) (Eq a p))) -> (H0 : Eq (gcd p m) (minus b m)) -> Eq (minus m b) (div (times m b) p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_885$ de $Aop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_885$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be a natural number. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n (_n)$. Then for all functions $case_le_S$ from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of $m + 1$ and $le_S (_n, m, __)$, for all natural numbers $__$, if $_n \\leq __$, then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (m + 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_869$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på", "label": "postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)", "predict": "postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A op _nil _nill _nilr _assoc))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_41. Nous pouvons démontrer que la somme de la somme de la puissance de $n$ et de $2$ et du produit de $3$ et de $n$ et de $5$ est impaire pour chaque entier $n$.\nAssistant:", "label": "postulate noLabel_41 : all Int (\\ n -> odd (plus (plus (pow n 2) (times 3 n)) 5))", "predict": "postulate noLabel_41 : all Nat (\\ n -> odd (plus (plus (pow n 2) (times 3 n)) 5))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I_gen. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_big", "label": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp0_body. För alla element $_n$ och $_m$ och $_q$ och $_r$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Q_$ från element $_x_857$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_859$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_858$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_859$ och $x_858$, för alla element $x_857$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_857$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)", "predict": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p2 (n1)= true$ et $p1 (n1)= true$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hc : and (p2 n1) (p1 n1)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type4_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_891$ av $ACop$ av $A$ och $_nil$ till element av $Type4$. Då för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_891$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891", "predict": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891"}
{"prompt": "Human: Translate the following French statement into Agda.\nTrue_inv_rect_CProp4. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Soit $P$ une fonction des éléments $_z161$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H1$ des éléments $_z162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nOrd_times. Soit $p, m, n \\in N$. Supposons que $0$ est inférieur à $m$. Alors si $0$ est inférieur à $n$, alors si $p$ est premier, alors $ord$ appliqué à le produit de $m$ et de $n$ et $p$ est égal à la somme de $ord$ appliqué à $m$ et $p$ et de $ord$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_676$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_676$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_676$.\nAssistant:", "label": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)", "predict": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc. Låt $A$ vara en mängd. Låt $nil$ vara ett element av $A$. Låt $xxx$ vara ett element av $Aop$ av $A$ och $nil$. Låt $a$ och $b$ och $c$ vara element av $A$. Då $op (A, nil, xxx, a, op (A, nil, xxx, b, c))= op (A, nil, xxx, op (A, nil, xxx, a, b), c)$.\nAssistant:", "label": "postulate assoc : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c)", "predict": "postulate assoc : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Anta att skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då är skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b, m \\in N$. Då för alla element $__$ av $min_spec$ av $n$ och $b$ och $f$ och $m$, är $min$ applicerat på $n$ och $b$ och $f$ lika med $m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m", "predict": "postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLog_times_l. Let $p$ and $n$ and $m$ be natural numbers. Then if $0 < n$, then if $0 < m$, then if $1 < p$, then $\\log_ p {n}+ \\log_ p {m}\\leq \\log_ p {(n m)}$.\nAssistant:", "label": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))", "predict": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log_ p n) (log_ p m)) (log_ p (times n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_sigma_p. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$, for all elements $__2$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and the disjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and $true$ and $Lt$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ and the conjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and absurdity and $Eq$ applied to $p2$ applied to $i$ and $true$ and $Lt$ applied to $0$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$ is less than $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$.\nAssistant:", "label": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i)) (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_fact_B. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_factorial.fact$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_factorial.fact$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nAssistant:", "label": "postulate eq_fact_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate eq_fact_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16171. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c$ un nombre naturel. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Alors si la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale à $1$, alors le diviseur commun plus grand de $p$ et de $m$ est égal à la différence du produit de $m$ et de $b$ et du produit de $p$ et de $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> Eq (minus (times b m) (times a p)) (gcd p m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type1. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_953$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type1$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_953$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_953$.\nAssistant:", "label": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953", "predict": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (Eq (f a) i) (Leq a n))) -> (Hc : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (Eq (f b) j) (Leq b n))) -> (Hd : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1544. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Then for all natural numbers $b$, if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$, then $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : N) -> (q : N) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1553. Låt $n, n0 \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $a$ som disjunktionen av $Eq$ applicerat på $n0$ och produkten av $2$ och $a$ och $Eq$ applicerat på $n0$ och summan av produkten av $2$ och $a$ och $1$. Låt $a \\in N$. Anta att $n0 = 2 a$ eller $n0 = 2 a + 1$. Anta att $n0 = 2 a + 1$. Då $n0 = a + (a + 1)$.\nAssistant:", "label": "postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))", "predict": "postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1542$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univ", "label": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nInjective_compose. Låt $A$ och $B$ och $C$ vara element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $g$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.injective$ applicerat på $A$ och $B$ och $f$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.injective$ applicerat på $B$ och $C$ och $g$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.injective$ applicerat på $A$ och $C$ och funktionen som avbildar $x$ som $g$ applicerat på $f$ applicerat på $x$.\nAssistant:", "label": "postulate injective_compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (__ : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__1 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (\\ x : cic.Term univs.Type0 A -> g (f x)))", "predict": "postulate injective_compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (__ : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__1 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (\\ x : cic.Term univs.Type0 A -> g (f x)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_ind_body. Let $_n \\in N$. Let $Q_$ be a function from natural numbers $x_417$ and elements $_x_418$ of $Leq$ of $_n$ and $x_417$ to propositions. Then for all elements $_H_le_n$ of $Q_$ of $_n$ and $le_n (_n)$, for all functions $_H_le_S$ from natural numbers $m$ and elements $x_419$ of $Leq$ of $_n$ and $m$ and elements $_x_421$ of $Q_$ of $m$ and $x_419$ to elements of $Q_$ of $m + 1$ and $le_S (_n, m, x_419)$, for all natural numbers $x_417$, if $_n \\leq x_417$, then $Q_$ holds for $x_417$ and $x_418$.\nAssistant:", "label": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418", "predict": "postulate le_ind_body : (_n : N) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n le_n (_n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (m + 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418"}
{"prompt": "Human: Translate the following French statement into Agda.\nProp50. $n$ n'est pas et pair et impair pour chaque nombre naturel $n$.\nAssistant:", "label": "postulate prop50 : all Nat (\\ n -> not (and (even n) (odd n)))", "predict": "postulate prop50 : (n : Nat) -> and (even n) (odd n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15624. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_Aop. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Aop$ of $A$ and $_nil$ to elements of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $return_type$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, for all elements $z$ of $Aop$ of $A$ and $_nil$, $return_type$ holds for $z$.\nAssistant:", "label": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z", "predict": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__1$ vara en funktion från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $H$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $H$, för alla funktioner $__3$ från element $__3$ av $cic.Term$ av $univs.Type0$ och $H$ och element $__4$ av $cic.Term$ av $univs.Type0$ och $H$ till element av $cic.Term$ av $univs.Type0$ och $H$, för alla funktioner $__4$ från element $__4$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $H$, håller $cic.Term$ för $univs.Type0$ och $H$.\nAssistant:", "label": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_plus. Let $n, p, q \\in N$. Then if $n$ is both divisible by $p$ and divisible by $q$, then $n$ is divisible by $p + q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : and (divisible n p) (divisible n q)) -> divisible n (plus p q)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16005. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$. Då är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq (minus (times d m) (times c n)) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sigma_p. Låt $n$ vara ett naturligt tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$, för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$, för alla element $__2$ av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och disjunktionen av konjunktionen av $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och $Lt$ applicerat på $g1$ applicerat på $i$ och $g2$ applicerat på $i$ och konjunktionen av konjunktionen av $Eq$ applicerat på $p1$ applicerat på $i$ och kontradiktion och $Eq$ applicerat på $p2$ applicerat på $i$ och $true$ och $Lt$ applicerat på $0$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$ mindre än $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$.\nAssistant:", "label": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> Prop) -> (p2 : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i)) (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nOrd_times. Let $p, m, n \\in N$. Assume that $0$ is less than $m$. Assume that $0$ is less than $n$. Then if $p$ is prime, then $ord$ applied to the product of $m$ and $n$ and $p$ is equal to the sum of $ord$ applied to $m$ and $p$ and $ord$ applied to $n$ and $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_CProp5_body. Soit $_A$ un ensemble. Alors pour toutes les fonctions $Q_$ des éléments $_x_931$ de $range$ de $_A$ à des propositions, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range (_A, _enum, _upto, _filter)$, pour tous les éléments $x_931$ de $range$ de $_A$, $Q_$ tient pour $x_931$.\nAssistant:", "label": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931", "predict": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931"}
{"prompt": "Human: Translate the following English statement into Agda.\nS_pred. Let $n \\in N$. Assume that $0 < n$. Then $pred (n)+ 1 = n$.\nAssistant:", "label": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n", "predict": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (pred n) (minus n 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_times. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $m$. Då om $0$ är mindre än $n$, så om $p$ är primt, så är $ord$ applicerat på produkten av $m$ och $n$ och $p$ lika med summan av $ord$ applicerat på $m$ och $p$ och $ord$ applicerat på $n$ och $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_to_lt_max. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m \\in N$. Anta att $0 < n$. Då om kontradiktion är lika med $f (n)$, så om $max (m, f)\\leq n$, så $max (m, f)< n$.\nAssistant:", "label": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n", "predict": "postulate false_to_lt_max : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq false (f n)) -> (__2 : Leq (max m f) n) -> Lt (max m f) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_invert_permut. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à $matita_arithmetics_permutation.invert_permut$ appliqué à $n$ et $f$ et $n$.\nAssistant:", "label": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)", "predict": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nInjn_Sn_n. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $__$ vara ett element av $injn$ av $f$ och summan av $n$ och $1$. Då håller $injn$ för $f$ och $n$.\nAssistant:", "label": "postulate injn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injn f (plus n 1)) -> injn f n", "predict": "postulate injn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injn f (plus n 1)) -> injn f n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp0_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_885$ av $Aop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, för alla element $x_885$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nBool_inv_rect_Type3. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $P$ une fonction des éléments $_z599$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type3$. Alors pour toutes les fonctions $_H1$ des éléments $_z600$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $Hterm$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_bool.true$, pour toutes les fonctions $_H2$ des éléments $_z600$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $Hterm$ et $matita_basics_bool.false$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_bool.false$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate bool_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate bool_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1573. Låt $n$ och $m$ vara naturliga tal. Anta att $0 < n$. Anta att $m$ är delbart med $n$. Låt $d$ vara ett naturligt tal. Då om $0 = m$, så om $n = m d$, så $n = m$.\nAssistant:", "label": "postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m", "predict": "postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (m d)) -> Eq n m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1062. Let $a, b, q, r, q1, r1 \\in N$. Let $_clearme$ be an element of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$. Assume that $r < b$ and $a = q b + r$. Let $_clearme0$ be an element of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$. Then if $r1 < b$ and $a = q1 b + r1$, then if $q$ is not less than or equal to $q1$, then $a = r1 + b q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus q b) r) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus q1 b) r1) -> (H : not (Leq q q1)) -> Eq a (plus r1 (times b q1))"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_64. Pour tous les entiers $n$, si $3 n - 5$ est impair, alors $n$ est pair.\nAssistant:", "label": "postulate noLabel_64 : (n : Int) -> if (odd (minus (times 3 n) 5)) (even n)", "predict": "postulate noLabel_64 : (n : Nat) -> (_ : odd (3 n - 5)) -> even n"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_Type4. Pour tous les ensembles $x1$, pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $Aop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1506$ de $Aop$ de $x1$ et de $x2$ à des éléments de $Type4$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_nill$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (x2, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (a, x2)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ et des éléments $_z1507$ de $Eq$ de $Hterm$ et de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ à des éléments de $P$ de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_x_times_x. För alla naturliga tal $x$, är $x$ mindre än eller lika med produkten av $x$ och $x$.\nAssistant:", "label": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)", "predict": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n \\in N$. Assume that $5 < n$. Let $m \\in N$. Assume that $6 \\leq m$. Assume that $(m + 1)^ 2 \\leq 2 ^ m$. Let $a$ be a natural number. Then if $6 \\leq a$, then if $2 (a + 1)+ 1 \\leq 2 ^ a$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : N) -> (posn : Lt 5 n) -> (m : N) -> (posm : Leq 6 m) -> (Hind : Leq (m + 1) (pow 2 m)) -> (a : Nat) -> (Hind1 : Leq 6 a) -> (Hind2 : Leq (times 2 (plus a 1)) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_sigma. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $__$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $__1$ une fonction des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Alors $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ est inférieur ou ágal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$.\nAssistant:", "label": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_O_to_eq. Pour tous les nombres naturels $n$, si $n$ est inférieur ou ágal à $0$, alors $0$ est égal à $n$.\nAssistant:", "label": "postulate le_n_O_to_eq : (n : Nat) -> (_ : Leq n 0) -> Eq 0 n", "predict": "postulate le_n_O_to_eq : (n : Nat) -> (_ : Leq n 0) -> Eq 0 n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_lop. Låt $n \\in N$. Anta att $1 \\leq n$. Då $list_of_primes (n)= cons (Nat, 2, tail (Nat, list_of_primes (n)))$.\nAssistant:", "label": "postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))", "predict": "postulate eq_lop : (n : Nat) -> (_ : Lt 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Låt $b \\in N$. Anta att $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$. Anta att $b$ är mindre än eller lika med $n$. Då om $f$ applicerat på $b$ är lika med $j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (a : Nat) -> (__2 : and (Leq a n) (Eq (f a) i)) -> (__3 : Leq a n) -> (__4 : Eq (f a) i) -> (b : Nat) -> (__5 : and (Leq b n) (Eq (f b) j)) -> (__6 : Leq b n) -> (__7 : Eq (f b) j) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_times_gcd_aux. Let $p, m, n, d, c \\in N$. Assume that $0 < c$. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq p$. Assume that $d$ is divisible by $c \\times m$. Then if $d$ is divisible by $c \\times n$, then $d$ is divisible by $c \\times gcd_aux (p, m, n)$.\nAssistant:", "label": "postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (times c m)) -> (__5 : divisible d (times c n)) -> divisible d (times c (gcd_aux p m n))", "predict": "postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (c * m)) -> (__5 : divisible d (c * n)) -> divisible d (c * gcd_aux p m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTheta_pred. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nAssistant:", "label": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Then for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the difference of the product of $m$ and $b$ and the product of $p$ and $a$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$. Then if $a \\leq n$, then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (Eq (f a) i)) -> (__1 : Leq a n) -> (__2 : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (Eq (f b) j)) -> (__3 : Leq b n) -> (__4 : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_inv_ind. Låt $x1$ och $x2$ vara naturliga tal. Låt $x3$ vara en funktion från naturliga tal till sanningsvärden. Låt $x4 \\in N$. Då för alla element $_Hterm$ av $min_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från naturliga tal $_z1890$ till påståenden, för alla funktioner $_H1$ från naturliga tal $m$ och element $_x_1080$ av $Leq$ av $x2$ och $m$ och element $_x_1079$ av $Lt$ av $m$ och summan av $x1$ och $x2$ och element $_x_1078$ av $Eq$ av $x3$ applicerat på $m$ och $true$ och funktioner $_x_1077$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och $m$ till element av $P$ av $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $x1$ och $x2$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och summan av $x1$ och $x2$ till element av $P$ av summan av $x1$ och $x2$, håller $P$ för $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Prop) -> (x4 : N) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_sqrt_to_lt_times_r. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $n$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_r : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt m) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.times n n))", "predict": "postulate lt_sqrt_to_lt_times_r : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt m) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.times n n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $return_sort$ vara ett element av $Sort$. Låt $return_type$ vara en funktion från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$. Låt $case_lstar_O$ vara en funktion från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $case_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $__1$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, __, l, b2, __1)$. Låt $__$ vara ett naturligt tal. Då för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (l + 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Let $f1$ and $f2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$", "label": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term un", "predict": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> matita_basics_logic.And (matita_basics_logic.And (cic.prod cic.prop univs.Type0 matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ i0 : cic.Term univs.Type0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_O_elim. Soit $n$ un nombre naturel. Alors si $n \\leq 0$, alors pour toutes les fonctions $P$ des nombres naturels $__1$ à des propositions, pour tous les éléments $__1$ de $P$ de $0$, $P$ tient pour $n$.\nAssistant:", "label": "postulate le_n_O_elim : (n : Nat) -> (_ : Leq n 0) -> (P : (__1 : Nat) -> Prop) -> (__1 : P 0) -> P n", "predict": "postulate le_n_O_elim : (n : Nat) -> (_ : Leq n 0) -> (P : (__1 : Nat) -> Prop) -> (__1 : P 0) -> P n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp5. För alla naturliga tal $_n$ och $_m$ och $_q$ och $_r$, för alla funktioner $Q_$ från element $_x_841$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden, för alla funktioner $_H_div_mod_spec_intro$ från element $x_843$ av $Lt$ av $_r$ och $_m$ och element $x_842$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n, _m, _q, _r, x_843, x_842)$, för alla element $x_841$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_841$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841", "predict": "postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_minus_O. For all natural numbers $n$ and $m$, if $n \\leq m$, then $n - m = 0$.\nAssistant:", "label": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0", "predict": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (n - m) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_max_n. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$ och $n$.\nAssistant:", "label": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)", "predict": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nProp110. Let $a, c \\in Z$. Assume that both $a$ and $c$ are odd. Then $a b + b c$ is even for every integer $b$.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : (a : Z) -> (c : Z) -> (_ : and (odd a) (odd c)) -> all Int (\\ b -> even (plus a b) (plus b c)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_times_SO_to_gcd_SO. Låt $m$ och $n$ och $p$ vara naturliga tal. Anta att $0 < n$ och $0 < p$. Då om $1$ är lika med det största gemensama delaret av $m$ och produkten av $n$ och $p$, så är $1$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1", "predict": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (_ : Lt 0 p) -> (__1 : Eq 1 (gcd m (times n p))) -> Eq 1 (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_rect_Type1. Let $x1$ be a set. Then for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $Aop$ of $x1$ and $x2$ to elements of $Type1$, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $c$.\nAssistant:", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_n_Sn. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$.\nAssistant:", "label": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))", "predict": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_aux_to_not_mod_O. Soit $p, n, m, q, r \\in N$. Supposons que $1 < m$. Supposons que $0 < n$. Alors si $n \\leq p$, alors si $p_ord_aux (p, n, m)= mk_Prod (Nat, Nat, q, r)$, alors $mod (r, m)$ n'est pas égal à $0$.\nAssistant:", "label": "postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)", "predict": "postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind_body. Let $_n, _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075 \\in N$. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind_body : (_n : N) -> (_b : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following English statement into Agda.\nConfluent1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$.\nAssistant:", "label": "postulate confluent1 : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.predicate A)", "predict": "postulate confluent1 : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.predicate A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_l. Let $B$ be a set. Let $R$ be a function from elements of $B$ and elements $__1$ of $B$ to propositions. Let $b2$ be an element of $B$. Let $P$ be an element of $relation2$ of $Nat$ and $B$. Let $__$ be an element of $P$ of $0$ and $b2$. Let $__1$ be a function from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b1$. Let $l \\in N$. Then for all elements $b1$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b1$.\nAssistant:", "label": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1", "predict": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_959$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_959$.\nAssistant:", "label": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959", "predict": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $b$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $n$ och $b$ och $f$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)", "predict": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type0_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_927$ av $range$ av $_A$ till mängder. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Då för alla element $x_927$ av $range$ av $_A$, håller $Q_$ för $x_927$.\nAssistant:", "label": "postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927", "predict": "postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type4_body. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Let $Q_$ be a function from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$. Let $_H_div_mod_spec_intro$ be a function from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$. Let $x_813$ be an element of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$. Then $Q_$ holds for $x_813$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813", "predict": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sqrt_to_lt_times_l. Låt $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $matita_arithmetics_sqrt.sqrt$ applicerat på $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $n$ och $m$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)", "predict": "postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnit_rect_Type2. Soit $Q_$ une fonction des éléments $_x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_it$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_503$.\nAssistant:", "label": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)", "predict": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$. Let $case_le_n$ be an element of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$. Let $case_le_S$ be a function from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)", "predict": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nS. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_forall_to_exists. Låt $P$ vara en funktion från naturliga tal till påståenden. Låt $n$ vara ett naturligt tal. Låt $__$ vara en funktion från naturliga tal $i$ till element av $decidable$ av $P$ applicerat på $i$. Då om det inte är fallet att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n$ och funktionen som avbildar $__1$ som $P$ applicerat på $i$, så håller $ex$ för $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och negationen av $P$ applicerat på $i$.\nAssistant:", "label": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))", "predict": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_div. Pour tous les nombres naturels $n$ et $m$ et $d$, si $0 < d$ et $d$ est divisible par $n$, alors si $d$ est divisible par $m$, alors $(n + m)\\div d = n \\div d + m \\div d$.\nAssistant:", "label": "postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) (plus (div n d) (div m d))", "predict": "postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) (plus (div n d) (div m d))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_CProp1_body. Låt $_A$ vara en mängd. Då för alla funktioner $Q_$ från element $_x_937$ av $range$ av $_A$ till påståenden, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$, för alla element $x_937$ av $range$ av $_A$, håller $Q_$ för $x_937$.\nAssistant:", "label": "postulate range_rect_CProp1_body : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937", "predict": "postulate range_rect_CProp1_body : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_Strue. Soit $k \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour toutes les fonctions $op$ des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $p (k)= true$, alors $op$ appliqué à $f$ appliqué à $k$ et $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à la somme de $k$ et de $1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)))", "predict": "postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (_ : nil B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop1. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $k$, för alla funktioner $__1$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $i$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $i$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2", "label": "postulate pad_bigop1 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate pad_bigop1 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop k n (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f __) (\\ __ : cic.Term univs.Type0 B -> nil) (\\ __ : cic.Term univs.Type0 B -> op __) (\\ __1 : cic.Term univs.Type0 B -> matita_arithmetics_nat.succ __1)) (matita_arithmetics_bigops.bigop k n (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f __) (\\ __ : cic.Term univs.Type0 B -> nil) (\\ __ : cic.Term univs.Type0 B -> op __) (\\ __1 : cic.Term univs.Type0 B -> matita_arithmetics_nat.succ __1)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_CProp4. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_957$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$", "label": "postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)", "predict": "postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_times. För alla naturliga tal $p$ och $m$ och $n$, om $0$ är mindre än $m$, så om $0$ är mindre än $n$, så om $p$ är primt, så är $ord$ applicerat på produkten av $m$ och $n$ och $p$ lika med summan av $ord$ applicerat på $m$ och $p$ och $ord$ applicerat på $n$ och $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSubR. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_R$ et $_S$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$, $cic.Univ$ tient pour $cic.prop$.\nAssistant:", "label": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_gcd_times_1. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $n$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Då är $1$ lika med det största gemensama delaret av $p$ och produkten av $n$ och $m$.\nAssistant:", "label": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1", "predict": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq 1 (gcd p n)) -> (__3 : Eq 1 (gcd p m)) -> Eq 1 (gcd p (times n m))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_sn. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l$ vara ett naturligt tal. Låt $b$ och $b2$ vara element av $B$. Låt $__$ vara ett element av $lstar_r$ av $B$ och $R$ och $l$ och $b$ och $b2$. Då för alla element $b1$ av $B$, för alla element $__1$ av $R$ av $b1$ och $b$, håller $lstar_r$ för $B$ och $R$ och $l + 1$ och $b1$ och $b2$.\nAssistant:", "label": "postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (l + 1) b1 b2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_47. Vi kan bevisa att summan av skillnaden mellan potensen av $n$ och $2$ och produkten av $3$ och $n$ och $9$ är udda för varje heltal $n$.\nAssistant:", "label": "postulate noLabel_47 : all Int (\\ n -> odd (plus (minus (pow n 2) (times 3 n)) 9))", "predict": "postulate noLabel_47 : (n : Nat) -> odd (plus (minus (pow n 2) (times 3 n)) 9)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$, for all functions $_H_div_mod_spec_intro$ from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$, for all elements $x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825", "predict": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"}
{"prompt": "Human: Translate the following French statement into Agda.\nLog_exp. Soient $p$ et $n$ et $m$ des nombres naturels. Alors si $1 < p$ et $0 < m$, alors $\\log_ p {p ^ n m}= n + (\\log_ p {m})$.\nAssistant:", "label": "postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (times (pow p n) m)) (plus n (log p m))", "predict": "postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (pow p n m)) (plus n (log p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_gcd_aux. Soient $p$ et $m$ et $n$ et $d$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $p$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, pour tous les éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $p$ et $m$ et $n$.\nAssistant:", "label": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))", "predict": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15624. Let $m, n, a, b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I_gen. Let $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita", "label": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_CProp5_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)", "predict": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin. Soient $__$ et $__1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $__2$ des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1))) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1544. Let $p$ and $q$ be natural numbers. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m, n \\in N$. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b \\in N$. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$. Then $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenq : Leq n q) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProp90. Låt $n$ vara ett naturligt tal. Då om $n$ är både jämnt och primt, så $n = 2$.\nAssistant:", "label": "postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)", "predict": "postulate prop90 : (n : Nat) -> (_ : and (even n) (prime n)) -> Eq n 2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1044$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type4$. Då för alla funktioner $_H1$ från element $_z1045$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_591$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1045$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_591$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_591$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_le. Låt $_n$ och $__$ vara naturliga tal. Låt $return_sort$ vara ett element av $Sort$. Då för alla funktioner $return_type$ från element $z$ av $Leq$ av $_n$ och $__$ till element av $return_sort$, för alla funktioner $return$ från element $z$ av $Leq$ av $_n$ och $__$ till element av $return_type$ av $z$, om $_n \\leq __$, så håller $return_type$ för $z$.\nAssistant:", "label": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z", "predict": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_divides_ord_rem. Låt $p, n, m \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $p$ är primt. Då om $n$ är delbart med $m$, så är $ord_rem (n, p)$ delbart med $ord_rem (m, p)$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Then if $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq d m))) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1561. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (and (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) (Eq (gcd p m) (minus (times a p) (times b m)))) -> (H0 : Eq (gcd p m) (minus (times a p) (times b m))) -> (H1 : Eq 1 (minus (times a p) (times b m))) -> Eq (minus (times a p) (times b m)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nEx_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.\nAssistant:", "label": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)", "predict": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod. Pour tous les nombres naturels $n$ et $m$, $n = n \\div m m + mod (n, m)$.\nAssistant:", "label": "postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (plus (times (div n m) m) (mod n m))", "predict": "postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (div n m m) (mod n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_div_mod_spec. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $m$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)", "predict": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMod_S. För alla naturliga tal $n$ och $m$, om $0 < m$ och $mod (n, m)+ 1 < m$, så $mod (n + 1, m)= mod (n, m)+ 1$.\nAssistant:", "label": "postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)", "predict": "postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (mod n m) + 1) m) -> Eq (mod (n + 1) m) (mod n m) + 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTo_min. För alla naturliga tal $i$ och $n$ och $m$, om $i \\leq n$, så om $i \\leq m$, så $i \\leq min (n, m)$.\nAssistant:", "label": "postulate to_min : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i n) -> (__1 : Leq i m) -> Leq i (min n m)", "predict": "postulate to_min : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i n) -> (__1 : Leq i m) -> Leq i (min n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_1_to_lt_n. Let $i$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $i$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)", "predict": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAssoc. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.\nAssistant:", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1$ un nombre naturel. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p2 (n1)= true$ et $p1 (n1)= true$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2n1 : Eq (p2 n1) true) -> (p1n1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_mod_to_divides. Let $p, m, n \\in N$. Assume that $0$ is less than $n$. Assume that $p$ is divisible by $mod$ applied to $m$ and $n$. Then if $p$ is divisible by $n$, then $p$ is divisible by $m$.\nAssistant:", "label": "postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m", "predict": "postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLog_div. Let $p, n, m \\in N$. Then if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.\nAssistant:", "label": "postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))", "predict": "postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_Type0. Soit $x1$ un ensemble. Soit $x2$ un élément de $x1$. Alors pour tous les éléments $Hterm$ de $ACop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1596$ de $ACop$ de $x1$ et de $x2$ à des ensembles, pour toutes les fonctions $_H1$ des éléments $aop$ de $Aop$ de $x1$ et de $x2$ et des fonctions $_comm$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ à des éléments de $Eq$ de $op (x1, x2, aop, a, b)$ et de $op (x1, x2, aop, b, a)$ et des éléments $_z1597$ de $Eq$ de $Hterm$ et de $mk_ACop (x1, x2, aop, _comm)$ à des éléments de $P$ de $mk_ACop (x1, x2, aop, _comm)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nAssistant:", "label": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)", "predict": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_div_S_S_div. Soient $n$ et $m$ des nombres naturels. Alors si $0 < m$, alors $(n + 1)\\div m \\leq n \\div m + 1$.\nAssistant:", "label": "postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (plus (div n m) 1)", "predict": "postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (plus (div n m) 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nSmallest_factor_to_min. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is equal to $min$ applied to $n$ and $2$ and the function that maps $m$ to $eqb$ applied to $mod$ applied to $n$ and $m$ and $0$.\nAssistant:", "label": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))", "predict": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_times. Let $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$. Then for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to", "label": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_ar", "predict": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_arithmetics_ord.p_ord b p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nOrd_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.\nAssistant:", "label": "postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))", "predict": "postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n \\in N$. Supposons que $5 < n$. Soit $m \\in N$. Alors si $6 \\leq m$ et $(m + 1)^ 2 \\leq 2 ^ m$, alors pour tous les nombres naturels $a$, si $6 \\leq a$ et $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (Hind : and (Leq 6 m) (Leq (pow m 2) (pow 2 m))) -> (a : Nat) -> (Hinda : and (Leq 6 a) (Leq (plus (times 2 a) 1) (pow 2 a))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus x2516 (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Låt $injf$ vara ett element av $injn$ av $f$ och $n$. Anta att $a = b$. Då $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (f a) i) (Leq a n)) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (f b) j) (Leq b n)) -> (fb : Eq (f b) j) -> (_ : (_ : Nat) -> (_ : Leq _ n) -> Leq (f _) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_O_log. Pour tous les éléments $p$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $p$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_log.log$ appliqué à $p$ et $n$.\nAssistant:", "label": "postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))", "predict": "postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime and $0 < m$, then if $n$ is divisible by $m$, then $ord_rem (m, n)< m$.\nAssistant:", "label": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m", "predict": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de $l + 1$ et de $b1$. Soit $l$ un nombre naturel. Soit $b1$ un élément de $B$. Soit $__2$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b2$. Alors $P$ tient pour $l$ et $b1$.\nAssistant:", "label": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1", "predict": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (l + 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10336. Let $n$ and $m$ be natural numbers. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi (p)$ and $pred (p)\\times (2 ^ (2 p - 3))$. Let $a \\in N$. Assume that $m = 2 a$ or $m = 2 a + 1$ and $m = 2 a + 1$. Assume that $1 < 2 a + 1$ and $0 < a$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\times (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : Lt 1 (2 a + 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516)) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type4_body. Låt $Q_$ vara en funktion från naturliga tal $_x_369$ till element av $Type4$. Låt $_H_O$ vara ett element av $Q_$ av $0$. Låt $_H_S$ vara en funktion från naturliga tal $x_370$ och element $_x_372$ av $Q_$ av $x_370$ till element av $Q_$ av $x_370 + 1$. Låt $x_369 \\in N$. Då håller $Q_$ för $x_369$.\nAssistant:", "label": "postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369", "predict": "postulate nat_rect_Type4_body : (_Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (x_370 + 1)) -> (x_369 : Nat) -> Q_ x_369"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_minus_associative. Soient $x$ et $y$ et $z$ des nombres naturels. Supposons que $z \\leq y$. Supposons que $y \\leq x$. Alors $x - (y - z)= x - y + z$.\nAssistant:", "label": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)", "predict": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (x - (y - z)) (x - y + z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp5_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_959$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a, _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a, aop__o__op (A, _nil, sum, b, c))$ et de $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ à des éléments de $Q_$ de $mk_Dop (A, _nil, sum, prod, _null, _distr)$, pour tous les éléments $x_959$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_959$.\nAssistant:", "label": "postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959", "predict": "postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_ind. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_664$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_664$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_664$.\nAssistant:", "label": "postulate Sig_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)", "predict": "postulate Sig_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_787$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $mat", "label": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)", "predict": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_Type2. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_897$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Then for all functions $P$ from elements $_z1716$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_ar", "label": "postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.op x1 x2 sum b c)) (matita_arithmetics_bigops.op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_d_times_gcd. Låt $m$ och $n$ och $d$ och $c$ vara naturliga tal. Anta att $0 < c$ och $d$ är delbart med $c \\times m$. Då om $d$ är delbart med $c \\times n$, så är $d$ delbart med produkten av $c$ och det största gemensama delaret av $n$ och $m$.\nAssistant:", "label": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))", "predict": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPad_bigop1. Let $k, n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be a function from elements of $B$ and elements $__1$ of $B$ to elements of $B$. Then for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_sum. Soient $k1$ et $k2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soient $p1$ et $p2$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $op$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$. Alors pour toutes les fonctions $f$ et $g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et $matita_arithmetics_bigops.bigop$ appliqué à $k1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $k2$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $k1$ et $", "label": "postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1", "predict": "postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 k2) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.andb (p1 i) (p2 i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRelation2. Låt $__$ och $__1$ vara element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Univ$ för $univs.Type0$.\nAssistant:", "label": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1560. Let $n, m \\in N$. Assume that $n$ is divisible by $m$. Assume that $0 = n$. Let $d \\in N$. Assume that $m = 0 d$. Then $n = 0$.\nAssistant:", "label": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0", "predict": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m 0 d) -> Eq n 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1704. Låt $m$ vara ett naturligt tal. Anta att $0$ är mindre än $m$. Låt $a, x1029 \\in N$. Då är $x1029$ lika med $aop__o__op$ applicerat på $Nat$ och $0$ och $plusAC$ och $x1029$ och $0$.\nAssistant:", "label": "postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)", "predict": "postulate let_clause_1704 : (m : Nat) -> (posn : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_957$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a, _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a, aop__o__op (A, _nil, sum, b, c))$ and $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ to elements of $Q_$ of $mk_Dop (A, _nil, sum, prod, _null, _distr)$, for all elements $x_957$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_957$.\nAssistant:", "label": "postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957", "predict": "postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_r_aux. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $b1$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $P$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.\nAssistant:", "label": "postulate lstar_ind_r_aux : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) -> cic.Term cic.prop (P l b2)", "predict": "postulate lstar_ind_r_aux : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) -> cic.Term cic.prop (P l b2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $c n - d m = 1$. Då för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (x1029 (minus (times c n) (times d m)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nSum_rect_CProp5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_inl$ be a function from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$. Let $_H_inr$ be a function from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$. Let $x_561$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.\nAssistant:", "label": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)", "predict": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1551. Pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $eqn0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x347$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $x347$ et $n$.\nAssistant:", "label": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))", "predict": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_CProp0. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_inl$ une fonction des éléments $x_582$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_582$. Soit $_H_inr$ une fonction des éléments $x_583$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_583$. Alors pour tous les éléments $x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_inv_plus_l. Soient $x$ et $y$ et $z$ des nombres naturels. Supposons que $x + y < z$. Alors $x < z$ et $y < z - x$.\nAssistant:", "label": "postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))", "predict": "postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_plus. Soient $n$ et $m$ et $p$ des nombres naturels. Alors la différence de la différence de $n$ et de $m$ et de $p$ est égale à la différence de $n$ et de la somme de $m$ et de $p$.\nAssistant:", "label": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))", "predict": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPrimes_below_to_bertrand. Let $pm \\in N$. Let $l$ be a list of natural numbers. Assume that $pm$ is prime. Then for all elements $__1$ of $primes_below$ of $l$ and $pm + 1$, for all functions $__2$ from natural numbers $p$ and elements $__2$ of $mem$ of $Nat$ and $p$ and $l$ and elements $__3$ of $Lt$ of $2$ and $p$ to elements of $ex$ of $Nat$ and the function that maps $pp$ to the conjunction of the conjunction of $mem$ applied to $Nat$ and $pp$ and $l$ and $Lt$ applied to $pp$ and $p$ and $Leq$ applied to $p$ and the product of $2$ and $pp$, for all natural numbers $n$, if $0 < n$ and $n < pm$, then $bertrand$ holds for $n$.\nAssistant:", "label": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n", "predict": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l pm + 1) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : and (Lt 0 n) (Lt n pm)) -> bertrand n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar_r. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Då för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$, för alla funktioner $case_lstar_r_O$ från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_r_O$ applicerat på $B$ och $_R$ och $b$, för alla funktioner $case_lstar_r_S$ från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $__1$ av $_R$ av $b$ och $b2$ till element av $return_type$ av summan av $l$ och $1$ och $b1$ och $b2$ och $lstar_r_S$ applicerat på $B$ och $_R$ och $l$ och $b1$ och $b$ och $__$ och $b2$ och $__1$, för alla naturliga tal $__$, för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_inv_rect_Type3. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $x1$. Låt $Hterm$ vara ett element av $Dop$ av $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1710$ av $Dop$ av $x1$ och $x2$ till element av $Type3$. Då för alla funktioner $_H1$ från element $sum$ av $ACop$ av $x1$ och $x2$ och funktioner $prod$ från element av $x1$ och element $__1$ av $x1$ till element av $x1$ och funktioner $_null$ från element $a$ av $x1$ till element av $Eq$ av $prod (a, x2)$ och $x2$ och funktioner $_distr$ från element $a$ av $x1$ och element $b$ av $x1$ och element $c$ av $x1$ till element av $Eq$ av $prod (a, aop__o__op (x1, x2, sum, b, c))$ och $aop__o__op (x1, x2, sum, prod (a, b), prod (a, c))$ och element $_z1711$ av $Eq$ av $Hterm$ och $mk_Dop (x1, x2, sum, prod, _null, _distr)$ till element av $P$ av $mk_Dop (x1, x2, sum, prod, _null, _distr)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate Dop_inv_rect_Type3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm", "predict": "postulate Dop_inv_rect_Type3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_pi_p_M. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.\nAssistant:", "label": "postulate divides_pi_p_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))", "predict": "postulate divides_pi_p_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (_clearme : and (Leq i n) (Leq j n)) -> (a : Nat) -> (_clearme0 : and (Leq a n) (and (f a) i) (Leq a n)) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme1 : and (Leq b n) (and (f b) j) (Leq b n)) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_exp. Låt $n, m, i \\in N$. Anta att $0$ är mindre än $m$. Anta att $mod$ applicerat på $n$ och $m$ inte är lika med $0$. Låt $p \\in N$. Då om $i$ är mindre än eller lika med $p$, så är $p_ord_aux$ applicerat på $p$ och produkten av potensen av $m$ och $i$ och $n$ och $m$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $i$ och $n$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $_p, _n \\in N$. Then the logarithm of $_p$ and $_n$ is a natural number.\nAssistant:", "label": "postulate log : (_p : Nat) -> (_n : Nat) -> Nat", "predict": "postulate log : (_p : Nat) -> (_n : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_1$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_1$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_refl$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Låt $x_1$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $x_2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_1$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_1$ och $x_2$.\nAssistant:", "label": "postulate eq_ind_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)", "predict": "postulate eq_ind_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type2_body. Let $_n, _m, _q, _r \\in N$. Let $Q_$ be a function from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$. Let $_H_div_mod_spec_intro$ be a function from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$. Let $x_825$ be an element of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$. Then $Q_$ holds for $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825", "predict": "postulate div_mod_spec_rect_Type2_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_log. Soit $p, n \\in N$. Supposons que $0 < n$. Alors $p ^ (\\log_ p {n})\\leq n$.\nAssistant:", "label": "postulate le_exp_log : (p : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> Leq (pow p (log p n)) n", "predict": "postulate le_exp_log : (p : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> Leq (pow p (log p n)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTrue_rect_CProp4. Låt $Q_$ vara en funktion från element $_x_54$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_I$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.I$. Låt $x_54$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_54$.\nAssistant:", "label": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)", "predict": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_O. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b$ of $B$, $lstar_r$ holds for $B$ and $R$ and $0$ and $b$ and $b$.\nAssistant:", "label": "postulate lstar_r_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar_r B R 0 b b", "predict": "postulate lstar_r_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar_r B R 0 b b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFmax_false. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m \\in N$. Då om $max (n, f)= m$, så om kontradiktion är lika med $f (m)$, så $m = 0$.\nAssistant:", "label": "postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0", "predict": "postulate fmax_false : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq false (f m)) -> Eq m 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1607. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Alors si $c n - d m = 1$ ou $d m - c n = 1$, alors si $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Then if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMatch_div_mod_spec. Soit $_n, _m, _q, _r \\in N$. Soit $return_sort$ un élément de $Sort$. Soit $return_type$ une fonction des éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des éléments de $return_sort$. Soit $case_div_mod_spec_intro$ une fonction des éléments de $Lt$ de $_r$ et de $_m$ et des éléments $__1$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $return_type$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $__$ et $__1$. Alors pour tous les éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $return_type$ tient pour $z$.\nAssistant:", "label": "postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z", "predict": "postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter. Let $T$ be an element of $cic.Univ$ of $univs.Type0$. Let $_p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.\nAssistant:", "label": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)", "predict": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)"}
{"prompt": "Human: Translate the following French statement into Agda.\nChecker_abl. Soient $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.checker$ appliqué à $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $a$ et $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $b$ et $l$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.lt$ appliqué à $a$ et $b$ et $matita_arithmetics_nat.le$ appliqué à $b$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.checker$ appliqué à $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $b$ et $l$ et $matita_basics_bool.true$.\nAssistant:", "label": "postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))", "predict": "postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1561. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $p$ is divisible by the product of $m$ and $n$, then for all natural numbers $c$, if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nPad_bigop_nil. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $n \\leq k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq (f (i), nil)$, $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_rect_Type0. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $Aop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1530$ of $Aop$ of $x1$ and $x2$ to sets. Let $_H1$ be a function from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2, a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a, x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ and elements $_z1531$ of $Eq$ of $Hterm$ and $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ to elements of $P$ of $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_to_lt_to_lt. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)", "predict": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_a. Pour tous les éléments $a$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $op$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $a$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.S$ appliqué à $b$ et $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $matita_basics_bool.true$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et $matita_arithmetics_bigops.bigop$", "label": "postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_nat.S i0)) (matita_arithmetics_nat.plus i a))) (f a)))", "predict": "postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop (matita"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp4_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$. Let $x_903$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_903$.\nAssistant:", "label": "postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903", "predict": "postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903"}
{"prompt": "Human: Translate the following French statement into Agda.\nAllr_fwd_append_sn. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Soient $l1$ et $l2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Allr$ appliqué à $A$ et $R$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Allr$ appliqué à $A$ et $R$ et $l1$.\nAssistant:", "label": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)", "predict": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_ind_body. Soit $_n, _m, _q, _r \\in N$. Soit $Q_$ une fonction des éléments $_x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Alors pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_811$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_810$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_811$ et $x_810$, pour tous les éléments $x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_809$.\nAssistant:", "label": "postulate div_mod_spec_ind_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809", "predict": "postulate div_mod_spec_ind_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16005. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (c n - d m) 1) (Eq (d m - c n) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (c n - d m) 1) (Eq (d m - c n) 1)) -> (H0 : Eq (d m - c n) 1) -> Eq (m d - n c) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nAssistant:", "label": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Then for all elements $x_875$ of $c", "label": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)", "predict": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nChecker_spec. Låt $tl$ vara en lista av naturliga tal. Låt $a \\in N$. Då för alla listor $l$ av naturliga tal, om $checker (l)= true$, så om $l = cons (Nat, a, tl)$, så för alla naturliga tal $p$, för alla element $__2$ av $mem$ av $Nat$ och $p$ och $tl$, håller $ex$ för $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$.\nAssistant:", "label": "postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))", "predict": "postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_exp. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $n$ och $m$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$.\nAssistant:", "label": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))", "predict": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_Type0. Let $_A$ be a set. Let $Q_$ be a function from elements $_x_927$ of $range$ of $_A$ to sets. Let $_H_mk_range$ be a function from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Then for all elements $x_927$ of $range$ of $_A$, $Q_$ holds for $x_927$.\nAssistant:", "label": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927", "predict": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_rect_Type3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_670$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H_mk_Sig$ vara en funktion från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$. Låt $x_670$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$. Då håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_670$.\nAssistant:", "label": "postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)", "predict": "postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProp110. För alla heltal $a$ och $c$, om $a$ är udda och $c$ är udda, så för alla heltal $b$, är $a b + b c$ jämnt.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : (a : Nat) -> (c : Nat) -> (_ : odd a) -> (_ : odd c) -> (b : Nat) -> Eq (a b + b c) (plus (times a b) (times b c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type0. Låt $Q_$ vara en funktion från naturliga tal $_x_389$ till mängder. Låt $_H_O$ vara ett element av $Q_$ av $0$. Då för alla funktioner $_H_S$ från naturliga tal $x_390$ och element $_x_392$ av $Q_$ av $x_390$ till element av $Q_$ av $x_390 + 1$, för alla naturliga tal $x_389$, håller $Q_$ för $x_389$.\nAssistant:", "label": "postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> Set) -> (_H_O : Q_ 0) -> (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (plus x_390 1)) -> (x_389 : Nat) -> Q_ x_389", "predict": "postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> Set) -> (_H_O : Q_ 0) -> (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (x_390 + 1)) -> (x_389 : Nat) -> Q_ x_389"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Supposons que $p2$ appliqué à $n1$ est égal à $true$. Alors si $p1$ appliqué à $n1$ est égal à $true$, alors pour tous les nombres naturels $x2515", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> (_ : Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> (_ : Eq (p2 i) true) -> Hind i (_ : Lt i (plus n1 1)) (__1 : Eq (p1 i) true) (Eq (p2 i) true) (\\ i : Nat -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i))) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> (_ : Leq (g1 i) (g2 i)) -> Hind i (_ : Lt i (plus n1 1)) (__1 : Eq (p1 i) true) (Leq (g1 i) (g2 i)) (\\ i : Nat -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_inv_ind. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$. Alors pour toutes les fonctions $P$ des éléments $_z1038$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1039$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_587$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1039$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_587$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_587$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate option_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1038 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_587 : cic.Term univs.Type0 x1) -> (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate option_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1038 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_587 : cic.Term univs.Type0 x1) -> (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_ind. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_781$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appl", "label": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)", "predict": "iquépostulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.Aop A _nil))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_minus_O. Let $n$ and $m$ be natural numbers. Assume that $n \\leq m$. Then $n - m = 0$.\nAssistant:", "label": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0", "predict": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (n - m) 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_CProp2. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_626$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_None$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_627$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_627$. Soit $x_626$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_626$.\nAssistant:", "label": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)", "predict": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type0. Let $Hterm$ be a natural number. Let $P$ be a function from natural numbers $_z683$ to sets. Let $_H1$ be a function from elements $_z684$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_390$ and functions $_x_392$ from elements $_z684$ of $Eq$ of $Hterm$ and $x_390$ to elements of $P$ of $x_390$ and elements $_z684$ of $Eq$ of $Hterm$ and the sum of $x_390$ and $1$ to elements of $P$ of the sum of $x_390$ and $1$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp4_body. För alla element $_A$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_nmk$ från funktioner $x_101$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_101$, för alla element $x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_100$.\nAssistant:", "label": "postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)", "predict": "postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_S. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Then for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nAssistant:", "label": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (l + 1) b1 b2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_ind. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z653$ till påståenden. Låt $_H1$ vara en funktion från element $_z654$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$. Då för alla funktioner $_H2$ från naturliga tal $x_366$ och funktioner $_x_368$ från element $_z654$ av $Eq$ av $Hterm$ och $x_366$ till element av $P$ av $x_366$ och element $_z654$ av $Eq$ av $Hterm$ och $x_366 + 1$ till element av $P$ av $x_366 + 1$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_ind : (Hterm : Nat) -> (P : (_z653 : Nat) -> Prop) -> (_H1 : (_z654 : Eq Hterm 0) -> P 0) -> (_H2 : (x_366 : Nat) -> (_x_368 : (_z654 : Eq Hterm x_366) -> P x_366) -> (_z654 : Eq Hterm (plus x_366 1)) -> P (plus x_366 1)) -> P Hterm", "predict": "postulate nat_inv_ind : (Hterm : Nat) -> (P : (_z653 : Nat) -> Prop) -> (_H1 : (_z654 : Eq Hterm 0) -> P 0) -> (_H2 : (x_366 : Nat) -> (_x_368 : (_z654 : Eq Hterm x_366) -> P x_366) -> (_z654 : Eq Hterm x_366 + 1) -> P (x_366 + 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_min_true. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Låt $__$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av konjunktionen av $Leq$ applicerat på $b$ och $i$ och $Lt$ applicerat på $i$ och summan av $n$ och $b$ och $Eq$ applicerat på $f$ applicerat på $i$ och $true$. Då $f (min (n, b, f))= true$.\nAssistant:", "label": "postulate f_min_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Eq (f (min n b f)) true", "predict": "postulate f_min_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Eq (f (min (n, b, f))) true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nUnit_rect_Type1. Låt $Q_$ vara en funktion från element $_x_505$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type1$. Då för alla element $_H_it$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_505$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_505$.\nAssistant:", "label": "postulate unit_rect_Type1 : (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) -> (x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type1 (Q_ x_505)", "predict": "postulate unit_rect_Type1 : (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) -> (x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type1 (Q_ x_505)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_exp1. Låt $p, n, q, r \\in N$. Anta att $0 < p$ och $p$ inte är delbart med $r$. Då om $n = p ^ q r$, så $p_ord (n, p)= mk_Prod (Nat, Nat, q, r)$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)", "predict": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times p q r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sqrt_n1. Let $n$ be a natural number. Then the difference of $n$ and the product of $2$ and the square root of $n$ is less than or equal to the exponentiation of the square root of $n$ and $2$.\nAssistant:", "label": "postulate le_sqrt_n1 : (n : Nat) -> Leq (minus n (times 2 (sqrt n))) (pow (sqrt n) 2)", "predict": "postulate le_sqrt_n1 : (n : Nat) -> Leq (minus n (times 2 (sqrt n))) (pow (sqrt n) 2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nF3_ind_aux. Soient $A1$ et $A2$ et $A3$ des ensembles. Soit $f$ une fonction des éléments de $A1$ et des éléments $__1$ de $A2$ et des éléments $__2$ de $A3$ à des nombres naturels. Soit $P$ un élément de $relation3$ de $A1$ et de $A2$ et de $A3$. Soit $__$ une fonction des nombres naturels $n$ et des fonctions des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments de $Lt$ de $f (a1, a2, a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$ et des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments $__1$ de $Eq$ de $f (a1, a2, a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$. Soit $n \\in N$. Soit $a1$ un élément de $A1$. Soit $a2$ un élément de $A2$. Soit $a3$ un élément de $A3$. Alors si $f (a1, a2, a3)= n$, alors $P$ tient pour $a1$ et $a2$ et $a3$.\nAssistant:", "label": "postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3", "predict": "postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc", "label": "postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)", "predict": "postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_True. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$. Alors pour toutes les fonctions $P$ des éléments $_z1740$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$", "label": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.op x1 x2 sum b c)) (matita_arithmetics_bigops.op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_lstar. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ och $__2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_ind. Let $_n, _m, _q, _r \\in N$. Let $Q_$ be a function from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions. Let $_H_div_mod_spec_intro$ be a function from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and $_q _m + _r$ to elements of $Q_$ of $div_mod_spec_intro (_n, _m, _q, _r, x_811, x_810)$. Then for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.\nAssistant:", "label": "postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809", "predict": "postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (_q _m + _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$. Soit $gcd1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $nm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $c$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appl", "label": "postulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p", "predict": "iquépostulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.ex matita_arithmetics_nat.nat (\\ y : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5$ är mindre än $n$. Låt $m \\in N$. Anta att $6$ är mindre än eller lika med $m$. Anta att potensen av summan av $m$ och $1$ och $2$ är mindre än eller lika med potensen av $2$ och $m$. Låt $a \\in N$. Då om $6$ är mindre än eller lika med $a$, så om summan av produkten av $2$ och summan av $a$ och $1$ och $1$ är mindre än eller lika med potensen av $2$ och $a$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nChecker. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nAssistant:", "label": "postulate checker : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate checker : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Aop. För alla mängder $A$, för alla element $_nil$ av $A$, för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från element $z$ av $Aop$ av $A$ och $_nil$ till element av $return_sort$, för alla funktioner $case_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $return_type$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, för alla element $z$ av $Aop$ av $A$ och $_nil$, håller $return_type$ för $z$.\nAssistant:", "label": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z", "predict": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_dividesb_true. Soient $n$ et $m$ des nombres naturels. Alors si $0 < n$, alors si $n$ est divisible par $m$, alors $dividesb (n, m)= true$.\nAssistant:", "label": "postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (dividesb n m) true", "predict": "postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (dividesb (n, m)) true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLd_to_prime. Låt $i$ vara ett naturligt tal. Då för alla listor $acc$ av naturliga tal, om $1$ är mindre än $i$, så för alla element $__1$ av $primes_below$ av $acc$ och $i$, om $list_divides$ applicerat på $acc$ och $i$ är lika med kontradiktion, så är $i$ primt.\nAssistant:", "label": "postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i", "predict": "postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp5_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $Aop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Då för alla element $x_877$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_877$.\nAssistant:", "label": "postulate Aop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877", "predict": "postulate Aop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_ind_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_889$ av $ACop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_889$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_889$.\nAssistant:", "label": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889", "predict": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Då för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$, så om $a p - b m = 1$, så $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (H : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus a p)) (Eq (gcd p m) (minus p a))) -> (H0 : Eq (gcd p m) (minus a p)) -> (H1 : Eq (minus a p) 1) -> Eq (minus p a) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Då för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (eqab : Eq a b) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1034. Let $n, m, p \\in N$. Assume that $0$ is less than $p$. Let $x2515, x2516 \\in N$. Then $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))", "predict": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Då för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nR3. Let $T0$ be an element of $cic.Univ$ of $univs.Type0$. Let $a0$ be an element of $cic.Term$ of $univs.Type0$ and $T0$. Let $T1$ be a function from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$. Let $a1$ be an element of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$. Let $T2$ be a function from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Let $a2$ be an element of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2", "label": "postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type", "predict": "postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) a1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T0 -> cic.Univ univs.Type0)) a0 (matita_basics_logic.R2 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) (T"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc_plus1. För alla naturliga tal $a$ och $b$ och $c$, är summan av $c$ och summan av $b$ och $a$ lika med summan av summan av $b$ och $c$ och $a$.\nAssistant:", "label": "postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)", "predict": "postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_pi. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Alors pour toutes les fonctions $__$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $p$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$, $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ est inférieur ou ágal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l_aux. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $b2$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $P$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $matita_arithmetics_nat.nat$ et $B$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$ et $b2$. Soit $__1$ une fonction des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b$ et $b2$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $l$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soient $b1$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b$. Alors pour tous les éléments $__3$ de $", "label": "postulate lstar_ind_l_aux : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) -> cic.Term cic.prop (P l b1)", "predict": "postulate lstar_ind_l_aux : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> cic.Term cic.prop (P l b)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_times_n_to_lt_r. Let $n$ and $p$ and $q$ be natural numbers. Assume that the product of $n$ and $p$ is less than the product of $n$ and $q$. Then $p$ is less than $q$.\nAssistant:", "label": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q", "predict": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16001. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (divnm n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (divnm m n) (minus (times n c) (times m d))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $Q_$ une fonction des nombres naturels $x_1233$ et des éléments $x_1232$ de $B$ et des éléments $x_1231$ de $B$ et des éléments $_x_1234$ de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$ à des propositions. Soit $_H_lstar_O$ une fonction des éléments $b$ de $B$ à des éléments de $Q_$ de $0$ et de $b$ et de $b$ et de $lstar_O (B, _R, b)$. Soit $_H_lstar_S$ une fonction des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $x_1236$ de $_R$ de $b1$ et de $b$ et des nombres naturels $l$ et des éléments $b2$ de $B$ et des éléments $x_1235$ de $lstar$ de $B$ et de $_R$ et de $l$ et de $b$ et de $b2$ et des éléments $_x_1238$ de $Q_$ de $l$ et de $b$ et de $b2$ et de $x_1235$ à des éléments de $Q_$ de $l + 1$ et de $b1$ et de $b2$ et de $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Soit $x_1233$ un nombre naturel. Soient $x_1232$ et $x_1231$ des éléments de $B$. Soit $x_1234$ un élément de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$. Alors $Q_$ tient pour $x_1233$ et $x_1232$ et $x_1231$ et $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1034. Låt $n$ och $m$ och $p$ vara naturliga tal. Anta att $0 < p$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = mod (x2515, x2516)+ x2516 (x2515 \\div x2516)$.\nAssistant:", "label": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))", "predict": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (mod x2515 x2516) + x2516 (x2515 \\ x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_CProp0. Let $Hterm \\in N$. Let $P$ be a function from natural numbers $_z713$ to propositions. Let $_H1$ be a function from elements $_z714$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_414$ and functions $_x_416$ from elements $_z714$ of $Eq$ of $Hterm$ and $x_414$ to elements of $P$ of $x_414$ and elements $_z714$ of $Eq$ of $Hterm$ and the sum of $x_414$ and $1$ to elements of $P$ of the sum of $x_414$ and $1$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : N) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1692. Låt $m$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Då för alla element $a$ och $x358$ och $x359$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_sigma_pi.plusAC$ och $x358$ och $matita_arithmetics_nat.times$ applicerat på $x358$ och $x359$ och $matita_arithmetics_nat.times$ applicerat på $x358$ och $matita_arithmetics_nat.S$ applicerat på $x359$.\nAssistant:", "label": "postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))", "predict": "postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_fact_to_le. För alla naturliga tal $p$ och $n$, om $p$ är primt, så om $p$ är delbart med $n!$, så $p \\leq n$.\nAssistant:", "label": "postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n", "predict": "postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_exp_prim4l. Låt $n$ vara ett naturligt tal. Anta att $0 < n$. Då $2 ^ (4 n + 1)\\leq 4 n ^ (prim (4 n)+ 1)$.\nAssistant:", "label": "postulate le_exp_prim4l : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (plus (times 4 n) 1)) (pow (times 4 n) (plus (prim (times 4 n)) 1))", "predict": "postulate le_exp_prim4l : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (4 n + 1)) (pow n (prim (4 n) + 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_log_n_n. Let $p$ and $n$ be natural numbers. Assume that $1 < p$. Assume that $0 < n$. Then $\\log_ p {n}< n$.\nAssistant:", "label": "postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (log p n) n", "predict": "postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (\\ log_ p {n} : Nat) n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_ind_body. Soient $_n$ et $_m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Q_$ des éléments $_x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_quotient$ des éléments $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1193$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_m$ et $matita_arithmetics_nat.times$ appliqué à $_n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_primes.quotient$ appliqué à $_n$ et $_m$ et $q$ et $x_1193$, pour tous les éléments $x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1192$.\nAssistant:", "label": "postulate divides_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)", "predict": "postulate divides_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_discr. Let $a1, a2, a3, a4 \\in N$. Let $x$ and $y$ be elements of $div_mod_spec$ of $a1$ and $a2$ and $a3$ and $a4$. Then if $x$ is equal to $y$, then $match_div_mod_spec$ holds for $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ to $match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $Eq$ applied to $a1$ and the sum of the product of $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $", "label": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Lt a4 a2 -> \\ t1 : Eq a1 (plus (times a3 a2) a4) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Lt a4 a2 -> \\ u1 : Eq a1 (plus (times a3 a2) a4) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (\\ _e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P))) (\\ _z53 : ((e0 : Eq (R0 (Lt a4 a2) t0) u0) -> (_e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a", "predict": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Nat -> \\ t1 : Nat -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Nat -> \\ u1 : Nat -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> \\ _x_20 : Eq (Lt a4 a2) t0 -> (\\ x0 : Nat -> \\ p0 : Eq a1 (plus (times a3 a2) a4) -> Eq x0 u0) x_19 _x_20) t1) u0) (\\ e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> \\ _x_20 : Eq (Lt a4 a2) t0 -> (\\ x0 : Nat -> \\ p0 : Eq a1 (plus (times a3 a2) a4) -> Eq x0 u0) x_19 _x_20) t1) u0 -> P))) (\\ _z53 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> \\ _x_20 : Eq (Lt a4 a2) t0 -> (\\ x0 : Nat -> \\ p0 : Eq a1 (plus (times a3 a2) a4) -> Eq x0 u0) x_19 _x_20) t1) u"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_inv_rect_Type2. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1650$ de $range$ de $x1$ à des éléments de $Type2$. Alors pour toutes les fonctions $_H1$ des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1651$ de $Eq$ de $Hterm$ et de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $P$ de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPlus_minus. För alla element $m$ och $n$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $n$ och $p$ och $m$.\nAssistant:", "label": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))", "predict": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_dividesb_true1. Pour tous les nombres naturels $n$ et $m$, si $0$ est inférieur à $m$, alors si $n$ est divisible par $m$, alors $dividesb$ appliqué à $n$ et $m$ est égal à $true$.\nAssistant:", "label": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true", "predict": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$. Then for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16921. Let $m \\in N$. Assume that $0$ is less than $m$. Then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.\nAssistant:", "label": "postulate let_clause_16921 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))", "predict": "postulate let_clause_16921 : (m : N) -> (posn : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAll_below. Låt $_l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Då för alla element $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_CProp1_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_911$ av $ACop$ av $A$ och $_nil$ till påståenden. Då för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_911$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_911$.\nAssistant:", "label": "postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911", "predict": "postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Then if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_S_mod. Pour tous les nombres naturels $n$, $permut$ tient pour $S_mod$ appliqué à la somme de $n$ et de $1$ et $n$.\nAssistant:", "label": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n", "predict": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_priml1. Pour tous les nombres naturels $n$, si $0 < n$, alors $2 n \\div ((\\log_ 2 {n})+ 2)- 1 \\leq prim (2 n)$.\nAssistant:", "label": "postulate le_priml1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (minus (div (times 2 n) (plus (log 2 n) 2)) 1) (prim (times 2 n))", "predict": "postulate le_priml1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (div (times 2 n) (plus (log 2 n) 2)) (prim (times 2 n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nFmin_true. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n, m, b \\in N$. Supposons que $m$ est égal à $min$ appliqué à $n$ et $b$ et $f$. Supposons que $m$ est inférieur à la somme de $n$ et de $b$. Alors $f$ appliqué à $m$ est égal à $true$.\nAssistant:", "label": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true", "predict": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1562. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $c n - d m = 1$, alors $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (and (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times c n) (times d m)) 1))) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15321. Soient $n$ et $m$ des nombres naturels. Supposons que $0 < m$. Supposons que $0 = n$. Supposons que $0$ est divisible par $m$. Soit $q$ un nombre naturel. Supposons que $m = 0 q$. Alors $m = 0$.\nAssistant:", "label": "postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0", "predict": "postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp0_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Then for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_plus_r. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.monotonic$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.lt$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.plus$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))", "predict": "postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Alors pour tous les nombres naturels $n1$, pour toutes les fonctions $Hind$ des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$, pour toutes les fonctions $H1$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$, pour toutes les fonctions $H2$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$, si $p2 (n1)= true$ et $p1 (n1)= true$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : Nat) -> (_ : Lt Nat n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (n1 + 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hc : and (p2 n1) (p1 n1)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be a natural number. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n$ applied to $_n$. Let $case_le_S$ be a function from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$. Then for all natural numbers $__$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1545. Soient $m$ et $n$ des nombres naturels. Supposons que $0$ est égal au diviseur commun plus grand de $m$ et de $n$. Supposons que $0$ est divisible par $n$. Soit $q1 \\in N$. Supposons que $n = 0 q1$. Supposons que $0$ est divisible par $m$. Soit $q2 \\in N$. Supposons que $m = 0 q2$. Alors $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 (gcd m n)) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (eqn1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (eqn2 : Eq m (times 0 q2)) -> Eq m 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p, m, n \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Då om det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (gcd1m : Eq 1 (gcd p m)) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (pc)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (minus (times a p) (times b m))) (Eq (gcd p m) (minus (times b m) (times a p)))) -> (H : Eq (gcd p m) (minus (times b m) (times a p))) -> (H0 : Eq b m) -> Eq (minus (times m b) (times p a)) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_rect_CProp0. För alla funktioner $Q_$ från element $_x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$, för alla element $x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_78$.\nAssistant:", "label": "postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)", "predict": "postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1047. Låt $k, n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla mängder $B$, för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n \\leq k$, så för alla naturliga tal $j$, om $n \\leq j$, så för alla funktioner $Hind$ från funktioner från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j$ till element av $Eq$ av $p (i)$ och kontradiktion till element av $Eq$ av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $bigop$ applicerat på $j$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$, för alla funktioner $Hfalse$ från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j + 1$ till element av $Eq$ av $p (i)$ och kontradiktion, för alla naturliga tal $x2571$ och $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571, x2572)$.\nAssistant:", "label": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))", "predict": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (le_nk : Leq n k) -> (j : Nat) -> (le_nj : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (j + 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 x2572 (x2571 \\div x2572) + mod x2571 x2572"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSmallest_factor_to_prime. Låt $n$ vara ett naturligt tal. Anta att $1 < n$. Anta att $smallest_factor (n)= n$. Då är $n$ primt.\nAssistant:", "label": "postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n", "predict": "postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_to_exp1. Låt $p$ och $n$ och $q$ och $r$ vara naturliga tal. Anta att $1$ är mindre än $p$. Anta att $0$ är mindre än $n$. Anta att $p_ord$ applicerat på $n$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $q$ och $r$. Då är $p$ inte delbart med $r$ och $n$ är lika med produkten av potensen av $p$ och $q$ och $r$.\nAssistant:", "label": "postulate p_ord_to_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Eq (p_ord n p) (mk_Prod Nat Nat q r)) -> and (not (divisible p r)) (Eq n (times (pow p q) r))", "predict": "postulate p_ord_to_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Eq (p_ord n p) (mk_Prod Nat Nat q r)) -> and (not (divisible p r)) (Eq n (times (pow p q) r))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop. Let $__$ be a natural number. Then for all functions $__1$ from natural numbers $__1$ to booleans, for all sets $H$, for all elements $__2$ of $H$, for all functions $__3$ from elements $__3$ of $H$ and elements $__4$ of $H$ to elements of $H$, for all functions $__4$ from natural numbers $__4$ to elements of $H$, $H$.\nAssistant:", "label": "postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H", "predict": "postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_inv_rect_CProp1. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1026$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_577$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1027$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_577$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_577$. Alors pour toutes les fonctions $_H2$ des éléments $x_578$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1027$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_578$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_578$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate Sum_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1026 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_577 : cic.Term univs.Type0 x1) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_577))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_577))) -> (_H2 : (x_578 : cic.Term univs.Type0 x2) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1026 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_577 : cic.Term univs.Type0 x1) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_577))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_577))) -> (_H2 : (x_578 : cic.Term univs.Type0 x2) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_exp. Soit $n, m, i \\in N$. Supposons que $0 < m$ et $mod (n, m)$ n'est pas égal à $0$. Soit $p$ un nombre naturel. Alors si $i \\leq p$, alors $p_ord_aux (p, m ^ i n, m)= mk_Prod (Nat, Nat, i, n)$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux (p, m ^ i n, m)) (mk_Prod Nat Nat i n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_minus_l. Låt $p$ och $q$ och $n$ vara naturliga tal. Anta att $n$ är mindre än eller lika med $q$. Då om $q$ är mindre än $p$, så är skillnaden mellan $q$ och $n$ mindre än skillnaden mellan $p$ och $n$.\nAssistant:", "label": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)", "predict": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_rect_Type3. Let $Q_$ be a function from natural numbers $_x_377$ to elements of $Type3$. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of $x_378 + 1$. Let $x_377$ be a natural number. Then $Q_$ holds for $x_377$.\nAssistant:", "label": "postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (plus x_378 1)) -> (x_377 : Nat) -> Q_ x_377", "predict": "postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (x_378 + 1)) -> (x_377 : Nat) -> Q_ x_377"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15621. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n$ un nombre naturel. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Alors pour toutes les fonctions $_H_not_found_max_spec$ des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$, pour tous les nombres naturels $x_971$, pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1544. Låt $p, q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Då för alla naturliga tal $m$ och $n$, om $0 < n$ och $n \\leq m$, så om $n \\leq q + 1$ och $n$ inte är delbart med $m$, så för alla naturliga tal $a$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$, för alla naturliga tal $b$, om $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ eller $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$ och $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$, så $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (leqm : Leq n m) -> (len : Leq n q) -> (Hindn : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (auto : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (auto' : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a n) (times b m)) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp1_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_965$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_965$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_965$.\nAssistant:", "label": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965", "predict": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound7. Soient $n$ et $m$ des nombres naturels. Supposons que $nth_prime$ appliqué à $n$ est inférieur à $m$. Alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_div. Let $n, d \\in N$. Then if $0 < n$, then if $d$ is divisible by $n$, then $n \\div (n \\div d)= d$.\nAssistant:", "label": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d", "predict": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (n \\ (n \\ d)) d"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sqrt_nl. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_plus. Soit $n, p, q \\in N$. Supposons que $n$ est divisible par $p$. Supposons que $n$ est divisible par $q$. Alors $n$ est divisible par la somme de $p$ et de $q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $bijf$ be an element of $bijn$ of $f$ and the sum of $n$ and $1$. Assume that $f$ applied to the sum of $n$ and $1$ is equal to the sum of $n$ and $1$. Let $i \\in N$. Assume that $i$ is less than or equal to $n$. Let $a \\in N$. Assume that $a$ is less than or equal to the sum of $n$ and $1$ and $f$ applied to $a$ is equal to $i$. Then if $a$ is less than or equal to the sum of $n$ and $1$, then if $f$ applied to $a$ is equal to $i$, then if $a$ is equal to the sum of $n$ and $1$, then $i$ is equal to $a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fi : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_sum. Soit $k1, k2 \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Alors pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ et $g$ des nombres naturels à des éléments de $B$, $bigop$ appliqué à la somme de $k1$ et de $k2$ et la fonction qui envoie $i$ à $match_bool$ appliqué à $Set$ et la fonction qui envoie $__$ à $bool$ et $p1$ appliqué à la différence de $i$ et de $k2$ et $p2$ appliqué à $i$ et $leb$ appliqué à $k2$ et $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $match_bool$ appliqué à $Set$ et la fonction qui envoie $__$ à $B$ et $f$ appliqué à la différence de $i$ et de $k2$ et $g$ appliqué à $i$ et $leb$ appliqué à $k2$ et $i$ est égal à $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à $k1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $bigop$ appliqué à $k2$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i))) (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))", "predict": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i))) (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_pi_bc. Pour tous les nombres naturels $a$ et $b$ et $c$, pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, $bigop$ appliqué à la différence de $c$ et de $b$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $b$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ au produit de $a$ et de $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $b$ est égal au produit de $a ^ (c - b)$ et de $bigop$ appliqué à la différence de $c$ et de $b$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $b$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $b$.\nAssistant:", "label": "postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a (minus c b)) (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b)))) (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> times a (f i0)) (plus i b)))", "predict": "postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> times a (f i0)) (plus i b))) (times (pow a (minus c b)) (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Soit $a$ un nombre naturel. Supposons que $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$. Alors si $1 < 2 a + 1$ et $0 < a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p \\* (2 ^ (2 p - 3)))) -> (a : Nat) -> (_clearme : or (Eq m (2 a)) (Eq m (2 a + 1))) -> (Hm : Eq m (2 a + 1)) -> (Hlt : Lt 1 (2 a + 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 \\ div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind. Let $B$ be a set. Let $_R$ be an element of $relation$ of $B$. Let $Q_$ be a function from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions. Then for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O (B, _R, b)$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of $l + 1$ and $b1$ and $b2$ and $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (l + 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_Type1. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_953$ av $Dop$ av $A$ och $_nil$ till element av $Type1$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_953$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_953$.\nAssistant:", "label": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953", "predict": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $", "label": "postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)", "predict": "postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrimeb_true_to_prime. Pour tous les nombres naturels $n$, si $primeb$ appliqué à $n$ est égal à $true$, alors $n$ est premier.\nAssistant:", "label": "postulate primeb_true_to_prime : (n : Nat) -> (_ : Eq (primeb n) true) -> prime n", "predict": "postulate primeb_true_to_prime : (n : Nat) -> (_ : Eq (primeb n) true) -> prime n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $c n - d m = 1$, then $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15691. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b \\in N$. Anta att $f$ applicerat på $b$ är lika med kontradiktion. Då är $min$ applicerat på summan av $n$ och $1$ och $b$ och $f$ lika med $min$ applicerat på $n$ och summan av $b$ och $1$ och $f$.\nAssistant:", "label": "postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)", "predict": "postulate false_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)"}
{"prompt": "Human: Translate the following French statement into Agda.\nSub_hk. Soit $__$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__1$ une fonction des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_relations.relation$ appliqué à $matita_arithmetics_bigops.range$ appliqué à $A$.\nAssistant:", "label": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrimes_below_lop. Soit $n$ un nombre naturel. Alors $primes_below$ tient pour $list_of_primes$ appliqué à $n$ et la somme de $n$ et de $2$.\nAssistant:", "label": "postulate primes_below_lop : (n : Nat) -> primes_below (list_of_primes n) (plus n 2)", "predict": "postulate primes_below_lop : (n : Nat) -> primes_below (list_of_primes n) (plus n 2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_divides_times_to_divides. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $n$ är lika med $1$. Anta att $p$ är delbart med produkten av $n$ och $m$. Då är $p$ delbart med $m$.\nAssistant:", "label": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m", "predict": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_Type4. Låt $x1$ och $x2$ och $x3$ och $x4$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1440$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från element $x_815$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x4$ och $x2$ och element $x_814$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x3$ och $x2$ och $x4$ och element $_z1441$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $Hterm$ och $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_815$ och $x_814$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_815$ och $x_814$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop1. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara en funktion från element av $B$ och element $__1$ av $B$ till element av $B$. Då för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Leq$ av $n$ och $i$ och element $__2$ av $Lt$ av $i$ och $k$ till element av $Eq$ av $p$ applicerat på $i$ och kontradiktion, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_le_ord. Let $p, n, m \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $p$ is prime. Assume that $n$ is divisible by $m$. Then $ord (n, p)\\leq ord (m, p)$.\nAssistant:", "label": "postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)", "predict": "postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1544. Soit $p, q \\in N$. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soit $m, n \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $n$ est inférieur ou ágal à $m$. Supposons que $n$ est inférieur ou ágal à la somme de $q$ et de $1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Alors si la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ est égale à $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ ou la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (posm : Leq n m) -> (posnS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_Psil. Soit $n \\in N$. Alors si $0 < n$, alors $2 ^ n \\leq Psi (2 n)$.\nAssistant:", "label": "postulate le_exp_Psil : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 n) (Psi (times 2 n))", "predict": "postulate le_exp_Psil : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 n) (Psi (times 2 n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_SO_nth_prime_n. Let $n \\in N$. Then $1$ is less than $nth_prime$ applied to $n$.\nAssistant:", "label": "postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)", "predict": "postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEnum_body. Let $A$ be a set. Let $_xxx$ be an element of $range$ of $A$. Then for all natural numbers $_x_942$, $A$.\nAssistant:", "label": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"}
{"prompt": "Human: Translate the following French statement into Agda.\nPi_p_primeb5. Soit $n$ un nombre naturel. Alors si $1 < n$, alors $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du produit de $2$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$ est égal à $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du produit de $2$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$.\nAssistant:", "label": "postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))", "predict": "postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nF_max_true. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n$ un nombre naturel. Soit $__$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$. Alors $f$ appliqué à $max$ appliqué à $n$ et $f$ est égal à $true$.\nAssistant:", "label": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true", "predict": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_sumI. Let $a$ and $b$ and $c$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a \\leq b$, then if $b \\leq c$, then $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $b$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $b$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $bigop$ applied to the difference of $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nAssistant:", "label": "postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))))", "predict": "postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (op B nil op (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))) (bigop (minus c a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax_spec_ind_body. Let $_n \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions. Let $_H_found_max_spec$ be a function from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$. Let $_H_not_found_max_spec$ be a function from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$. Then for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.\nAssistant:", "label": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind_body : (_n : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_plus_to_le. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nAssistant:", "label": "postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)", "predict": "postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_CProp5. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_905$ de $ACop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_905$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExample1. $smallest_factor (3)= 3$.\nAssistant:", "label": "postulate example1 : Eq (smallest_factor 3) 3", "predict": "postulate example1 : Eq (smallest_factor 3) 3"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type4_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.\nAssistant:", "label": "postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863", "predict": "postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_discr. Låt $a1$ vara en mängd. Då för alla element $a2$ av $a1$, för alla element $x$ och $y$ av $Dop$ av $a1$ och $a2$, om $x$ är lika med $y$, så håller $match_Dop$ för $a1$ och $a2$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar $t0$ och $t1$ och $t2$ och $t3$ som $match_Dop$ applicerat på $a1$ och $a2$ och summan av $Type2", "label": "postulate Dop_discr : (a1 : Set) -> (a2 : a1) -> (x : Dop a1 a2) -> (y : Dop a1 a2) -> (_e : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ t0 : ACop a1 a2 -> \\ t1 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t2 : ((a : a1) -> Eq (t1 a a2) a2) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ u0 : ACop a1 a2 -> \\ u1 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u2 : ((a : a1) -> Eq (u1 a a2) a2) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (\\ e0 : Eq (R0 (ACop a1 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 u0 e0) u1) (\\ e1 : Eq (R1 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) x0 p0 -> \\ _ : Eq (R1 (ACop a1 a2) t0 (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 x0 p0) x1 -> (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> \\ x11 : ((__1 : a1) -> (__2 : a1) ->", "predict": "postulate Dop_discr : (a1 : Set) -> (a2 : a1) -> (x : Dop a1 a2) -> (y : Dop a1 a2) -> (_e : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ t0 : a1 -> \\ t1 : a1 -> \\ t2 : a1 -> \\ t3 : a1 -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ u0 : a1 -> \\ u1 : a1 -> \\ u2 : a1 -> \\ u3 : a1 -> Eq (match_Dop a1 a2 Type2 (\\ _ : a1 -> univ Type2) (\\ v0 : a1 -> \\ v1 : a1 -> \\ v2 : a1 -> \\ v3 : a1 -> Eq t0 u0) (\\ w0 : a1 -> \\ w1 : a1 -> \\ w2 : a1 -> \\ w3 : a1 -> Eq t1 w0) (\\ x0 : a1 -> \\ x1 : a1 -> \\ x2 : a1 -> \\ x3 : a1 -> Eq t2 x0) (\\ y0 : a1 -> \\ y1 : a1 -> \\ y2 : a1 -> \\ y3 : a1 -> Eq t3 y0) (\\ z0 : a1 -> \\ z1 : a1 -> \\ z2 : a1 -> \\ z3 : a1 -> Eq t3 z0) (\\ p0 : a1 -> \\ p1 : a1 -> \\ p2 : a1 -> \\ p3 : a1 -> Eq t0 p0) (\\ q0 : a1 -> \\ q1 : a1 -> \\ q2 : a1 -> \\ q3 : a1 -> Eq t1 q0) (\\ r0 : a1 -> \\ r1 : a1 -> \\ r2 : a1 -> \\ r3 : a1 -> Eq t2 r0) (\\ s0 : a1 -> \\ s1 : a1 -> \\ s2 : a1 -> \\ s3 : a1 -> Eq t3 s0) (\\ u0 : a1 -> \\ u1 : a1 -> \\ u2 : a1 -> \\ u"}
{"prompt": "Human: Translate the following English statement into Agda.\nNil_append_elim. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $l1$ and $l2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.\nAssistant:", "label": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)", "predict": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_priml. Soit $n \\in N$. Supposons que $0 < n$. Alors $2 ^ (2 n)\\leq 2 n ^ (prim (2 n)+ 1)$.\nAssistant:", "label": "postulate le_exp_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (pow (times 2 n) (plus (prim (times 2 n)) 1))", "predict": "postulate le_exp_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (times n (prim (times 2 n) + 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Assume that $5 < n$. Let $m$ be a natural number. Assume that $6 \\leq m$ and $(m + 1)^ 2 \\leq 2 ^ m$. Let $a \\in N$. Assume that $6 \\leq a$ and $2 (a + 1)+ 1 \\leq 2 ^ a$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (posn : Lt 5 n) -> (m : Nat) -> (lt6 : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : N) -> (Hind1 : and (Leq 6 a) (Leq (plus (times 2 a) 1) (pow 2 a))) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (div x2515 x2516) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDpi1__o__aop. För alla element $x0$ av $cic.Univ$ av $univs.Type0$, för alla element $x1$ av $cic.Term$ av $univs.Type0$ och $x0$, för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $x3$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ och $x2$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x0$ och $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)", "predict": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nCommutative_plus. $commutative$ tient pour $Nat$ et $plus$.\nAssistant:", "label": "postulate commutative_plus : commutative Nat plus", "predict": "postulate commutative_plus : commutative Nat plus"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFound_max_spec. Låt $n \\in N$. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Då för alla naturliga tal $m$, om $m < n$ och $f (m)= true$, så för alla funktioner $__2$ från naturliga tal $i$ och element $__2$ av $Lt$ av $m$ och $i$ och element $__3$ av $Lt$ av $i$ och $n$ till element av $Eq$ av $f (i)$ och kontradiktion, håller $max_spec$ för $n$ och $f$ och $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBool_inv_rect_CProp1. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $P$ vara en funktion från element $_z641$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z642$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$. Då för alla funktioner $_H2$ från element $_z642$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate bool_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate bool_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1542$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x", "label": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b x2)) (op (op a b) x2))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $len$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $p$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lep$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_sqrt.sqrt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$. Låt $ltp$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $Hc$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_chebyshev_bertrand.k$ applicerat på $mat", "label": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (", "predict": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k matita_arithmetics_nat.nat)) (matita_basics_bool.true))) -> (H0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S n)) (matita_basics_bool.true))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 un"}
{"prompt": "Human: Translate the following English statement into Agda.\nDpi1__o__aop. Let $x0$ be a set. Then for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop (x0, x1)$ and $x2$, $Aop$ holds for $x0$ and $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1", "predict": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_d_gcd. Pour tous les éléments $m$ et $n$ et $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))", "predict": "postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))"}