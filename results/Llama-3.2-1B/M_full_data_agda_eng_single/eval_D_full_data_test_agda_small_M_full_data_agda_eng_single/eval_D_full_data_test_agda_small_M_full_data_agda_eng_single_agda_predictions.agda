postulate bigop_false : lett natuligt tal. lett B (mengd) (allt (elem nil B) (\ op : (B : Mengd) -> (__1 : B) -> B) (\ f : (_ : Nat) -> B) (allt nil B (\ _ : (B : Mengd) -> (__1 : B) -> B))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (i' : Lt n i) -> (j' : Lt n i) -> (a : Nat) -> (auto : and (Leq a n) (Leq (f a) i)) -> (auto' : and (Leq a n) (Leq (f a) i)) -> (auto'' : all (all (Leq b n) (f b)) (Leq b n)) -> (auto''' : all (Leq b n) (f b)) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto'' : Eq a b) -> Eq (f a) i
postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (nil) (bigop n (\ i : Nat -> false) B nil op (\ i : Nat -> f i))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (Hind : Eq c n - d m) -> (Hindm : Eq (times d m) c) -> (Hindn : Eq m d) -> Eq m n
postulate ex_prime : soit n un nombre naturel. supposons que 1 leq n. alors ex tient pour Nat et la fonction qui envoie m a la conjonction de la conjonction de (lt n m) (leq m (plus (factorial n) 1)) (prime m))
postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m _n + _b) -> (x_1078 : Eq _f m) -> (x_1077 : (_ : Nat) -> (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq _f i) -> (_f : (x_1075 : Nat) -> Eq (min_spec _n _b _f m x_1075) x_1076) -> (_H_not_found_min_spec : (x_1081 : (_ : Nat) -> (_ : Leq _b x_1081) -> (__1 : Lt x_1081 _n + _b) -> Eq _f x_1081) -> (Q_ : (_ : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec' : (x_1075 : Nat) -> Q_ x_1075 x_1076) -> (_H_not_found_min_spec' : x_1075 -> Q_ _n + _b -> not_found_min_spec _n _b _f x_1075) -> (x_1075 : Nat) -> x_1076
postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop
postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)
postulate ACop_inv_rect_CProp1 : soit x1 un élément de cic.Univ univs.Type0. soit x2 un élément de cic.Term univs.Type0 x1. soit Hterm un élément de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2). soit P une fonction des éléments _z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop. alors pour toutes les fonctions _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)
postulate ACop_rect_Type4 : soit A un élément de cic.Univ univs.Type0. Soit _nil un élément de cic.Term univs.Type0 A. Soit Q_ une fonction des éléments _x_891 de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) de cic.Univ univs.Type4. Soit _H_mk_ACop une fonction des éléments aop de cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) des fonctions _comm des éléments a de cic.Term univs.Type0 A et des éléments b de cic.Term univs.Type0 A à des éléments de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a)) (cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm)) x_891)
postulate le_Psil1 : (n : Nat) -> bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> Nat) (leq (p) (Psi n))
postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (posm : Eq 1 (div (comm : Nat p m) (div p m))) -> (c : Nat) -> (nm : Nat) -> (auto : divisible p m) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m)
 professorpostulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)
postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0
postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)
postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (ant : Lt 0 n) -> (auto : prime p) -> (auto' : not (divisible p n)) -> bigop m (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1)
postulate transpose_i_j_i : (i : Nat) -> (j : Nat) -> Eq (transpose i j i) j
postulate DPair_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)
postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (i : Nat) -> (j : Nat) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)
postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posn' : Eq 0 m) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ _clearme0 : Eq (minus (times c n) m) (times d m)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> (H : Eq n c) -> Eq (times m n) (times d m)
postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> Prop) -> bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> 1)
atpostulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1771 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 matita_basics_bool.true) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_bool.true)
postulate lt_sqrt : soit n un nombre naturel. Alors n est inférieur a la puissance de la somme de la racine carrée de n et de 1 et de 2.
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p1 i) -> Nat 0 plus (\ i : Nat -> g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p2 i) -> Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (n1 : Nat) -> true) -> (p1 : (n1 : Nat) -> true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)
postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> då om 0 < n och n inte är delbart med m så gcd_aux (p + 1, m, n) = gcd_aux (p, n, mod (m, n))
postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate bigop_diff : (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (i < n) -> (p (i)) -> (aop__o__op : B nil op f) -> (i : Nat) -> (n : Nat) -> (i < n) -> (p (x)) -> (B nil aop__o__op op f) -> (x : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (aop__o__op B nil op f i bigop n f x) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op f) (\ x : Nat -> f x))
postulate make_list_body : soit A un element de cic.Univ univs.Type0. soit _a un element de cic.Term univs.Type0 A. alors pour tous les elements _n de cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_lists_list.list A)
postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate log_times_l : låt p och n och m vara naturliga tal. Anta att 0 är mindre än n. Anta att 0 är mindre än m. Då om 1 är mindre än p, så är summan av logaritmen av p och n och logaritmen av p och m mindre eller lika med logaritmen av p och (produkten av n och m).
postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (x_577 : cic.Term univs.Type0 _A) -> (x_578 : cic.Term univs.Type0 _B) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)
postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867
postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (f g) n
iqué àpostulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (_ : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjoncte (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (posm : Lt n m) -> (pnm : Lt n (plus q 1)) -> (Hind0 : (_ : Nat) -> (b : Nat) -> disjoncte (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind1 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind2 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind3 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind4 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind5 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind6 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind7 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind8 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind9 : Eq (minus (times a (mod
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate let_clause_15622 : soit m, n, a, b \in N
postulate option_inv_rect_Type4 : soit x1 un élément de cic.Univ univs.Type0. Alors pour tous les éléments Hterm de cic.Term univs.Type0 (matita_basics_types.option x1) pour toutes les fonctions P des (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)
postulate match_le : (_n : N) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (__ : Nat) -> (_n : Nat) -> return_type _n z
postulate håller för : (univs.Type0 : cic.Univ) -> cic.Univ
postulate leb : (_ : Nat) -> (__1 : Nat) -> bool
postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> ((_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (cic.Univ cic.prop)
postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)
postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (plus c n) (plus d m)) 1) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dn : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (minus (times d m) (times c n)) 1) -> Eq (div (plus d m) (plus c n)) (minus (times d m) (times c n))
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (lt1n : Lt 1 n) -> (H : Leq i n) -> (Hn : Eq (gcd i n) 1) -> Lt i n
postulate lstar_ind_l_aux : soit B un ensemble. soit R une fonction des elements de B et des elements __1 de B a des propositions. soit b2 un element de B. soit P un element de relation2 Nat B. soit __ un element of P 0 b2. alors pour toutes les functions __1 des nombres naturels l et des elements b1 de B et des elements b de B et des elements __1 de R b1 b et des elements __2 de lstar B R l b b2 et des elements __3 de P l b a des elements of P l + 1 b1. pour tous les numbers l. pour tous elements b1 and b of B. for all elements __2 of lstar B R l b1 and b. if b = b2, then P l b1.
postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunkion (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) c) n)) -> (H : Eq (times d m) c) -> Eq m n
postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i) (mineralteq (g1 i) (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i)))
postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))
postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (prime p) -> (lt1 : Lt m 1) -> (lt2 : Leq p 2 m + 1) -> divisible p (M m)
postulate k1 : (n : Nat) -> (p : Nat) -> (posp : Leq 18 n) -> (posp' : Leq p n) -> (H : Lt 2 n 3) -> Eq (k (2 n, p) 0)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (auto : Leq i n) -> (auto' : Leq j n) -> (a : Nat) -> (auto" : Leq a n) -> (f' : (_ : Nat) -> Nat) -> (auto'' : f (a)) = i) -> (b : Nat) -> (auto'' : Leq b n) -> (f'' : (_ : Nat) -> Nat) -> (auto''' : f (b)) = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> f a = j
postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)
postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967
postulate Prod : (s1 : Sort) -> (s2 : Sort) -> all (fun a : Univ s1 -> fun b : Term s1 a -> Univ s2) (rule s1 s2)
postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq m n
postulate le_exp_Psi2 : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))
postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)
postulate min_O_f : soit f : (_ : Nat) -> bool -> all Nat (\ b : Nat -> min (0 b f))
postulate let_clause_15611 : let (p : Nat) (m : Nat) (n : Nat) -> (posn : Lt 0 p) -> (same : Eq 1 (gcd p m)) -> (p : Nat) -> (nm : Nat) -> (c : Nat) -> (mnm : Nat) -> (auto : ex Nat (\ b : Nat -> (\ a : Nat -> (\ p : Nat -> Eq (times a p) c) -> let (H : Eq (times a p) (times b m)) in (times b m) (gcd p m) (Eq (times b m) (times a p)) (gcd p m))) -> (H : Eq (times b m) (times a p)) -> (auto : ex Nat (\ b : Nat -> (\ a : Nat -> (\ p : Nat -> Eq (times a p) c) -> let (H : Eq (times a p) (times b m)) in (times b m) (gcd p m) (Eq (times b m) (times a p)) (gcd p m))) -> (auto : Eq (times b m) (times a p)) -> (auto : Eq (times a p) (times b m)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (gcd p m) (same m n)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (same p m)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n)
postulate unit_inv_rect_CProp1 : soit Hterm un élément de cic.Term univs.Type0 matita_basics_types.unit Soit P une fonction des éléments _z960 de cic.Term univs.Type0 matita_basics_types.unit à des éléments de cic.Univ cic.prop Soit _H1 une fonction des éléments _z961 de cic.Term cic.prop matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it à des éléments de cic.Term cic.prop (P matita_basics_types.it)
postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192
postulate range_rect_Type5_body : (_A : Mngd) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> Q_ x_919) -> (x_919 : range _A) -> Q_ x_919
postulate let_clause_10131 : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (max : (_ : Nat) -> (_ : Nat) -> Eq (max (n0) 1) m) -> (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (x7 : Nat) -> Eq x7 (plus m x7)
postulate void_rect_CProp1 : soit Q_ une fonction des elements _x_493 de cic.Term univs.Type0 matita_basics_types.void à des elements de cic.Univ cic.prop. Soit x_493 un element de cic.Term univs.Type0 matita_basics_types.void. Alors cic.Term tient pour cic.prop (Q_ x_493)
postulate exp_to_fact1 : (n : Nat) -> (_ : Lt 0 n) -> Lt (times (times (pow 2 (times 2 n)) (factorial n)) (factorial n)) (factorial (plus (times 2 n) 1))
postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)
postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B
postulate le_exp1 : let n : Nat in let m : Nat in let a : Nat in and (Lt 0 a) (Lt n m) (pow n m)
postulate R1 : cic.Univ univs.Type2 -> cic.Term univs.Type2 A -> cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0 -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)
postulate length_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (fa : Nat) -> (b : Nat) -> (fb : Nat) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> letjf : injn f n -> (injf : injn f n) -> (auto : Eq a b) -> f a = j
postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> let (x : (_ : Nat) -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> let (y : (_ : Nat) -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> let (z : (_ : Nat) -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> Eq (x z) (y z)
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076
postulate fact_pi_p : soit n : Nat -> et (same_pn n (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (div n (pow p (plus i 1))))))
erat påpostulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : Nat -> (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : prod Prop Prop (Eq (p1 i) true) (\ _1 : Eq (f1 i) f2) (\ _2 : Eq (p2 i) true) (\ _3 : Eq (f1 n1) (f2 n2)) (\ _4 : Eq (p1 n1) (p2 n2)) (\ _5 : Eq (f1 n1) (f2 n2)) (\ _6 : Eq (f2 n2) (f1 n1)) (\ _7 : Eq (f1 (op n1 k)) (f2 (op n2 k))) (\ _8 : Eq (op k h) B) (\ _9 : Eq (f2 (op n2 k)) (f1 n1)) (\ _10 : Eq (f1 (op n1 k)) (f2 n1)) (\ _11 : Eq (f2 n1) (f1 n1)) (\ _12 : Eq (f1 (op n1 k)) (f2 n1)) (\ _13 : Eq (f1 (op n2 k)) (f2 n2)) (\ _14 : Eq (f2 n2) (f1 n2)) (\ _15 : Eq (f1 (op n1 k)) (f2 n1)) (\ _16 : Eq (f2 n1) (f1 n1)) (\ _17 : Eq (f1 (op n1 k)) (f2 n1)) (\ _18 : Eq (f1 (op n2 k)) (f2 n2)) (\ _19 : Eq (f
postulate let_clause_15625 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (div (plus c n) (plus d m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq m d) -> Eq (times d n) m
postulate ab_times_cd : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a b) (matita_arithmetics_nat.times c d)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))
postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> invert_permut n f (f m)
postulate le_minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))
postulate min : (_ : Nat) -> (__1 : Nat) -> (f : (__2 : Nat) -> bool) -> Nat
postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true
postulate ACop_ind_body : Soit A un ensemble. Soit _nil un élément de A. Soit Q_ une fonction des _x_889 de ACop de A _nil à des propositions. Alors pour toutes les fonctions _H_mk_ACop des elements aop de Aop de A _nil et des fonctions _comm des elements a de A et des elements b de A à des elements de Eq (op A _nil aop a b) (op A _nil aop b a)
postulate div_mod_spec_rect_CProp0_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857
postulate list_of_primes_def : soit n : Nat -> ainsi que list_of_primes (n) est égale a (lprim n 2 (nil Nat))
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (commun n m) 1) (Nat)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (div (commun m n) (minus (times m d) (times n c))) (minus (times m d) (times n c))
postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.list x1) x_733 x_732)) -> (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq
postulate sub_comp_r : soit A un élément de cic.Univ univs.Type0. Soient R et R1 et R2 des éléments de cic.Term univs.Type0 (matita_basics_relations.relation A). Alors pour tous les éléments __ de cic.Term cic.prop (matita_basics_relations.subR A R1 R2) citec.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))
postulate prime_nth_prime : soit n : Nat -> premier (nth_prime n)
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (prime : prime p) -> (_clearme : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_909 : ACop A _nil) -> Ptn) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_909 : ACop A _nil) -> Q_ x_909
postulate sigma_p_dividesb1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (eqn0 : Eq 0 n) -> (d : Nat) -> (eqm : Eq m (times 0 d)) -> Eq n 0
postulate And_rect_CProp5 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)
postulate primes_below_to_bertrand : (pm : Nat) -> (l : lista Nat) -> (lts : primt pm) -> (__1 : primes_below l pm + 1) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> (\ H : Lt 2 p) -> pp)) -> (n : Nat) -> (posn : Lt 0 n) -> bertrand n
postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> Eq (upto A I) 0 -> (_1 : sub_hk h k A J I) -> (i : Nat) -> (_2 : Lt i (upto A J)) -> Eq (filter A J i) false
postulate let_clause_10331 : soit n un nombre naturel. supposons que 5 est inférieur à n. soit m un nombre naturel. supposons que 6 est inférieur ou ágal à m. supposons que la puissance de la somme de m et de 1 et de 2 est inférieure ou ágale à la puissance de 2 et de m. soit a ∈ N. supposons que 6 est inférieur ou ágal à a. supposons que la somme du produit de 2 et de la somme de a et de 1 et de 1 est inférieure ou ágale à la puissance de 2 et de a. alors pour tous les nombres naturels x2515 et x2516, x2515 est égal à la somme du produit x2516 et du quotient de x2515 et x2516 et (mod x2515 x2516).
postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)
postulate not_divides_to_dividesb_false : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)
postulate lstar_inv_S : Soit B un ensemble. Soit R un élément de relation B. Soit l : N. Alors pour tous les éléments b1 et b2 de B, pour tous les éléments __ de lstar B R l b1 b2, pour tous les nombres naturels l0, si l0 + 1 = l, alors ex2 tient pour B et la fonction qui envoie b à R (b1, b) et la fonction qui envoie b à lstar B R l0 b b2.
postulate divides_plus : soit n, p, q : N -> propos (and (divisible n p) (divisible n q)) (divisible n (plus p q))
postulate eqb_sym : (a : Nat) -> (b : Nat) -> Eq (eqb a b) (eqb b a)
postulate option_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)
postulate låt : (B : Mngd) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f n + 1) -> (f' : (n : Nat) -> Nat) -> (i : Nat) -> (lt0 : Lt i n) -> (a : Nat) -> (lt1 : Lt a n) -> (f' : (a : Nat) -> i) -> (lt2 : Lt a n) -> (f : (a : Nat) -> i) -> (Hc : Eq a n + 1) -> (Hlt : Lt a n) -> (Hlt0 : Lt n a + 1) -> (Hlt1 : Lt n a) -> (Hlt2 : Eq n a) -> Eq (f a) i
postulate not_divides_to_gcd_aux : soit p, m, n : N -> (posn : Lt 0 n) -> (nm : not (divisible n m)) -> gcd_aux (p + 1, m, n) (gcd_aux (p, n, mod (m, n)))
postulate soit : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (H : Lt m n) -> (f' : (_ : Nat) -> bool) -> (H' : Lt m n) -> (H" : Eq (f i) false) -> max_spec n f m
postulate le_prim_n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)
postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (posn : Lt 0 n) -> (auto : not (divisible p n)) -> bigop m (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1)
postulate True_inv_ind : soit Hterm un element de cic.Term cic.prop matita_basics_logic.True : ainsi pour toutes fonctions P des elements _z125 de cic.Term cic.prop matita_basics_logic.True à des elements cic.Univ cic.prop : pour toutes fonctions _H1 des elements _z126 de cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) : cic.Term cic.prop (P matita_basics_logic.I)
postulate filter_DPair : soit A un élément de cic.Univ univs.Type0. soit _f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0. soit return_sort : cic.Sort. soit return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort. alors pour toutes les fonctions return des elements z de cic.Term univs.Type0 (matita_basics_types.DPair A _f) elements de cic.Term return_sort (return_type z) pour tous les elements z de cic.Term univs.Type0 (matita_basics_types.DPair A _f) elements de cic.Term return_sort (return_type z)
postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))
postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate låt : (Q_ : cic.Term univs.Type0 matita_basics_types.void) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4
postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (_ : Nat) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ l + 1 b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> (Q_ x_1337 x_1336 x_1335 x_1338)
postulate mod_O_to_divides : sont n et m des nombres naturels. alors (mod (m, n)) = 0 -> divisible n m
postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (div1 : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times p a) (times m b))
postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> R b b2 -> (__1 : R b b2) -> lstar_r B R l + 1 b1 b2
postulate exp_n_1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))
postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> and (Lt (pow m n) n) (Lt m (times n n))
postulate eq_Psi_2_n : soit n : Nat -> (posn : Lt 0 n) -> Eq (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi 2 n)
postulate let_clause_15691 : let m n a b : Nat\n  and (Lt 0 n) (Lt 0 m) (Eq (gcd n m) 1)
postulate le_theta_M_theta : tous les nombres naturels m -> theta (2 m + 1) \leq M (m)theta (m + 1)
postulate RC_reflexive : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))
postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (prod b c)) (prod (matita_arithmetics_bigops.ACop x1 x2) a b c))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) Hterm (matita_arithmetics_bigops.Dop x1 x2 P)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.Dop x1 x2 P) Hterm)
postulate monotonic_le_minus_r : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))
postulate låt : (_n : Nat) -> Nat -> Nat
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (auto : Nat -> (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (auto : Eq (gcd p m) a p - b m) -> (auto : Eq (gcd p m) a p) -> (auto : Eq (gcd p m) b m) -> (H : Eq (gcd p m) b m - a) -> Eq m b - p a
postulate congruent_ab_lt : let (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))
postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (nm : Leq n q) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Lt n b) -> Eq n (a (mod m n))
postulate p_ord_to_not_eq_O : (n, p, q, r : Nat) -> (_ : Lt 1 n) -> (p_ord : (n : Nat) -> Nat) -> (q : Nat) -> (r : Nat) -> not (Eq r 0)
postulate min_exists : soit f : (_ : Nat) -> (v : bool) -> (t : Nat) -> (m : Nat) -> (posn : Lt m t) -> (f : (_ : Nat) -> bool) -> (k : Nat) -> (b : Nat) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (t : Nat) -> (k : Nat) -> (b : Nat) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (H : Eq t k + b) -> and (min k b f) m
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (H : Eq m n) -> (H0 : Eq (gcd p m) (gcd p m)) -> (H1 : Eq (gcd p m) (gcd p m)) -> (H2 : Eq (gcd p m) (gcd p m)) -> (H3 : Eq (gcd p m) (gcd p m)) -> (H4 : Eq (gcd p m) (gcd p m)) -> (H5 : Eq (gcd p m) (gcd p m)) -> (H6 : Eq (gcd p m) (gcd p m)) -> Eq (m b) (p a)
postulate SubR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop
postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a
postulate bigop_0 : soit n : Nat\n        soit B : Set\n        soit nil : B\n        all : (op : Aop B nil) -> (f : (_ : Nat) -> B) -> op (B nil op (bigop n (\ i : Nat -> true) B nil op) (\ i : Nat -> f (plus i 1)) (f 0))
postulate let_clause_15622 : soit m, n, a, b \in N. supposons que 0 < n et 0 < m. supposons que 1 = diviseur commun plus grand de n et m. soit c un nombre naturel. soit _clearme un element de ex Nat (\ d : Nat -> disjonct ( Eq (minus (times c n) (times d m)) 1) ( Eq (minus (times d m) (times c n)) 1)) soit d \in N. alors si (c n - d m) = 1 ou (d m - c n) = 1 et (d m - c n) = 1 alors m d - n c = 1
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (Hind : Leq i n) -> (Hind0 : Leq f i0 n) -> (Hind1 : Leq a n) -> (Hind2 : Leq b n) -> (Hind3 : Leq f b) -> (auto : (_ : Nat) -> Leq a n) -> (auto' : (_ : Nat) -> Leq b n) -> (auto'' : (injf : injn f n) -> (auto' : Leq a b) -> f a)
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (len : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hind : all (d : Nat -> or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) (Nat)) -> (Hind0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hind1 : Eq n c) -> (Hind2 : Eq m d) -> (Hind3 : Eq n (times c n)) -> Eq m d
postulate let_clause_15611 : soit p, m, n \in N. Supposons que 0 < p. Supposons que 1 = diviseur commun plus grand de p et m. Supposons que p est divisible par m \times n. Soit c un nombre naturel. Supposons que m n = p c. Soit a \in N. Soit _clearme0 : ex Nat (\ b -> disjonct (Eq (minus (times a p) (times b m)) (diviseur commun plus grand de p m)) (Eq (minus (times b m) (times a p)) (diviseur commun plus grand de p m))) Soit b \in N. Supposons que le diviseur commun plus grand de p et m est égal à a p - b m ou le diviseur commun plus grand de p et m est égal à b m - a p. Supposons que le diviseur commun plus grand de p et m est égal à b m - a p. Supposons que b m - a p = 1. Alors m b - p a = 1.
postulate let_clause_15625 : soit m, n, a, b \in N
postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Då Nat
postulate prop140 : (x : Z) -> (y : Z) -> Eq x y -> even (plus x y)
postulate let_clause_1607 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (zero : Lt 0 n) -> (smaller : Lt 0 m) -> (H : Eq 0 m) -> (H0 : Eq 0 n) -> (H1 : Eq (largestCommonDenominator n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> (\ H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (H2 : Eq (minus (times c n) (times d m)) (times c n)) -> (H3 : Eq (minus (times d m) (times c n)) 1) -> (H4 : Eq (minus (times d m) (times c n)) 1) -> Eq (largestCommonDenominator m n) (minus (times m d) (times n c))
postulate ex_ind_body : let A : cic.Univ univs.Type0 in let _P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop in let Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop in (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop _P x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)
postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)
postulate All_append : soit A un élément de cic.Univ univs.Type0. Soit P une fonction des elements __ : cic.Term univs.Type0 A -> cic.Univ cic.prop. Soient l1 et l2 des elements de cic.Term univs.Type0 (matita_basics_lists_list.list A). Soit __ un element de cic.Term cic.prop (matita_basics_lists_list.All A P l1). Alors pour tous les elements __1 de cic.Term cic.prop (matita_basics_lists_list.All A P l2), cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))
postulate let : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.succ univs.Type2 (\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2 (\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2 (\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.prod (cic.succ univs.Type0) univs.Type0 (cic.univ univs.Type0) (\ u : cic.Term univs.Type0 univs.Type0 -> \ v : cic.Term univs.Type0 univs
postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0
postulate prime_to_lt_O : tous les nombres naturels p -> (p : Nat) -> (_ : prime p) -> Lt 0 p
postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))
postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\ y : cic.Term univs.Type0 A -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B) y)))
postulate divides_exp_to_divides : soit p, n, m : Nat -> (_ : prime p) -> (__1 : divisible p n) -> divisible p n
postulate letimes : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> Nat
postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (divcomm : Eq (gcd p m) 1) -> (auto : divisible p (times m n)) -> (c : Nat) -> (auto' : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disjonct (Eq (minus (times a p) (times b m)) (divcomm)) (Eq (minus (times b m) (times a p)) (divcomm))) (Eq (minus (times b m) (times a p)) (divcomm)) (Eq (minus (times a p) (times b m)) (divcomm))) -> (b : Nat) -> (_clearme1 : Eq (minus (times a p) (times b m)) (divcomm)) -> (auto' : Eq (minus (times b m) (times a p)) (divcomm)) -> (H : Eq (minus (times a p) (times b m)) (divcomm)) -> (auto' : Eq (minus (times a p) (times b m)) 1) -> Eq (divcomm p m) (minus (times p m) (times a b))
postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\ t : Nat -> c \ t)
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : all Nat (\ d : Nat -> or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hc : Eq (minus (times d m) (times c n)) 1) -> Eq n (times c m)
postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate sameF_p_le : låt A vara en mängd. låt p vara en funktion från naturliga tal till sanningsvärden. låt f och g vara funktioner från naturliga tal till element av A. låt n och m vara naturliga tal. Då om n är mindre eller lika med m, så för alla element __1 av sameF_p m p A f g, håller sameF_p n p A f g.
postulate prop110 : (a : Int) -> (c : Int) -> even (plus a b) (plus c b)
postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) (minus (times d m) (times c n))) -> Eq (minus (times m d) (times n c)) 1
postulate decidable_lt :forall (n : Nat) (m : Nat) -> decidable (Lt (n, m))
postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))
postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)
postulate soit : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)
postulate le_n_Sm_elim : soit n, m : Nat -> Prop -> Prop -> (P : Prop) -> (__1 : (__1 : Leq (plus n m) 1) -> plus m 1) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P
postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq (gcd p n) 1) -> (H0 : Eq (gcd p m) 1) -> (H1 : Lt 1 (gcd p (times n m))) -> (H2 : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)
postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)
postulate lt_S_to_lt : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> soit m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)
postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 Type2 1 (\ _ : range a1) -> univ Type2 (\ t0 : (_ : range a1) -> t1 : (_ : range a1) -> t2 : (_ : range a1) -> match_range a1 (plus Type2 1) (\ _ : range a1) -> univ Type2 (\ u0 : (_ : range a1) -> u1 : (_ : range a1) -> u2 : (_ : range a1) -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ e0 : Eq (R0 (prod Set Set Nat) (\ _ : range a1) t0 u0) t1 u0 e0) u1) (\ e1 : Eq (R0 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ _ : range a1) -> prod Prop Type1 (Eq (R1 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ x0 : (_ : range a1) -> p0 : Eq x0 t0) t1 u0 e0 u1) (\ e0 : Eq (R1 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ _ : range a1) -> prod Prop Type1 (Eq (R2 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ x0 : (_ : range a1) -> p0 : Eq x0 t0) t1 u0 e0 u1 x0) (\ x1 : (_ : range a1) -> p1 : Eq x1 t1) t2 u0 e0 u1 x0 x1) (\ e0 : Eq (R2 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ _ : range a1) -> prod Prop Type1 (Eq (R3 (prod Set Set Nat) (\ _ : range a1) t0 u0) (\ x0
postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d c) -> (__2 : divisible d c) -> divisible d (times c (div c m))
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)
postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n
postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eqn : Eq 1 (gcd p m)) -> (divnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) a p) (Eq (gcd p m) b m)) -> (H : Eq (gcd p m) b m) -> Eq m b p
postulate divides_mod : soit p, m, n : N -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)
postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> let n : Nat -> let m : Nat -> let p : Nat -> let le : (_ : Nat) -> (_ : Nat) -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Natpostulate
postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))
postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)
postulate length_map : sont A B : cic.Univ univs.Type0 -> cic.Univ univs.Type0 -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))
postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat
postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)
postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)
postulate range_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> or (and (Eq m 2 a) (and (Lt 1 2 a) (Lt a 1))) -> (and (Lt m 2 a) (and (Lt 1 2 a) (Lt a 1))) -> (Lt 1 2 a) -> Eq (pred m) a
postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))
postulate låt : (B : Mngd) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\ b : B -> lstar B R l b1 b) (\ b : B -> R b b2)
postulate lt_inv_plus_l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))
postulate sqrt_def : soit n un élément de cic.Term univs.Type0 matita_arithmetics_nat.nat. Alors cic.Term tient pour cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))
postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : (_ : f n) -> n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq i n) -> (H0 : Leq j n) -> (H1 : Leq a n) -> (H2 : Leq a n) -> (H3 : f (a)) -> (H4 : Leq b n) -> (H5 : f (b)) -> (H6 : Leq b n) -> (H7 : f (b)) -> (H8 : injn f n) -> (H9 : injn f n) -> (H10 : Eq (f a) j) -> (H11 : Leq b n) -> (H12 : Leq f (b)) -> (H13 : injf (f a) n) -> (H14 : injf (f b) n) -> (H15 : Eq (f a) j) -> (H16 : Leq (f a) n) -> Eq (f a) j
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (ltm : Leq n m) -> (bnd : Nat) -> (auto : a mod (m n) - b n = gcd_aux (q n) (mod (m n))) -> (Hind' : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux (q n) (mod (m n)))) -> (Hind'' : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))
postulate eq_or_gt : let n : Nat in or (Eq 0 n) (Lt 0 n)
postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type z (matita_arithmetics_bigops.Dop A _nil)) (case_mk_Dop (matita_arithmetics_bigops.ACop A _nil) (prod __ __1) (__ __2) __3) (prod __4 __5) (__6 __7)
postulate fst_p_ord_times : let (p : Nat) -> (a : Nat) -> (b : Nat) -> (primp : prim p) -> (posn : Lt 0 a) -> (Hind : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))
postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> Anta att 0 < n
postulate found_max_spec : soit n : Nat\n           soit f : (_ : Nat) -> bool\n           soit m : Nat\n           then (inf m n) -> (H : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate lt_exp_to_lt : soit a n m : Nat -> (_ : Lt 0 a) -> (__1 : Lt a n) -> Lt m a
postulate distributive_times_plus_r : let a : Nat, b : Nat, c : Nat -> Eq (times (plus b c) a) (plus (times b a) (times c a))
postulate range_inv_rect_Type2 : (x1 : Mngd) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> (Hterm : range x1) -> P Hterm
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (times c n) (times d m)) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))
postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)
postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q
postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A Type1) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925
postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)
postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)
postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)
postulate K1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (ltml : Leq p n) -> (__1 : Lt 2 n (div p)) -> Eq (k (2 n, p)) 0
postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (ltml : Lt n (pow 2 (mod n 2))) -> (Pn : (_ : Nat) -> Prop) -> (i : Nat) -> (_ : Lt i n) -> not (P i)
postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> and (div n p) (div n q)
postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1))) -> cic.Term univs.Type0 (matita_basics_logic.R2 T0 (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1) x0 p0 x1)
postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (auto : and (div n m) (Eq 0 n)) -> (d : Nat) -> (auto' : Eq m (times 0 d)) -> Eq m n
postulate låt : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (Hm : Eq b m) -> (Hm1 : Eq m (plus n b)) -> (f' : (_ : Nat) -> Eq (f m) true) -> (min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> Eq (f m) true) -> Eq (min_spec n b f m)
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (gcd m n) (minus (times m d) (times n c)))
postulate plus_minus_m_m : (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> Eq n (plus (minus n m) m)
postulate match_lstar_r : (B : Mngd) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (l1 : lstar_r B _R l l b b1) -> (b2 : B) -> (__1 : _R b b2) -> return_type l + 1 b1 b2 l1 b2 __1) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z
postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f)) a (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f)) a (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f))))
postulate för alla element A av cic.Univ univs.Type0 : ( _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A
nilpostulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil _nil))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)
postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)
postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> ord (p ^ m) p
postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
_postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.ACop x1 x2)) (matita_arithmetics_bigops.Dop x1 x2))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)
postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1
postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943
postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)
postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq false (eqb n m)
postulate ACop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907
postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)
postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))
postulate And_rect_CProp3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)
postulate let_clause_1704 : soit m un nombre naturel. supposons 0 < m. alors pour tous les nombres naturels a et x1029, x1029 = aop__o__op (Nat, 0, plusAC, x1029, 0)
postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (qmin : Lt q (max (plus m 1) (\ i : Nat -> andb (primeb i) (dividesb i m)))) -> Eq (bigop q (\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\ p : Nat -> pow p (ord m p))) m
postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (lt0 : Leq m 6) -> (Hind : Pow (plus 1 m) 2) -> (a : Nat) -> (lt1 : Leq a 6) -> (Hind0 : Pow (plus 1 a) 2) -> (x2515 : Nat) -> (x2516 : Nat) -> (Hind1 : Eq x2515 x2516) -> (Hind2 : and (Lt x2515 x2516) (Leq (plus 1 m) 2)) -> (Hind3 : and (Lt x2515 x2516) (Leq (plus 1 a) 2)) -> (Hind4 : Eq x2515 (mod (x2515 x2516) (x2516)))
postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (H : Lt 1 b) -> Leq n m
postulate ACop_inv_rect_CProp4 : (x1 : Mng) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Pn) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate ACop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895
postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq (bigop m (\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\ i : Nat -> 1)) m
postulate range_rect_Type4_body : (_A : Mngd) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> Q_ x_917) -> (x_917 : range _A) -> Q_ x_917
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (auto : Eq 0 (gcd m n) (div n m)) -> (q1 : Nat) -> (auto' : Eq n 0 q1) -> (auto'' : Eq 0 m) -> (q2 : Nat) -> (auto''': Eq m 0) -> Eq (gcd m n) (div n m)
postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (ltml : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)
postulate let_clause_16001 : soit m, n, a, b \in N
postulate min_spec_inv_ind : sont x1 x2 : Nat -> x3 : (_ : Nat) -> x4 : Nat -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m x1 + x2) -> (_x_1078 : Eq x3 m) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq x3 i) -> (_z1891 : Eq x4 m) -> (_z1892 : Eq x4 (x1 + x2)) -> (Pm : P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i x1 + x2) -> Eq x3 i) -> (_z1891 : Eq x4 (x1 + x2)) -> Pm) -> P x4
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate monotonic_lt_plus_l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))
postulate eq_rect_Type0_r : soit A un élément de cic.Univ univs.Type2. Alors pour tous les éléments a de cic.Term univs.Type2 A, pour toutes les fonctions P des elements x de cic.Term univs.Type2 A et des elements __ de cic.Term cic.prop et de matita_basics_logic.eq A x a elements de cic.Univ univs.Type0, pour tous les elements __ de cic.Term univs.Type0 P a (matita_basics_logic.eq A x a) elements de cic.Univ univs.Type0, pour tous les elements x de cic.Term univs.Type2 A, pour tous les elements p de cic.Term cic.prop et (matita_basics_logic.eq A x a) elements de cic.Term cic.prop, cic.Term univs.Type0 P x p
postulate lt_div_S : (n : Nat) -> (m : Nat) -> då om 0 < m, så n < (n div m) + 1m
postulate div_mod_spec_inv_rect_CProp1 : låt x1, x2, x3, x4 \in N. då för alla element Hterm av div_mod_spec x1 x2 x3 x4, för alla funktioner P från (_z1488 : div_mod_spec x1 x2 x3 x4) -> påståenden, för alla funktioner _H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 x3 x2 + x4) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)
postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 1 p) -> (posn2 : Leq n m) -> Leq (log_ p n) (log_ p m)
postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i) (mineralize i) (\ i : Nat -> g2 i)
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (j : Leq n) -> (p : (__2 : bijn f n) -> Nat) -> bijn (f n) n
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Mngd) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873
postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n
postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)
postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_clearme : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : and (Lt 1 2 a) (Lt a 0)) -> (Ha : Lt m 1) -> (Hc : Lt 2 a + 1) -> (Hd : Lt 2 a + 1) -> (Ht : Lt 1 2 a) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a0 : Nat) -> (Hind0 : Eq m 2 a) -> (Hind1 : Eq m 2 a + 1) -> (Hind2 : Eq m 2 a + 1) -> (Hind3 : Eq 1 2 a) -> (Hind4 : Lt m 1) -> (Hind5 : Lt 2 a + 1) -> (Hind6 : Lt 2 a + 1) -> (Hind7 : Lt 1 2 a) -> (Hind8 : Lt (Psi p) (pred p)) -> (Hind9 : Leq (Psi p) (pred p)) -> (Hind10 : Lt 2 a 2) -> (Hind11 : Lt 2 a 1) -> (Hind12 : Lt 2 a 0) -> (Hind13 : Lt (Hind2 m) (Hind3 m)) -> (Hind14 : Lt (Hind4 m) (Hind5 m)) -> (Hind15 : Lt (Hind6 m) (Hind7 m)) -> (Hind16 : Lt (Hind8 m) (Hind9 m)) -> (Hind17 : Lt (Hind10 m) (Hind11 m)) -> (Hind18 : Lt (Hind12 m) (Hind13 m)) -> (Hind19
postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq n c - m d
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (plus c n) (plus d m)) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times c n) (times d m)) 1
postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (e : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) -> (H1 : (i : Nat) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (__1 : Lt i n1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (_ : Nat) -> true) -> (p1 : (_ : Nat) -> true) -> let x2515 : Nat -> let x2516 : Nat -> x2515 = x2516 (x2515 \ div x2516) + mod x2515 x2516
postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> let p : prim p -> not (divisible p q) -> let p : divisible p n -> let q : divisible p n -> let n : Nat -> (q : divisible p n) -> (p : divisible p n) -> (q : divisible p n) -> divisible p (times q n)
postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903
postulate let_clause_1033 : soit n un nombre naturel. Supposons que 2 ^ 7 \leq n. Soit p un nombre naturel. Supposons que ((sqrt 2 n) + 1) \leq p et p < 2 n + 1. Supposons que leb (2, k (2 n, p))= true et 2 n < p ^ 2. Soit x2515, x2516 un nombre. Alors x2515 = x2516 (x2515 \div x2516)+ mod (x2515, x2516)
postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop b (\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\ i : Nat -> f i)) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (a i)) B nil (op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (a i)))
postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a
postulate div : (_ : Nat) -> (__1 : Nat) -> Nat
postulate assume : Sort -> Sort
postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq m d) -> (H0 : Eq n d) -> Eq (div m n) (gcd m n)
postulate ord_ord_rem : let (p : Nat) -> (q : Nat) -> (m : Nat) -> (posp : Lt 0 m) -> (primp : prim p) -> (qtp : prim q) -> (ltq : Lt q p) -> ord (ord_rem (m, p), q) (ord m q)
postulate lstar_inv_S_dx : Soit B un ensemble. Soit R un element de relation B. Soit l un nombre naturel. Alors pour tous les elements b1 et b2 de B, pour tous les elements __ de lstar B R l + 1 b1 b2, ex2 tient pour B et la fonction qui envoie b à lstar (B R l b1 b) et la fonction qui envoie b à R (b b2).postulate ex2 : (b1 : B) -> (b2 : B) -> (__ : lstar B R l + 1 b1 b) -> ex2 : B (\ b : B -> lstar B R l b1 b) (\ b : B -> R b b2)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f n + 1) -> (f (n + 1) = n + 1) -> (i : Nat) -> (le_n : Leq i n) -> (a : Nat) -> (le_n1 : Leq a n + 1) -> (f a = i) -> (a : Nat) -> (le_n2 : Leq a n + 1) -> (f a = i) -> (H : Eq a n + 1) -> Eq i a
postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)
postulate let_clause_15692 : cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))
postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i, j : Nat) -> (ii : Nat) -> (aj : Nat) -> (aj0 : Nat) -> (_ : Nat -> Leq i0 n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (matita_basics_bool.notb (matita_basics_bool.andb (matita_arithmetics_nat.notb _n) _b)) m) (matita_basics_bool.andb (matita_basics_bool.notb (matita_basics_bool.andb (matita_arithmetics
postulate noLabel_4 : soit x : R -> and (and (Lt 0 x) (Lt x 1)) -> Eq (plus (minus (pow x 2) (times 2 x)) (times 2 x)) 0
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (auto : Eq m n) -> (auto' : Eq (gcd p m) (gcd p m)) -> (auto'' : Eq (gcd p m) a (gcd p m)) -> (auto''' : Eq (gcd p m) a b) -> (auto'''' : Eq (gcd p m) a (gcd p m)) -> (H : Eq (gcd p m) a b) -> (H' : Eq (gcd p m) a (gcd p m)) -> (H'' : Eq (gcd p m) a b) -> Eq (gcd p m) a b
postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate soit : (_ : Nat) -> (__1 : Nat) -> Nat
postulate lt_to_leb_false : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)
postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics
postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : mod n m) -> (__1 : p_ord_aux (p, n / m, m)) -> (__2 : p_ord_aux (p + 1, n, m)) -> mk_Prod Nat Nat q r
postulate låt : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)
postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f x_1075) (matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.leb _b m)) (matita_basics_bool.notb (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)))))) -> (x_1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univ
postulate Nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)
postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))
postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)
postulate let_clause_1617 : let p m n : Nat\n  and (Lt 0 p) (Eq (gcd p m) 1) (div m n) (Eq (times m n) (times p c))
postulate let_clause_1033 : nat (n) (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x251
postulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> bool Soient p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soient Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2 : (_ : Nat) -> Eq (p1 n1) true) -> (p1 : (_ : Nat) -> Eq (p1 n1) true) -> (xpostulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> bool Soient p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soient Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus
postulate op : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A
postulate ACop_rect_Type4_body : soit A un élément de cic.Univ univs.Type0. Soit _nil un élément de cic.Term univs.Type0 et A. Alors pour toutes les fonctions Q_ des _x_891 de cic.Term univs.Type0 et (matita_arithmetics_bigops.ACop A _nil) à des éléments de cic.Univ univs.Type4, pour toutes les fonctions _H_mk_ACop des (aop de cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) des (_comm de (a de cic.Term univs.Type0 A) et (b de cic.Term univs.Type0 A)) à des éléments de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a)) (cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm)) x_891))
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (auto : Eq m (times 2 a)) -> (auto' : Eq m (plus (times 2 a) 1)) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Ha : Lt 1 (plus (times 2 a) 1)) -> (Hx2515 : Lt a 0) -> (Hx2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (divnm : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n m d) -> Eq 0 n
postulate let_clause_10334 : soit n un nombre naturel. Supposons que 0 est inférieur a n. Soit x2515, x2516 \in N. Alors x2515 est egale à la somme du produit de x2516 et du quotient de x2515 et de x2516 et de modul x2515 x2516.
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_clearme : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : Eq m 2 a + 1) -> (Ha : Lt 1 2 a + 1) -> (Ha0 : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (1 : Eq n m) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (auto : Eq c n - d m = 1) -> (auto' : Eq (minus (times d m) (times c n)) 1) -> (auto'' : Eq c n - d m = 1) -> Eq n m
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))
postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m
postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)
postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))
postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (j : Leq m) -> (__2 : permut f m) -> permut (\ n : Nat -> transpose i j (f n)) m
postulate noLabel_20 : (a : Int) -> (c : Int) -> (u : not (odd a)) -> (v : not (odd c)) -> Eq (plus a b) (plus b c)
postulate let_clause_1033 : let n : Nat in Låt p1 och p2 vara funktioner från naturliga tal till sanningsvärden. Låt g1 och g2 vara funktioner från naturliga tal till naturliga tal. Låt n1 : Nat in Låt Hind : (i : Nat) -> (lt i n1) -> (__1 : Eq p1 (i)) -> Eq p2 (i) -> (__1 : Nat -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i g2) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate minus_minus_associative : soit x, y, z : N -> (_ : Lt z y) -> (__1 : Lt y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)
postulate le_inv_plus_l : let x : cic.Term univs.Type0 matita_arithmetics_nat.nat in let y : cic.Term univs.Type0 matita_arithmetics_nat.nat in let z : cic.Term univs.Type0 matita_arithmetics_nat.nat in let __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))
postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate let_clause_16003 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : N) -> (_clearme : ex Nat (\ d : Nat -> (\ E : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (times m n) (minus (times m d) (times n c))
postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> or (Lt m i) (Lt i m)
postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0
postulate let_clause_1033 : soit n un nombre naturel. supposons que la puissance de 2 et de 7 est inférieure ou àgale à n. soit p un nombre naturel. supposons que la somme de la racine carrée du produit de 2 et de n et de 1 est inférieure ou àgale à p. supposons que p est inférieur à la somme du produit de 2 et de n et de 1. supposons que lebbeau 2 et kbeau le produit de 2 et n et p est égal à true. alors si le produit de 2 et de n est inférieur à la puissance de p et de 2, alors pour tous les nombres naturels x2515 et x2516, x2515 est égal à la somme du produit x2516 et du quotient de x2515 et de x2516 et de mod x2515 x2516.
postulate mod_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p))
postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)
postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : list_divides (l, n)) -> ex Nat (\ p : Nat -> (\ _ : divisible p n) -> p)
postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (posn : Eq m 2 a) -> (posn1 : Eq m 2 a + 1) -> (posn2 : Eq 1 2 a + 1) -> (Hind0 : Lt 2 a + 1) -> (Hind1 : Lt 0 2 a) -> (Hind2 : Lt a 2) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)
postulate lt_S_S_to_lt : låt n m vara naturliga tal. då om n + 1 < m + 1, så n < m
postulate max_cases : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) f n) matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) n)) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) f n) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) (matita_arithmetics_minimization.max n f)))
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (gcd : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq m d (gcd m n)
postulate min_not_exists : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) (contradiction)) -> Eq (min n b f) (plus n b)
postulate Dop_rect_Type2_body : soit A un élément de cic.Univ univs.Type0. soit _nil un élément de cic.Term univs.Type0 et de A. Alors pour toutes les fonctions Q_ des éléments _x_951 de cic.Term univs.Type0 et de matita_arithmetics_bigops.Dop A _nil à des éléments de cic.Univ univs.Type2, pour toutes les fonctions _H_mk_Dop des éléments sum de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) des fonctions prod __ : cic.Term univs.Type0 A des éléments __1 de cic.Term univs.Type0 A et des cic.Term univs.Type0 A et __ : cic.Term univs.Type0 A des cic.Term univs.Type0 A, des cic.Term univs.Type0 A des cic.Term univs.Type0 A et (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> Q_ (matita_arithmetics_bigops.aop__o__op A _nil sum b c)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (same : Eq 1 (gcd p m)) -> (c : Nat) -> (nm : Nat) -> (auto : Eq m n) -> (auto' : Eq (times m n) p) -> (auto'' : Eq c (Nat (gcd p m) (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (auto' : Eq b (Nat p (gcd p m))) -> (auto'' : Eq (times p m) n) -> (auto''' : Eq c (Nat (gcd p m) (Eq (minus (times a p) (times b m)) (gcd p m))) (Eq (minus (times b m) (times a p)) (gcd p m))) -> Eq (times p m) n
postulate let_clause_1569 : soit m, n, a, b \in N. supposons que 0 est inférieur à n. supposons que 0 est inférieur à m. supposons que le diviseur commun plus grand de n et de m est égal à 1. soit c \in N. soit _clearme : ex Nat (\ d : Nat -> disjonct ( Eq ( minus ( times c n) ( times d m)) 1) ( Eq ( minus ( times d m) ( times c n)) 1)) soit d : Nat. supposons que la différence du produit de c et de n et du produit de d et de m est égale à 1. ou la différence du produit de d et de m et du produit de c et de n est égale à 1. alors si la différence du produit de c et de n et du produit de d et de m est égale à 1, alors la différence du produit de n et de c et du produit de m et de d est égale à 1.
postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)
postulate let_clause_1033 : soit n un nombre naturel. Soient p1 et p2 des fonctions des nombres naturels à des valeurs booléennes. Soient g1 et g2 des fonctions des nombres naturels à des nombres naturels. Soit n1 un nombre naturel. Soit Hind une fonction des fonctions des nombres naturels i et des éléments de Lt de i et n1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Eq de p2 (i) et true et des fonctions __1 des nombres naturels i et __1 de Lt de i et n1 et des éléments __2 de Eq de p1 (i) et true à des éléments de Leq de g1 (i) et g2 (i) à des éléments de Leq de bigop applied to n1 and the function which envoie i to p1 applied to i and Nat 0 plus the function which envoie i to g1 applied to i and bigop applied to n1 and the function which envoie i to p2 applied to i and Nat 0 plus the function which envoie i to g2 applied to i. Soit H1 une fonction des nombres naturels i et des éléments de Lt de i n1 + 1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Eq de p2 (i) et true. Alors pour toutes les fonctions H2 des nombres naturels i et des éléments de Lt de i n1 + 1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Leq de g1 (i) et g2 (i) si p2 (n1) = true, si p1 (n1) = true, alors pour tous les nombres naturels x2515 et x2516, x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)
postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (divnm : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0
postulate log_exp2 : let p : Nat -> n : Nat -> m : Nat -> anta att 1 < p -> då om 0 < n -> m log_ p n <= log_ p (n ^ m))
postulate let_clause_10331 : let n : Nat in let (a : Nat) -> let (m : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let (s : Nat) -> let (t : Nat) -> let (u : Nat) -> let (v : Nat) -> let (w : Nat) -> let (x : Nat) -> let (y : Nat) -> let (z : Nat) -> let (a : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let (s : Nat) -> let (t : Nat) -> let (u : Nat) -> let (v : Nat) -> let (w : Nat) -> let (x : Nat) -> let (y : Nat) -> let (z : Nat) -> let (a : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let (
postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> Lt p m) -> (__1 : Lt 1 p) -> (Leq : (Psi : Nat) -> pred p) -> (a : Nat) -> or (and (Leq m 2 a) (and (Lt 1 2 a) (and (Lt a 2) (pow 2 (2 * p))))) (and (Lt 1 2 a) (and (Lt a 2) (pow 2 (2 * p))))
postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)
postulate ord_O_to_not_divides : let (p : Nat) -> (m : Nat) -> (posp : Lt 0 m) -> (primp : prim p) -> (H : Eq (ord m p) 0) -> not (divisible p m)
postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (dividesb (d, n) true) -> Eq (dividesb (n \ div d) n) true
postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (one : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq c n) (Eq d m)) -> (H : Eq (times d m) c) -> Eq (times m d) n
postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> Prop) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) (contradiction m (found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) (contradiction m (found_max_spec _n _f m x_975 x_974 x_973))) -> (_H : (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (eqm : Lt 0 m) -> (gcd : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq m d
postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times b a)) (matita_arithmetics_nat.times (matita_arithmetics_nat
postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)
postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> x134 + (x135 + x136) = x135 + (x134 + x136)
postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (Hn : Lt n m) -> (Hp : Lt p q) -> (Hq : Lt 0 q) -> and (Lt n p) (Lt m q)
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (lea : Leq a n) -> (fa : Eq (f a) i) -> (ab : Nat) -> (lb : Leq a n) -> (fb : Eq (f a) i) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> injf : injn f n -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt n 0) -> (posm : Lt m 0) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hm : Eq (minus (times d m) (times c n)) 1) -> Eq m d n
kpostulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\ _ : Nat -> Nat)) (\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk (h k) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (k : (_ : Nat) -> Nat) -> (B0 : Set) -> (k0 : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1) (\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk (h k) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (i : Nat) -> (j : Nat) -> (k : (_ : Nat) -> Nat) -> (l : (_ : Nat) -> Nat) -> (_clearme2 : and (and (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n1)
postulate div_mod_spec_rect_Type3_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> Då för alla funktioner Q_ från (_x_821 : div_mod_spec _n _m _q _r) till Type3, för alla funktioner _H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)
postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))
postulate iter_body : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H
postulate lt_n_nth_prime_n : soit n N. alors n < nth_prime n
postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)
postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))
postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1
postulate monotonic_sqrt : monotonic Nat Leq sqrt
postulate plus_minus : soit m : Nat, n : Nat, p : Nat -> (le m n) -> Eq n (m + p)
postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq false (f n)) -> (__2 : Leq (max m f) n) -> Lt (max m f) n
postulate Dop_rect_CProp1_body : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965
postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)
postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)
postulate lstar_ind_body : soit B un ensemble. soit _R un element de relation de B. soit Q_ une fonction des nombres naturels x_1233 et des elements x_1232 de B et des elements x_1231 de B et des elements _x_1234 de lstar de B _R x_1233 x_1232 x_1231 et des propositions. soit _H_lstar_O une fonction des elements b de B a des elements Q_ 0 b b et b et lstar_O (B _R b). soit _H_lstar_S une fonction des elements b1 de B et des elements b de B et des elements x_1236 de _R b1 b et des nombres l et des elements b2 de B et des elements x_1235 de lstar de B _R l b b2 et des elements _x_1238 de Q_ l b b2 x_1235 et des elements Q_ l + 1 b1 b2 lstar_S (B _R b1 b x_1236 l b2 x_1235). soit x_1233 in N. soit x_1232 et x_1231 des elements de B. soit x_1234 un element de lstar de B _R x_1233 x_1232 x_1231. alors Q_ tient pour x_1233 x_1232 x_1231 x_1234.
postulate let_clause_15621 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (D : Eq 0 n) -> (posc : Eq 0 m) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))
postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (__ : ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p
postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B
postulate lt_SO_smallest_factor : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))
postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq B (2 n) 2 ^ pred (2 n)
postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (divisible p m)) -> not (Eq (ord m p) 0)
postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat
postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m
postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (prime : prim n) -> (lt0m : Lt n m) -> (divn : divisible n m) -> Lt (ord_rem m n) m
postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)
785postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)
postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat
postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)
postulate låt : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)
postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n
postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : Aop B nil) -> Nat) -> (f : (_ : Nat) -> B) -> (a : Nat) -> (b : Nat) -> (leb : (_ : Nat) -> (_ : Nat) -> bool) -> (i : Nat) -> andb (leb a i) (p i B nil op B nil op) (\ i : Nat -> f i) (bigop (b i) (\ i : Nat -> andb (leb a i) (p i)) B nil op B nil op) (\ i : Nat -> (\ i0 : Nat -> p i0) (sum i a) B nil op B nil op) (\ i : Nat -> (\ i0 : Nat -> f i0) (sum i a))
postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate fact_to_exp : soit n : Nat -> ainsi la factorielle du produit de 2 et de n est inférieure ou àgale au produit du produit de la puissance de 2 et de (pred (times 2 n)) et de la factorielle de n et de la factorielle de n.
postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A des propositions) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915) -> (x_915 : range _A) -> Q_ x_915
postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd p n)) -> (Hm : Eq (gcd p (times n m)) (gcd p (times n m))) -> Eq (gcd p m) (gcd p n)
postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (ant : prim p) -> (H : Lt (plus m 1) p) -> (ltml : Lt p (plus (times 2 m) 1)) -> Eq p (div m (times m 2))
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eqn : Eq 1 (div (comm p m) m)) -> (divp : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))))) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\ _ : Eq (minus (times a p) (times b m)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (H : Eq (div (times a b) (times m n)) (div (times p m) (times (div p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m))))) -> (H0 : Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (H1 : Eq (div (times a b) (times m n)) (div (times p m) (times (div p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))))) -> (H2 : Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m
postulate le_S_times_2 : soit n : Nat -> suppos (Eq 0 n) (Lt (plus n 1) (times 2 n))
postulate exp_to_log_r : sont_b_n_m : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Lt (pow b n) m) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m
postulate noLabel_15 : forall n, (odd n) -> (plus (times 4 (pow n 3)) (times 2 n)) 1
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ltml : Lt 0 p) -> (eqn1 : Eq 1 (gcd p m)) -> (ltml2 : Eq p (gcd m n)) -> (p : Nat) -> (c : Nat) -> (nm : Eq m n) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> Eq (p : Nat) (c : Nat) -> Eq (m : Nat) n)) -> (b : Nat) -> (_clearme1 : Eq (gcd p m) (gcd p m)) -> (Hc : Eq (gcd p m) (gcd p m)) -> Eq (gcd p m) (a : Nat) -> Eq (gcd p m) (b : Nat) -> Eq (gcd p m) (a : Nat)
postulate låt : (x1 : Mngd) -> (x2 : Mngd) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Påstånd) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> Hterm
postulate let : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop
postulate checker_abl : soit a, b \in N. soit l une liste de nombres naturels. alors si checker (cons (Nat, a, cons (Nat, b, l)))= true, alors a < b, b \leq 2 a et checker (cons (Nat, b, l))= true
postulate permut_S_mod : (n : Nat) -> permut (S_mod n + 1) n
postulate example12 : Eq (nth_prime 3) 7
postulate let_clause_1033 : let n : Nat -> (p : Nat) -> (leb : Lt (pow 2 7) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1) -> (p : Nat) -> (leb2 : Lt (pow 2 n) p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1) -> (leb3 : Lt (pow p 2) (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1)
postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n p + m) -> Lt n m
postulate noLabel_8 : forall n : Nat -> beq (plus n (div 1 n)) 2 -> Lt (plus (pow n 2) (div 1 (pow n 2))) 4
postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)
postulate let_clause_10331 : (n : Nat) -> (le_n : Leq (pow 2 8) n) -> (m : Nat) -> (lt_m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875
postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (posn : Lt 0 n) -> (posp : Lt 0 p) -> (H : Eq 1 (div (gcd m (times n p)) (gcd m p))) -> Eq 1 (gcd m n)
postulate leb_false_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Eq (contradiction (leb n m)) (not (infelible n m))) -> not (infelible n m)
postulate let_clause_16003 : let m n a b : N
postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)
postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P x_773)
postulate k1 : let n : Nat, p : Nat -> let (le18 : Leq n p) (le : Lt p n) -> let (lt2np : Lt 2 n) (p : Nat) -> Eq (k (2 n, p)) 0
postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)
postulate true_to_le_min : låt f vara en funktion från naturliga tal till sanningsvärden. låt n och m och b vara naturliga tal. Då om b leq m och f (m) = true, så min (n, b, f) leq m
postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))
postulate noLabel_34 : (x : Int) -> if (even (plus (times 7 x) 4)) (odd (minus (times 3 x) 11))
postulate pi_1 : soit n un nombre naturel. Alors pour toutes les fonctions p des nombres naturels à des valeurs booléennes, 1 est égal à bigop n (p i) (Nat 1 times (\ i : Nat -> p i)) Nat 1 times (\ i : Nat -> 1))
postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)
postulate p_ord_p : soit p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))
postulate lt_SO_to_le_B_exp : låt n : N -> anta att 1 < n -> Då är B (produkten av 2 och n) mindre eller lika med potensen av 2 och pred (produkten av 2 och n)
postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (ltm : Lt m t) -> (f_m : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m
postulate True_rect_Type3_body : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)
postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> min (n, b, f) = m
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> (_ : Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq _f i) -> (Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 -> x_972) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p1 i) -> Nat 0 plus (\ i : Nat -> g1 i)) -> (H1 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (n1 : Nat) -> true) -> (p1 : (n1 : Nat) -> true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)
postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (Hn1 : Leq n1 n2) -> (Hm1 : Leq m1 m2) -> Leq n1 m1 n2 m2
postulate nat_inv_rect_Type2 : låt Hterm : N. låt P : (_z671 : Nat) -> Type2. då för alla funktioner _H1 : (_z672 : Eq Hterm 0) -> P 0, för alla funktioner _H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)
postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)
postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n
postulate let_clause_1648 : let n : Nat -> let q : Nat -> let n1 : Nat -> let sum : (p : Nat) -> let p : (m : Nat) -> andb (leb 1 m) (dividesb q m) -> Nat 0 plus (\ m : Nat -> 1) q -> (q : Nat) -> Eq (mod n1 q) n1
postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (x + (y - z)) (x + y - z)
postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> list_of_primes n -> cons Nat 2 (tail Nat (list_of_primes n))
postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)
postulate let_previous_prime7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate pred_Sn : (n : Nat) -> Eq n (pred (plus n 1))
postulate let_upper_bound7 : soit n m : Nat -> (H : Lt (nth_prime n) m) -> Nat
postulate ACop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)
postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)
postulate theta_pi_p_theta : (m : Nat) -> Eq (times (bigop (plus (times 2 m) 2) (\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\ p : Nat -> p)) (theta (m + 1))) (theta (2 m + 1))
postulate noLabel_5 : forall n, (min (abs (minus n 1)) (abs (plus n 1))) -> (Leq (abs (minus (pow n 2) 1)) 4)
postulate nat_inv_rect_CProp2 : låt Hterm vara ett naturligt tal. låt P vara en funktion från naturliga tal _z701 till påståenden. låt _H1 vara en funktion från element _z702 av Eq Hterm 0 till element av P 0. låt _H2 vara en funktion från naturliga tal x_406 och funktioner _x_408 från element _z702 av Eq Hterm x_406 till element av P x_406 och element _z702 av Eq Hterm (plus x_406 1) till element av P (plus x_406 1). då håller P Hterm.
postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> Prop) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> f i)) (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> pow (f i) m))
postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> (_ : Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq _f i) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> Q_ x_971 x_972
postulate let_clause_1551 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x347 : Nat) -> Eq n (times x347 n)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Lt n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) (contradiction)) (Eq (f i) nil)) -> bigop n (\ i : Nat -> p i) B nil op (\ B : Set -> nil) op (\ i : Nat -> f i) (bigop k (\ i : Nat -> p i) B nil op (\ B : Set -> nil)) op (\ i : Nat -> f i)
postulate same_bigop : soit k : Nat -> soit p1 : (_ : Nat) -> soit p2 : (_ : Nat) -> soit B : Set -> soit nil : B -> soit op : (_ : B) -> (__1 : B) -> B -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\ i : Nat -> p1) B nil op (\ i : Nat -> f) (\ i : Nat -> g)) (bigop k (\ i : Nat -> p2) B nil op (\ i : Nat -> f) (\ i : Nat -> g))
postulate exp_to_fact2 : låt n vara ett naturligt tal. Då om 0 är mindre än n, så är produkten av potensen av 2 och produkten av 2 n och potensen av fakulteten av n och 2 mindre eller lika med produkten av produkten av 2 n och fakulteten av produkten 2 n.
postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n
postulate list_divides_false : (l : list Nat) -> (n : Nat) -> Eq (contradiction (list_divides (l, n))) (p) -> (__1 : mem Nat p l) -> not (divisible p n)
postulate låt : (A : Set) -> (lätt : Nat) -> (_xxx : range A) -> (x : Nat) -> A
postulate ACop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)
postulate let_clause_10331 : let n : Nat -> let m : Nat -> let a : Nat -> let H : Lt 5 n -> let g : Nat -> let F : Nat -> let x2515 : Nat -> let x2516 : Nat -> let x2517 : Nat -> let H0 : Leq 6 a -> Lt (2 (a + 1)) 2 ^ a -> let x2518 : Nat -> let H1 : Nat -> let F0 : Nat -> let H2 : Nat -> let a0 : Nat -> let H3 : Nat -> let P : Nat -> let q : Nat -> let R : Nat -> let S : Nat -> let T : Nat -> let U : Nat -> let V : Nat -> let W : Nat -> let X : Nat -> let Y : Nat -> let Z : Nat -> let AA : Nat -> let BB : Nat -> let CC : Nat -> let DD : Nat -> let EE : Nat -> let FF : Nat -> let GG : Nat -> let HH : Nat -> let II : Nat -> let III : Nat -> let IV : Nat -> let V0 : Nat -> let W0 : Nat -> let X0 : Nat -> let Y0 : Nat -> let Z0 : Nat -> let AA0 : Nat -> let BB0 : Nat -> let CC0 : Nat -> let DD0 : Nat -> let EE0 : Nat -> let FF0 : Nat -> let GG0 : Nat -> let HH0 : Nat -> let I00 : Nat -> let II0 : Nat -> let III0 : Nat -> let IV0 : Nat -> let V10 : Nat -> let W10 : Nat -> let X10 : Nat -> let Y10 : Nat -> let Z10 : Nat -> let AA10 : Nat -> let BB10 : Nat -> let CC10 : Nat -> let DD10 : Nat -> let EE10 : Nat -> let FF10 : Nat -> let GG10 : Nat -> let HH10 : Nat -> let I100 : Nat -> let II100 : Nat -> let III100 : Nat -> let IV100 : Nat -> let V110 : Nat -> let W110 : Nat -> let X110 : Nat -> let Y110 : Nat -> let Z110 : Nat -> let AA110 : Nat -> let BB110 : Nat -> let CC110 : Nat -> let DD110 : Nat -> let EE110 : Nat -> let FF110 : Nat -> let GG110 : Nat -> let HH110
postulate le_exp1 : tous les nombres naturels n et m et a -> (0 : Nat) -> (inf : Lt 0 a) -> (_ : Leq n m) -> (__1 : Lt a n) -> Leq (pow n a) (pow m a)
postulate let_clause_16005 : soit m, n, a, b \in N
postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)
postulate le_prim_n3 : soit n un nombre naturel. supposons que 15 est inférieur ou ágal à n. alors prim (n) est inférieur ou ágal à pred (div n 2)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (auto : Eq c n - d m) -> (auto' : Eq (minus (times d m) (times c n)) 1) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))
postulate bijn_n_Sn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : f n + 1) -> bijn f n + 1
postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)
postulate let_clause_1258 : let (b : Nat) -> anta (Lt 1 b) (latt (Nat) (pow b 1)) (dagar (Nat) (and (Eq b 1) (Eq (b ^ n) b)))
postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z
postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)
postulate nat_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> (_H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378)) -> cic.Term univs.Type3 (P x_378)) -> (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm)
postulate transpose_i_j_j_i : let i : Nat -> let j : Nat -> let n : Nat -> let transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> let transpose (i, j, n) -> transpose (j, i, n)
postulate eq_ord_sigma_p : soit n, m, x : Nat -> (posn : Lt 0 n) -> (x' : Nat) -> (posm : Leq x m) -> (n' : Lt n x) -> Eq (bigop m (\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\ i : Nat -> 1)) (ord n x)
postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (P : Prop) -> (_ : Leq n m + 1) -> (P' : Prop) -> (__1 : (__1 : Leq n + 1) -> M : P) -> (__2 : (__2 : Eq n m + 1) -> P) -> P
postulate let_clause_16921 : soit m un nombre naturel. supposons que 0 est inférieur a m. alors pour tous les nombres naturels a et x358 et x359, aop__o__op nat 0 plusAC x358 (times x358 x359) = times x358 (plus x359 1)
postulate pi_p_primeb4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat
postulate divides_fact_to_divides : soit p, n : Nat
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq i n) -> (H0 : Leq j n) -> (H1 : Leq a n) -> (H2 : Leq b n) -> (H3 : Leq b n) -> (H4 : Leq (f b) j) -> (H5 : Leq b n) -> (H6 : Leq (f b) j) -> (H7 : (__ : Nat) -> (_ : Leq i0 n) -> (_ : Leq f (i0)) -> n) -> (injf : injn f n) -> (H8 : Eq a b) -> f a
postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) 1) (d m)) (Eq (minus (times d m) (times c n)) 1)) -> Eq m d - n c
postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)
postulate DPair_inv_ind : soit x1 un élément de cic.Univ univs.Type0. soit x2 une fonction des elements __ de cic.Term univs.Type0 x1 à des elements cic.Univ univs.Type0. soit Hterm un élément cic.Term univs.Type0 (matita_basics_types.DPair x1 x2). soit P une fonction (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop. soit (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)
postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)
postulate let_clause_1062 : naturala tal.
postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) (matita_basics_bool.andb (matita_basics_bool.or (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true) (matita_basics_bool.notb (matita_b
postulate congruent_ab_lt : let m : Nat, n : Nat, a : Nat, b : Nat -> Nat
postulate let_clause_16003 : let m n a b : Nat -> let n m a b : Nat -> let a b : Nat -> let c : Nat -> let _clearme : ex Nat (\ d : Nat -> if (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> let d : Nat -> let c : Nat -> let _clearme0 : ex Nat (\ e : Nat -> if (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> let e : Nat -> let f : Nat -> let g : Nat -> let h : Nat -> let i : Nat -> let j : Nat -> let k : Nat -> let l : Nat -> let m : Nat -> let n : Nat -> let o : Nat -> let p : Nat -> let q : Nat -> let r : Nat -> let s : Nat -> let t : Nat -> let u : Nat -> let v : Nat -> let w : Nat -> let x : Nat -> let y : Nat -> let z : Nat -> let aa : Nat -> let ab : Nat -> let ac : Nat -> let ad : Nat -> let ae : Nat -> let af : Nat -> let ag : Nat -> let ah : Nat -> let ai : Nat -> let aj : Nat -> let ak : Nat -> let al : Nat -> let am : Nat -> let an : Nat -> let ap : Nat -> let a0 : Nat -> let b0 : Nat -> let c0 : Nat -> let d0 : Nat -> let e0 : Nat -> let f0 : Nat -> let g0 : Nat -> let h0 : Nat -> let i0 : Nat -> let j0 : Nat -> let k0 : Nat -> let l0 : Nat -> let m0 : Nat -> let n0 : Nat -> let o0 : Nat -> let p0 : Nat -> let q0 : Nat -> let r0 : Nat -> let s0 : Nat -> let t0 : Nat -> let u0 : Nat -> let v0 : Nat -> let w0 : Nat -> let x0 : Nat -> let y0 : Nat -> let
postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (pnm : Eq 1 (gcd p m)) -> (pnm0 : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disjunk (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\ _ : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H : Eq (gcd p m) (a p - b m)) -> (H0 : Eq (gcd p m) (b m - a p)) -> (H1 : Eq (gcd p m) (b m - a p)) -> Eq (times b a) (gcd p m)) -> Eq (times b a) (gcd p m)
postulate mod_times_mod : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> mod (n p) (mod (mod n m p) p)
postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arith
postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f x_676 _pi2)) (Q_ _pi1 (matita_basics_types.mk_Sig A _f x_676 _pi2))
postulate let_clause_10331 : (n : Nat) -> (antata : Lt 5 n) -> (m : Nat) -> (lemm : Leq 6 m) -> (H : Nat) -> (a : Nat) -> (lema : Leq 6 a) -> (H0 : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) (mod x2515 x2516)
postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j (transpose i j n)) n
postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R
postulate Soit : Aunenom : EnsemeleApostulate _nil : UnelmaApostulate Q_ : (_x_865 : Aop A _nil) -> Type5 -> All (_H_mk_Aop (op _ : (_ : A) -> (__1 : A) -> A) (_nill : (a : A) -> Eq (op _ a) a) (_nilr : (a : A) -> Eq (op a _nil) a) (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865
postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> prod A nil xxx a nil
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (i0 : Nat) -> (Leq i0 n) -> (a : Nat) -> (Ha : Eq a n) -> (f : (_ : Nat) -> Nat) -> (b : Nat) -> (Hb : Eq b n) -> (f' : (_ : Nat) -> Nat) -> (Hind : injn f n) -> (Hind0 : Eq a b) -> Eq (f a) i
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eqnm : Eq 1 (div (comm p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m)
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ H : Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) m) (times c n))) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> (\ H : Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) m) (times c n))) -> (H : Eq c n - d m) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))
postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)
postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1496 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> (x_8590 : Lt x4 x2) -> (x_8580 : Eq x1 (plus (times x3 x2) x4)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_8580)
postulate div_mod_spec_rect_Type2_body : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type2) -> (_H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> (x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type2 (Q_ x_825)
postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)
postulate let_clause_1033 : let n : Nat in let (2 : Nat) -> let (p : Nat) -> let (l : Lt (sqrt (2 n)) p) -> let (k : Nat -> Nat -> Nat) -> let (H : Lt p 2 n + 1) -> let (leb : Lt (2 n) p) -> let (H0 : Lt p 2 n) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)
postulate nth_body : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 n) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H1 : Eq c n - d m) -> (H2 : Eq (minus (times d m) (times c n)) 1) -> Eq n c - m d
postulate let : (_ : Nat) -> (__1 : Nat) -> Nat
postulate sub_lt : (A : Mngd) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> Sann) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (H : sub_hk (x : Mngd) (\ x : Mngd -> x) (\ x : Mngd -> x) A (mk_range A e n p) (mk_range A e m p))
postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> and (f m) true
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)
postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) n)
postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))
postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n + 1) -> (__1 : f n + 1) -> bijn f n
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ant : Lt 0 p) -> (same : Eq (times p m) 1) -> (c : Nat) -> Eq (times m n) (times p c) -> (a : Nat) -> Eq (times m n) (times p c) -> (b : Nat) -> Eq (times m n) (times p c) -> (H : all (_clearme0 : ex Nat (\ b : Nat -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) Eq (minus (times b m) (times a p)) (stort delar p m))) -> (H0 : all (_clearme1 : ex Nat (\ b : Nat -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) Eq (minus (times a p) (times b m)) (stort delar p m))) -> (H1 : Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m))))
postulate times_Sn_m : soit n m : N -> alors m n : N -> m + n m = (n + 1) m
postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)
postulate range_inv_rect_CProp1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1686 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1687 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)
postulate permut_S_to_permut : soit f : (_ : Nat) -> Nat -> (m : Nat) -> (_ : permut f (plus m 1)) -> (H : Eq (f (plus m 1)) (plus m 1)) -> permut f m
postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (op B nil op (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil op (\ i : Nat -> (\ i0 : Nat -> f (succ i0)) (plus i a))) (f a)) (bigop (minus (plus b 1) a) (\ i : Nat -> (\ i0 : Nat -> true) (plus i a)) B nil op (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a)))
postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905
postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> Eq n c - m d
postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div (div n d) d) d
postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> (c : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P n)
postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> Eq (Q_ (\ a : A -> Eq (op a _nil) a) (\ a : A -> Eq (op _nil a) a)) (\ a : A -> Eq (op a _nil) a)) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc) A _nil op _nill _nilr _assoc) -> (x_867 : Aop A _nil) -> Q_ x_867
postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p))) -> (__5 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p))) -> (__6 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__7 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> (__8 : cic.Term cic.prop (matita_basics
postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (posp : Lt 0 m) -> (inp : Lt 1 p) -> not (divisible p (ord_rem m p))
postulate let_clause_1648 : soit n, q : N
cdpostulate let_clause_16171 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term univs.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term univs.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term un
postulate Mk_Dop : (A : Mngd) -> (nil : A) -> (sum : ACop A nil) -> (Dop : (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil) -> Dop A nil
postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))
postulate let : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P (matita_basics_bool.true))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P (matita_basics_bool.false))) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))
postulate nat_ind : soit Q_ une fonction des nombres naturels _x_365 à des propositions. Soit _H_O un élément de Q_ de 0. Alors pour toutes les fonctions _H_S des nombres naturels x_366 et des éléments _x_368 de Q_ de x_366 à des éléments de Q_ de la somme de x_366 et 1, pour tous les nombres naturels x_365, Q_ tient pour x_365.
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (d : Nat) -> (auto : Lt 0 n) -> (auto' : Eq 0 m) -> (auto'' : Eq n m) -> let (d : Nat) -> (auto'' : Eq 0 m) -> Eq 0 n
postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (op B nil op (bigop n (\ i : Nat -> true) B nil op (\ i : Nat -> f (plus i 1)) (f 0))) (bigop (plus n 1) (\ i : Nat -> true) B nil op (\ i : Nat -> f i))
postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)
postulate le_n_8_to_le_Psi_exp : låt n : Nat -> då om n <= 8 så Psi n <= 2 ^ (2 n - 3)
postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879
postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate nat_elim1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P n)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (Hind : and (Leq i n) (Leq j n)) -> (b : Nat) -> (Hind0 : and (Leq b n) (f (b))) -> (Hind1 : and (Leq b n) (f (b))) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (Hind2 : Eq a b) -> f a
postulate div_mod_spec_inv_rect_Type3 : let x1 : N, x2 : N, x3 : N, x4 : N -> let Hterm : div_mod_spec x1 x2 x3 x4 -> let P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3 -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm
postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt n m) -> (posm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (H : Eq (minus (times d m) c) n) -> Eq m d
postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.range a1)
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (len : Leq n k) -> (j : Nat) -> (le : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))
postulate Aop_inv_rect_CProp4 : (x1 : Mngd x1) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Påstånd) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> håller P Hterm
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (H : Leq i n) -> (j : Nat) -> (a : Nat) -> (H' : Leq a n) -> (f' : (_ : Nat) -> Nat) -> (b : Nat) -> (H'' : Leq b n) -> (H' : f' b = j) -> (H : all (\ i0 : Nat -> Leq i0 n) (\ f : (_ : Nat) -> Nat) -> (\ i : Nat -> Leq f i0) n) -> (\ injn : injn f n) -> (a : Nat) -> (H : Eq a b) -> f' a
postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> let (x1106 : Nat) -> x1106 = x1106 - m
postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (x : prime x) -> (H : Leq (pow x m) n) -> (n : Nat) -> Eq (ord n x) (bigop m (\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\ i : Nat -> 1))
distrpostulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)
postulate eq_p_ord_q_O : soit p, n, q : N -> quebe (Eq (p_ord n p) (mk_Prod Nat Nat q 0)) -> and (Eq n 0) (Eq q 0)
postulate congruent_times : soit n, m, n1, m1, p : N -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent n (times n m) n1 (times m m1) p
postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i n + b) -> Eq (f i) false) -> Eq (min n b f) n + b
postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) n i
postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)
postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) (contradiction)) (Eq (f i) nil)) -> Eq (bigop k (\ i : Nat -> p i) B nil op) (bigop n (\ i : Nat -> p i) B nil op) (\ i : Nat -> f i)
postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)
 påpostulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (x = y) -> match_div_mod_spec a1 a2 a3 a4 (Type2 + 1) (\ _ : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ __ : univ Type2 -> (\ t0 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ t1 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ __ : univ Type2 -> (\ u0 : div_mod_spec a1 a2 a3 a4 -> (\ u1 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u2 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u3 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u4 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u5 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u6 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u7 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u8 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u9 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u10 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u11 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u12 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u13 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u14 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\ u15 : div_mod_spec a1 a2 a3
_Aoppostulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (Q_ : (matita_arithmetics_bigops.mk_Aop A _nil) -> cic.Univ cic.prop) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil) (op _nil a) a)
postulate nat_ind_body : soit Q_ une fonction des éléments _x_365 de cic.Term univs.Type0 matita_arithmetics_nat.nat à des éléments de cic.Univ cic.prop. Alors pour tous les éléments _H_O de cic.Term cic.prop (Q_ matita_arithmetics_nat.O) pour toutes les fonctions _H_S des éléments x_366 de cic.Term univs.Type0 matita_arithmetics_nat.nat et (_x_368 de cic.Term cic.prop (Q_ x_366)) de cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366)) pour tous les éléments x_365 de cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_365)
postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (antata : Eq 0 (gcd m n) (div n m)) -> (q1 : Nat) -> (nq1 : Eq n 0) -> (q2 : Nat) -> (m0 : Eq m 0) -> Eq (gcd m n) (div n m)
postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))
postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> Lt 0 a -> Lt (pow a n) (pow a m) -> Lt n m
postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)
postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (p : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posd : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (times d m) (times c n)) -> (H0 : Eq m c) -> Eq d n
postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> min n b f <= min m b f
postulate let_clause_1033 : (n : Nat) -> (lt1n : Lt 1 n) -> (H1 : (m : Nat) -> (_ : divisible m 2 * n) -> (__1 : Lt 1 m) -> Eq m 2 * n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (div (times d m) (gcd m n)) (plus m n)) -> Eq (times d m) (div (times d m) (gcd m n))
postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (_ : all (lambda nil : B) (\ op : (_ : B) -> __1) B) -> (f : (_ : Nat) -> B) -> (n : Nat) -> (ltml : or (Eq n k) (Eq n k)) -> bigop n (\ i : B -> p i) B nil op (\ i : B -> f i) (bigop k (\ i : B -> match_bool Set (\ _0 : bool -> bool) false (p i) (leb n i)) i B nil op (\ i : B -> f i))
postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)
postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> då om 1 < n, så om p_ord n (nth_prime p) är lika med mk_Prod Nat Nat q r, så är r inte lika med 0
postulate bigop_diff : soit p : (_ : Nat) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (H : p i) -> Eq (aop__o__op B nil op f i) (bigop n (\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op (\ x : Nat -> f x)))
postulate låt : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> prim p
postulate match_lstar : let B : Mngd -> let _R : relation B -> let return_sort : Sort -> let return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort -> (case_lstar_O : (b : B) -> return_type 0 b b) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : relation b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type l + 1 b1 b2) -> (_ : N) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z
postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate let_clause_1561 : soit p, m, n : Nat\n  -> (posp : Lt 0 p) -> (eqm : Eq 1 (div comm p m)) -> (pdiv : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (ac : Nat) -> (b : Nat) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) c)) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times b m) (times a p))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> Eq (p a) m b
postulate cr_pair4 : Eq (cr_pair 5 7 3 2) 23
postulate Dop_rect_Type4 : soit A un ensemble. soit _nil un élément de A. soit Q_ une fonction des _x_945 de Dop de A _nil à des éléments de Type4. Alors pour toutes les fonctions _H_mk_Dop des éléments sum de ACop de A _nil et des fonctions prod des éléments de A __1 de A à des éléments de A et des (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945
postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))
postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (Hind : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n m) -> Eq 0 n
postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853
postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)
postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0
postulate match_divides : (_n : N) -> (_m : N) -> (return_sort : Sort) -> (z : divisible _n _m) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z
postulate list_divides_false : soit l : liste Nat -> tous (fun n -> (eqn (list_divides l n) false) -> (fun p : Nat -> (__1 : mem Nat p l) -> not (divisible p n))) -> tous (\ p : Nat -> (__1 : mem Nat p l) -> not (divisible p n))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (b : Nat) -> (H : Leq a n) -> (f a) i -> (f b) j -> (H0 : Leq f b) -> (injf : injn f n) -> (H1 : Eq a b) -> f a)
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (antatt : Lt 0 n) -> (antatt2 : Lt 0 m) -> (eqn1 : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ e : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (H : Eq c n - d m) -> Eq (minus (times d m) (times c n)) 1
postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> let (posn : Lt 0 n) -> (posn0 : divisible n m) -> Eq (gcd n m) n
postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1))
postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)
postulate let_clause_1033 : (n : Nat) -> (lt1n : Lt 1 n) -> (prime2n : prime 2 * n) -> (H1 : (m : Nat) -> (_ : divisible m 2 * n) -> (__1 : Lt 1 m) -> Eq m 2 * n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) + mod x2515 x2516
postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (Hind : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))
postulate let_clause_10331 : soit n un nombre naturel. Supposons que 5 < n. Soit m \in N. Supposons que 6 \leq m. Supposons que (m + 1)^ 2 \leq 2 ^ m. Soit a \in N. Alors si 6 \leq a, alors si 2 (a + 1)+ 1 \leq 2 ^ a, alors pour tous les nombres naturels x2515 et x2516, x2515 = x2516 (x2515 \div x2516)+ mod (x2515, x2516).
postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\ i : Nat -> match_bool Set (\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op (\ i : Nat -> match_bool Set (\ __ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i))) (bigop k1 (\ i : Nat -> p1 i) B nil (op B nil op (\ i : Nat -> p1 i)) (\ i : Nat -> f i)) (bigop k2 (\ i : Nat -> p2 i) B nil (op B nil op (\ i : Nat -> p2 i)) (\ i : Nat -> g i)))
postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> let n : Nat -> let m : Nat -> let (nth_prime : (_ : Nat) -> Lt (nth_prime n) m) -> (posn : Lt m (nth_prime n + 1)) -> not (prime m)
postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_10331 : let n : Nat -> (k : Nat) -> (l : Nat) -> (lt4n : Lt 5 n) -> (auto : Eq m (min (pow (plus m 1) 2) (pow 2 m))) -> (auto' : Eq a (min (pow 2 (plus m 1)) 1)) -> (auto" : Eq x2515 (plus (times 2 (plus a 1)) 1)) -> (auto' : Eq x2516 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))) -> (auto'' : Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (clearme : div_mod_spec a b q r) -> (r : Lt r b) -> (auto : Eq a (plus (times q b) r)) -> (auto0 : (_clearme0 : div_mod_spec a b q1 r1) -> (r1 : Lt r1 b) -> Eq a (plus (times q1 b) r1)) -> (auto1 : Lt q r1) -> Eq a (plus r (times b q))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (gcd p m) (minus (times m b) (times p a))) -> Eq (gcd p m) (minus (times m b) (times p a))
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> let p : Nat in let n : Nat in let m : Nat in let zero : Lt p 1 == (max (gcd p n) m) -> (div p m)
postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> (pos : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2
postulate div_mod_spec_rect_Type5 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)
postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> div (ord_rem x p) m
postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq false (p k)) -> Eq (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate min_spec_inv_ind : let (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Sann) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Påstånd) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_z1891 : Eq x4 m) -> (_z1892 : Eq x4 (plus x1 x2)) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_z1891 : Eq x4 (plus x1 x2)) -> Eq (x3 i) (contradiktion)) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n (plus a m)) -> Leq n m
postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0
postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))
postulate let_clause_15611 : soit p, m, n : N
postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (leqn : Leq n m) -> (eqm : Leq n (plus q 1)) -> (Hind' : (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind'' : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times a n) (times b m)) (gcd_aux q m n)
postulate monotonic_lt_times_r : let c : Nat in let _ : Lt 0 c in monotonic Nat Lt (\ t : Nat -> c * t)
postulate let_clause_16005 : soit m, n, a, b : N
postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)
postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B
postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (le : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (_ : Lt m1 m2) -> and (Leq n1 n2) (Leq n2 n1)
postulate let_clause_15611 : soit p, m, n \in N. supposons que 0 < p et 1 = diviseur commun plus grand de p et m. supposons que p est divisible par m \times n. soit c un nombre naturel. supposons que m n = p c. soit a \in N. soit _clearme0 : ex Nat (\ b : Nat -> disjonct (Eq (minus (times a p) (times b m)) (diviseur commun plus grand de p m)) (Eq (minus (times b m) (times a p)) (diviseur commun plus grand de p m))) soit b \in N. supposons que le diviseur commun plus grand de p et m est égal à a p - b m ou égal à b m - a p. supposons que b m - a p = 1. alors m b - p a = 1
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (smrd : Eq (gcd p m) 1) -> (c : Nat) -> (nm : Eq (prod m n) (prod p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> Eq (prod a p) (prod b m))) -> (H : Eq (minus (prod a p) (prod b m)) (prod p c)) -> (H0 : Eq (minus (prod b m) (prod a p)) (prod p c)) -> (H1 : Eq (gcd p m) (gcd a m)) -> (H2 : Eq (gcd a p) (gcd b m)) -> (H3 : Eq (gcd p m) (gcd a m)) -> (H4 : Eq (gcd a p) (gcd b m)) -> (H5 : Eq (gcd p m) (gcd a m)) -> Eq (gcd p m) (gcd a m)
postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> and (min (max n f) (max n g)) (min (max n g) f)
postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (posn : Eq 0 l) -> Eq b1 b2
postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)
 påpostulate let_clause_15441 : let p, q : Nat -> let Hind : (m : Nat) -> (n : Nat) -> Lt 0 n -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunk Eq (minus (times a n) (times b m)) (gcd_aux q m n)) Eq (minus (times b m) (times a n)) (gcd_aux q m n))) -> let m : Nat -> let n : Nat -> (posn : Lt 0 n) -> (nm : Eq n m) -> (Hind : (a : Nat) -> ex Nat (\ b : Nat -> disjunk Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (Hindb : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> (H0 : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (times (gcd_aux q n (mod m n)) (gcd_aux q m n)) (gcd_aux q m n)
postulate enum_body : M (A : Set) -> (_xxx : range A) -> (_x_942 : N) -> (A : Set) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : letpostulate let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate
postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> Eq (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (divnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (cn : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (H : Eq (gcd p m) a p - b m) -> (H0 : Eq (gcd p m) b m - a p) -> (H1 : Eq (gcd p m) b m - a p) -> (H2 : Eq (gcd p m) (gcd a m) (gcd b m)) -> (H3 : Eq (gcd p m) a m -> Eq (gcd a m) (gcd b m)) -> (H4 : Eq (gcd p m) b m -> Eq (gcd a m) (gcd b m)) -> (H5 : Eq (gcd p m) (gcd a b) (gcd b m)) -> (H6 : Eq (gcd p m) a b -> Eq (gcd a b) (gcd b m)) -> Eq (gcd p m) (gcd a b)
postulate let_clause_1062 : soit a, b, q, r, q1, r1 \in N
postulate let_clause_10331 : soit n : Nat Soit p : (_ : Nat) -> bool Soient g1 : (_ : Nat) -> Nat Soient g2 : (_ : Nat) -> n1 : Nat Soit Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (_ : __1 : Eq p i) -> Leq g1 i) -> (g2 : (_ : Nat) -> Leq bigop n1 (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i)) -> (Hle : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p i) -> Leq g1 i) -> (Hle0 : p n1) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516
postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n
postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> då om n <= sqrt m, så n n le m
postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : p_ord n p) -> (__5 : p_ord m p) -> and (divisible b d) (and (Leq a c) (Gt d c))
postulate f_false_to_le_max : (f : (_ : Nat) -> Sann) -> (n : Nat) -> (p : Nat) -> (ex : Nat -> (_ : Eq (f n) true) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) (contradiction)) -> max n f) -> (x : Nat) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) (contradiction)) -> Leq (max n f) p
postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (f' : (_ : Nat) -> bool) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (len : Leq i n) -> (lenj : Leq j n) -> (a : Nat) -> (le : Leq a n) -> (fa : i) -> (b : Nat) -> (leb : Leq b n) -> (fb : b) -> (_ : (_ : Nat) -> Leq i0 n) -> Leq (f i0) n -> letinjf : injn f n -> (Hind : Eq a b) -> f a
postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat
postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z) (return_type z)
postulate le_or_ge : (m : Nat) -> (n : Nat) -> or (Lt m n) (Lt n m)
 depostespostulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S mat
postulate exp_ord : sont : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))
postulate lt_log2_sqrt : soit n un nombre naturel. supposons 2^6 <= n. alors log_ 2 {n} < sqrt n.
postulate distr : soit A un elemente de cic.Univ univs.Type0. Alors pour tous les elements nil de cic.Term univs.Type0 A. pour tous elements xxx de cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil). pour tous elements a et b et c de cic.Term univs.Type0 A. cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))
postulate f_ind_aux : (A : Mngd) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a
postulate succ : (_ : Nat) -> Nat
postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)
postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (Q_ : (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H : cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op __ __1) __1 __2 __3 __4 __5 __6 __7 __8 __9 __10 __11 __12 __13 __14 __15 __16 __17 __18 __19 __20 __21 __22 __23 __24 __25 __26 __27 __28 __29 __30 __31 __32 __33 __34 __35 __36 __37 __38 __39 __40 __41 __42 __43 __44 __45 __46 __47 __48 __49 __50 __51 __52 __53 __54 __55 __56 __57 __58 __59 __60 __61 __62 __63 __64 __65 __66 __67 __68 __69 __
postulate fold_sum : soit A B : cic.Univ univs.Type0\n    soit I J : cic.Term univs.Type0 (matita_basics_lists_list.list A)\n    soit nil : cic.Term univs.Type0 B\n  -> tous (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) I (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))
postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm x_390 + 1) -> P x_390 + 1) -> P Hterm
postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (lain : Leq a n) -> (fa : f a) -> (b : Nat) -> (lebn : Leq b n) -> (fb : f b) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq f (i0)) -> (injf : injn f n) -> (auto : Eq a b) -> f a
postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (n div m) (plus 1 m))
postulate not_forall_to_exists : soit P : (_ : Nat) -> Prop -> (n : Nat) -> (__ : (i : Nat) -> decidable (P i)) -> (__1 : P i) -> ex Nat (\ i : Nat -> conj (Lt i n) (\ __1 : P i -> P i))
postulate lt_log2_sqrt : let n : Nat in då om 2^6 <= n then \log_ 2 {n} < sqrt n
postulate lstar_r_inv_lstar : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar_r B R l b1 b2) -> lstar B R l b1 b2
postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq 1 (gcd p n)) -> (__2 : Eq 1 (gcd p m)) -> Eq 1 (gcd p (times n m))
postulate le_S_times_2 : soit n un nombre naturel. supposons que 0 < n. alors n + 1 <= 2 n
postulate let : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P (matita_basics_bool.true))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P (matita_basics_bool.false))) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))
postulate lhd_cons_ltl : soit A un element de cic.Univ univs.Type0. Alors pour tous les elements n de cic.Term univs.Type0 matita_arithmetics_nat.nat, pour tous les elements l de cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)
postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (le_n : Leq i n) -> not (divisible i (plus (pow n i) 1))
postulate låt : (a1 : Mngd) -> (a2 : Mngd) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> Eq x y
postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))
postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)
postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (x_370 : Nat) -> (_x_372 : Q_ x_370) -> (x_369 : Nat) -> Q_ x_369
postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)
postulate let_upper_bound5 : soit n, m : Nat -> alors (nth_prime n) < m -> Nat
postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)
postulate let_clause_1561 : let p m n : Nat\n  and (Lt 0 p) (Eq (gcd p m) 1) (Eq p (times m n))
postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (_clearme : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (cn : Eq p m \* n) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (a p - b m)) (Eq (gcd p m) (b m - a p))) -> (H : Eq (gcd p m) (b m - a p)) -> (H0 : Eq b m - a p) -> Eq m b - p a
postulate nat_inv_rect_Type2 : soit Hterm un nombre naturel. Alors pour toutes les fonctions P des nombres naturels _z671 à des éléments de Type2, pour toutes les fonctions _H1 des éléments _z672 de Eq Hterm 0 à des éléments de P 0, pour toutes les fonctions _H2 des nombres naturels x_382 et des fonctions _x_384 des éléments _z672 de Eq Hterm x_382 à des éléments de P x_382 et des éléments _z672 de Eq Hterm (plus x_382 1) à des éléments de P (plus x_382 1), P Hterm.
postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> Q_ x_1075 x_1076
postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)
postulate let_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (ltml : Lt n m) -> or (and (Ltml n m) (and (Leq n m) (Eq n m)))
postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))
postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n
postulate p_ord_exp1 : tous les nombres naturels p et n et q et r et (si 0 < p et p n'est pas divisible par r) (si n = p ^ q r) alors p_ord (n, p) = mk_Prod Nat Nat q r
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posd : Eq (minus (times c n) (times d m)) 1) -> (H : Eq (minus (times c n) (times d m)) (times c n)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (gcd m n) (minus (times m d) (times n c))) -> Eq (gcd m n) (minus (times m d) (times n c))
apostulate let_clause_1544 : let p q : Nat -> let Hind : (m : Nat) -> (n : Nat) -> Lt 0 n -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunk (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> let m : Nat -> let n : Nat -> (posn : Lt 0 n) -> (same : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (b : Nat) -> (Hindb : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind0 : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> (Hind1 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind2 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind3 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind4 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind5 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind6 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind7 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind8
postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (posn : Lt n m) -> not (Leq m n)
postulate let_clause_16002 : let m n a b : N -> anta that 0 < n -> anta that 0 < m -> då (smilarsoma n m) (samep (samep n m) 1) (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) (times (times d m) (times c n))) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (times (times d m) (times c n)) 1) -> Eq (smilarsoma m n) (minus (times m n) (times d m))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eqn : Eq 1 (div (comm : max p m) m)) -> (c : Nat) -> (posm : Eq m n) -> (c0 : ex Nat (\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : max p m) m)) (Eq (minus (times b m) (times a p)) (div (comm : max p m) m)))) -> (b : Nat) -> (_clearme0 : ex Nat (\ _ : Nat -> Eq m n)) -> (posn : Eq (div p m) a) -> (H : Eq (div p m) b) -> (H0 : Eq (div p m) b) -> (H1 : Eq m n) -> (H2 : Eq b m) -> Eq (div p m)
postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type m + 1) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (op (op a b) c))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)
postulate noLabel_41 : Nous pouvons démontrer que la somme de la somme de la puissance de n et de 2 et du produit de 3 et de n et de 5 est impaire pour chaque entier n.
postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)
postulate let_clause_1033 : soit n un nombre naturel. soit (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : N) -> (Hind : (_ : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) -> (p2 : (_ : Nat) -> Eq i true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate ACop_rect_Type4_body : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> (x_891 : ACop A _nil) -> Q_ x_891
postulate True_inv_rect_CProp4 : soit Hterm un élément de cic.Term cic.prop matita_basics_logic.True ; Soit P une fonction des éléments _z161 de cic.Term cic.prop matita_basics_logic.True à des éléments de cic.Univ cic.prop ; Alors pour toutes les fonctions _H1 des éléments _z162 de cic.Term cic.prop matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I à des éléments de cic.Term cic.prop (P matita_basics_logic.I) ; cic.Term cic.prop P matita_basics_logic.I
postulate ord_times : soit p, m, n : N -> supposons que 0 est inférieur a m. Alors si 0 est inférieur a n, alors si p est premier, alors ord applied to the product of m and n and p is equal to the plus of ord applied to m and p and ord applied to n and p
postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _pi1 _pi2) (_f _pi1) _pi2)) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)
postulate låt : (A : Mngd) -> (nil : Mngd) -> (xxx : Mngd A nil) -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngdpostulate låt : (A : Mngd) -> (nil : Mngd) -> (xxx : Mngd A nil) -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (
postulate let_clause_15692 : let m n a b : Nat\n  and ( Lt 0 n) ( Lt 0 m) ( Eq ( gcd n m) 1)
postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m
postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (log_ p n) (log_ p m)
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq p1 i) -> Leq g1 i) -> (__2 : ex Nat (\ i : Nat -> and (Lt i n) (or (and (Eq p1 i) (Lt (g1 i) (g2 i))) (and (and (Eq p1 i) false) (Eq p2 i)) (Lt 0 (g2 i)))) -> Lt (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i)) (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)))
postulate eq_fact_B : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (divcomm : Eq (gcd p m) 1) -> (div : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (divcomm p m)) (Eq (minus (times b m) (times a p)) (divcomm p m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\ _ : Eq (minus (times a p) (times b m)) (divcomm p m)) -> Eq (minus (times b m) (times a p)) (divcomm p m)) -> (H : Eq (minus (times b m) (times a p)) (divcomm p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (divcomm p m) (minus (times m b) (times p a))
postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq a n) -> (f a) = i) -> (b : Nat) -> (Hb : Leq b n) -> (f b) = j) -> (Hc : f b) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (Hind : Eq a b) -> f a
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (nm : Leq n m) -> (nm0 : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (Hind' : or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind0 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind1 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind2 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind3 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n)))
postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (l : ex Nat (\ a : Nat -> disjunkion (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (auto : or (Eq n0 2 a) (Eq n0 2 a + 1)) -> (auto' : Eq n0 2 a + 1) -> (auto'' : Eq n0 2 a) -> (auto''' : n0 = a + (a + 1))
postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate injective_compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (x : (__ : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__1 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (g x))) -> (__2 : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__3 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (g x))
postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ m + 1) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418
postulate prop50 : not (and (even n) (prime n))
postulate let_clause_15624 : let m : Nat and n : Nat and a : Nat and b : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 n) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) c) n)) -> (H1 : Eq (minus (times d m) c) n) -> Eq m n
postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z
postulate bigop_body : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H
postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n p + q
postulate let_clause_16005 : let m n a b : Nat -> let n m : Nat -> let a b : Nat -> let c : Nat -> let _clearme : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let d : Nat -> let m : Nat -> let n : Nat -> let _clearme0 : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let d0 : Nat -> let m0 : Nat -> let n0 : Nat -> let _clearme1 : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m1 : Nat -> let n1 : Nat -> let c1 : Nat -> let _clearme2 : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m2 : Nat -> let n2 : Nat -> let c2 : Nat -> let _clearme3 : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m3 : Nat -> let n3 : Nat -> let c3 : Nat -> let _clearme4 : ex Nat (\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 
postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> sann) -> (p2 : (_ : Nat) -> sann) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq p1 (true)) -> Eq p2 (true)) -> (__1 : (_ : Nat) -> (__1 : Lt i n) -> (__2 : Eq p1 (true)) -> Leq g1 i g2) -> (__2 : ex Nat (\ i : Nat -> (\ __1 : Lt i n) -> (__2 : Eq p1 (true)) -> Lt (g1 i) (g2 i)) -> conj (conj (Eq p1 (true)) (Eq p2 i)) true) -> Lt 0 (g2 i)
postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))
postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A des propositions) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931) -> (x_931 : range _A) -> Q_ x_931
postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (pred n) n
postulate ord_times : let (p : Nat) (m : Nat) (n : Nat) -> Nat\n  and (Lt 0 m) (and (Lt 0 n) (Eq (ord (times m n) p) (plus (ord (times m p) (ord n p)))))
postulate låt : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (H : Eq (f n) 0) -> (auto : Leq (max m f) n) -> Lt (max m f) n
postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)
postulate injn_Sn_n : let f : (_ : Nat) -> Nat -> let n : Nat -> let _ : injn f (plus n 1) -> injn f n
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Pont) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate bool_inv_rect_Type3 : soit (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)
postulate let_clause_1573 : let n : Nat -> let m : Nat -> (n : Nat) -> (m : Nat) -> (d : Nat) -> (H : Lt 0 n) -> (H0 : Eq 0 m) -> (H1 : Eq n m) -> Eq n m
postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (r < b) -> (a : Nat) -> (_clearme0 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q : Nat) -> (not (Leq q q1)) -> (a : Nat) -> (_clearme1 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme2 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme3 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme4 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme5 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme6 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (r < b) -> (a : Nat) -> (_clearme0 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q : Nat) -> (not (Leq q q1)) -> (a : Nat) -> (_clearme
postulate noLabel_64 : tous (entiers n) (\ _ : impair 3 n -> pair n)
postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate le_x_times_x : (x : Nat) -> Leq x (times x x)
postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (le : Leq m 6) -> (H : And (And (Leq m 6) (pow (m + 1) 2)) (pow (a : Nat) 1 (pow (2 a) 2))) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)
postulate le_sigma : soit n : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> and (bigop n (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))
postulate le_n_O_to_eq : (n : Nat) -> (_ : Leq n 0) -> Eq 0 n
postulate eq_lop : let n : Nat in let anta : Leq 1 n in let list_of_primes : (n : Nat) -> cons Nat 2 (tail Nat (list_of_primes n))
postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (auto : and (Leq i n) (Leq j n)) -> (a : Nat) -> (auto' : and (Leq a n) (Leq f a)) -> (auto'' : and (Leq a n) (Leq f a)) -> (b : Nat) -> (auto'' : and (Leq b n) (Leq f b)) -> (auto''' : and (Leq f b) j) -> (auto' : and (Leq i n) (Leq f i)) -> (auto : (_ : Nat) -> Leq (f i) n) -> (auto' : (injf : injn f n) -> and (Leq a b) (f a)) -> (auto'' : Eq a b) -> f a
postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt n m) -> (__2 : Leq n m) -> (__3 : divisible d c * m) -> (__4 : divisible d c * n) -> divisible d (c * gcd_aux p m n)
postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))
postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (Ha : Leq a n) -> (fa : f a) -> (Hb : Leq b n) -> (fb : f b) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq f (i0)) -> (injf : injn f n) -> (auto : Eq a b) -> f a
postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Sann) -> (x4 : Nat) -> (P : (_ : Nat) -> Påstånd) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P' : (_ : Nat) -> Påstånd) -> (_H1 : (m : Nat) -> (_ : Leq x2 m) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) i) -> (_z1891 : Eq x4 m) -> P m) -> (P' : (_ : Nat) -> Påstånd) -> (_H2 : (_ : x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) (contradiktion)) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4
postulate lt_sqrt_to_lt_times_r : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt m) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.times n n))
postulate match_lstar : let B : Mngd Låt _R : relation B Låt return_sort : Sort Låt return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort -> (case_lstar_O : (b : B) -> return_type 0 b b) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : relation b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type l + 1 b1 b2) -> (_ : Nat) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z
postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop (matita_arithmetics_nat.nat (\ j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat
postulate le_n_O_elim : soit n un nombre naturel. Alors si n <= 0, alors pour toutes les fonctions P des nombres naturels __1 a des propositions, pour tous les elements __1 de P de 0, P tient pour n.
postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n _q _m + _r) -> Q_ (div_mod_spec _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841
postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq n - m 0
postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)
postulate prop110 : (a : Z) -> (c : Z) -> even (plus a b) (b c)
postulate gcd_times_SO_to_gcd_SO : let (m : Nat) -> let (n : Nat) -> let (p : Nat) -> (posn : Lt 0 n) -> (posp : Lt 0 p) -> Eq 1 (gcd (div m n) (times n p))
postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))
postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))
postulate p_ord_aux_to_not_mod_O : soit p, n, m, q, r \in N
postulate min_spec_ind_body : (_n : N) -> (_b : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> Q_ x_1075 x_1076
postulate confluent1 : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.predicate A)
postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> all (P l b1)
postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)
postulate range_rect_Type0_body : (_A : Mngd) -> (Q_ : (_x_927 : range _A) -> Mngd) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927
postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813
postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)
postulate unit_rect_Type2 : soit Q_ une fonction des elements _x_503 de cic.Term univs.Type0 matita_basics_types.unit à des elements de cic.Univ univs.Type2. Alors pour tous les elements _H_it de cic.Term univs.Type2 Q_ applied matita_basics_types.it, pour tous les elements x_503 de cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type2 Q_ applied x_503.
postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)
postulate soit : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (H : not (prod Set Prop Nat (\ i : Nat -> prod Prop Prop (Lt i n) (\ _ : Lt i n -> P i)))) -> ex Nat (\ i : Nat -> P i)
postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) n (div d m)
postulate range_rect_CProp1_body : (_A : Mngd) -> (Q_ : (_x_937 : range _A) -> påståenden) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937
postulate bigop_Strue : soit k : Nat -> soit p : (_ : Nat) -> B -> all (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : p k) -> Eq (op (f k) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) (bigop (plus k 1) (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate pad_bigop1 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)
postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum b c (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum b c (matita_arithmetics_bigops.aop__o__op A _nil sum b c))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)
postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prim p) -> Eq (ord (times m n) p) (plus (ord (times m p) (ord n p)) (ord n p))
postulate SubR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop
postulate eq_gcd_times_1 : let p : Nat -> let n : Nat -> let m : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> Eq 1 (gcd p n) (gcd p m)
postulate låt : (B : Mngd) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R l + 1 b1 b2
postulate noLabel_47 : vi kan bevisa att summan av skillnaden mellan potensen av n och 2 och produkten av 3 och n och 9 är udda för varje heltal n.
postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate log_exp : sont_p n m -> (_ : Lt 1 p) -> (0 : Lt m 0) -> log_ p (p^n m) = n + (log_ p m)
postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))
postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times m d) (times n c)) 1) -> Eq (minus (times m d) (times n c)) 1
postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))
postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)
postulate soit : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat
postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (cnd : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dnd : Nat) -> (auto : Eq (times d m) n) -> (auto' : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq m n
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (lt2n : Leq n m) -> (lt2q : Leq n q + 1) -> (divnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) b) n) (Eq (minus (times b n) (times a (mod m n))) n)) -> (Hind' : or (Eq (minus (times a (mod m n)) n) b) (Eq (minus (times b n) (times a (mod m n))) n)) -> (Hind'' : Eq (minus (times a (mod m n)) n) b) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))
postulate prop90 : let n : Nat in do (if (and (prime n) (even n)) n)
postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)
postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (z : Leq _n __) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (_n : Nat) -> (__ : Nat) -> (z : Leq _n __) -> return_type z
postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> and (Lt 0 n) (Lt 0 m) (prime p) -> (H : divisible n m) -> and (divisible (ord_rem n p) (ord_rem m p))
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq (m d - n c) (gcd m n)
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (posm : Eq 1 (div (comm : greater p m) m)) -> (pnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (auto : Eq m n) -> (auto' : ex Nat (\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : greater p m) m)) (Eq (minus (times b m) (times a p)) (div (comm : greater p m) m))) (Eq (minus (times b m) (times a p)) (div (comm : greater p m) m))) -> (auto'' : Eq c (times a b)) -> (auto''' : Eq b m) -> (auto''': Eq (div (comm : greater p m) m) a) -> (auto'''': Eq (div (comm : greater p m) m) p) -> (auto'''''' : Eq p m) -> Eq (times a b) (times (div (comm : greater p m) m) (div (comm : greater p m) m))
postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)
postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (n div m m)
postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)
postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (mod n m) + 1) -> Eq (mod n m) (mod n m) + 1
postulate to_min : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i n) -> (__1 : Leq i m) -> Leq i (min n m)
postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)
postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))
postulate let_clause_1033 : soit n : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> true) -> (p2 : (_ : Nat) -> Eq (p1 (i)) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 (i)) -> Leq g1 i) -> Leq (bigop n1 (\ i : Nat -> p1 (i)) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 (i)) Nat 0 plus (\ i : Nat -> g2 i)) -> (H1 : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> Eq (p2 (i)) true) -> (H2 : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> Leq g1 i) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)
postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m
postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))
postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm
postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)
postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (div n m + 1)
postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\ m : Nat -> eqb (mod n m) 0))
postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_logic.rfl a p)) (matita_basics_logic.rfl b (matita_basics_logic.rfl c d e f g h i j k l m n o p q r
postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))
postulate let_clause_10331 : soit n : Nat -> supposons (Lt 5 n) (m : Nat) -> (H : Leq 6 m) -> (auto : (m : Nat) -> Leq 2 (m + 1)) -> (H' : Leq 6 a) -> (auto' : Leq 2 (a + 1) + 1) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) + mod x2515 x2516
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i, j : Nat) -> (l : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Leq i n) -> (j : Leq n) -> (a : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Nat) -> (f0 : (_ : Nat) -> Nat) -> (injf : injn f n) -> (Hc : Eq a b) -> (f0 : (_ : Nat) -> Nat) -> (H : Leq f i0 n) -> (Hc0 : Leq f (f i0) n) -> (Hc1 : Leq f b n) -> (Hc2 : Leq f (f b) n) -> (_e : Eq (f a) j) -> (Hc3 : Leq a b) -> (Hc4 : Eq (f a) i0) -> (Hc5 : Leq a (f n)) -> (Hc6 : Eq f (f n)) -> Eq (f (f a)) (f (f b))
postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))
postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m
postulate lstar_ind_l : soit B un ensemble. soit R une fonction des elements de B et des elements __1 de B a des propositions. soit b2 un element de B. soit P un element de relation2 Nat B. soit __ un element of P 0 b2. soit __1 une fonction des nombres naturels l et des elements b1 de B et des elements b de B et des elements __1 de R b1 b. soit __2 de lstar B R l b b2. soit __3 de P l b. soit l un nombre naturel. soit b1 un element de B. soit __2 de lstar B R l b1 b2. alors P tient pour l b1.
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (am : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : Lt 1 2 a + 1) -> (Ha : Lt a 0) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516
postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ x_370 + 1) -> (x_369 : Nat) -> (Q_ : x_369 -> Q_ x_369) -> Q_ x_369
postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (zLeqy : Leq z y) -> (yLeqx : Leq y x) -> (H : z <= y) -> (H0 : y <= x) -> x - (y - z) = x - y + z
postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959
postulate Sig_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)
postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.Aop A _nil) _nilr _assoc)) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787 (matita_basics_lists_list.mk_Aop A _nil))
postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897
postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.ACop x1 x2)) (matita_arithmetics_bigops.Dop x1 x2))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)
postulate divides_d_times_gcd : let (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> Nat\n  -> and (Lt 0 c) (div d c)\n  -> and (div d c) (div (div c m) (gcd n m))
postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 (matita_arithmetics_nat.times k1 k2)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus k1 (matita_arithmetics_nat.times k1 k2)) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.n
postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0
postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (zero : Eq 0 n) -> (d : Nat) -> (eqm0d : Eq m 0 d) -> Eq n 0
postulate let_clause_1704 : let m : Nat -> and (Lt 0 m) (Lett x1029 : Nat) -> x1029 : Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)
postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957
postulate lstar_ind_r_aux : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) -> cic.Term cic.prop (P l b2)
postulate let_clause_1575 : let m : Nat and n : Nat and a : Nat and b : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (lt1 : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (pos : Eq c d) -> (Hc : Eq n m) -> (Hm : Eq c d) -> (Hn : Eq (times d m) (times c n)) -> (Hc0 : all Nat (\ x1029 : Nat -> Eq x1029 (n c - m d))) -> Eq x1029 (x1029 (n c - m d))
postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)
postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))
postulate Sum_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)
postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (H : Lt x y z) -> and (Lt x z) (Lt y z - x)
postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))
postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (prime : prime pm) -> (__1 : primes_below l pm + 1) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> and (and (prime n) (and (Lt n pm) (Leq p (times 2 n)))) -> bertrand n
postulate match_lstar_r : let B : Mngd B let _R : relation B Då for (return_sort : Sort) (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) (case_lstar_r_O : (b : B) -> return_type 0 b b) (b : B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (l1 : lstar_r B _R l b b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (sum m1 m2) (lstar_r_S B _R l b b __ b2 __1) (__1 : B) (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z
postulate Dop_inv_rect_Type3 : (x1 : Mngd) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (Hterm : Dop x1 x2) -> (_H1 : (sum : ACop x1 x2) -> (_ : sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> (Hterm : Dop x1 x2) -> P Hterm
postulate divides_pi_p_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ain : Nat) -> (a : Nat) -> (abin : Nat) -> (fbin : (a : Nat) -> i) -> (abin0 : Nat) -> (fbin0 : (a : Nat) -> j) -> (b : Nat) -> (bin : Nat) -> (b0 : Nat) -> (fbin0 : (a : Nat) -> b) -> (Hind : Eq (f (b)) j) -> (Hind0 : (_ : (i0 : Nat) -> Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (ainf : Eq a n) -> (abinf : Nat) -> (fbin : (a : Nat) -> i) -> (abinf0 : Nat) -> (fbin0 : (a : Nat) -> j) -> (binf : (b : Nat) -> Eq (f b) j) -> (Hind1 : Eq (f (b)) j) -> (Hind2 : Eq (f a) i) -> (Hind3 : Eq a n) -> Eq (f a) j
postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (p : Nat) -> (auto : Lt 0 m) -> (auto' : not (Eq (mod n m) 0)) -> (auto'' : Eq p (p_ord_aux p (times (pow m i) n) m)) -> Eq (mk_Prod Nat Nat i n) (mk_Prod Nat Nat i n)
postulate log : (_p : Nat) -> (_n : Nat) -> Nat
postulate eq_ind_body : let A : cic.Univ univs.Type2 in let _x : cic.Term univs.Type2 A in let Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop in let _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)
postulate div_mod_spec_rect_Type2_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825
postulate le_exp_log : soit p : N -> n : Nat -> (_ : Lt 0 n) -> Leq (p (\ log_p n)) n
postulate True_rect_CProp4 : (Q_ : cic.Term cic.prop matita_basics_logic.True) -> (låt : cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ (x_54))
postulate lstar_r_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar_r B R 0 b b
postulate fmax_false : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (ltml : Lt (max n f) m) -> Eq (f m) m -> Eq m 0
postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (times d m) (times d m)) -> (H' : Eq (times d m) (times c n)) -> Eq (div m n) (gcd m n)
postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (auto : Eq (times m n) (times p c)) -> (auto' : all Nat (\ a : Nat -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (all Nat (\ b : Nat -> Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times a p) (times b m))
postulate match_div_mod_spec : _n : N -> _m : N -> _q : N -> _r : N -> Sort -> return_sort : Sort
postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)
postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1
postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop k (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i)) (bigop n (\ i : Nat -> p i) B nil (op B nil op) (\ i : Nat -> f i))
postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm
postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)
postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a)) (matita_arithmetics_bigops.bigop (matita
postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903
postulate Allr_fwd_append_sn : soit A un élément de cic.Univ univs.Type0. Soit R un élément de cic.Term univs.Type0 (matita_basics_relations.relation A). Soient l1 et l2 des éléments de cic.Term univs.Type0 (matita_basics_lists_list.list A). Soit __ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2)). Alors cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)
postulate div_mod_spec_ind_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810) x_810) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809
postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 0 m) -> (two : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ e : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (D : Nat) -> (H : Eq (times d m) (times n c)) -> Eq m d n
postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)
postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)
postulate let : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (checker : (_ : list Nat) -> bool) -> (l : cons Nat a tl) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\ nat : Nat -> pp (pp l (Lt pp p)) (Leq p (times 2 pp)))
postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (c : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m))))
postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927
postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)
postulate prop110 : forall a c, (odd a) && (odd c) -> allint b (a * b) + (c * b)
postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> M) -> (_H_O : Q_ 0) -> (x_390 : Nat) -> (_x_392 : Q_ x_390) -> (x_389 : Nat) -> Q_ x_389
postulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soit Hind : (_ : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i)) -> (H1 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2 : (_ : Nat) -> Eq (p1 n1) true) -> (p1 : (_ : Nat) -> Eq (p1 n1) true) -> let_clause_1033
postulate option_inv_ind : soit x1 un élément de cic.Univ univs.Type0. Soit Hterm un élément de cic.Term univs.Type0 (matita_basics_types.option x1). Alors pour toutes les fonctions P des éléments _z1038 de cic.Term univs.Type0 (matita_basics_types.option x1) à des éléments de cic.Univ cic.prop, pour toutes les fonctions _H1 des éléments _z1039 de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) à des éléments de cic.Term cic.prop (P (matita_basics_types.None x1)). Pour toutes les fonctions _H2 (x_587 : cic.Term univs.Type0 x1) et (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) à des éléments de cic.Term cic.prop (P (matita_basics_types.Some x1 x_587)). Et enfin cic.Term cic.prop (P Hterm)
iquéepostulate Aop_ind : soit A un élément de cic.Univ univs.Type0. soit _nil un élément de cic.Term univs.Type0 A. soit Q_ une fonction des _x_781 de cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) des éléments de cic.Univ cic.prop. alors pour toutes les fonctions _H_mk_Aop des fonctions op des __ de cic.Term univs.Type0 A et des __1 de cic.Term univs.Type0 A à des cic.Term univs.Type0 A et des (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ _x_781 (matita_basics_lists_list.Aop A _nil) des éléments de cic.Univ cic.prop)
postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq n m
postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)
postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm
postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)
postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R l + 1 b1 b2
postulate nat_inv_ind : låt Hterm vara ett naturligt tal. låt P vara en funktion från naturliga tal _z653 till påståenden. låt _H1 vara en funktion från _z654 av Eq av Hterm och 0 till P av 0. då för alla funktioner _H2 från naturliga tal x_366 och funktioner _x_368 från _z654 av Eq av Hterm x_366 till P x_366 och _z654 av Eq av Hterm x_366 + 1 till P x_366 + 1, håller P för Hterm.
postulate f_min_true : let f : (_ : Nat) -> sanningsvärden f = let n : Nat -> let b : Nat -> (_ : ex Nat (\ i : Nat -> (\ j : Nat -> (\ k : Nat -> i) (Leq b i) (Lt i (plus n b)) Eq (f i) true)))) -> (_ : Eq (f (min n b f)) true)
postulate let : (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) -> (x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type1 (Q_ x_505)
postulate p_ord_exp1 : let p, n, q, r : Nat -> and (Lt 0 p) (not (divisible p r)) -> (eqn n (p ^ q r)) -> p_ord (n, p) = mk_Prod Nat Nat q r
postulate le_sqrt_n1 : (n : Nat) -> Leq (minus n (times 2 (sqrt n))) (pow (sqrt n) 2)
postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3
postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)
postulate filter_True : soit (return_sort un element de cic.Sort) alors pour toutes les fonctions return_type des elements z de cic.Term cic.prop matita_basics_logic.True à des elements de cic.Univ return_sort) pour toutes les fonctions return des elements z de cic.Term cic.prop matita_basics_logic.True à des elements de cic.Term return_sort (return_type z)) pour tous les elements z de cic.Term cic.prop matita_basics_logic.True
postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x1) (prod b x1))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _H1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _H1))
postulate filter_lstar : cic.Univ univs.Type0 -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)
postulate div_mod_spec_ind : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809
iquépostulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p
postulate let_clause_10331 : let n : Nat -> let (5 : Nat) -> let (m : Nat) -> let (nm : Nat) -> let (H : Lt 5 n) -> let (Lm : Eq 6 m) -> let (Hm : Lt (plus m 1) 2) -> let (a : Nat) -> let (Ht : Eq 6 a) -> let (Hlt : Lt (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> let (x2515 : Nat) -> let (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))
postulate låt : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool
postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z
postulate divides_to_dividesb_true : sont n et m des nombres naturels. Alors si 0 < n, alors si n est divisible par m, alors dividesb (n, m) = true
postulate låt : (i : Nat) -> (acc : list Nat) -> (ltml : Lt 1 i) -> (__1 : primes_below acc i) -> (ltmlc : Eq (list_divides acc i) (contradiction)) -> prim i
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Ptn) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877
postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Pta) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889
postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ltml : Lt 0 p) -> (eqn : Eq 1 (gcd p m)) -> (c : Nat) -> (nm : Eq m n) -> (ac : Nat) -> (b : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> and (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (H : Eq (times b m) p) -> (H0 : Eq (times a m) p) -> Eq (times p m) (gcd p m)
postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (leina : Leq a n) -> (fa : f a) -> (b : Nat) -> (lejb : Leq b n) -> (fb : f b) -> (_ : (_ : Nat) -> Leq i0 n) -> (Hind : Leq i0 n) -> (Hindf : Leq (f i0) n) -> (Hindb : Leq b n) -> (Hindc : Leq (f b) j) -> (_clearme : and (Leq i n) (Leq j n)) -> (Hindf0 : Leq (f i) n) -> (Hind0 : Leq i n) -> (Hind1 : Leq f (f i)) -> (Hind2 : Leq n (f i)) -> (Hind3 : Leq i n) -> (Hind4 : Leq a n) -> (Hind5 : Leq f a) -> (Hind6 : Leq b n) -> (Hind7 : Leq f b) -> (Hind8 : Leq i0 n) -> (Hind9 : Leq (f i0) n) -> (Hind10 : Leq i0 n) -> (Hind11 : Leq i n) -> (Hind12 : Leq (f i) n) -> (Hind13 : Leq n (f i)) -> (Hind14 : Leq a n) -> (Hind15 : Leq f a) -> (Hind16 : Leq b n) -> (Hind17 : Leq f b) -> (Hind18 : Leq i0 n) -> (Hind19 : Leq (f i0) n) -> (Hind20 : Leq i0 n) -> (Hind21 : Leq i n) -> (Hind22 : Leq (f i) n) -> (Hind23 : Leq n (f i)) -> (Hind24 : Leq a n) -> (Hind25 : Leq f a) -> (Hind26 : Leq b n
postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 0 m) -> (two : Eq 1 (max (gcd n m) 1)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> (\ _clearme : Eq (minus (times c n) m) (times d m)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> (Hc : Eq (times d m) 1) -> (Hn : Eq n c) -> (Hm : Eq m d) -> (Hn0 : Eq (times d m) 1) -> Eq n c m
postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1))) -> cic.Univ univs.Type0
postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)
postulate le_pi : soit n : Nat\n        soit p : (_ : Nat) -> bool\n        soit g1 : (_ : Nat) -> Nat\n        soit g2 : (_ : Nat) -> Nat\n        et __ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)\n        et bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g1 i) is inferior or (bigop n (\ i : Nat -> p i) Nat 1 times (\ i : Nat -> g2 i))
postulate lstar_ind_l_aux : soit B un élément de cic.Univ univs.Type0. soit R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop. soit b2 : cic.Term univs.Type0 B. soit P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> (__ : cic.Term cic.prop P (matita_arithmetics_nat.O) b2) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop P l b) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop P l b1) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b2 b)) -> (__3 : cic.Term cic.prop P l b2) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b
postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q
postulate let_clause_16001 : soit m, n, a, b : N\n  -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (comm : Nat m n) 1) (Nat c)) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dn : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (Hm : Eq (minus (times d m) (times c n)) 1) -> (Hc : Eq (minus (times c n) (times d m)) 1) -> Eq (div m n) (minus (times n c) (times m d))
postulate lstar_ind : soit B un ensemble. soit _R un element de relation de B. soit Q_ une fonction des nombres naturels x_1233 et des elements x_1232 de B et des elements x_1231 de B et des elements _x_1234 de lstar de B _R x_1233 x_1232 x_1231 et des propositions. soit _H_lstar_O une fonction des elements b de B a des elements Q_ 0 b b et b et lstar_O (B _R b). soit _H_lstar_S une fonction des elements b1 de B et des elements b de B et des elements x_1236 de _R b1 b et des nombres l et des elements b2 de B et des elements x_1235 de lstar de B _R l b b2 et des elements _x_1238 de Q_ l b b2 x_1235 et des elements Q_ l + 1 b1 b2 lstar_S (B _R b1 b x_1236 l b2 x_1235). soit x_1233 un nombre naturel. soient x_1232 et x_1231 des elements de B. soient x_1234 un element de lstar de B _R x_1233 x_1232 x_1231. alors Q_ tient pour x_1233 x_1232 x_1231 x_1234.
postulate let_clause_1034 : let n : Nat -> m : Nat -> p : Nat -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = mod x2515 x2516 + x2516 (x2515 / x2516)
postulate nat_inv_rect_CProp0 : (Hterm : N) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm
postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))
postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p n) -> Leq p n
postulate le_exp_prim4l : lett Nat (\ n -> ett Nat) (and (Lt 0 n) (Leq 2 (pow 4 n + 1)))
postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (log p n) n
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))
postulate divides_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)
postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ t0 : Nat -> \ t1 : Nat -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\ u0 : Nat -> \ u1 : Nat -> prod (plus Type1 1) Type1 (univ Type1) (\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\ x_19 : Nat -> _x_20) t1) u0) (\ e1 : Eq (R1 (Lt a4 a2) t0 (\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\ e2 : Eq (R1 (Lt a4 a2) t0 (\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\ e3 : Eq (R1 (Lt a4 a2) t0 (\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\ e4 : Eq (R1 (Lt a4 a2) t0 (\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3
postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm
postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))
postulate divides_to_dividesb_true1 : tous les nombres naturels n m si 0 est inférieur a m alors si n est divisible par m alors dividesb n m est égal à true
postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)
postulate let_clause_16921 : (m : Nat) -> (posn : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))
postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (all : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> cic.Univ cic.prop
postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (Q_ : (_H_mk_ACop : (aop : Aop A) -> (_nil : A) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911
postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (H : Eq (minus (times d m) c) (gcd m n)) -> Eq m d (gcd m n)
postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n
postulate le_priml1 : tous les nombres naturels n, (0 < n) -> 2 n / ((log_2 n) + 2) - 1 <= prim (2 n)
postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (eqm : Eq m (min n b f)) -> (ltm : Lt m (plus n b)) -> Eq (f m) true
postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn1 : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (times n c) m
postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (posn0 : Eq 0 n) -> (posn1 : divisible 0 m) -> (q : Nat) -> (eqm0 : Eq m 0) -> (auto : Eq q 0) -> Eq m 0
postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885
postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))
postulate let_clause_1033 : soit n un nombre naturel. soit (p1 : (_ : Nat) -> bool) et (p2 : (_ : Nat) -> bool) et (g1 : (_ : Nat) -> Nat) et (g2 : (_ : Nat) -> Nat) alors pour tous les nombres naturels n1, pour toutes les fonctions Hind : (_ : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) et (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) et (Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i))) (Leq (bigop n1 (\ i : Nat -> p1 i) Nat 0 plus (\ i : Nat -> g1 i)) (bigop n1 (\ i : Nat -> p2 i) Nat 0 plus (\ i : Nat -> g2 i)))
postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z
postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (posn : Eq 0 (div m n)) -> (posn' : divisible 0 n) -> (q1 : Nat) -> (posn2 : Eq n 0 q1) -> (posn3 : divisible 0 m) -> (q2 : Nat) -> (posn4 : Eq m 0 q2) -> Eq m 0
postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\ b : Nat -> (\ p : Nat -> (\ m : Nat -> (\ n : Nat -> ( Eq (p (times n)) m) c) -> (a : Nat) -> (_clearme1 : Eq (m n) p) -> Eq (Eq (p (times b)) m) (Eq (a p) (times n b)) -> Eq (p m) (times n b)) -> Eq (b n) (times m n)) -> (H : Eq (p m) a) -> Eq (b n) (times m n)) -> (Hm : Eq (p m) a) -> Eq (b n) (times m n)) -> Eq (p m) a
postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)
postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (n : Nat) -> (j : Nat) -> (ltml : Leq n k) -> (jlt : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) (contradiction)) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Hfalse : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) (contradiction)) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop j (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> (Htrue : Eq (p n) (contradiction)) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 x2572 (x2571 div x2572) + (mod x2571 x2572)
postulate smallest_factor_to_prime : let n : Nat in let (lt : Lt n 1) in let (factorial : prime n) in n
postulate p_ord_to_exp1 : let (p : Nat) (n : Nat) (q : Nat) (r : Nat) -> and (Lt 1 p) (Lt 0 n) (Eq (p_ord n p) (mk_Prod Nat Nat q r)) (Eq p (p_ord n p)) (Eq n (times (pow p q) r))
postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H
postulate Sum_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1026 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_577 : cic.Term univs.Type0 x1) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_577))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_577))) -> (_H2 : (x_578 : cic.Term univs.Type0 x2) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P Hterm)
postulate p_ord_exp : soit n, m, i : Nat -> (posn : Lt 0 m) -> (modn : not (Eq (n, m) 0)) -> (p : Nat) -> (i : Nat) -> (H : Leq i p) -> p_ord_aux (p, m ^ i n, m)
postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> Nat
postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ x_378 + 1) -> (x_377 : Nat) -> Q_ x_377
postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> let_Hind : (m : Nat) -> (n : Nat) -> (Hind : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\ a : Nat -> ex Nat (\ b : Nat -> disjunkion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (and (and (Lt 0 n) (and (Leq n m) (Leq n q))) (or (and (Eq (minus (times a (mod m n)) n) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) (and (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (and (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)))
postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965
postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (H : Lt (nth_prime n) m) -> Nat
postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div (div n d) d) d
postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))
postulate divides_plus : soit n, p, q : N -> propos (divisible n p) (divisible n q)
postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (lea : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (H : Eq a (plus n 1)) -> Eq i a
postulate bigop_sum : soit k1 : Nat -> k2 : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\ i : Nat -> match_bool Set (\ _ : bool -> bool) (p1 (\ i : Nat -> minus i k2) p2) (leb k2 i)) B nil (op B nil op) (\ i : Nat -> match_bool Set (\ _ : bool -> B) (f (\ i : Nat -> minus i k2) g) (leb k2 i))) (op B nil op (bigop k1 (\ i : Nat -> p1 i) B nil (op B nil op) (\ i : Nat -> f (\ i : Nat -> minus i k2) g)) (bigop k2 (\ i : Nat -> p2 i) B nil (op B nil op) (\ i : Nat -> g (\ i : Nat -> minus i k2) f)))
postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> true) (plus i b)) Nat 1 times (\ i : Nat -> (\ i0 : Nat -> times a (f i0)) (plus i b))) (times a (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> true) (plus i b)) Nat 1 times (\ i : Nat -> (\ i0 : Nat -> f i0)) (plus i b)))
postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (posn : Lt m 2 a) -> (posn1 : Lt 1 2 a) -> (Hind' : (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516))
postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234
postulate Dop_rect_Type1 : Dop_rect_Type1 : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953
postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)
postulate primeb_true_to_prime : tous les nombres naturels n -> (primeb : (_ : Nat) -> Eq (primeb n) true) -> premier n
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) 1) 1) -> Eq n c m
postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : Nat) -> (_clearme : ex Nat (\ d : Nat -> disjonct (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posn : Eq (minus (times c n) (times d m)) 1) -> (posm : Eq (minus (times d m) (times c n)) 1) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1
postulate false_min : let f : (_ : Nat) -> Sann
postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))
postulate primes_below_lop : soit n un nombre naturel. alors primes_below tient pour (list_of_primes n) (plus n 2)
postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> let (l : Lt 0 p) -> Eq (gcd p n) 1 -> (h : Eq p (div n m)) -> Eq p m
postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)
postulate pad_bigop1 : let (k : Nat) (n : Nat) -> let (p : (_ : Nat) -> bool) -> let (B : Set) -> let (nil : B) -> let (op : (_ : B) -> (__1 : B) -> B) -> let (f : (_ : Nat) -> B) -> (_ : (n : Nat) -> or (Leq n k) (Eq (p n) (p i))) -> (__1 : (_ : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) (op n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))) -> Eq (bigop n (\ i : Nat -> p i) B nil op (\ i : Nat -> f i)) (bigop k (\ i : Nat -> p i) B nil op (\ i : Nat -> f i))
postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (H : prime p) -> (Hn : divisible n m) -> Leq (ord n p) (ord m p)
n$ est égale à $gcdpostulate let_clause_1544 : soit p, q \in N
postulate le_exp_Psil : soit n : Nat -> alors (Lt 0 n) (pow 2 n)
postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)
postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A
postulate pi_p_primeb5 : soit n : Nat -> (1 < n) -> Eq (bigop (plus n 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p n) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus (times 2 n) 1) (\ p : Nat -> primeb p) Nat 1 times (\ p : Nat -> bigop (log p (times 2 n)) (\ i : Nat -> true) Nat 1 times (\ i : Nat -> pow p (plus 2 (div n (pow p (plus i 1)))))))
postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true
postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (op B nil op (bigop (minus c b) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i b)) B nil op (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil op (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a)))) (bigop (minus c a) (\ i : Nat -> (\ i0 : Nat -> p i0) (plus i a)) B nil op (\ i : Nat -> (\ i0 : Nat -> f i0) (plus i a)))
postulate max_spec_ind_body : (_n : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972
postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)
postulate ACop_rect_CProp5 : soit A un ensemble. soit _nil un élément de A. soit Q_ une fonction des _x_905 de ACop de A _nil à des propositions. alors pour toutes les fonctions _H_mk_ACop des elements aop de Aop de A _nil et des fonctions _comm des elements a de A et des elements b de A à des éléments de Eq (op A _nil aop a b) (op A _nil aop b a)
postulate example1 : Eq (smallest_factor 3) 3
postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863
postulate låt : (a1 : Mngd) -> (a2 : a1) -> (x : a1) -> (y : a1) -> (_ : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3 : match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type2 -> \ t3postulate match_Dop : (a1 : Mngd) -> (a2 : a1) -> (x : a1) -> (y : a1) -> (_ : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\ _ : Type2 -> univ) (\ t0 : Type2 -> \ t1 : Type2 -> \ t2 : Type
postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)
postulate le_exp_priml : soit n : Nat -> (posn : Lt 0 n) -> Leq 2 ^ (2 n) 2 n (prim (2 n) + 1)
postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (lt2 : Leq m 6) -> (Hind : Leq m (plus 1 2)) -> (a : Nat) -> (lt3 : Leq 6 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)
postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)
postulate commutative_plus : commutative Nat plus
postulate let : (n : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (_ : Lt m n) -> (f' : (_ : Nat) -> true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) (contradiction)) -> max_spec n f m
postulate bool_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)
postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)
postulate let_clause_1033 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term univs.prop (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita
postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1
postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))
