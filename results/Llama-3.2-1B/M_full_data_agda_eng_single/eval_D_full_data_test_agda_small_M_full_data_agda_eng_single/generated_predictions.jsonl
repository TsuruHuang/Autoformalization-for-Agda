{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_false. Låt $n$ vara ett naturligt tal. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, är $nil$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som kontradiktion och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i)) nil", "predict": "postulate bigop_false : lett natuligt tal. lett B (mengd) (allt (elem nil B) (\\ op : (B : Mengd) -> (__1 : B) -> B) (\\ f : (_ : Nat) -> B) (allt nil B (\\ _ : (B : Mengd) -> (__1 : B) -> B))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Då för alla naturliga tal $b$, om $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$, så om $b$ är mindre än eller lika med $n$, så om $f$ applicerat på $b$ är lika med $j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (i' : Lt n i) -> (j' : Lt n i) -> (a : Nat) -> (auto : and (Leq a n) (Leq (f a) i)) -> (auto' : and (Leq a n) (Leq (f a) i)) -> (auto'' : all (all (Leq b n) (f b)) (Leq b n)) -> (auto''' : all (Leq b n) (f b)) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto'' : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_false. Let $n$ be a natural number. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, $nil$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to absurdity and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i)) nil", "predict": "postulate bigop_false : (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> Eq (nil) (bigop n (\\ i : Nat -> false) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16004. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $d m - c n = 1$. Då är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (Hind : Eq c n - d m) -> (Hindm : Eq (times d m) c) -> (Hindn : Eq m d) -> Eq m n"}
{"prompt": "Human: Translate the following French statement into Agda.\nEx_prime. Soit $n$ un nombre naturel. Supposons que $1 \\leq n$. Alors $ex$ tient pour $Nat$ et la fonction qui envoie $m$ à la conjonction de la conjonction de $Lt$ appliqué à $n$ et $m$ et de $Leq$ appliqué à $m$ et la somme de la factorielle de $n$ et de $1$ et de $prime$ appliqué à $m$.\nAssistant:", "label": "postulate ex_prime : (n : Nat) -> (_ : Leq 1 n) -> ex Nat (\\ m : Nat -> and (and (Lt n m) (Leq m (plus (factorial n) 1))) (prime m))", "predict": "postulate ex_prime : soit n un nombre naturel. supposons que 1 leq n. alors ex tient pour Nat et la fonction qui envoie m a la conjonction de la conjonction de (lt n m) (leq m (plus (factorial n) 1)) (prime m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_ind_body. Soient $_n$ et $_b$ des nombres naturels. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_1075$ et des éléments $_x_1076$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $x_1075$ à des propositions. Soit $_H_found_min_spec$ une fonction des nombres naturels $m$ et des éléments $x_1080$ de $Leq$ de $_b$ et de $m$ et des éléments $x_1079$ de $Lt$ de $m$ et de $_n + _b$ et des éléments $x_1078$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_1077$ des nombres naturels $i$ et des éléments de $Leq$ de $_b$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_min_spec (_n, _b, _f, m, x_1080, x_1079, x_1078, x_1077)$. Soit $_H_not_found_min_spec$ une fonction des fonctions $x_1081$ des nombres naturels $i$ et des éléments de $Leq$ de $_b$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n + _b$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $_n + _b$ et de $not_found_min_spec (_n, _b, _f, x_1081)$. Soit $x_1075 \\in N$. Alors pour tous les éléments $x_1076$ de $min_spec$ de $_n$ et de $_b$ et de $_f$ et de $x_1075$, $Q_$ tient pour $x_1075$ et $x_1076$.\nAssistant:", "label": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m _n + _b) -> (x_1078 : Eq _f m) -> (x_1077 : (_ : Nat) -> (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq _f i) -> (_f : (x_1075 : Nat) -> Eq (min_spec _n _b _f m x_1075) x_1076) -> (_H_not_found_min_spec : (x_1081 : (_ : Nat) -> (_ : Leq _b x_1081) -> (__1 : Lt x_1081 _n + _b) -> Eq _f x_1081) -> (Q_ : (_ : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec' : (x_1075 : Nat) -> Q_ x_1075 x_1076) -> (_H_not_found_min_spec' : x_1075 -> Q_ _n + _b -> not_found_min_spec _n _b _f x_1075) -> (x_1075 : Nat) -> x_1076"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides. För alla element $_n$ och $_m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate divides : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_CProp0_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_inl$ une fonction des éléments $x_582$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_582$. Soit $_H_inr$ une fonction des éléments $x_583$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_583$. Alors pour tous les éléments $x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_CProp1. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1620$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H1$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $x1$ et $x2$ et $aop$ et $b$ et $a$ et des éléments $_z1621$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $x1$ et $x2$ et $aop$ et $_comm$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate ACop_inv_rect_CProp1 : soit x1 un élément de cic.Univ univs.Type0. soit x2 un élément de cic.Term univs.Type0 x1. soit Hterm un élément de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2). soit P une fonction des éléments _z1620 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2) -> cic.Univ cic.prop. alors pour toutes les fonctions _H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1621 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$. Soit $_H_mk_ACop$ une fonction des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$. Alors pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4 : soit A un élément de cic.Univ univs.Type0. Soit _nil un élément de cic.Term univs.Type0 A. Soit Q_ une fonction des éléments _x_891 de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) de cic.Univ univs.Type4. Soit _H_mk_ACop une fonction des éléments aop de cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil) des fonctions _comm des éléments a de cic.Term univs.Type0 A et des éléments b de cic.Term univs.Type0 A à des éléments de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a)) (cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm)) x_891)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_Psil1. För alla naturliga tal $n$, är $bigop$ applicerat på summan av $n$ och $1$ och funktionen som avbildar $p$ som $primeb$ applicerat på $p$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $p$ som $n$ mindre än eller lika med $Psi (n)$.\nAssistant:", "label": "postulate le_Psil1 : (n : Nat) -> Leq (Psi n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> n))", "predict": "postulate le_Psil1 : (n : Nat) -> bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> Nat) (leq (p) (Psi n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPermut_n_to_eq_n. För alla funktioner $h$ från naturliga tal till naturliga tal, för alla naturliga tal $n$, för alla element $__$ av $permut$ av $h$ och $n$, för alla funktioner $__1$ från naturliga tal $m$ och element $__1$ av $Lt$ av $m$ och $n$ till element av $Eq$ av $h$ applicerat på $m$ och $m$, är $h$ applicerat på $n$ lika med $n$.\nAssistant:", "label": "postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n", "predict": "postulate permut_n_to_eq_n : (h : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : permut h n) -> (__1 : (m : Nat) -> (__1 : Lt m n) -> Eq (h m) m) -> Eq (h n) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$. Supposons que $a p - b m = 1$. Alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (posm : Eq 1 (div (comm : Nat p m) (div p m))) -> (c : Nat) -> (nm : Nat) -> (auto : divisible p m) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m) (Eq (minus (times b m) (times a p)) (div (comm : Nat p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_inv_rect_CProp3. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$, för alla funktioner $P$ från element $_z1344$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.nil$ applicerat på $x1$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_lists_list.nil$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_763$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $x_762$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ och funktioner $_x_765$ från element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $x_762$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_762$ och element $_z1345$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_763$ och $x_762$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_763$ och $x_762$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant", "label": "postulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)", "predict": " professorpostulate list_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1344 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_763 : cic.Term univs.Type0 x1) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_765 : (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_762)) -> cic.Term cic.prop (P x_762)) -> (_z1345 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_763 x_762))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__op. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$ et $x2$, pour tous les éléments $_x_887$ et $_x_888$ de $cic.Term$ de $univs.Type0$ et de $x0$, $cic.Term$ tient pour $univs.Type0$ et $x0$.\nAssistant:", "label": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0", "predict": "postulate dpi1__o__op : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.Aop x0 x1) x2)) -> (_x_887 : cic.Term univs.Type0 x0) -> (_x_888 : cic.Term univs.Type0 x0) -> cic.Term univs.Type0 x0"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_p_ord_inv. Let $p, m, x \\in N$. Then if $ord$ applied to $x$ and $p$ is less than $m$, then the quotient of $p_ord_inv$ applied to $p$ and $m$ and $x$ and $m$ is equal to $ord_rem$ applied to $x$ and $p$.\nAssistant:", "label": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)", "predict": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb. Låt $m, n, p \\in N$. Anta att $0 < n$ och $p$ är primt. Då om $p$ inte är delbart med $n$, så är $bigop$ applicerat på $m$ och funktionen som avbildar $i$ som $dividesb$ applicerat på potensen av $p$ och summan av $i$ och $1$ och produkten av potensen av $p$ och $m$ och $n$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $1$ lika med $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (ant : Lt 0 n) -> (auto : prime p) -> (auto' : not (divisible p n)) -> bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_i_j_i. För alla naturliga tal $i$ och $j$, är $transpose$ applicerat på $i$ och $j$ och $i$ lika med $j$.\nAssistant:", "label": "postulate transpose_i_j_i : (i : Nat) -> (j : Nat) -> Eq (transpose i j i) j", "predict": "postulate transpose_i_j_i : (i : Nat) -> (j : Nat) -> Eq (transpose i j i) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_ind. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_DPair$ be a function from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$. Then for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.\nAssistant:", "label": "postulate DPair_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)", "predict": "postulate DPair_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMonotonic_iter2. Let $g$ be a function from natural numbers to natural numbers. Let $a$ and $i$ and $j$ be natural numbers. Let $__$ be a function from natural numbers $x$ to elements of $Leq$ of $x$ and $g (x)$. Assume that $i \\leq j$. Then $iter (Nat, g, i, a)\\leq iter (Nat, g, j, a)$.\nAssistant:", "label": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)", "predict": "postulate monotonic_iter2 : (g : (_ : Nat) -> Nat) -> (a : Nat) -> (i : Nat) -> (j : Nat) -> (_ : (x : Nat) -> Leq x (g x)) -> (i : Nat) -> (j : Nat) -> (__1 : Leq i j) -> Leq (iter Nat g i a) (iter Nat g j a)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBool_to_decidable_eq. Let $b1$ and $b2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.decidable$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $b1$ and $b2$.\nAssistant:", "label": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))", "predict": "postulate bool_to_decidable_eq : (b1 : cic.Term univs.Type0 matita_basics_bool.bool) -> (b2 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (matita_basics_logic.decidable (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) b1 b2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1600. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Då om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så är $n c - m d$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posn' : Eq 0 m) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ _clearme0 : Eq (minus (times c n) m) (times d m)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> (H : Eq n c) -> Eq (times m n) (times d m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPi_1. Låt $n \\in N$. Då för alla funktioner $p$ från naturliga tal till sanningsvärden, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $1$ lika med $1$.\nAssistant:", "label": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1", "predict": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> Prop) -> bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec_inv_ind. Låt $x1$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $x2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $x3$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.max_spec$ applicerat på $x1$ och $x2$ och $x3$. Låt $P$ vara en funktion från element $_z1769$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $_x_975$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $x1$ och element $_x_974$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x2$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $_x_973$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $i$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $x2$ applicerat på $i$ och $matita_basics_bool.false$ och element $_z1770$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicer", "label": "postulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq", "predict": "atpostulate max_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.max_spec x1 x2 x3)) -> (P : (_z1769 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_975 : cic.Term cic.prop (matita_arithmetics_nat.lt m x1)) -> (_x_974 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 m) matita_basics_bool.true)) -> (_x_973 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i x1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1770 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 i) matita_basics_bool.false)) -> (_z1771 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x2 matita_basics_bool.true) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_bool.true)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_sqrt. Soit $n$ un nombre naturel. Alors $n$ est inférieur à la puissance de la somme de la racine carrée de $n$ et de $1$ et de $2$.\nAssistant:", "label": "postulate lt_sqrt : (n : Nat) -> Lt n (pow (plus (sqrt n) 1) 2)", "predict": "postulate lt_sqrt : soit n un nombre naturel. Alors n est inférieur a la puissance de la somme de la racine carrée de n et de 1 et de 2."}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be a natural number. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1$ be a natural number. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$ and $p1 (n1)= true$. Let $x2515, x2516 \\in N$. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p1 i) -> Nat 0 plus (\\ i : Nat -> g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p2 i) -> Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (n1 : Nat) -> true) -> (p1 : (n1 : Nat) -> true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_divides_to_gcd_aux. Låt $p, m, n \\in N$. Då om $0 < n$ och $n$ inte är delbart med $m$, så $gcd_aux (p + 1, m, n)= gcd_aux (p, n, mod (m, n))$.\nAssistant:", "label": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))", "predict": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> då om 0 < n och n inte är delbart med m så gcd_aux (p + 1, m, n) = gcd_aux (p, n, mod (m, n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind_body. Soit $_n$ un nombre naturel. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Alors pour toutes les fonctions $_H_not_found_max_spec$ des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$, pour tous les nombres naturels $x_971$, pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_diff. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f$ vara en funktion från naturliga tal till element av $B$. Låt $i$ och $n$ vara naturliga tal. Anta att $i < n$ och $p (i)= true$. Då är $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och $f$ applicerat på $i$ och $bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $andb$ applicerat på $notb$ applicerat på $eqb$ applicerat på $i$ och $x$ och $p$ applicerat på $x$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $x$ som $p$ applicerat på $x$ och $B$ och $nil$ och $aop__o__op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $x$ som $f$ applicerat på $x$.\nAssistant:", "label": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))", "predict": "postulate bigop_diff : (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (i < n) -> (p (i)) -> (aop__o__op : B nil op f) -> (i : Nat) -> (n : Nat) -> (i < n) -> (p (x)) -> (B nil aop__o__op op f) -> (x : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (aop__o__op B nil op f i bigop n f x) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op f) (\\ x : Nat -> f x))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMake_list_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_a$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour tous les éléments $_n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_lists_list.list$ appliqué à $A$.\nAssistant:", "label": "postulate make_list_body : (A : cic.Univ univs.Type0) -> (_a : cic.Term univs.Type0 A) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_basics_lists_list.list A)", "predict": "postulate make_list_body : soit A un element de cic.Univ univs.Type0. soit _a un element de cic.Term univs.Type0 A. alors pour tous les elements _n de cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term univs.Type0 (matita_basics_lists_list.list A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I. Let $n$ be a natural number. Let $p$ be a function from natural numbers to booleans. Then for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $bigop$ applied to the difference of $n$ and $0$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $0$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $0$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (minus n 0) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i 0)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i 0))) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_times_l. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om $1$ är mindre än $p$, så är summan av logaritmen av $p$ och $n$ och logaritmen av $p$ och $m$ mindre än eller lika med logaritmen av $p$ och produkten av $n$ och $m$.\nAssistant:", "label": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))", "predict": "postulate log_times_l : låt p och n och m vara naturliga tal. Anta att 0 är mindre än n. Anta att 0 är mindre än m. Då om 1 är mindre än p, så är summan av logaritmen av p och n och logaritmen av p och m mindre eller lika med logaritmen av p och (produkten av n och m)."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSum_rect_CProp1_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_576$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_inl$ från element $x_577$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_577$, för alla funktioner $_H_inr$ från element $x_578$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_578$, för alla element $x_576$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_576$.\nAssistant:", "label": "postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_577 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_577))) -> (_H_inr : (x_578 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_578))) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)", "predict": "postulate Sum_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (x_577 : cic.Term univs.Type0 _A) -> (x_578 : cic.Term univs.Type0 _B) -> (x_576 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_576)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_Type3_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_867$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type3$. Soit $_H_mk_Aop$ une fonction des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a, _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ à des éléments de $Q_$ de $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Soit $x_867$ un élément de $Aop$ de $A$ et de $_nil$. Alors $Q_$ tient pour $x_867$.\nAssistant:", "label": "postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867", "predict": "postulate Aop_rect_Type3_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_fg. Låt $f$ och $g$ vara funktioner från naturliga tal till naturliga tal. Låt $n \\in N$. Då för alla element $__$ av $bijn$ av $f$ och $n$, för alla element $__1$ av $bijn$ av $g$ och $n$, håller $bijn$ för funktionen som avbildar $p$ som $f (g (p))$ och $n$.\nAssistant:", "label": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (\\ p : Nat -> f (g p)) n", "predict": "postulate bijn_fg : (f : (_ : Nat) -> Nat) -> (g : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : bijn g n) -> bijn (f g) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1544. Soient $p$ et $q$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soient $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $n$ est inférieur ou ágal à $m$. Supposons que $n$ est inférieur ou ágal à la somme de $q$ et de $1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Supposons que la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ est égale à $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ ou la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appl", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "iqué àpostulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (_ : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjoncte (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (posm : Lt n m) -> (pnm : Lt n (plus q 1)) -> (Hind0 : (_ : Nat) -> (b : Nat) -> disjoncte (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind1 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind2 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind3 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind4 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind5 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind6 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind7 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind8 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind9 : Eq (minus (times a (mod"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15622 : soit m, n, a, b \\in N"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_inv_rect_Type4. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1044$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H1$ des éléments $_z1045$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_591$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1045$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_591$ à des éléments de $cic.Term$ de $univs.Type4$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_591$, $cic.Term$ tient pour $univs.Type4$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate option_inv_rect_Type4 : soit x1 un élément de cic.Univ univs.Type0. Alors pour tous les éléments Hterm de cic.Term univs.Type0 (matita_basics_types.option x1) pour toutes les fonctions P des (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n \\in N$. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n$ applied to $_n$. Let $case_le_S$ be a function from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$. Let $__$ be a natural number. Assume that $_n$ is less than or equal to $__$. Then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : N) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (__ : Nat) -> (_n : Nat) -> return_type _n z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nUnit. $cic.Univ$ håller för $univs.Type0$.\nAssistant:", "label": "postulate unit : cic.Univ univs.Type0", "predict": "postulate håller för : (univs.Type0 : cic.Univ) -> cic.Univ"}
{"prompt": "Human: Translate the following French statement into Agda.\nLeb. Soient $__$ et $__1$ des nombres naturels. Alors $bool$.\nAssistant:", "label": "postulate leb : (_ : Nat) -> (__1 : Nat) -> bool", "predict": "postulate leb : (_ : Nat) -> (__1 : Nat) -> bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec. Låt $_n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate max_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> ((_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (cic.Univ cic.prop)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_DPair$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $_f$ applied to $dpi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_DPair$ applied to $A$ and $_f$ and $dpi1$ and $_dpi2$, for all elements $x_638$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_638$.\nAssistant:", "label": "postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)", "predict": "postulate DPair_ind_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ cic.prop) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_638 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term cic.prop (Q_ x_638)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_rect_CProp1_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $Q_$ des éléments $_x_162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_conj$ des éléments $x_164$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_163$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_164$ et $x_163$, pour tous les éléments $x_162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_162$.\nAssistant:", "label": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)", "predict": "postulate And_rect_CProp1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_164 : cic.Term cic.prop _A) -> (x_163 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) -> (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_162)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (plus c n) (plus d m)) 1) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dn : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (minus (times d m) (times c n)) 1) -> Eq (div (plus d m) (plus c n)) (minus (times d m) (times c n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_lt_n. Låt $i$ och $n$ vara naturliga tal. Då om $1$ är mindre än $n$, så om $i$ är mindre än eller lika med $n$, så om det största gemensama delaret av $i$ och $n$ är lika med $1$, så är $i$ mindre än $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n", "predict": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (lt1n : Lt 1 n) -> (H : Leq i n) -> (Hn : Eq (gcd i n) 1) -> Lt i n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l_aux. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Alors pour toutes les fonctions $__1$ des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de $l + 1$ et de $b1$, pour tous les nombres naturels $l$, pour tous les éléments $b1$ et $b$ de $B$, pour tous les éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b$, si $b = b2$, alors $P$ tient pour $l$ et $b1$.\nAssistant:", "label": "postulate lstar_ind_l_aux : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (b : B) -> (__2 : lstar B R l b1 b) -> (__3 : Eq b b2) -> P l b1", "predict": "postulate lstar_ind_l_aux : soit B un ensemble. soit R une fonction des elements de B et des elements __1 de B a des propositions. soit b2 un element de B. soit P un element de relation2 Nat B. soit __ un element of P 0 b2. alors pour toutes les functions __1 des nombres naturels l et des elements b1 de B et des elements b de B et des elements __1 de R b1 b et des elements __2 de lstar B R l b b2 et des elements __3 de P l b a des elements of P l + 1 b1. pour tous les numbers l. pour tous elements b1 and b of B. for all elements __2 of lstar B R l b1 and b. if b = b2, then P l b1."}
{"prompt": "Human: Translate the following English statement into Agda.\nTimesAC. $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))", "predict": "postulate timesAC : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Då om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunkion (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) c) n)) -> (H : Eq (times d m) c) -> Eq m n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_pi. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ mindre än eller lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i) (mineralteq (g1 i) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_O_gcd. Pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$.\nAssistant:", "label": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))", "predict": "postulate lt_O_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_gcd.gcd m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nAssistant:", "label": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "Human: Translate the following English statement into Agda.\nPrime_to_divides_M. Let $m$ and $p$ be natural numbers. Assume that $p$ is prime. Assume that $m + 1 < p$. Assume that $p \\leq 2 m + 1$. Then $p$ is divisible by $M (m)$.\nAssistant:", "label": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)", "predict": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (prime p) -> (lt1 : Lt m 1) -> (lt2 : Leq p 2 m + 1) -> divisible p (M m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nK1. Soient $n$ et $p$ des nombres naturels. Supposons que $18 \\leq n$ et $p \\leq n$. Supposons que $2 n \\div 3 < p$. Alors $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate k1 : (n : Nat) -> (p : Nat) -> (posp : Leq 18 n) -> (posp' : Leq p n) -> (H : Lt 2 n 3) -> Eq (k (2 n, p) 0)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$ och $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Då om $b \\leq n$ och $f (b)= j$ och $b \\leq n$, så om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (auto : Leq i n) -> (auto' : Leq j n) -> (a : Nat) -> (auto\" : Leq a n) -> (f' : (_ : Nat) -> Nat) -> (auto'' : f (a)) = i) -> (b : Nat) -> (auto'' : Leq b n) -> (f'' : (_ : Nat) -> Nat) -> (auto''' : f (b)) = j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> f a = j"}
{"prompt": "Human: Translate the following English statement into Agda.\nAllr_fwd_append_sn. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$. Let $l1$ and $l2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_lists_list.Allr$ applied to $A$ and $R$ and $l1$.\nAssistant:", "label": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)", "predict": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp0_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_967$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_967$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_967$.\nAssistant:", "label": "postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967", "predict": "postulate Dop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_967 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_967 : Dop A _nil) -> Q_ x_967"}
{"prompt": "Human: Translate the following French statement into Agda.\nProd. Soient $s1$ et $s2$ des éléments de $Sort$. Alors pour tous les éléments $a$ de $Univ$ de $s1$, pour toutes les fonctions $b$ des éléments de $Term$ de $s1$ et de $a$ à des éléments de $Univ$ de $s2$, $Univ$ tient pour $rule$ appliqué à $s1$ et $s2$.\nAssistant:", "label": "postulate prod : (s1 : Sort) -> (s2 : Sort) -> (a : Univ s1) -> (b : Term s1 a -> Univ s2) -> Univ (rule s1 s2)", "predict": "postulate Prod : (s1 : Sort) -> (s2 : Sort) -> all (fun a : Univ s1 -> fun b : Term s1 a -> Univ s2) (rule s1 s2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nProd_inv_ind. For all elements $x1$ and $x2$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1236$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $_fst$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_snd$ of $cic.Term$ of $univs.Type0$ and $x2$ and elements $_z1237$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_types.mk_Prod$ applied to $x1$ and $x2$ and $_fst$ and $_snd$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Prod_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> (P : (_z1236 : cic.Term univs.Type0 (matita_basics_types.Prod x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (_fst : cic.Term univs.Type0 x1) -> (_snd : cic.Term univs.Type0 x2) -> (_z1237 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod x1 x2)) Hterm (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod x1 x2 _fst _snd))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15692. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Then if $0 < n$, then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq m n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_Psi2. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $n$.\nAssistant:", "label": "postulate le_exp_Psi2 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))", "predict": "postulate le_exp_Psi2 : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) (matita_arithmetics_chebyshev_chebyshev_psi.Psi n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDPair_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $univs.Type0$. Låt $Q_$ vara en funktion från element $_x_650$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_mk_DPair$ vara en funktion från element $dpi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_dpi2$ av $cic.Term$ av $univs.Type0$ och $_f$ applicerat på $dpi1$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.mk_DPair$ applicerat på $A$ och $_f$ och $dpi1$ och $_dpi2$. Då för alla element $x_650$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_650$.\nAssistant:", "label": "postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)", "predict": "postulate DPair_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (Q_ : (_x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ univs.Type0) -> (_H_mk_DPair : (dpi1 : cic.Term univs.Type0 A) -> (_dpi2 : cic.Term univs.Type0 (_f dpi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_DPair A _f dpi1 _dpi2))) -> (x_650 : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term univs.Type0 (Q_ x_650)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_O_f. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Alors pour tous les nombres naturels $b$, $min (0, b, f)= b$.\nAssistant:", "label": "postulate min_O_f : (f : (_ : Nat) -> bool) -> (b : Nat) -> Eq (min 0 b f) b", "predict": "postulate min_O_f : soit f : (_ : Nat) -> bool -> all Nat (\\ b : Nat -> min (0 b f))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : let (p : Nat) (m : Nat) (n : Nat) -> (posn : Lt 0 p) -> (same : Eq 1 (gcd p m)) -> (p : Nat) -> (nm : Nat) -> (c : Nat) -> (mnm : Nat) -> (auto : ex Nat (\\ b : Nat -> (\\ a : Nat -> (\\ p : Nat -> Eq (times a p) c) -> let (H : Eq (times a p) (times b m)) in (times b m) (gcd p m) (Eq (times b m) (times a p)) (gcd p m))) -> (H : Eq (times b m) (times a p)) -> (auto : ex Nat (\\ b : Nat -> (\\ a : Nat -> (\\ p : Nat -> Eq (times a p) c) -> let (H : Eq (times a p) (times b m)) in (times b m) (gcd p m) (Eq (times b m) (times a p)) (gcd p m))) -> (auto : Eq (times b m) (times a p)) -> (auto : Eq (times a p) (times b m)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (gcd p m) (same m n)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (same p m)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n) (times a p)) -> (auto : Eq (times a p) (same m n)) -> (auto : Eq (same m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnit_inv_rect_CProp1. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$. Soit $P$ une fonction des éléments $_z960$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $_z961$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.unit$ et $Hterm$ et $matita_basics_types.it$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.it$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate unit_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z960 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ cic.prop) -> (_H1 : (_z961 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term cic.prop (P matita_basics_types.it)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate unit_inv_rect_CProp1 : soit Hterm un élément de cic.Term univs.Type0 matita_basics_types.unit Soit P une fonction des éléments _z960 de cic.Term univs.Type0 matita_basics_types.unit à des éléments de cic.Univ cic.prop Soit _H1 une fonction des éléments _z961 de cic.Term cic.prop matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it à des éléments de cic.Term cic.prop (P matita_basics_types.it)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_ind. Let $_n$ and $_m$ be natural numbers. Let $Q_$ be a function from elements $_x_1192$ of $divisible$ of $_n$ and $_m$ to propositions. Then for all functions $_H_quotient$ from natural numbers $q$ and elements $x_1193$ of $Eq$ of $_m$ and the product of $_n$ and $q$ to elements of $Q_$ of $quotient$ applied to $_n$ and $_m$ and $q$ and $x_1193$, if $_n$ is divisible by $_m$, then $Q_$ holds for $x_1192$.\nAssistant:", "label": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192", "predict": "postulate divides_ind : (_n : Nat) -> (_m : Nat) -> (Q_ : (_x_1192 : divisible _n _m) -> Prop) -> (_H_quotient : (q : Nat) -> (x_1193 : Eq _m (times _n q)) -> Q_ (quotient _n _m q x_1193)) -> (x_1192 : divisible _n _m) -> Q_ x_1192"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type5_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_919$ av $range$ av $_A$ till element av $Type5$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Låt $x_919$ vara ett element av $range$ av $_A$. Då håller $Q_$ för $x_919$.\nAssistant:", "label": "postulate range_rect_Type5_body : (_A : Set) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_919 : range _A) -> Q_ x_919", "predict": "postulate range_rect_Type5_body : (_A : Mngd) -> (Q_ : (_x_919 : range _A) -> Type5) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> Q_ x_919) -> (x_919 : range _A) -> Q_ x_919"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10131. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m, n0 \\in N$. Anta att $max$ applicerat på summan av $n0$ och $1$ och $f$ är lika med $m$. Anta att $f$ applicerat på $m$ är lika med kontradiktion. Låt $i, j \\in N$. Anta att summan av $j$ och $1$ är mindre än summan av $n0$ och $1$. Låt $x7$ vara ett naturligt tal. Då är $x7$ lika med summan av $m$ och $x7$.\nAssistant:", "label": "postulate let_clause_10131 : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (eqm : Eq (max (plus n0 1) f) m) -> (fm : Eq (f m) false) -> (i : Nat) -> (j : Nat) -> (ltj : Lt (plus j 1) (plus n0 1)) -> (x7 : Nat) -> Eq x7 (plus m x7)", "predict": "postulate let_clause_10131 : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (n0 : Nat) -> (max : (_ : Nat) -> (_ : Nat) -> Eq (max (n0) 1) m) -> (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (x7 : Nat) -> Eq x7 (plus m x7)"}
{"prompt": "Human: Translate the following French statement into Agda.\nVoid_rect_CProp1. Soit $Q_$ une fonction des éléments $_x_493$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $x_493$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_493$.\nAssistant:", "label": "postulate void_rect_CProp1 : (Q_ : (_x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_493 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_493)", "predict": "postulate void_rect_CProp1 : soit Q_ une fonction des elements _x_493 de cic.Term univs.Type0 matita_basics_types.void à des elements de cic.Univ cic.prop. Soit x_493 un element de cic.Term univs.Type0 matita_basics_types.void. Alors cic.Term tient pour cic.prop (Q_ x_493)"}
{"prompt": "Human: Translate the following English statement into Agda.\nExp_to_fact1. Let $n$ be a natural number. Assume that $0$ is less than $n$. Then the product of the product of the exponentiation of $2$ and the product of $2$ and $n$ and the factorial of $n$ and the factorial of $n$ is less than the factorial of the sum of the product of $2$ and $n$ and $1$.\nAssistant:", "label": "postulate exp_to_fact1 : (n : Nat) -> (_ : Lt 0 n) -> Lt (times (times (pow 2 (times 2 n)) (factorial n)) (factorial n)) (factorial (plus (times 2 n) 1))", "predict": "postulate exp_to_fact1 : (n : Nat) -> (_ : Lt 0 n) -> Lt (times (times (pow 2 (times 2 n)) (factorial n)) (factorial n)) (factorial (plus (times 2 n) 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Let $P$ be a function from elements $_z185$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H1$ from elements $_z186$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.True$ and $Hterm$ and $matita_basics_logic.I$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_logic.I$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp0 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z185 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z186 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_mop. Let $n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $R$ be an element of $Dop$ of $B$ and $nil$. Then for all functions $f$ from natural numbers to elements of $B$, for all elements $a$ and $_x_969$ and $_x_970$ of $B$, $B$.\nAssistant:", "label": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B", "predict": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_exp1. Låt $n$ och $m$ och $a$ vara naturliga tal. Anta att $0 < a$. Anta att $n \\leq m$. Då $n ^ a \\leq m ^ a$.\nAssistant:", "label": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)", "predict": "postulate le_exp1 : let n : Nat in let m : Nat in let a : Nat in and (Lt 0 a) (Lt n m) (pow n m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nR1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H_refl$ vara ett element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Då för alla element $x_19$ av $cic.Term$ av $univs.Type2$ och $A$, för alla element $x_20$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_19$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_19$ och $x_20$.\nAssistant:", "label": "postulate R1 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_19 : cic.Term univs.Type2 A) -> (_x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Univ univs.Type0) -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)", "predict": "postulate R1 : cic.Univ univs.Type2 -> cic.Term univs.Type2 A -> cic.Term cic.prop (matita_basics_logic.eq A _x x_19) -> cic.Univ univs.Type0 -> (_H_refl : cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_19 : cic.Term univs.Type2 A) -> (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19)) -> cic.Term univs.Type0 (Q_ x_19 x_20)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLength_body. För alla element $H$ av $cic.Univ$ av $univs.Type0$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate length_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate length_body : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_CProp2_body. Let $_n$ and $_m$ and $_q$ and $_r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $Q_$ be a function from elements $_x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_div_mod_spec_intro$ be a function from elements $x_851$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $_r$ and $_m$ and elements $x_850$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $_n$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $_q$ and $_m$ and $_r$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_851$ and $x_850$. Then for all elements $x_849$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $_n$ and $_m$ and $_q$ and $_r$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_849$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)", "predict": "postulate div_mod_spec_rect_CProp2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_851 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_850 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_851 x_850))) -> (x_849 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_849)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (fa : Nat) -> (b : Nat) -> (fb : Nat) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> letjf : injn f n -> (injf : injn f n) -> (auto : Eq a b) -> f a = j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1, n2 \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Assume that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_hk$ holds for $h$ and $k$ and $B", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i", "predict": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> let (x : (_ : Nat) -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> let (y : (_ : Nat) -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> let (z : (_ : Nat) -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) -> Eq (x z) (y z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind. Let $_n$ and $_b$ be natural numbers. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075 \\in N$. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following French statement into Agda.\nFact_pi_p. Soit $n \\in N$. Alors la factorielle de $n$ est égale à $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$.\nAssistant:", "label": "postulate fact_pi_p : (n : Nat) -> Eq (factorial n) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (div n (pow p (plus i 1))))))", "predict": "postulate fact_pi_p : soit n : Nat -> et (same_pn n (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (div n (pow p (plus i 1))))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10471. Låt $n1, n2 \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara ett element av $ACop$ av $B$ och $nil$. Låt $f1$ och $f2$ vara funktioner från naturliga tal till element av $B$. Låt $_clearme$ vara ett element av $iso$ av $B$ och $mk_range (B, f1, n1, p1)$ och $mk_range (B, f2, n2, p2)$. Låt $h$ vara en funktion från naturliga tal till naturliga tal. Låt $_clearme0$ vara ett element av $ex$ av $prod$ applicerat på $Set$ och $Set$ och $Nat$ och funktionen som avbildar $__$ som $Nat$ och funktionen som avbildar $k$ som konjunktionen av konjunktionen av $prod$ applicerat på $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applicerat på $Prop$ och $Prop$ och $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och funktionen som avbildar $__1$ som $Eq$ applicerat på $f1$ applicerat på $i$ och $f2$ applicerat på $h$ applicerat på $i$ och $sub_hk$ applicerat på $h$ och $k$ och $B$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $sub_hk$ applicerat på $k$ och $h$ och $B$ och $mk_range$ applicerat på $B$ och $f2$ och $n2$ och $p2$ och $mk_range$ applicerat på $B$ och $f1$ och $n1$ och $p1$. Låt $k$ vara en funktion från naturliga tal till naturliga tal. Anta att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n1$ och funktionen som avbildar $__$ som $prod$ applic", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1", "predict": "erat påpostulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : Nat -> (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : prod Prop Prop (Eq (p1 i) true) (\\ _1 : Eq (f1 i) f2) (\\ _2 : Eq (p2 i) true) (\\ _3 : Eq (f1 n1) (f2 n2)) (\\ _4 : Eq (p1 n1) (p2 n2)) (\\ _5 : Eq (f1 n1) (f2 n2)) (\\ _6 : Eq (f2 n2) (f1 n1)) (\\ _7 : Eq (f1 (op n1 k)) (f2 (op n2 k))) (\\ _8 : Eq (op k h) B) (\\ _9 : Eq (f2 (op n2 k)) (f1 n1)) (\\ _10 : Eq (f1 (op n1 k)) (f2 n1)) (\\ _11 : Eq (f2 n1) (f1 n1)) (\\ _12 : Eq (f1 (op n1 k)) (f2 n1)) (\\ _13 : Eq (f1 (op n2 k)) (f2 n2)) (\\ _14 : Eq (f2 n2) (f1 n2)) (\\ _15 : Eq (f1 (op n1 k)) (f2 n1)) (\\ _16 : Eq (f2 n1) (f1 n1)) (\\ _17 : Eq (f1 (op n1 k)) (f2 n1)) (\\ _18 : Eq (f1 (op n2 k)) (f2 n2)) (\\ _19 : Eq (f"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (div (plus c n) (plus d m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq m d) -> Eq (times d n) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nAb_times_cd. Let $a$ and $b$ and $c$ and $d$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $b$ and $matita_arithmetics_nat.times$ applied to $c$ and $d$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $a$ and $c$ and $matita_arithmetics_nat.times$ applied to $b$ and $d$.\nAssistant:", "label": "postulate ab_times_cd : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a b) (matita_arithmetics_nat.times c d)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))", "predict": "postulate ab_times_cd : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a b) (matita_arithmetics_nat.times c d)) (matita_arithmetics_nat.times (matita_arithmetics_nat.times a c) (matita_arithmetics_nat.times b d)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nInvert_permut_f. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n$ et $m$, si $m \\leq n$, alors pour tous les éléments $__1$ de $injn$ de $f$ et de $n$, $invert_permut (n, f, f (m))= m$.\nAssistant:", "label": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> Eq (invert_permut n f (f m)) m", "predict": "postulate invert_permut_f : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> (__1 : injn f n) -> invert_permut n f (f m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_minus_to_plus. För alla element $n$ och $m$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $matita_arithmetics_nat.plus$ applicerat på $p$ och $m$.\nAssistant:", "label": "postulate le_minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))", "predict": "postulate le_minus_to_plus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n m) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le n (matita_arithmetics_nat.plus p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin. Soient $__$ et $__1$ des nombres naturels. Alors pour toutes les fonctions $__2$ des nombres naturels $__2$ à des valeurs booléennes, $Nat$.\nAssistant:", "label": "postulate min : (_ : Nat) -> (__1 : Nat) -> (__2 : (__2 : Nat) -> bool) -> Nat", "predict": "postulate min : (_ : Nat) -> (__1 : Nat) -> (f : (__2 : Nat) -> bool) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_leb_true. For all natural numbers $n$ and $m$, if $n$ is less than or equal to $m$, then $leb$ applied to $n$ and $m$ is equal to $true$.\nAssistant:", "label": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true", "predict": "postulate le_to_leb_true : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (leb n m) true"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_ind_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_889$ de $ACop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_889$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_889$.\nAssistant:", "label": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889", "predict": "postulate ACop_ind_body : Soit A un ensemble. Soit _nil un élément de A. Soit Q_ une fonction des _x_889 de ACop de A _nil à des propositions. Alors pour toutes les fonctions _H_mk_ACop des elements aop de Aop de A _nil et des fonctions _comm des elements a de A et des elements b de A à des elements de Eq (op A _nil aop a b) (op A _nil aop b a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp0_body. Soit $_n, _m, _q, _r \\in N$. Soit $Q_$ une fonction des éléments $_x_857$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_859$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_858$ de $Eq$ de $_n$ et de $_q _m + _r$ à des éléments de $Q_$ de $div_mod_spec_intro (_n, _m, _q, _r, x_859, x_858)$. Soit $x_857$ un élément de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$. Alors $Q_$ tient pour $x_857$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp0_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857", "predict": "postulate div_mod_spec_rect_CProp0_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_857 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_859 : Lt _r _m) -> (x_858 : Eq _n _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_859 x_858)) -> (x_857 : div_mod_spec _n _m _q _r) -> Q_ x_857"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_of_primes_def. Soit $n \\in N$. Alors $list_of_primes$ appliqué à $n$ est égal à $lprim$ appliqué à $n$ et $2$ et $nil$ appliqué à $Nat$.\nAssistant:", "label": "postulate list_of_primes_def : (n : Nat) -> Eq (list_of_primes n) (lprim n 2 (nil Nat))", "predict": "postulate list_of_primes_def : soit n : Nat -> ainsi que list_of_primes (n) est égale a (lprim n 2 (nil Nat))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Pour tous les nombres naturels $m$ et $n$ et $a$ et $b$, si $0$ est inférieur à $n$, alors si $0$ est inférieur à $m$, alors si le diviseur commun plus grand de $n$ et de $m$ est égal à $1$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (commun n m) 1) (Nat)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (div (commun m n) (minus (times m d) (times n c))) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_inv_rect_Type3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1314$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type3$. Då för alla funktioner $_H1$ från element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.nil$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_lists_list.nil$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_733$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $x_732$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $x1$ och funktioner $_x_735$ från element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $x_732$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $x_732$ och element $_z1315$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $x1$ och $Hterm$ och $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_733$ och $x_732$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_basics_lists_list.cons$ applicerat på $x1$ och $x_733$ och $", "label": "postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate list_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1314 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ univs.Type3) -> (_H1 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.cons x1 x_733 x_732))) -> cic.Term univs.Type3 (P (matita_basics_lists_list.list x1) x_733 x_732)) -> (x_733 : cic.Term univs.Type0 x1) -> (x_732 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_735 : (_z1315 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_732)) -> cic.Term univs.Type3 (P x_732)) -> (_z1315 : cic.Term cic.prop (matita_basics_logic.eq"}
{"prompt": "Human: Translate the following French statement into Agda.\nSub_comp_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soient $R$ et $R1$ et $R2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_relations.subR$ appliqué à $A$ et $R1$ et $R2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_relations.subR$ appliqué à $A$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R$ et $R1$ et $matita_basics_relations.Rcomp$ appliqué à $A$ et $R$ et $R2$.\nAssistant:", "label": "postulate sub_comp_r : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R1 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (R2 : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (__ : cic.Term cic.prop (matita_basics_relations.subR A R1 R2)) -> cic.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))", "predict": "postulate sub_comp_r : soit A un élément de cic.Univ univs.Type0. Soient R et R1 et R2 des éléments de cic.Term univs.Type0 (matita_basics_relations.relation A). Alors pour tous les éléments __ de cic.Term cic.prop (matita_basics_relations.subR A R1 R2) citec.Term cic.prop (matita_basics_relations.subR A (matita_basics_relations.Rcomp A R R1) (matita_basics_relations.Rcomp A R R2))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrime_nth_prime. Soit $n \\in N$. Alors $nth_prime (n)$ est premier.\nAssistant:", "label": "postulate prime_nth_prime : (n : Nat) -> prime (nth_prime n)", "predict": "postulate prime_nth_prime : soit n : Nat -> premier (nth_prime n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_divides_ord_rem. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $p$ est premier. Alors si $n$ est divisible par $m$, alors $ord_rem (n, p)$ est divisible par $ord_rem (m, p)$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (prime : prime p) -> (_clearme : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_CProp2. Let $_A$ be a set. Let $Q_$ be a function from elements $_x_935$ of $range$ of $_A$ to propositions. Then for all functions $_H_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range (_A, _enum, _upto, _filter)$, for all elements $x_935$ of $range$ of $_A$, $Q_$ holds for $x_935$.\nAssistant:", "label": "postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935", "predict": "postulate range_rect_CProp2 : (_A : Set) -> (Q_ : (_x_935 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_935 : range _A) -> Q_ x_935"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_CProp2_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_909$ av $ACop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_909$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_909$.\nAssistant:", "label": "postulate ACop_rect_CProp2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_909 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_909 : ACop A _nil) -> Q_ x_909", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_909 : ACop A _nil) -> Ptn) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_909 : ACop A _nil) -> Q_ x_909"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb1. Låt $m$ och $n$ och $p$ och $k$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.prime$ applicerat på $p$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $p$ och $n$, för alla element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $k$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_bigops.bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $matita_arithmetics_primes.dividesb$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $i$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $m$ och $n$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.plus$ och funktionen som avbildar $i$ som $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate sigma_p_dividesb1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate sigma_p_dividesb1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__2 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p n))) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.dividesb (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p m) n)) matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_nat.plus (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1560. Let $n$ and $m$ be natural numbers. Assume that $n$ is divisible by $m$. Assume that $0$ is equal to $n$. Let $d$ be a natural number. Assume that $m$ is equal to the product of $0$ and $d$. Then $n$ is equal to $0$.\nAssistant:", "label": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0", "predict": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (eqn0 : Eq 0 n) -> (d : Nat) -> (eqm : Eq m (times 0 d)) -> Eq n 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_rect_CProp5. Let $_A$ and $_B$ be elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_conj$ be a function from elements $x_152$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_151$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_152$ and $x_151$. Then for all elements $x_150$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_150$.\nAssistant:", "label": "postulate And_rect_CProp5 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)", "predict": "postulate And_rect_CProp5 : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_152 : cic.Term cic.prop _A) -> (x_151 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) -> (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_150)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPrimes_below_to_bertrand. Låt $pm \\in N$. Låt $l$ vara en lista av naturliga tal. Anta att $pm$ är primt. Låt $__1$ vara ett element av $primes_below$ av $l$ och $pm + 1$. Låt $__2$ vara en funktion från naturliga tal $p$ och element $__2$ av $mem$ av $Nat$ och $p$ och $l$ och element $__3$ av $Lt$ av $2$ och $p$ till element av $ex$ av $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$. Låt $n \\in N$. Anta att $0 < n$. Då om $n < pm$, så håller $bertrand$ för $n$.\nAssistant:", "label": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n", "predict": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : lista Nat) -> (lts : primt pm) -> (__1 : primes_below l pm + 1) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> (\\ H : Lt 2 p) -> pp)) -> (n : Nat) -> (posn : Lt 0 n) -> bertrand n"}
{"prompt": "Human: Translate the following English statement into Agda.\nSub0_to_false. Let $h$ and $k$ be functions from natural numbers to natural numbers. Let $A$ be a set. Let $I$ and $J$ be elements of $range$ of $A$. Assume that $upto$ applied to $A$ and $I$ is equal to $0$. Let $__1$ be an element of $sub_hk$ of $h$ and $k$ and $A$ and $J$ and $I$. Let $i \\in N$. Assume that $i$ is less than $upto$ applied to $A$ and $J$. Then $filter$ applied to $A$ and $J$ and $i$ is equal to absurdity.\nAssistant:", "label": "postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> (_ : Eq (upto A I) 0) -> (__1 : sub_hk h k A J I) -> (i : Nat) -> (__2 : Lt i (upto A J)) -> Eq (filter A J i) false", "predict": "postulate sub0_to_false : (h : (_ : Nat) -> Nat) -> (k : (_ : Nat) -> Nat) -> (A : Set) -> (I : range A) -> (J : range A) -> Eq (upto A I) 0 -> (_1 : sub_hk h k A J I) -> (i : Nat) -> (_2 : Lt i (upto A J)) -> Eq (filter A J i) false"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n$ un nombre naturel. Supposons que $5$ est inférieur à $n$. Soit $m$ un nombre naturel. Supposons que $6$ est inférieur ou ágal à $m$. Supposons que la puissance de la somme de $m$ et de $1$ et de $2$ est inférieure ou ágale à la puissance de $2$ et de $m$. Soit $a \\in N$. Supposons que $6$ est inférieur ou ágal à $a$. Supposons que la somme du produit de $2$ et de la somme de $a$ et de $1$ et de $1$ est inférieure ou ágale à la puissance de $2$ et de $a$. Alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : soit n un nombre naturel. supposons que 5 est inférieur à n. soit m un nombre naturel. supposons que 6 est inférieur ou ágal à m. supposons que la puissance de la somme de m et de 1 et de 2 est inférieure ou ágale à la puissance de 2 et de m. soit a ∈ N. supposons que 6 est inférieur ou ágal à a. supposons que la somme du produit de 2 et de la somme de a et de 1 et de 1 est inférieure ou ágale à la puissance de 2 et de a. alors pour tous les nombres naturels x2515 et x2516, x2515 est égal à la somme du produit x2516 et du quotient de x2515 et x2516 et (mod x2515 x2516)."}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type2. Pour tous les éléments $_A$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $Q_$ des éléments $_x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$, pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_603$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_603$, pour tous les éléments $x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_602$.\nAssistant:", "label": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)", "predict": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_divides_to_dividesb_false. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_primes.dividesb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nAssistant:", "label": "postulate not_divides_to_dividesb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)", "predict": "postulate not_divides_to_dividesb_false : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides n m))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_primes.dividesb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_inv_S. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l \\in N$. Alors pour tous les éléments $b1$ et $b2$ de $B$, pour tous les éléments $__$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b2$, pour tous les nombres naturels $l0$, si $l0 + 1 = l$, alors $ex2$ tient pour $B$ et la fonction qui envoie $b$ à $R (b1, b)$ et la fonction qui envoie $b$ à $lstar (B, R, l0, b, b2)$.\nAssistant:", "label": "postulate lstar_inv_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (l0 : Nat) -> (__1 : Eq (plus l0 1) l) -> ex2 B (\\ b : B -> R b1 b) (\\ b : B -> lstar B R l0 b b2)", "predict": "postulate lstar_inv_S : Soit B un ensemble. Soit R un élément de relation B. Soit l : N. Alors pour tous les éléments b1 et b2 de B, pour tous les éléments __ de lstar B R l b1 b2, pour tous les nombres naturels l0, si l0 + 1 = l, alors ex2 tient pour B et la fonction qui envoie b à R (b1, b) et la fonction qui envoie b à lstar B R l0 b b2."}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_plus. Soit $n, p, q \\in N$. Supposons que $n$ est et divisible par $p$ et divisible par $q$. Alors $n$ est divisible par $p + q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : soit n, p, q : N -> propos (and (divisible n p) (divisible n q)) (divisible n (plus p q))"}
{"prompt": "Human: Translate the following English statement into Agda.\nEqb_sym. Let $a, b \\in N$. Then $eqb (a, b)= eqb (b, a)$.\nAssistant:", "label": "postulate eqb_sym : (a : Nat) -> (b : Nat) -> Eq (eqb a b) (eqb b a)", "predict": "postulate eqb_sym : (a : Nat) -> (b : Nat) -> Eq (eqb a b) (eqb b a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Alors pour tous les éléments $_H_None$ de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$, pour toutes les fonctions $_H_Some$ des éléments $x_607$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_607$, pour tous les éléments $x_606$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_606$.\nAssistant:", "label": "postulate option_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)", "predict": "postulate option_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type1) -> (_H_None : cic.Term univs.Type1 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_607 : cic.Term univs.Type0 _A) -> cic.Term univs.Type1 (Q_ (matita_basics_types.Some _A x_607))) -> (x_606 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type1 (Q_ x_606)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_ind. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1233$ och element $x_1232$ av $B$ och element $x_1231$ av $B$ och element $_x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$ till påståenden. Låt $_H_lstar_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $_H_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element $x_1236$ av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $x_1235$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ och element $_x_1238$ av $Q_$ av $l$ och $b$ och $b2$ och $x_1235$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Då för alla naturliga tal $x_1233$, för alla element $x_1232$ och $x_1231$ av $B$, för alla element $x_1234$ av $lstar$ av $B$ och $_R$ och $x_1233$ och $x_1232$ och $x_1231$, håller $Q_$ för $x_1233$ och $x_1232$ och $x_1231$ och $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate låt : (B : Mngd) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following French statement into Agda.\nS_mod. Pour tous les nombres naturels $_n$ et $_m$, $Nat$.\nAssistant:", "label": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat", "predict": "postulate S_mod : (_n : Nat) -> (_m : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1075. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $bijf$ vara ett element av $bijn$ av $f$ och $n + 1$. Anta att $f (n + 1)= n + 1$. Låt $i \\in N$. Anta att $i \\leq n$. Låt $a \\in N$. Anta att $a \\leq n + 1$ och $f (a)= i$. Anta att $a \\leq n + 1$. Anta att $f (a)= i$. Då om $a = n + 1$, så $i = a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f n + 1) -> (f' : (n : Nat) -> Nat) -> (i : Nat) -> (lt0 : Lt i n) -> (a : Nat) -> (lt1 : Lt a n) -> (f' : (a : Nat) -> i) -> (lt2 : Lt a n) -> (f : (a : Nat) -> i) -> (Hc : Eq a n + 1) -> (Hlt : Lt a n) -> (Hlt0 : Lt n a + 1) -> (Hlt1 : Lt n a) -> (Hlt2 : Eq n a) -> Eq (f a) i"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_divides_to_gcd_aux. Soit $p, m, n \\in N$. Supposons que $0 < n$ et $n$ n'est pas divisible par $m$. Alors $gcd_aux (p + 1, m, n)= gcd_aux (p, n, mod (m, n))$.\nAssistant:", "label": "postulate not_divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : not (divisible n m)) -> Eq (gcd_aux (plus p 1) m n) (gcd_aux p n (mod m n))", "predict": "postulate not_divides_to_gcd_aux : soit p, m, n : N -> (posn : Lt 0 n) -> (nm : not (divisible n m)) -> gcd_aux (p + 1, m, n) (gcd_aux (p, n, mod (m, n)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nFound_max_spec. Soit $n$ un nombre naturel. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m$ un nombre naturel. Supposons que $m < n$ et $f (m)= true$. Alors pour toutes les fonctions $__2$ des nombres naturels $i$ et des éléments $__2$ de $Lt$ de $m$ et de $i$ et des éléments $__3$ de $Lt$ de $i$ et de $n$ à des éléments de $Eq$ de $f (i)$ et de contradiction, $max_spec$ tient pour $n$ et $f$ et $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate soit : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (H : Lt m n) -> (f' : (_ : Nat) -> bool) -> (H' : Lt m n) -> (H\" : Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_prim_n1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_chebyshev_chebyshev_psi.prim$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $n$.\nAssistant:", "label": "postulate le_prim_n1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.prim (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) n)", "predict": "postulate le_prim_n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSigma_p_dividesb. Låt $m, n, p \\in N$. Då om $0 < n$ och $p$ är primt, så om $p$ inte är delbart med $n$, så är $bigop$ applicerat på $m$ och funktionen som avbildar $i$ som $dividesb$ applicerat på potensen av $p$ och summan av $i$ och $1$ och produkten av potensen av $p$ och $m$ och $n$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $1$ lika med $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (posn : Lt 0 n) -> (auto : not (divisible p n)) -> bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nTrue_inv_ind. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Alors pour toutes les fonctions $P$ des éléments $_z125$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z126$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate True_inv_ind : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z125 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z126 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_ind : soit Hterm un element de cic.Term cic.prop matita_basics_logic.True : ainsi pour toutes fonctions P des elements _z125 de cic.Term cic.prop matita_basics_logic.True à des elements cic.Univ cic.prop : pour toutes fonctions _H1 des elements _z126 de cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I) : cic.Term cic.prop (P matita_basics_logic.I)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_DPair. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $return_sort$ un élément de $cic.Sort$. Soit $return_type$ une fonction des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $return_sort$. Alors pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_DPair : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_DPair : soit A un élément de cic.Univ univs.Type0. soit _f : (__ : cic.Term univs.Type0 A) -> cic.Univ univs.Type0. soit return_sort : cic.Sort. soit return_type : (z : cic.Term univs.Type0 (matita_basics_types.DPair A _f)) -> cic.Univ return_sort. alors pour toutes les fonctions return des elements z de cic.Term univs.Type0 (matita_basics_types.DPair A _f) elements de cic.Term return_sort (return_type z) pour tous les elements z de cic.Term univs.Type0 (matita_basics_types.DPair A _f) elements de cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_plus_mod. Soient $m$ et $n$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $m$ et $n$ et $q$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $q$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $q$.\nAssistant:", "label": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))", "predict": "postulate le_plus_mod : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_div_and_mod.mod (matita_arithmetics_nat.plus m n) q) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.mod m q) (matita_arithmetics_div_and_mod.mod n q)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $permf$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$. Let $i$ and $j$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $lein$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $lejn$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $j$ and $n$. Let $a$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $_clearme$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $a$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $lean$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $n$, for all elements $fa$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $a$ and $i$, for all elements $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_clearme0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_nat.le$ applied to $b$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$", "label": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type", "predict": "postulate let_clause_1068 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (Hind : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nVoid_rect_Type4. Låt $Q_$ vara en funktion från element $_x_483$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$ till element av $cic.Univ$ av $univs.Type4$. Låt $x_483$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.void$. Då håller $cic.Term$ för $univs.Type4$ och $Q_$ applicerat på $x_483$.\nAssistant:", "label": "postulate void_rect_Type4 : (Q_ : (_x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term univs.Type4 (Q_ x_483)", "predict": "postulate låt : (Q_ : cic.Term univs.Type0 matita_basics_types.void) -> (x_483 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ univs.Type4"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_ind_body. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $Q_$ vara en funktion från naturliga tal $x_1337$ och element $x_1336$ av $B$ och element $x_1335$ av $B$ och element $_x_1338$ av $lstar_r$ av $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$ till påståenden. Låt $_H_lstar_r_O$ vara en funktion från element $b$ av $B$ till element av $Q_$ av $0$ och $b$ och $b$ och $lstar_r_O (B, _R, b)$. Låt $_H_lstar_r_S$ vara en funktion från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element $x_1340$ av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $x_1339$ av $_R$ av $b$ och $b2$ och element $_x_1342$ av $Q_$ av $l$ och $b1$ och $b$ och $x_1340$ till element av $Q_$ av $l + 1$ och $b1$ och $b2$ och $lstar_r_S (B, _R, l, b1, b, x_1340, b2, x_1339)$. Låt $x_1337$ vara ett naturligt tal. Låt $x_1336$ och $x_1335$ vara element av $B$. Låt $x_1338$ vara ett element av $lstar_r$ av $B$ och $_R$ och $x_1337$ och $x_1336$ och $x_1335$. Då håller $Q_$ för $x_1337$ och $x_1336$ och $x_1335$ och $x_1338$.\nAssistant:", "label": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Prop) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ (plus l 1) b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> Q_ x_1337 x_1336 x_1335 x_1338", "predict": "postulate lstar_r_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (_ : Nat) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (_x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> (_H_lstar_r_O : (b : B) -> Q_ 0 b b (lstar_r_O B _R b)) -> (_H_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (x_1340 : lstar_r B _R l b1 b) -> (b2 : B) -> (x_1339 : _R b b2) -> (_x_1342 : Q_ l b1 b x_1340) -> Q_ l + 1 b1 b2 (lstar_r_S B _R l b1 b x_1340 b2 x_1339)) -> (x_1337 : Nat) -> (x_1336 : B) -> (x_1335 : B) -> (x_1338 : lstar_r B _R x_1337 x_1336 x_1335) -> (Q_ x_1337 x_1336 x_1335 x_1338)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMod_O_to_divides. Soient $n$ et $m$ des nombres naturels. Alors si $0 < n$ et $mod (m, n)= 0$, alors $n$ est divisible par $m$.\nAssistant:", "label": "postulate mod_O_to_divides : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (mod m n) 0) -> divisible n m", "predict": "postulate mod_O_to_divides : sont n et m des nombres naturels. alors (mod (m, n)) = 0 -> divisible n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_CProp4_body. För alla funktioner $Q_$ från naturliga tal $_x_393$ till påståenden, för alla element $_H_O$ av $Q_$ av $0$, för alla funktioner $_H_S$ från naturliga tal $x_394$ och element $_x_396$ av $Q_$ av $x_394$ till element av $Q_$ av summan av $x_394$ och $1$, för alla naturliga tal $x_393$, håller $Q_$ för $x_393$.\nAssistant:", "label": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393", "predict": "postulate nat_rect_CProp4_body : (Q_ : (_x_393 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_394 : Nat) -> (_x_396 : Q_ x_394) -> Q_ (plus x_394 1)) -> (x_393 : Nat) -> Q_ x_393"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$. Then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (div1 : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times p a) (times m b))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_S. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Let $__$ be an element of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$. Let $b2$ be an element of $B$. Then for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nAssistant:", "label": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> R b b2 -> (__1 : R b b2) -> lstar_r B R l + 1 b1 b2"}
{"prompt": "Human: Translate the following English statement into Agda.\nExp_n_1. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_exp.exp$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate exp_n_1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate exp_n_1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_exp.exp n (matita_arithmetics_nat.S matita_arithmetics_nat.O)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sqrt_to_lt_times_r. Låt $m, n \\in N$. Anta att kvadratroten av $m$ är mindre än $n$. Då är $m$ mindre än produkten av $n$ och $n$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> (_ : Lt (sqrt m) n) -> Lt m (times n n)", "predict": "postulate lt_sqrt_to_lt_times_r : (m : Nat) -> (n : Nat) -> and (Lt (pow m n) n) (Lt m (times n n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_Psi_2_n. Soit $n \\in N$. Supposons que $0 < n$. Alors le produit de $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et de $bool_to_nat$ appliqué à $leb$ appliqué à la somme de $n$ et de $1$ et la puissance de $p$ et de la somme de $i$ et de $1$ et de $Psi (n)$ est égal à $Psi (2 n)$.\nAssistant:", "label": "postulate eq_Psi_2_n : (n : Nat) -> (_ : Lt 0 n) -> Eq (Psi (times 2 n)) (times (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi n))", "predict": "postulate eq_Psi_2_n : soit n : Nat -> (posn : Lt 0 n) -> Eq (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (bool_to_nat (leb (plus n 1) (pow p (plus i 1))))))) (Psi 2 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : let m n a b : Nat\n  and (Lt 0 n) (Lt 0 m) (Eq (gcd n m) 1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_theta_M_theta. Pour tous les nombres naturels $m$, $theta (2 m + 1)\\leq M (m)theta (m + 1)$.\nAssistant:", "label": "postulate le_theta_M_theta : (m : Nat) -> Leq (theta (plus (times 2 m) 1)) (times (M m) (theta (plus m 1)))", "predict": "postulate le_theta_M_theta : tous les nombres naturels m -> theta (2 m + 1) \\leq M (m)theta (m + 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRC_reflexive. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $R$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_relations.reflexive$ applied to $A$ and $matita_basics_relations.RC$ applied to $A$ and $R$.\nAssistant:", "label": "postulate RC_reflexive : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))", "predict": "postulate RC_reflexive : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term cic.prop (matita_basics_relations.reflexive A (matita_basics_relations.RC A R))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_inv_ind. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $x2$ av $cic.Term$ av $univs.Type0$ och $x1$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$, för alla funktioner $P$ från element $_z1698$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x1$ och $x2$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat på $a$ och $x2$ och $x2$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $prod$ applicerat", "label": "postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1699 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1698 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (prod b c)) (prod (matita_arithmetics_bigops.ACop x1 x2) a b c))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) Hterm (matita_arithmetics_bigops.Dop x1 x2 P)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.Dop x1 x2 P) Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_le_minus_r. Låt $p$ och $q$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $p$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $p$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $q$.\nAssistant:", "label": "postulate monotonic_le_minus_r : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))", "predict": "postulate monotonic_le_minus_r : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le q p)) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.minus n p) (matita_arithmetics_nat.minus n q))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAxiom. Låt $_n$ vara ett naturligt tal. Då är $\\sqrt{ _n}$ ett naturligt tal.\nAssistant:", "label": "postulate sqrt : (_n : Nat) -> Nat", "predict": "postulate låt : (_n : Nat) -> Nat -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Assume that $m n = p c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (auto : Nat -> (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (auto : Eq (gcd p m) a p - b m) -> (auto : Eq (gcd p m) a p) -> (auto : Eq (gcd p m) b m) -> (H : Eq (gcd p m) b m - a) -> Eq m b - p a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCongruent_ab_lt. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Då för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $x$ som $matita_basics_logic.And$ applicerat på $matita_basics_logic.And$ applicerat på $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $a$ och $m$ och $matita_arithmetics_congruence.congruent$ applicerat på $x$ och $b$ och $n$ och $matita_arithmetics_nat.lt$ applicerat på $x$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$.\nAssistant:", "label": "postulate congruent_ab_lt : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))", "predict": "postulate congruent_ab_lt : let (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> let (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_congruence.congruent x a m) (matita_arithmetics_congruence.congruent x b n)) (matita_arithmetics_nat.lt x (matita_arithmetics_nat.times m n))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_O_to_not_divides. Soient $n$ et $i$ et $r$ des nombres naturels. Alors si $0$ est inférieur à $n$, alors si $p_ord$ appliqué à $n$ et $nth_prime$ appliqué à $i$ est égal à $mk_Prod$ appliqué à $Nat$ et $Nat$ et $0$ et $r$, alors $nth_prime$ appliqué à $i$ n'est pas divisible par $n$.\nAssistant:", "label": "postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)", "predict": "postulate p_ord_O_to_not_divides : (n : Nat) -> (i : Nat) -> (r : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (p_ord n (nth_prime i)) (mk_Prod Nat Nat 0 r)) -> not (divisible (nth_prime i) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$ and $n \\leq m$. Assume that $n \\leq q + 1$ and $n$ is not divisible by $m$. Let $a \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$ and $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then $n b - a mod (m, n)= gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (nm : Leq n q) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Lt n b) -> Eq n (a (mod m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_to_not_eq_O. Let $n, p, q, r \\in N$. Assume that $1 < n$ and $p_ord (n, nth_prime (p))= mk_Prod (Nat, Nat, q, r)$. Then $r$ is not equal to $0$.\nAssistant:", "label": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)", "predict": "postulate p_ord_to_not_eq_O : (n, p, q, r : Nat) -> (_ : Lt 1 n) -> (p_ord : (n : Nat) -> Nat) -> (q : Nat) -> (r : Nat) -> not (Eq r 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_exists. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soient $t$ et $m$ des nombres naturels. Supposons que $m < t$. Supposons que $f (m)= true$. Soit $k, b \\in N$. Supposons que $b \\leq m$. Soit $__3$ une fonction des nombres naturels $i$ et des éléments $__3$ de $Leq$ de $b$ et de $i$ et des éléments $__4$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $f (i)$ et de contradiction. Alors si $t = k + b$, alors $min (k, b, f)= m$.\nAssistant:", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : soit f : (_ : Nat) -> (v : bool) -> (t : Nat) -> (m : Nat) -> (posn : Lt m t) -> (f : (_ : Nat) -> bool) -> (k : Nat) -> (b : Nat) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (t : Nat) -> (k : Nat) -> (b : Nat) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (H : Eq t k + b) -> and (min k b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c \\in N$. Then if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if $b m - a p = 1$, then $m b - p a$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (H : Eq m n) -> (H0 : Eq (gcd p m) (gcd p m)) -> (H1 : Eq (gcd p m) (gcd p m)) -> (H2 : Eq (gcd p m) (gcd p m)) -> (H3 : Eq (gcd p m) (gcd p m)) -> (H4 : Eq (gcd p m) (gcd p m)) -> (H5 : Eq (gcd p m) (gcd p m)) -> (H6 : Eq (gcd p m) (gcd p m)) -> Eq (m b) (p a)"}
{"prompt": "Human: Translate the following English statement into Agda.\nSubR. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_R$ and $_S$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$. Then $cic.Univ$ holds for $cic.prop$.\nAssistant:", "label": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate SubR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following English statement into Agda.\nNill. Let $A$ be a set. Let $nil$ be an element of $A$. Then for all elements $xxx$ of $Aop$ of $A$ and $nil$, for all elements $a$ of $A$, $op$ applied to $A$ and $nil$ and $xxx$ and $nil$ and $a$ is equal to $a$.\nAssistant:", "label": "postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a", "predict": "postulate nill : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> Eq (op A nil xxx nil a) a"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_0. Soit $n \\in N$. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Alors pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $true$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à la somme de $i$ et de $1$ et $f$ appliqué à $0$ est égal à $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $i$ à $true$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i)) (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0))", "predict": "postulate bigop_0 : soit n : Nat\n        soit B : Set\n        soit nil : B\n        all : (op : Aop B nil) -> (f : (_ : Nat) -> B) -> op (B nil op (bigop n (\\ i : Nat -> true) B nil op) (\\ i : Nat -> f (plus i 1)) (f 0))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15622 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15622 : soit m, n, a, b \\in N. supposons que 0 < n et 0 < m. supposons que 1 = diviseur commun plus grand de n et m. soit c un nombre naturel. soit _clearme un element de ex Nat (\\ d : Nat -> disjonct ( Eq (minus (times c n) (times d m)) 1) ( Eq (minus (times d m) (times c n)) 1)) soit d \\in N. alors si (c n - d m) = 1 ou (d m - c n) = 1 et (d m - c n) = 1 alors m d - n c = 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (Hind : Leq i n) -> (Hind0 : Leq f i0 n) -> (Hind1 : Leq a n) -> (Hind2 : Leq b n) -> (Hind3 : Leq f b) -> (auto : (_ : Nat) -> Leq a n) -> (auto' : (_ : Nat) -> Leq b n) -> (auto'' : (injf : injn f n) -> (auto' : Leq a b) -> f a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (len : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hind : all (d : Nat -> or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) (Nat)) -> (Hind0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hind1 : Eq n c) -> (Hind2 : Eq m d) -> (Hind3 : Eq n (times c n)) -> Eq m d"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que $b m - a p = 1$. Alors $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : soit p, m, n \\in N. Supposons que 0 < p. Supposons que 1 = diviseur commun plus grand de p et m. Supposons que p est divisible par m \\times n. Soit c un nombre naturel. Supposons que m n = p c. Soit a \\in N. Soit _clearme0 : ex Nat (\\ b -> disjonct (Eq (minus (times a p) (times b m)) (diviseur commun plus grand de p m)) (Eq (minus (times b m) (times a p)) (diviseur commun plus grand de p m))) Soit b \\in N. Supposons que le diviseur commun plus grand de p et m est égal à a p - b m ou le diviseur commun plus grand de p et m est égal à b m - a p. Supposons que le diviseur commun plus grand de p et m est égal à b m - a p. Supposons que b m - a p = 1. Alors m b - p a = 1."}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : soit m, n, a, b \\in N"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_aux_body. Låt $_p, _m, _n \\in N$. Då $Nat$.\nAssistant:", "label": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Nat", "predict": "postulate div_aux_body : (_p : Nat) -> (_m : Nat) -> (_n : Nat) -> Då Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nProp140. Let $x, y \\in Z$. Then $x$ is equal in parity with $y$, if and only if the sum of $x$ and $y$ is even.\nAssistant:", "label": "postulate prop140 : (x : Int) -> (y : Int) -> iff (same_parity x y) (even (plus x y))", "predict": "postulate prop140 : (x : Z) -> (y : Z) -> Eq x y -> even (plus x y)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Då om $0$ är mindre än $m$, så om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (zero : Lt 0 n) -> (smaller : Lt 0 m) -> (H : Eq 0 m) -> (H0 : Eq 0 n) -> (H1 : Eq (largestCommonDenominator n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> (\\ H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (H2 : Eq (minus (times c n) (times d m)) (times c n)) -> (H3 : Eq (minus (times d m) (times c n)) 1) -> (H4 : Eq (minus (times d m) (times c n)) 1) -> Eq (largestCommonDenominator m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEx_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_ex_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $x_236$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.ex_intro$ applicerat på $A$ och $_P$ och $x$ och $x_236$, för alla element $x_235$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_235$.\nAssistant:", "label": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)", "predict": "postulate ex_ind_body : let A : cic.Univ univs.Type0 in let _P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop in let Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop in (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop _P x) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_void. Pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_void : (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAll_append. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soient $l1$ et $l2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l1$. Alors pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $l2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.All$ appliqué à $A$ et $P$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$.\nAssistant:", "label": "postulate All_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.All A P l1)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.All A P l2)) -> cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))", "predict": "postulate All_append : soit A un élément de cic.Univ univs.Type0. Soit P une fonction des elements __ : cic.Term univs.Type0 A -> cic.Univ cic.prop. Soient l1 et l2 des elements de cic.Term univs.Type0 (matita_basics_lists_list.list A). Soit __ un element de cic.Term cic.prop (matita_basics_lists_list.All A P l1). Alors pour tous les elements __1 de cic.Term cic.prop (matita_basics_lists_list.All A P l2), cic.Term cic.prop (matita_basics_lists_list.All A P (matita_basics_lists_list.append A l1 l2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_discr. Låt $a1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $a2$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $a1$ till element av $cic.Univ$ av $cic.prop$. Då för alla element $x$ och $y$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $a1$ och $a2$, för alla element $_e$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Sig$ applicerat på $a1$ och $a2$ och $x$ och $y$, håller $cic.Term$ för $univs.Type2$ och $matita_basics_types.match_Sig$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $t0$ och $t1$ som $matita_basics_types.match_Sig$ applicerat på $a1$ och $a2$ och $cic.succ$ applicerat på $univs.Type2$ och funktionen som avbildar $__$ som $cic.univ$ applicerat på $univs.Type2$ och funktionen som avbildar $u0$ och $u1$ som", "label": "postulate Sig_discr : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ t0 : cic.Term univs.Type0 a1 -> \\ t1 : cic.Term cic.prop (a2 t0) -> matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2) (\\ u0 : cic.Term univs.Type0 a1 -> \\ u1 : cic.Term cic.prop (a2 u0) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 ((\\ x0 : cic.Term univs.Type0 a1 -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 a1) (matita_basics_logic.R0 a1 t0) x0) -> a2 x0) u0 e0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 a1) t0 (\\ x_19 : cic.Term univs.Type0 a1 -> \\ _x_", "predict": "postulate let : (a1 : cic.Univ univs.Type0) -> (a2 : (__ : cic.Term univs.Type0 a1) -> cic.Univ cic.prop) -> (x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig a1 a2)) x y)) -> cic.Term univs.Type2 (matita_basics_types.match_Sig a1 a2 (cic.succ univs.Type2) (\\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.succ univs.Type2 (\\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2 (\\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.univ univs.Type2 (\\ x : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ y : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> \\ z : cic.Term univs.Type0 (matita_basics_types.Sig a1 a2) -> cic.prod (cic.succ univs.Type0) univs.Type0 (cic.univ univs.Type0) (\\ u : cic.Term univs.Type0 univs.Type0 -> \\ v : cic.Term univs.Type0 univs"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_div_mod_spec. Let $n$ and $m$ be natural numbers. Assume that $0$ is less than $n$. Assume that $n$ is divisible by $m$. Then $div_mod_spec$ holds for $m$ and $n$ and the quotient of $m$ and $n$ and $0$.\nAssistant:", "label": "postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0", "predict": "postulate divides_to_div_mod_spec : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> div_mod_spec m n (div m n) 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrime_to_lt_O. Pour tous les nombres naturels $p$, si $p$ est premier, alors $0$ est inférieur à $p$.\nAssistant:", "label": "postulate prime_to_lt_O : (p : Nat) -> (_ : prime p) -> Lt 0 p", "predict": "postulate prime_to_lt_O : tous les nombres naturels p -> (p : Nat) -> (_ : prime p) -> Lt 0 p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPair_elim2. Låt $A$ och $B$ och $C$ och $C'$ vara element av $cic.Univ$ av $univs.Type0$. Låt $T$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Låt $T'$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C'$. Då för alla element $p$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$, för alla funktioner $P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $C$ och element $__2$ av $cic.Term$ av $univs.Type0$ och $C'$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $__$ från element $lft$ av $cic.Term$ av $univs.Type0$ och $A$ och element $rgt$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.Prod$ applicerat på $A$ och $B$ och $p$ och $matita_basics_types.mk_Prod$ applicerat på $A$ och $B$ och $lft$ och $rgt$ till element av $cic.Term$ av $cic.prop", "label": "postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (P (matita_basics_types.mk_Prod A B lft rgt) (T lft rgt) (T' lft rgt))) -> cic.Term cic.prop (P p (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C) (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T lft rgt) p) (matita_basics_types.match_Prod A B univs.Type0 (\\ _0 : cic.Term univs.Type0 (matita_basics_types.Prod A B) -> C') (\\ lft : cic.Term univs.Type0 A -> \\ rgt : cic.Term univs.Type0 B -> T' lft rgt) p))", "predict": "postulate pair_elim2 : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (C' : cic.Univ univs.Type0) -> (T : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (T' : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C') -> (p : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_types.Prod A B)) -> (__1 : cic.Term univs.Type0 C) -> (__2 : cic.Term univs.Type0 C') -> cic.Univ cic.prop) -> (__ : (lft : cic.Term univs.Type0 A) -> (rgt : cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod A B)) p (matita_basics_types.mk_Prod A B lft rgt))"}
{"prompt": "Human: Translate the following English statement into Agda.\nRefute_none_by_refl. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $Q$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Univ$ of $univs.Type0$. Let $x$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.option$ applied to $A$. Then for all functions $H$ from elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.None$ applied to $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, for all functions $__$ from elements $v$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $matita_basics_types.Some$ applied to $A$ and $v$ to elements of $cic.Term$ of $univs.Type0$ and $Q$ applied to $P$ applied to $v$, $cic.Term$ holds for $univs.Type0$ and $Q$ applied to $matita_basics_types.match_option$ applied to $A$ and $univs.Type0$ and the function that maps $y$ to $cic.prod$ applied to $cic.prop$ and $univs.Type0$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.option$ applied to $A$ and $x$ and $y$ and the function that maps $__1$ to $B$ and the function that maps $", "label": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 (matita_basics_types.option A) -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B)) (\\ E : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A)) -> matita_basics_logic.match_False univs.Type0 (\\ _0 : cic.Term cic.prop matita_basics_logic.False -> B) (H E)) (\\", "predict": "postulate refute_none_by_refl : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (Q : (__ : cic.Term univs.Type0 B) -> cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_basics_types.option A)) -> (H : (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.None A))) -> cic.Term cic.prop matita_basics_logic.False) -> (__ : (v : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x (matita_basics_types.Some A v))) -> cic.Term univs.Type0 (Q (P v))) -> cic.Term univs.Type0 (Q (matita_basics_types.match_option A univs.Type0 (\\ y : cic.Term univs.Type0 A -> cic.prod cic.prop univs.Type0 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) (\\ __1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option A)) x y) -> B) y)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_exp_to_divides. Soit $p, n, m \\in N$. Alors si $p$ est premier, alors si $p$ est divisible par $n ^ m$, alors $p$ est divisible par $n$.\nAssistant:", "label": "postulate divides_exp_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : prime p) -> (__1 : divisible p (pow n m)) -> divisible p n", "predict": "postulate divides_exp_to_divides : soit p, n, m : Nat -> (_ : prime p) -> (__1 : divisible p n) -> divisible p n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_times. Låt $n1$ och $n2$ och $m1$ och $m2$ vara naturliga tal. Anta att $n1$ är mindre än eller lika med $n2$. Då om $m1$ är mindre än eller lika med $m2$, så är produkten av $n1$ och $m1$ mindre än eller lika med produkten av $n2$ och $m2$.\nAssistant:", "label": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)", "predict": "postulate letimes : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_maxr. Let $i, n, m \\in N$. Assume that $max$ applied to $n$ and $m$ is less than or equal to $i$. Then $m$ is less than or equal to $i$.\nAssistant:", "label": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i", "predict": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c \\in N$. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a \\in N$. Alors pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$, alors si la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale à $1$, alors le diviseur commun plus grand de $p$ et de $m$ est égal à la différence du produit de $p$ et de $a$ et du produit de $m$ et de $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (divcomm : Eq (gcd p m) 1) -> (auto : divisible p (times m n)) -> (c : Nat) -> (auto' : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> disjonct (Eq (minus (times a p) (times b m)) (divcomm)) (Eq (minus (times b m) (times a p)) (divcomm))) (Eq (minus (times b m) (times a p)) (divcomm)) (Eq (minus (times a p) (times b m)) (divcomm))) -> (b : Nat) -> (_clearme1 : Eq (minus (times a p) (times b m)) (divcomm)) -> (auto' : Eq (minus (times b m) (times a p)) (divcomm)) -> (H : Eq (minus (times a p) (times b m)) (divcomm)) -> (auto' : Eq (minus (times a p) (times b m)) 1) -> Eq (divcomm p m) (minus (times p m) (times a b))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMonotonic_lt_times_r. Let $c \\in N$. Then if $0 < c$, then $monotonic$ holds for $Nat$ and $Lt$ and the function that maps $t$ to $c \\times t$.\nAssistant:", "label": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> times c t)", "predict": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> c \\ t)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1569. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : all Nat (\\ d : Nat -> or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hc : Eq (minus (times d m) (times c n)) 1) -> Eq n (times c m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type0. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_873$ of $Aop$ of $A$ and $_nil$ to sets. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Then for all elements $x_873$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_873$.\nAssistant:", "label": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873", "predict": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSameF_p_le. Låt $A$ vara en mängd. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $f$ och $g$ vara funktioner från naturliga tal till element av $A$. Låt $n$ och $m$ vara naturliga tal. Då om $n$ är mindre än eller lika med $m$, så för alla element $__1$ av $sameF_p$ av $m$ och $p$ och $A$ och $f$ och $g$, håller $sameF_p$ för $n$ och $p$ och $A$ och $f$ och $g$.\nAssistant:", "label": "postulate sameF_p_le : (A : Set) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> A) -> (g : (_ : Nat) -> A) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (__1 : sameF_p m p A f g) -> sameF_p n p A f g", "predict": "postulate sameF_p_le : låt A vara en mängd. låt p vara en funktion från naturliga tal till sanningsvärden. låt f och g vara funktioner från naturliga tal till element av A. låt n och m vara naturliga tal. Då om n är mindre eller lika med m, så för alla element __1 av sameF_p m p A f g, håller sameF_p n p A f g."}
{"prompt": "Human: Translate the following English statement into Agda.\nProp110. Let $a$ and $c$ be integers. Then if both $a$ and $c$ are odd, then $a b + b c$ is even for every integer $b$.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : (a : Int) -> (c : Int) -> even (plus a b) (plus c b)"}
{"prompt": "Human: Translate the following English statement into Agda.\nPlus_to_minus. For all elements $n$ and $m$ and $p$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.minus$ applied to $n$ and $m$ and $p$.\nAssistant:", "label": "postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)", "predict": "postulate plus_to_minus : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus n m) p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Då om $0$ är mindre än $n$, så om $0$ är mindre än $m$, så om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) (minus (times d m) (times c n))) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDecidable_lt. För alla naturliga tal $n$ och $m$, håller $decidable$ för $Lt (n, m)$.\nAssistant:", "label": "postulate decidable_lt : (n : Nat) -> (m : Nat) -> decidable (Lt n m)", "predict": "postulate decidable_lt :forall (n : Nat) (m : Nat) -> decidable (Lt (n, m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_73. Let $n$ and $m$ and $p$ be natural numbers. Assume that $0$ is less than $p$. Let $x134$ and $x135$ and $x136$ be natural numbers. Then the sum of $x134$ and the sum of $x135$ and $x136$ is equal to the sum of $x135$ and the sum of $x134$ and $x136$.\nAssistant:", "label": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))", "predict": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_Type2. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_602$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type2$. Soit $_H_None$ un élément de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_603$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_603$. Soit $x_602$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$. Alors $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_602$.\nAssistant:", "label": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)", "predict": "postulate option_rect_Type2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ univs.Type2) -> (_H_None : cic.Term univs.Type2 (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_603 : cic.Term univs.Type0 _A) -> cic.Term univs.Type2 (Q_ (matita_basics_types.Some _A x_603))) -> (x_602 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term univs.Type2 (Q_ x_602)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBool_rect_Type2. Soit $Q_$ une fonction des éléments $_x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_true$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.true$, pour tous les éléments $_H_false$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_bool.false$, pour tous les éléments $x_338$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_338$.\nAssistant:", "label": "postulate bool_rect_Type2 : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)", "predict": "postulate soit : (Q_ : (_x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type2) -> (_H_true : cic.Term univs.Type2 (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term univs.Type2 (Q_ matita_basics_bool.false)) -> (x_338 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ x_338)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_Sm_elim. Soit $n, m \\in N$. Supposons que $n$ est inférieur ou ágal à la somme de $m$ et de $1$. Soit $P$ une proposition. Soit $__1$ une fonction des éléments $__1$ de $Leq$ de la somme de $n$ et de $1$ et de la somme de $m$ et de $1$ à des éléments de $P$. Alors pour toutes les fonctions $__2$ des éléments $__2$ de $Eq$ de $n$ et de la somme de $m$ et de $1$ à des éléments de $P$, $P$.\nAssistant:", "label": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P", "predict": "postulate le_n_Sm_elim : soit n, m : Nat -> Prop -> Prop -> (P : Prop) -> (__1 : (__1 : Leq (plus n m) 1) -> plus m 1) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1595. Let $p, n, m \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Then if the greatest common divisor of $p$ and $n$ is equal to $1$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $1$ is less than the greatest common divisor of $p$ and the product of $n$ and $m$, then if $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $n$ is equal to the greatest common divisor of $p$ and $m$.\nAssistant:", "label": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)", "predict": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq (gcd p n) 1) -> (H0 : Eq (gcd p m) 1) -> (H1 : Lt 1 (gcd p (times n m))) -> (H2 : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMod_n_n. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $n$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)", "predict": "postulate mod_n_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n n) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_S_to_lt. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et $m$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate lt_S_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)", "predict": "postulate lt_S_to_lt : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> soit m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S n) m)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_discr. For all sets $a1$, for all elements $x$ and $y$ of $range$ of $a1$, if $x = y$, then $match_range$ holds for $a1$ and $Type2 + 1$ and the function that maps $__$ to $univ (Type2)$ and the function that maps $t0$ and $t1$ and $t2$ to $match_range$ applied to $a1$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ and $u2$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $a1$ and $t0$ and the function that maps $x0$ and $p0$ to $Nat$ and $t1$ and $u0$ and $e0$ and $u1$ and the function that maps $e1$ to $prod$", "label": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ t0 : ((_ : Nat) -> a1) -> \\ t1 : Nat -> \\ t2 : ((_ : Nat) -> bool) -> match_range a1 (plus Type2 1) (\\ _ : range a1 -> univ Type2) (\\ u0 : ((_ : Nat) -> a1) -> \\ u1 : Nat -> \\ u2 : ((_ : Nat) -> bool) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0) (\\ e0 : Eq (R0 (prod Set Set Nat (\\ _ : Nat -> a1)) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\ p00 : Eq t0 x00 -> Nat) t1 x0 p0) x1 -> prod Set Set Nat (\\ _ : Nat -> bool)) t2 u0 e0 u1 e1) u2) (\\ _e2 : Eq (R2 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> Nat) t1 (\\ x0 : ((_ : Nat) -> a1) -> \\ p0 : Eq t0 x0 -> \\ x1 : Nat -> \\ p1 : Eq (R1 (prod Set Set Nat (\\ _ : Nat -> a1)) t0 (\\ x00 : ((_ : Nat) -> a1) -> \\", "predict": "postulate range_discr : (a1 : Set) -> (x : range a1) -> (y : range a1) -> (_e : Eq x y) -> match_range a1 Type2 1 (\\ _ : range a1) -> univ Type2 (\\ t0 : (_ : range a1) -> t1 : (_ : range a1) -> t2 : (_ : range a1) -> match_range a1 (plus Type2 1) (\\ _ : range a1) -> univ Type2 (\\ u0 : (_ : range a1) -> u1 : (_ : range a1) -> u2 : (_ : range a1) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ e0 : Eq (R0 (prod Set Set Nat) (\\ _ : range a1) t0 u0) t1 u0 e0) u1) (\\ e1 : Eq (R0 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ _ : range a1) -> prod Prop Type1 (Eq (R1 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ x0 : (_ : range a1) -> p0 : Eq x0 t0) t1 u0 e0 u1) (\\ e0 : Eq (R1 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ _ : range a1) -> prod Prop Type1 (Eq (R2 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ x0 : (_ : range a1) -> p0 : Eq x0 t0) t1 u0 e0 u1 x0) (\\ x1 : (_ : range a1) -> p1 : Eq x1 t1) t2 u0 e0 u1 x0 x1) (\\ e0 : Eq (R2 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ _ : range a1) -> prod Prop Type1 (Eq (R3 (prod Set Set Nat) (\\ _ : range a1) t0 u0) (\\ x0"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_d_times_gcd. Soient $m$ et $n$ et $d$ et $c$ des nombres naturels. Alors si $0 < c$ et $d$ est divisible par $c \\times m$, alors si $d$ est divisible par $c \\times n$, alors $d$ est divisible par le produit de $c$ et du diviseur commun plus grand de $n$ et de $m$.\nAssistant:", "label": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))", "predict": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d c) -> (__2 : divisible d c) -> divisible d (times c (div c m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_divides_ord_rem. Let $p, n, m \\in N$. Then if $0$ is less than $n$, then if $0$ is less than $m$, then if $p$ is prime, then if $n$ is divisible by $m$, then $ord_rem$ applied to $n$ and $p$ is divisible by $ord_rem$ applied to $m$ and $p$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_1_to_lt_n. Let $i, n \\in N$. Assume that $1$ is less than $n$. Then if $i$ is less than or equal to $n$, then if the greatest common divisor of $i$ and $n$ is equal to $1$, then $i$ is less than $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n", "predict": "postulate gcd_1_to_lt_n : (i : Nat) -> (n : Nat) -> (_ : Lt 1 n) -> (__1 : Leq i n) -> (__2 : Eq (gcd i n) 1) -> Lt i n"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp5_body. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a \\in N$. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Assume that $b m - a p = 1$. Then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eqn : Eq 1 (gcd p m)) -> (divnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) a p) (Eq (gcd p m) b m)) -> (H : Eq (gcd p m) b m) -> Eq m b p"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_mod. Soit $p, m, n \\in N$. Alors si $0$ est inférieur à $n$, alors si $p$ est divisible par $m$, alors si $p$ est divisible par $n$, alors $p$ est divisible par $mod$ appliqué à $m$ et $n$.\nAssistant:", "label": "postulate divides_mod : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)", "predict": "postulate divides_mod : soit p, m, n : N -> (_ : Lt 0 n) -> (__1 : divisible p m) -> (__2 : divisible p n) -> divisible p (mod m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_lt_to_lt. Let $n, m, p \\in N$. Assume that $n \\leq m$ and $m < p$. Then $n < p$.\nAssistant:", "label": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq n m) -> (__1 : Lt m p) -> Lt n p", "predict": "postulate le_to_lt_to_lt : (n : Nat) -> (m : Nat) -> (p : Nat) -> let n : Nat -> let m : Nat -> let p : Nat -> let le : (_ : Nat) -> (_ : Nat) -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Natpostulate"}
{"prompt": "Human: Translate the following English statement into Agda.\nEven_or_odd. For all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $a$ to $matita_basics_logic.Or$ applied to $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $a$.\nAssistant:", "label": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))))", "predict": "postulate even_or_odd : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ a : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nFalse_rect_CProp0_body. For all functions $Q_$ from elements $_x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$ to elements of $cic.Univ$ of $cic.prop$, for all elements $x_78$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.False$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_78$.\nAssistant:", "label": "postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)", "predict": "postulate False_rect_CProp0_body : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLength_map. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_basics_lists_list.length$ appliqué à $B$ et $matita_basics_lists_list.map$ appliqué à $A$ et $B$ et $f$ et $l$ et $matita_basics_lists_list.length$ appliqué à $A$ et $l$.\nAssistant:", "label": "postulate length_map : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))", "predict": "postulate length_map : sont A B : cic.Univ univs.Type0 -> cic.Univ univs.Type0 -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length B (matita_basics_lists_list.map A B f l)) (matita_basics_lists_list.length A l))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax'. Let $__ \\in N$. Let $__1$ be a function from natural numbers $__1$ to booleans. Let $__2$ be a natural number. Then $Nat$.\nAssistant:", "label": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat", "predict": "postulate max' : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (__2 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_inv_rect_Type3. För alla element $x1$ av $cic.Univ$ av $univs.Type0$, för alla element $Hterm$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$, för alla funktioner $P$ från element $_z1644$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type3$, för alla funktioner $_H1$ från funktioner $_enum$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och element $_upto$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_filter$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ och element $_z1645$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_bigops.range$ applicerat på $x1$ och $Hterm$ och $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$ till element av $cic.Term$ av $univs.Type3$ och $P$ applicerat på $matita_arithmetics_bigops.mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$, håller $cic.Term$ för $univs.Type3$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate range_inv_rect_Type3 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1644 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ univs.Type3) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1645 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_list. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $return_sort$ de $cic.Sort$, pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_list : (_A : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_CProp1_body. Let $_A$ be an element of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $cic.prop$. Then for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_937$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_937$.\nAssistant:", "label": "postulate range_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)", "predict": "postulate range_rect_CProp1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ cic.prop) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_937 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term cic.prop (Q_ x_937)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1686. Låt $n$ och $m$ vara naturliga tal. Låt $Hind$ vara en funktion från naturliga tal $p$ och element av $Lt$ av $p$ och $m$ och element $__1$ av $Lt$ av $1$ och $p$ till element av $Leq$ av $Psi (p)$ och $pred (p)\\times (2 ^ (2 p - 3))$. Låt $a \\in N$. Anta att $m = 2 a$ eller $m = 2 a + 1$ och $m = 2 a + 1$. Anta att $1 < 2 a + 1$ och $0 < a$. Då $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> or (and (Eq m 2 a) (and (Lt 1 2 a) (Lt a 1))) -> (and (Lt m 2 a) (and (Lt 1 2 a) (Lt a 1))) -> (Lt 1 2 a) -> Eq (pred m) a"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_min_r. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $n$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$.\nAssistant:", "label": "postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))", "predict": "postulate le_min_r : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b f) (matita_arithmetics_nat.plus n b))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_inv_S_dx. Låt $B$ vara en mängd. Då för alla element $R$ av $relation$ av $B$, för alla naturliga tal $l$, för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar$ av $B$ och $R$ och summan av $l$ och $1$ och $b1$ och $b2$, håller $ex2$ för $B$ och funktionen som avbildar $b$ som $lstar$ applicerat på $B$ och $R$ och $l$ och $b1$ och $b$ och funktionen som avbildar $b$ som $R$ applicerat på $b$ och $b2$.\nAssistant:", "label": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)", "predict": "postulate låt : (B : Mngd) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_inv_plus_l. Låt $x$ och $y$ och $z$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $z$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $x$ och $z$ och $matita_arithmetics_nat.lt$ applicerat på $y$ och $matita_arithmetics_nat.minus$ applicerat på $z$ och $x$.\nAssistant:", "label": "postulate lt_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))", "predict": "postulate lt_inv_plus_l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.lt x z) (matita_arithmetics_nat.lt y (matita_arithmetics_nat.minus z x)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSqrt_def. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_sqrt.sqrt$ appliqué à $n$ et $matita_arithmetics_minimization.max$ appliqué à $matita_arithmetics_nat.S$ appliqué à $n$ et la fonction qui envoie $x$ à $matita_arithmetics_nat.leb$ appliqué à $matita_arithmetics_nat.times$ appliqué à $x$ et $x$ et $n$.\nAssistant:", "label": "postulate sqrt_def : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))", "predict": "postulate sqrt_def : soit n un élément de cic.Term univs.Type0 matita_arithmetics_nat.nat. Alors cic.Term tient pour cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_sqrt.sqrt n) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) (\\ x : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.leb (matita_arithmetics_nat.times x x) n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nProd. For all elements $_A$ and $_B$ of $cic.Univ$ of $univs.Type0$, $cic.Univ$ holds for $univs.Type0$.\nAssistant:", "label": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Alors pour tous les nombres naturels $b$, si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : (_ : f n) -> n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq i n) -> (H0 : Leq j n) -> (H1 : Leq a n) -> (H2 : Leq a n) -> (H3 : f (a)) -> (H4 : Leq b n) -> (H5 : f (b)) -> (H6 : Leq b n) -> (H7 : f (b)) -> (H8 : injn f n) -> (H9 : injn f n) -> (H10 : Eq (f a) j) -> (H11 : Leq b n) -> (H12 : Leq f (b)) -> (H13 : injf (f a) n) -> (H14 : injf (f b) n) -> (H15 : Eq (f a) j) -> (H16 : Leq (f a) n) -> Eq (f a) j"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b$ be a natural number. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$. Then if $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then $n b - a mod (m, n)= gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (ltm : Leq n m) -> (bnd : Nat) -> (auto : a mod (m n) - b n = gcd_aux (q n) (mod (m n))) -> (Hind' : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux (q n) (mod (m n)))) -> (Hind'' : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))) -> Eq (minus (times a (mod m n)) (times b n)) (gcd_aux (q n) (mod (m n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_or_gt. Låt $n$ vara ett naturligt tal. Då $0 = n$ eller $0 < n$.\nAssistant:", "label": "postulate eq_or_gt : (n : Nat) -> or (Eq 0 n) (Lt 0 n)", "predict": "postulate eq_or_gt : let n : Nat in or (Eq 0 n) (Lt 0 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Dop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Då för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på", "label": "postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ return_sort) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Dop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (z : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> (case_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term return_sort (return_type z (matita_arithmetics_bigops.Dop A _nil)) (case_mk_Dop (matita_arithmetics_bigops.ACop A _nil) (prod __ __1) (__ __2) __3) (prod __4 __5) (__6 __7)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFst_p_ord_times. Låt $p$ och $a$ och $b$ vara naturliga tal. Anta att $p$ är primt. Anta att $0$ är mindre än $a$. Då om $0$ är mindre än $b$, så är $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på produkten av $a$ och $b$ och $p$ lika med summan av $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $a$ och $p$ och $fst$ applicerat på $Nat$ och $Nat$ och $p_ord$ applicerat på $b$ och $p$.\nAssistant:", "label": "postulate fst_p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))", "predict": "postulate fst_p_ord_times : let (p : Nat) -> (a : Nat) -> (b : Nat) -> (primp : prim p) -> (posn : Lt 0 a) -> (Hind : Lt 0 b) -> Eq (fst Nat Nat (p_ord (times a b) p)) (plus (fst Nat Nat (p_ord a p)) (fst Nat Nat (p_ord b p)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_div_div_div_div. Låt $n, m, q \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då är kvoten av kvoten av $q$ och $n$ och $m$ lika med kvoten av kvoten av $q$ och $m$ och $n$.\nAssistant:", "label": "postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> Eq (div (div q n) m) (div (div q m) n)", "predict": "postulate eq_div_div_div_div : (n : Nat) -> (m : Nat) -> (q : Nat) -> Anta att 0 < n"}
{"prompt": "Human: Translate the following French statement into Agda.\nFound_max_spec. Soit $n \\in N$. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $m \\in N$. Alors si $m$ est inférieur à $n$, alors si $f$ appliqué à $m$ est égal à $true$, alors pour toutes les fonctions $__2$ des nombres naturels $i$ et des éléments $__2$ de $Lt$ de $m$ et de $i$ et des éléments $__3$ de $Lt$ de $i$ et de $n$ à des éléments de $Eq$ de $f$ appliqué à $i$ et de contradiction, $max_spec$ tient pour $n$ et $f$ et $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : soit n : Nat\n           soit f : (_ : Nat) -> bool\n           soit m : Nat\n           then (inf m n) -> (H : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_exp_to_lt. Soit $a, n, m \\in N$. Alors si $0 < a$, alors si $a ^ n < a ^ m$, alors $n < m$.\nAssistant:", "label": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m", "predict": "postulate lt_exp_to_lt : soit a n m : Nat -> (_ : Lt 0 a) -> (__1 : Lt a n) -> Lt m a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDistributive_times_plus_r. Låt $a$ och $b$ och $c$ vara naturliga tal. Då är produkten av summan av $b$ och $c$ och $a$ lika med summan av produkten av $b$ och $a$ och produkten av $c$ och $a$.\nAssistant:", "label": "postulate distributive_times_plus_r : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (times (plus b c) a) (plus (times b a) (times c a))", "predict": "postulate distributive_times_plus_r : let a : Nat, b : Nat, c : Nat -> Eq (times (plus b c) a) (plus (times b a) (times c a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_inv_rect_Type2. Låt $x1$ vara en mängd. Låt $Hterm$ vara ett element av $range$ av $x1$. Låt $P$ vara en funktion från element $_z1650$ av $range$ av $x1$ till element av $Type2$. Låt $_H1$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $x1$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden och element $_z1651$ av $Eq$ av $Hterm$ och $mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$ till element av $P$ av $mk_range$ applicerat på $x1$ och $_enum$ och $_upto$ och $_filter$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_Type2 : (x1 : Mngd) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> (Hterm : range x1) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors pour tous les nombres naturels $x1029$, $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (times c n) (times d m)) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Then for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$, for all functions $P$ from elements $_z1128$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1129$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type1$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type1$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate DPair_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1128 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1129 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nTheta_pred. Pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_chebyshev_chebyshev_theta.theta$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nAssistant:", "label": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_plus_times. För alla naturliga tal $m$ och $q$ och $r$, om $r$ är mindre än $m$, så är kvoten av summan av produkten av $q$ och $m$ och $r$ och $m$ lika med $q$.\nAssistant:", "label": "postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q", "predict": "postulate div_plus_times : (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt r m) -> Eq (div (plus (times q m) r) m) q"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_divides. Pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_bool.bool$.\nAssistant:", "label": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1. Soit $_A$ un ensemble. Soit $Q_$ une fonction des éléments $_x_925$ de $range$ de $_A$ à des éléments de $Type1$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range (_A, _enum, _upto, _filter)$. Soit $x_925$ un élément de $range$ de $_A$. Alors $Q_$ tient pour $x_925$.\nAssistant:", "label": "postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925", "predict": "postulate range_rect_Type1 : (_A : Set) -> (Q_ : (_x_925 : range _A Type1) -> Type1) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_925 : range _A) -> Q_ x_925"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_to_le. For all elements $x$ and $y$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $x$ and $y$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x$ and $y$.\nAssistant:", "label": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)", "predict": "postulate lt_to_le : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt x y)) -> cic.Term cic.prop (matita_arithmetics_nat.le x y)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProd_ind_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_690$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $x_690$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_690$.\nAssistant:", "label": "postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)", "predict": "postulate Prod_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ cic.prop) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_690 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term cic.prop (Q_ x_690)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type1. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Då för alla funktioner $P$ från element $_z1062$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type1$, för alla funktioner $_H1$ från element $_z1063$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_607$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1063$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_607$ till element av $cic.Term$ av $univs.Type1$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_607$, håller $cic.Term$ för $univs.Type1$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)", "predict": "postulate option_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1062 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type1) -> (_H1 : (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type1 (P (matita_basics_types.None x1))) -> (_H2 : (x_607 : cic.Term univs.Type0 x1) -> (_z1063 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P (matita_basics_types.Some x1 x_607))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nK1. Soient $n$ et $p$ des nombres naturels. Alors si $18 \\leq n$ et $p \\leq n$, alors si $2 n \\div 3 < p$, alors $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate K1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (ltml : Leq p n) -> (__1 : Lt 2 n (div p)) -> Eq (k (2 n, p)) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_exists_to_forall. Låt $P$ vara en funktion från naturliga tal till påståenden. Låt $n \\in N$. Anta att det inte är fallet att $ex$ håller för $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och $P$ applicerat på $i$. Då för alla naturliga tal $i$, om $i < n$, så är det inte fallet att $P$ håller för $i$.\nAssistant:", "label": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)", "predict": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (ltml : Lt n (pow 2 (mod n 2))) -> (Pn : (_ : Nat) -> Prop) -> (i : Nat) -> (_ : Lt i n) -> not (P i)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_minus. Låt $n, p, q \\in N$. Anta att $n$ är delbart med $p$. Anta att $n$ är delbart med $q$. Då är $n$ delbart med $p - q$.\nAssistant:", "label": "postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (minus p q)", "predict": "postulate divides_minus : (n : Nat) -> (p : Nat) -> (q : Nat) -> and (div n p) (div n q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nR2. For all elements $T0$ of $cic.Univ$ of $univs.Type0$, for all elements $a0$ of $cic.Term$ of $univs.Type0$ and $T0$, for all functions $T1$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $a1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$, for all functions $T2$ from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$, for all elements $_a2$ of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $", "label": "postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univ", "predict": "postulate R2 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (_a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1))) -> cic.Term univs.Type0 (matita_basics_logic.R2 T0 (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1) x0 p0 x1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1559. Låt $n, m \\in N$. Anta att $n$ är delbart med $m$. Anta att $0$ är lika med $n$. Låt $d \\in N$. Anta att $m$ är lika med produkten av $0$ och $d$. Då är $m$ lika med $n$.\nAssistant:", "label": "postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq m n", "predict": "postulate let_clause_1559 : (n : Nat) -> (m : Nat) -> (auto : and (div n m) (Eq 0 n)) -> (d : Nat) -> (auto' : Eq m (times 0 d)) -> Eq m n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFound_min_spec. Låt $n$ och $b$ vara naturliga tal. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $m \\in N$. Anta att $b$ är mindre än eller lika med $m$. Anta att $m$ är mindre än summan av $n$ och $b$. Anta att $f$ applicerat på $m$ är lika med $true$. Då för alla funktioner $__3$ från naturliga tal $i$ och element $__3$ av $Leq$ av $b$ och $i$ och element $__4$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion, håller $min_spec$ för $n$ och $b$ och $f$ och $m$.\nAssistant:", "label": "postulate found_min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Leq b m) -> (__1 : Lt m (plus n b)) -> (__2 : Eq (f m) true) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> min_spec n b f m", "predict": "postulate låt : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (Hm : Eq b m) -> (Hm1 : Eq m (plus n b)) -> (f' : (_ : Nat) -> Eq (f m) true) -> (min_spec : (n : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> Eq (f m) true) -> Eq (min_spec n b f m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_exp. Let $n$ and $m$ and $i$ be natural numbers. Assume that $0$ is less than $m$. Assume that $mod$ applied to $n$ and $m$ is not equal to $0$. Let $p$ be a natural number. Then if $i$ is less than or equal to $p$, then $p_ord_aux$ applied to $p$ and the product of the exponentiation of $m$ and $i$ and $n$ and $m$ is equal to $mk_Prod$ applied to $Nat$ and $Nat$ and $i$ and $n$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16004. Let $m, n, a, b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (gcd m n) (minus (times m d) (times n c)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPlus_minus_m_m. For all natural numbers $n$ and $m$, if $m$ is less than or equal to $n$, then $n$ is equal to the sum of the difference of $n$ and $m$ and $m$.\nAssistant:", "label": "postulate plus_minus_m_m : (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> Eq n (plus (minus n m) m)", "predict": "postulate plus_minus_m_m : (n : Nat) -> (m : Nat) -> (_ : Leq m n) -> Eq n (plus (minus n m) m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar_r. För alla mängder $B$, för alla element $_R$ av $relation$ av $B$, för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$, för alla funktioner $case_lstar_r_O$ från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_r_O (B, _R, b)$, för alla funktioner $case_lstar_r_S$ från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $__1$ av $_R$ av $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_r_S (B, _R, l, b1, b, __, b2, __1)$, för alla naturliga tal $__$, för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar_r : (B : Mngd) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (l1 : lstar_r B _R l l b b1) -> (b2 : B) -> (__1 : _R b b2) -> return_type l + 1 b1 b2 l1 b2 __1) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_distr. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $B$ and $nil$. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $a$ of $cic.Term$ of $univs.Type0$ and $B$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.let_mop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_bigops.aop__o__op$ applied to $B$ and $nil$ and $matita_arithmetics_bigops.let_aop$ applied to $n$ and $p$ and $B$ and $nil$ and $R$ and $f$ and $a", "label": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))))", "predict": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f)) a (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f)) a (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.range$ applicerat på $A$, för alla element $_x_942$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $univs.Type0$ och $A$.\nAssistant:", "label": "postulate enum : (A : cic.Univ univs.Type0) -> (_xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A", "predict": "postulate för alla element A av cic.Univ univs.Type0 : ( _xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.range A)) -> (_x_942 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 A"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp1. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_803$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.mk_Aop$ applicerat på $A$ och $_", "label": "postulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)", "predict": "nilpostulate Aop_rect_CProp1 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil _nil))) -> (x_803 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_803)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_rect_Type1_body. For all elements $_A$ and $_B$ of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $univs.Type1$, for all functions $_H_conj$ from elements $x_140$ of $cic.Term$ of $cic.prop$ and $_A$ and elements $x_139$ of $cic.Term$ of $cic.prop$ and $_B$ to elements of $cic.Term$ of $univs.Type1$ and $Q_$ applied to $matita_basics_logic.conj$ applied to $_A$ and $_B$ and $x_140$ and $x_139$, for all elements $x_138$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $_A$ and $_B$, $cic.Term$ holds for $univs.Type1$ and $Q_$ applied to $x_138$.\nAssistant:", "label": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)", "predict": "postulate And_rect_Type1_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ univs.Type1) -> (_H_conj : (x_140 : cic.Term cic.prop _A) -> (x_139 : cic.Term cic.prop _B) -> cic.Term univs.Type1 (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) -> (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term univs.Type1 (Q_ x_138)"}
{"prompt": "Human: Translate the following French statement into Agda.\nOrd_exp. Soient $p$ et $m$ des nombres naturels. Alors si $1 < p$, alors $ord (p ^ m, p)= m$.\nAssistant:", "label": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> Eq (ord (pow p m) p) m", "predict": "postulate ord_exp : (p : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> ord (p ^ m) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_ind. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1500$ of $Aop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2, a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a, x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ and elements $_z1501$ of $Eq$ of $Hterm$ and $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ to elements of $P$ of $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_ind : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1500 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1501 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type1. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1722$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type1$. Then for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita", "label": "postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)", "predict": "_postulate Dop_inv_rect_Type1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1722 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type1) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.ACop x1 x2)) (matita_arithmetics_bigops.Dop x1 x2))) -> (_z1723 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type1 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__aop. Soit $x0$ un ensemble. Soit $x1$ un élément de $x0$. Alors pour toutes les fonctions $x2$ des éléments de $ACop$ de $x0$ et de $x1$ à des ensembles, pour tous les éléments $x3$ de $DPair$ de $ACop$ appliqué à $x0$ et $x1$ et de $x2$, $Aop$ tient pour $x0$ et $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1", "predict": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_ind. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_943$ of $Dop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_943$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_943$.\nAssistant:", "label": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943", "predict": "postulate Dop_ind : (A : Set) -> (_nil : A) -> (Q_ : (_x_943 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_943 : Dop A _nil) -> Q_ x_943"}
{"prompt": "Human: Translate the following English statement into Agda.\nAnd_inv_rect_Type3. Let $x1$ and $x2$ be elements of $cic.Univ$ of $cic.prop$. Let $Hterm$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z335$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type3$. Then for all functions $_H1$ from elements $x_132$ of $cic.Term$ of $cic.prop$ and $x1$ and elements $x_131$ of $cic.Term$ of $cic.prop$ and $x2$ and elements $_z336$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $cic.prop$ and $univs.Type2$ and $matita_basics_logic.And$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_basics_logic.conj$ applied to $x1$ and $x2$ and $x_132$ and $x_131$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate And_inv_rect_Type3 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ univs.Type3) -> (_H1 : (x_132 : cic.Term cic.prop x1) -> (x_131 : cic.Term cic.prop x2) -> (_z336 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P (matita_basics_logic.conj x1 x2 x_132 x_131))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_eq_to_eqb_false. For all natural numbers $n$ and $m$, if $n$ is not equal to $m$, then absurdity is equal to $eqb (n, m)$.\nAssistant:", "label": "postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq (eqb n m) false", "predict": "postulate not_eq_to_eqb_false : (n : Nat) -> (m : Nat) -> (_ : not (Eq n m)) -> Eq false (eqb n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_907$ of $ACop$ of $A$ and $_nil$ to propositions. Then for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_907$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_907$.\nAssistant:", "label": "postulate ACop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907", "predict": "postulate ACop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_907 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_907 : ACop A _nil) -> Q_ x_907"}
{"prompt": "Human: Translate the following English statement into Agda.\nSig_rect_CProp2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Let $Q_$ be a function from elements $_x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Sig$ be a function from elements $pi1$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $_pi2$ of $cic.Term$ of $cic.prop$ and $_f$ applied to $pi1$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.mk_Sig$ applied to $A$ and $_f$ and $pi1$ and $_pi2$. Then for all elements $x_684$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sig$ applied to $A$ and $_f$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_684$.\nAssistant:", "label": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)", "predict": "postulate Sig_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_684 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_684)"}
{"prompt": "Human: Translate the following English statement into Agda.\nPos_div. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_div_and_mod.mod$ applied to $n$ and $m$ and $matita_arithmetics_nat.O$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $m$.\nAssistant:", "label": "postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))", "predict": "postulate pos_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n m) matita_arithmetics_nat.O)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_div_and_mod.div n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_rect_CProp3_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_154$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_conj$ des éléments $x_156$ de $cic.Term$ de $cic.prop$ et de $_A$ et des éléments $x_155$ de $cic.Term$ de $cic.prop$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_logic.conj$ appliqué à $_A$ et $_B$ et $x_156$ et $x_155$, pour tous les éléments $x_154$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_154$.\nAssistant:", "label": "postulate And_rect_CProp3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)", "predict": "postulate And_rect_CProp3_body : (_A : cic.Univ cic.prop) -> (_B : cic.Univ cic.prop) -> (Q_ : (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Univ cic.prop) -> (_H_conj : (x_156 : cic.Term cic.prop _A) -> (x_155 : cic.Term cic.prop _B) -> cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) -> (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B)) -> cic.Term cic.prop (Q_ x_154)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1704. Soit $m$ un nombre naturel. Supposons que $0 < m$. Alors pour tous les nombres naturels $a$ et $x1029$, $x1029 = aop__o__op (Nat, 0, plusAC, x1029, 0)$.\nAssistant:", "label": "postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)", "predict": "postulate let_clause_1704 : soit m un nombre naturel. supposons 0 < m. alors pour tous les nombres naturels a et x1029, x1029 = aop__o__op (Nat, 0, plusAC, x1029, 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_max_to_pi_p_primeb. Soit $q, m \\in N$. Supposons que $0 < m$. Supposons que $q$ est inférieur à $max$ appliqué à la somme de $m$ et de $1$ et la fonction qui envoie $i$ à $andb$ appliqué à $primeb$ appliqué à $i$ et $dividesb$ appliqué à $i$ et $m$. Alors $bigop$ appliqué à $q$ et la fonction qui envoie $p$ à $andb$ appliqué à $primeb$ appliqué à $p$ et $dividesb$ appliqué à $p$ et $m$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à la puissance de $p$ et de $ord$ appliqué à $m$ et $p$ est égal à $m$.\nAssistant:", "label": "postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (max (plus m 1) (\\ i : Nat -> andb (primeb i) (dividesb i m))) q) -> Eq m (bigop q (\\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\\ p : Nat -> pow p (ord m p)))", "predict": "postulate lt_max_to_pi_p_primeb : (q : Nat) -> (m : Nat) -> (posm : Lt 0 m) -> (qmin : Lt q (max (plus m 1) (\\ i : Nat -> andb (primeb i) (dividesb i m)))) -> Eq (bigop q (\\ p : Nat -> andb (primeb p) (dividesb p m)) Nat 1 times (\\ p : Nat -> pow p (ord m p))) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$. Anta att $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a \\in N$. Anta att $6 \\leq a$. Anta att $2 (a + 1)+ 1 \\leq 2 ^ a$. Låt $x2515, x2516 \\in N$. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (lt0 : Leq m 6) -> (Hind : Pow (plus 1 m) 2) -> (a : Nat) -> (lt1 : Leq a 6) -> (Hind0 : Pow (plus 1 a) 2) -> (x2515 : Nat) -> (x2516 : Nat) -> (Hind1 : Eq x2515 x2516) -> (Hind2 : and (Lt x2515 x2516) (Leq (plus 1 m) 2)) -> (Hind3 : and (Lt x2515 x2516) (Leq (plus 1 a) 2)) -> (Hind4 : Eq x2515 (mod (x2515 x2516) (x2516)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_to_le. Soient $b$ et $n$ et $m$ des nombres naturels. Supposons que $1 < b$ et $b ^ n \\leq b ^ m$. Alors $n \\leq m$.\nAssistant:", "label": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Leq (pow b n) (pow b m)) -> Leq n m", "predict": "postulate le_exp_to_le : (b : Nat) -> (n : Nat) -> (m : Nat) -> (H : Lt 1 b) -> Leq n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_inv_rect_CProp4. För alla mängder $x1$, för alla element $x2$ av $x1$, för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1602$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op (x1, x2, aop, a, b)$ och $op (x1, x2, aop, b, a)$ och element $_z1603$ av $Eq$ av $Hterm$ och $mk_ACop (x1, x2, aop, _comm)$ till element av $P$ av $mk_ACop (x1, x2, aop, _comm)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp4 : (x1 : Mng) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1602 : ACop x1 x2) -> Pn) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1603 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_Type3. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_895$ of $ACop$ of $A$ and $_nil$ to elements of $Type3$, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_895$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_895$.\nAssistant:", "label": "postulate ACop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895", "predict": "postulate ACop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_895 : ACop A _nil) -> Type3) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_895 : ACop A _nil) -> Q_ x_895"}
{"prompt": "Human: Translate the following English statement into Agda.\nSigma_p_dividesb. Let $m$ and $n$ and $p$ be natural numbers. Then if $0 < n$, then if $p$ is prime, then if $p$ is not divisible by $n$, then $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $p$ and the sum of $i$ and $1$ and the product of the exponentiation of $p$ and $m$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$ is equal to $m$.\nAssistant:", "label": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq m (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate sigma_p_dividesb : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : prime p) -> (__2 : not (divisible p n)) -> Eq (bigop m (\\ i : Nat -> dividesb (pow p (plus i 1)) (times (pow p m) n)) Nat 0 plus (\\ i : Nat -> 1)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type4_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_917$ av $range$ av $_A$ till element av $Type4$. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Låt $x_917$ vara ett element av $range$ av $_A$. Då håller $Q_$ för $x_917$.\nAssistant:", "label": "postulate range_rect_Type4_body : (_A : Set) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_917 : range _A) -> Q_ x_917", "predict": "postulate range_rect_Type4_body : (_A : Mngd) -> (Q_ : (_x_917 : range _A) -> Type4) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> Q_ x_917) -> (x_917 : range _A) -> Q_ x_917"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1545. Låt $m, n \\in N$. Anta att $0$ är både lika med det största gemensama delaret av $m$ och $n$ och delbart med $n$. Låt $q1 \\in N$. Anta att $n = 0 q1$ och $0$ är delbart med $m$. Låt $q2 \\in N$. Då om $m = 0 q2$, så $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (auto : Eq 0 (gcd m n) (div n m)) -> (q1 : Nat) -> (auto' : Eq n 0 q1) -> (auto'' : Eq 0 m) -> (q2 : Nat) -> (auto''': Eq m 0) -> Eq (gcd m n) (div n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $p, n \\in N$. Assume that $1 < p$. Let $m$ and $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (lt1p : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (p : Nat) -> (n : Nat) -> (ltml : Lt 1 p) -> (m : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16001. Soit $m, n, a, b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$, alors si $c n - d m = 1$, alors $n c - m d$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_16001 : soit m, n, a, b \\in N"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_inv_ind. Soient $x1$ et $x2$ des nombres naturels. Soit $x3$ une fonction des nombres naturels à des valeurs booléennes. Soit $x4$ un nombre naturel. Soit $_Hterm$ un élément de $min_spec$ de $x1$ et de $x2$ et de $x3$ et de $x4$. Soit $P$ une fonction des nombres naturels $_z1890$ à des propositions. Soit $_H1$ une fonction des nombres naturels $m$ et des éléments $_x_1080$ de $Leq$ de $x2$ et de $m$ et des éléments $_x_1079$ de $Lt$ de $m$ et de $x1 + x2$ et des éléments $_x_1078$ de $Eq$ de $x3 (m)$ et de $true$ et des fonctions $_x_1077$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $m$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $m$ à des éléments de $P$ de $m$. Soit $_H2$ une fonction des fonctions $_x_1081$ des nombres naturels $i$ et des éléments de $Leq$ de $x2$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $x1 + x2$ à des éléments de $Eq$ de $x3 (i)$ et de contradiction et des éléments $_z1891$ de $Eq$ de $x4$ et de $x1 + x2$ à des éléments de $P$ de $x1 + x2$. Alors $P$ tient pour $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : sont x1 x2 : Nat -> x3 : (_ : Nat) -> x4 : Nat -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m x1 + x2) -> (_x_1078 : Eq x3 m) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq x3 i) -> (_z1891 : Eq x4 m) -> (_z1892 : Eq x4 (x1 + x2)) -> (Pm : P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i x1 + x2) -> Eq x3 i) -> (_z1891 : Eq x4 (x1 + x2)) -> Pm) -> P x4"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a \\in N$. Then for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_plus_l. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.monotonic$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.lt$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.plus$ applicerat på $m$ och $n$.\nAssistant:", "label": "postulate monotonic_lt_plus_l : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))", "predict": "postulate monotonic_lt_plus_l : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus m n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_rect_Type0_r. Soit $A$ un élément de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $a$ de $cic.Term$ de $univs.Type2$ et de $A$, pour toutes les fonctions $P$ des éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $P$ appliqué à $a$ et $matita_basics_logic.refl$ appliqué à $A$ et $a$, pour tous les éléments $x$ de $cic.Term$ de $univs.Type2$ et de $A$, pour tous les éléments $p$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $A$ et $x$ et $a$, $cic.Term$ tient pour $univs.Type0$ et $P$ appliqué à $x$ et $p$.\nAssistant:", "label": "postulate eq_rect_Type0_r : (A : cic.Univ univs.Type2) -> (a : cic.Term univs.Type2 A) -> (P : (x : cic.Term univs.Type2 A) -> (__ : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a))) -> (x : cic.Term univs.Type2 A) -> (p : cic.Term cic.prop (matita_basics_logic.eq A x a)) -> cic.Term univs.Type0 (P x p)", "predict": "postulate eq_rect_Type0_r : soit A un élément de cic.Univ univs.Type2. Alors pour tous les éléments a de cic.Term univs.Type2 A, pour toutes les fonctions P des elements x de cic.Term univs.Type2 A et des elements __ de cic.Term cic.prop et de matita_basics_logic.eq A x a elements de cic.Univ univs.Type0, pour tous les elements __ de cic.Term univs.Type0 P a (matita_basics_logic.eq A x a) elements de cic.Univ univs.Type0, pour tous les elements x de cic.Term univs.Type2 A, pour tous les elements p de cic.Term cic.prop et (matita_basics_logic.eq A x a) elements de cic.Term cic.prop, cic.Term univs.Type0 P x p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_div_S. Låt $n, m \\in N$. Då om $0 < m$, så $n < (n \\div m + 1)m$.\nAssistant:", "label": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)", "predict": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> då om 0 < m, så n < (n div m) + 1m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_CProp1. Låt $x1, x2, x3, x4 \\in N$. Då för alla element $Hterm$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från element $_z1488$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden, för alla funktioner $_H1$ från element $x_855$ av $Lt$ av $x4$ och $x2$ och element $x_854$ av $Eq$ av $x1$ och $x3 x2 + x4$ och element $_z1489$ av $Eq$ av $Hterm$ och $div_mod_spec_intro (x1, x2, x3, x4, x_855, x_854)$ till element av $P$ av $div_mod_spec_intro (x1, x2, x3, x4, x_855, x_854)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_CProp1 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1488 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 (plus (times x3 x2) x4)) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp1 : låt x1, x2, x3, x4 \\in N. då för alla element Hterm av div_mod_spec x1 x2 x3 x4, för alla funktioner P från (_z1488 : div_mod_spec x1 x2 x3 x4) -> påståenden, för alla funktioner _H1 : (x_855 : Lt x4 x2) -> (x_854 : Eq x1 x3 x2 + x4) -> (_z1489 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_855 x_854)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_log. Soient $p$ et $n$ et $m$ des nombres naturels. Supposons que $1 < p$. Supposons que $n \\leq m$. Alors $\\log_ p {n}\\leq \\log_ p {m}$.\nAssistant:", "label": "postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Leq n m) -> Leq (log p n) (log p m)", "predict": "postulate le_log : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 1 p) -> (posn2 : Leq n m) -> Leq (log_ p n) (log_ p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_pi. Låt $n$ vara ett naturligt tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p$ applicerat på $i$ och $true$ till element av $Leq$ av $g1$ applicerat på $i$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ mindre än eller lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i) (mineralize i) (\\ i : Nat -> g2 i)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15623. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Then for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_transpose_l. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n, i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Då för alla element $__2$ av $bijn$ av $f$ och $n$, håller $bijn$ för funktionen som avbildar $p$ som $transpose (i, j, f (p))$ och $n$.\nAssistant:", "label": "postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> (__2 : bijn f n) -> bijn (\\ p : Nat -> transpose i j (f p)) n", "predict": "postulate bijn_transpose_l : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (j : Leq n) -> (p : (__2 : bijn f n) -> Nat) -> bijn (f n) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type0. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_873$ av $Aop$ av $A$ och $_nil$ till mängder. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Då för alla element $x_873$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_873$.\nAssistant:", "label": "postulate Aop_rect_Type0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Set) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_873 : Aop A _nil) -> Mngd) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_873 : Aop A _nil) -> Q_ x_873"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_gcd_aux. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Then if $0$ is less than $n$, then if $n$ is divisible by $m$, then $gcd_aux$ applied to $p$ and $m$ and $n$ is equal to $n$.\nAssistant:", "label": "postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n", "predict": "postulate divides_to_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 n) -> (__2 : divisible n m) -> Eq (gcd_aux p m n) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nSig_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$, pour toutes les fonctions $P$ des éléments $_z1212$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $x2$ appliqué à $pi1$ et des éléments $_z1213$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sig$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $x1$ et $x2$ et $pi1$ et $_pi2$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sig_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ cic.prop) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> (P : (_z1212 : cic.Term univs.Type0 (matita_basics_types.Sig x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (pi1 : cic.Term univs.Type0 x1) -> (_pi2 : cic.Term cic.prop (x2 pi1)) -> (_z1213 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sig x1 x2)) Hterm (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_Sig x1 x2 pi1 _pi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBool_rect_CProp3_body. För alla funktioner $Q_$ från element $_x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_true$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.true$, för alla element $_H_false$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_bool.false$, för alla element $x_353$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_353$.\nAssistant:", "label": "postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)", "predict": "postulate bool_rect_CProp3_body : (Q_ : (_x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_353 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_353)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1686. Soit $n, m \\in N$. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Alors pour tous les nombres naturels $a$, si $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$, alors si $1 < 2 a + 1$ et $0 < a$, alors $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_clearme : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : and (Lt 1 2 a) (Lt a 0)) -> (Ha : Lt m 1) -> (Hc : Lt 2 a + 1) -> (Hd : Lt 2 a + 1) -> (Ht : Lt 1 2 a) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a0 : Nat) -> (Hind0 : Eq m 2 a) -> (Hind1 : Eq m 2 a + 1) -> (Hind2 : Eq m 2 a + 1) -> (Hind3 : Eq 1 2 a) -> (Hind4 : Lt m 1) -> (Hind5 : Lt 2 a + 1) -> (Hind6 : Lt 2 a + 1) -> (Hind7 : Lt 1 2 a) -> (Hind8 : Lt (Psi p) (pred p)) -> (Hind9 : Leq (Psi p) (pred p)) -> (Hind10 : Lt 2 a 2) -> (Hind11 : Lt 2 a 1) -> (Hind12 : Lt 2 a 0) -> (Hind13 : Lt (Hind2 m) (Hind3 m)) -> (Hind14 : Lt (Hind4 m) (Hind5 m)) -> (Hind15 : Lt (Hind6 m) (Hind7 m)) -> (Hind16 : Lt (Hind8 m) (Hind9 m)) -> (Hind17 : Lt (Hind10 m) (Hind11 m)) -> (Hind18 : Lt (Hind12 m) (Hind13 m)) -> (Hind19"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1569. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq n c - m d"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1575. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$. Alors pour tous les nombres naturels $x1029$, $x1029$ est égal au produit de $x1029$ et de la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (plus c n) (plus d m)) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times c n) (times d m)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPermut_n_to_le. Låt $h$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $h$ och $n$. Låt $__2$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $h$ applicerat på $m$ och $m$. Låt $j$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__3$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $j$. Då för alla element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $k$ och $h$ applicerat på $j$.\nAssistant:", "label": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))", "predict": "postulate permut_n_to_le : (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le k n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_permutation.permut h n)) -> (__2 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt m k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (h m) m)) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le k j)) -> (e : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> cic.Term cic.prop (matita_arithmetics_nat.le k (h j))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$. Assume that $p1 (n1)= true$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) -> (H1 : (i : Nat) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (__1 : Lt i n1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (_ : Nat) -> true) -> (p1 : (_ : Nat) -> true) -> let x2515 : Nat -> let x2516 : Nat -> x2515 = x2516 (x2515 \\ div x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_divides_times. Låt $p, q, n \\in N$. Anta att $p$ är primt. Anta att $p$ inte är delbart med $q$. Anta att $p$ är delbart med $n$. Då om $q$ är delbart med $n$, så är $p \\times q$ delbart med $n$.\nAssistant:", "label": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : not (divisible p q)) -> (__2 : divisible p n) -> (__3 : divisible q n) -> divisible (times p q) n", "predict": "postulate divides_to_divides_times : (p : Nat) -> (q : Nat) -> (n : Nat) -> let p : prim p -> not (divisible p q) -> let p : divisible p n -> let q : divisible p n -> let n : Nat -> (q : divisible p n) -> (p : divisible p n) -> (q : divisible p n) -> divisible p (times q n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp4. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_903$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_903$.\nAssistant:", "label": "postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903", "predict": "postulate ACop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Supposons que $2 ^ 7 \\leq n$. Soit $p \\in N$. Supposons que $(\\sqrt{ 2 n})+ 1 \\leq p$ et $p < 2 n + 1$. Supposons que $leb (2, k (2 n, p))= true$ et $2 n < p ^ 2$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n un nombre naturel. Supposons que 2 ^ 7 \\leq n. Soit p un nombre naturel. Supposons que ((sqrt 2 n) + 1) \\leq p et p < 2 n + 1. Supposons que leb (2, k (2 n, p))= true et 2 n < p ^ 2. Soit x2515, x2516 un nombre. Alors x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_I_gen. Soient $a$ et $b$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ un élément de $Aop$ de $B$ et de $nil$. Soit $f$ une fonction des nombres naturels à des éléments de $B$. Supposons que $a \\leq b$. Alors $bigop$ appliqué à $b$ et la fonction qui envoie $i$ à $andb$ appliqué à $leb$ appliqué à $a$ et $i$ et $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à la différence de $b$ et de $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $p$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $a$.\nAssistant:", "label": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (a i)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (a i)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nF_ind. Let $A$ be a set. Let $f$ be a function from elements of $A$ to natural numbers. Then for all elements $P$ of $predicate$ of $A$, for all functions $__$ from natural numbers $n$ and functions from elements $a$ of $A$ and elements of $Lt$ of $f$ applied to $a$ and $n$ to elements of $P$ of $a$ and elements $a$ of $A$ and elements $__1$ of $Eq$ of $f$ applied to $a$ and $n$ to elements of $P$ of $a$, for all elements $a$ of $A$, $P$ holds for $a$.\nAssistant:", "label": "postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a", "predict": "postulate f_ind : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (a : A) -> P a"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $__$ and $__1$ be natural numbers. Then $__ \\div __1$ is a natural number.\nAssistant:", "label": "postulate div : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate div : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nNext. Assume that $Sort$. Then $Sort$.\nAssistant:", "label": "postulate next : Sort -> Sort", "predict": "postulate assume : Sort -> Sort"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Prod. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_mk_Prod$ från element $_fst$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $_snd$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_types.mk_Prod$ applicerat på $_A$ och $_B$ och $_fst$ och $_snd$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Prod$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_Prod : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ return_sort) -> (case_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term return_sort (return_type (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (z : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq m d) -> (H0 : Eq n d) -> Eq (div m n) (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_ord_rem. Låt $p$ och $q$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Anta att $q$ är primt. Då om $q < p$, så $ord (ord_rem (m, p), q)= ord (m, q)$.\nAssistant:", "label": "postulate ord_ord_rem : (p : Nat) -> (q : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : prime q) -> (__3 : Lt q p) -> Eq (ord (ord_rem m p) q) (ord m q)", "predict": "postulate ord_ord_rem : let (p : Nat) -> (q : Nat) -> (m : Nat) -> (posp : Lt 0 m) -> (primp : prim p) -> (qtp : prim q) -> (ltq : Lt q p) -> ord (ord_rem (m, p), q) (ord m q)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_inv_S_dx. Soit $B$ un ensemble. Soit $R$ un élément de $relation$ de $B$. Soit $l$ un nombre naturel. Alors pour tous les éléments $b1$ et $b2$ de $B$, pour tous les éléments $__$ de $lstar$ de $B$ et de $R$ et de $l + 1$ et de $b1$ et de $b2$, $ex2$ tient pour $B$ et la fonction qui envoie $b$ à $lstar (B, R, l, b1, b)$ et la fonction qui envoie $b$ à $R (b, b2)$.\nAssistant:", "label": "postulate lstar_inv_S_dx : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R (plus l 1) b1 b2) -> ex2 B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)", "predict": "postulate lstar_inv_S_dx : Soit B un ensemble. Soit R un element de relation B. Soit l un nombre naturel. Alors pour tous les elements b1 et b2 de B, pour tous les elements __ de lstar B R l + 1 b1 b2, ex2 tient pour B et la fonction qui envoie b à lstar (B R l b1 b) et la fonction qui envoie b à R (b b2).postulate ex2 : (b1 : B) -> (b2 : B) -> (__ : lstar B R l + 1 b1 b) -> ex2 : B (\\ b : B -> lstar B R l b1 b) (\\ b : B -> R b b2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $bijf$ be an element of $bijn$ of $f$ and $n + 1$. Assume that $f (n + 1)= n + 1$. Let $i$ be a natural number. Assume that $i \\leq n$. Let $a \\in N$. Assume that $a \\leq n + 1$ and $f (a)= i$. Assume that $a \\leq n + 1$. Assume that $f (a)= i$. Then if $a = n + 1$, then $i = a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f n + 1) -> (f (n + 1) = n + 1) -> (i : Nat) -> (le_n : Leq i n) -> (a : Nat) -> (le_n1 : Leq a n + 1) -> (f a = i) -> (a : Nat) -> (le_n2 : Leq a n + 1) -> (f a = i) -> (H : Eq a n + 1) -> Eq i a"}
{"prompt": "Human: Translate the following English statement into Agda.\nTimes_div. Let $a$ and $b$ and $c$ be natural numbers. Then if $0$ is less than $b$, then if $c$ is divisible by $b$, then the product of $a$ and the quotient of $b$ and $c$ is equal to the quotient of the product of $a$ and $b$ and $c$.\nAssistant:", "label": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)", "predict": "postulate times_div : (a : Nat) -> (b : Nat) -> (c : Nat) -> (_ : Lt 0 b) -> (__1 : divisible c b) -> Eq (times a (div b c)) (div (times a b) c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Låt $pnm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $n$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $d$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $d$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $c$ och $n$ och $matita_arithmetics_nat.S$ applicerat på $matita_ar", "label": "postulate let_clause_15692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics", "predict": "postulate let_clause_15692 : cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_div. Soient $n$ et $m$ et $d$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $d$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $n$ et $m$ et $d$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $d$ et $matita_arithmetics_div_and_mod.div$ appliqué à $m$ et $d$.\nAssistant:", "label": "postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))", "predict": "postulate plus_div : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O d)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus n m) d) (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div n d) (matita_arithmetics_div_and_mod.div m d)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nFalse_rect_Type4. Pour toutes les fonctions $Q_$ des éléments $_x_67$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $univs.Type4$, pour tous les éléments $x_67$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_67$.\nAssistant:", "label": "postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)", "predict": "postulate False_rect_Type4 : (Q_ : (_x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ univs.Type4) -> (x_67 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term univs.Type4 (Q_ x_67)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1068. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soit $i, j \\in N$. Supposons que $i$ est inférieur ou ágal à $n$. Supposons que $j$ est inférieur ou ágal à $n$. Soit $a \\in N$. Supposons que $a$ est inférieur ou ágal à $n$ et $f$ appliqué à $a$ est égal à $i$. Supposons que $a$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $a$ est égal à $i$. Soit $b$ un nombre naturel. Supposons que $b$ est inférieur ou ágal à $n$ et $f$ appliqué à $b$ est égal à $j$. Supposons que $b$ est inférieur ou ágal à $n$. Supposons que $f$ appliqué à $b$ est égal à $j$. Soit $__$ une fonction des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f$ appliqué à $i0$ et de $n$. Soit $injf$ un élément de $injn$ de $f$ et de $n$. Supposons que $a$ est égal à $b$. Alors $f$ appliqué à $a$ est égal à $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i, j : Nat) -> (ii : Nat) -> (aj : Nat) -> (aj0 : Nat) -> (_ : Nat -> Leq i0 n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_min_spec. Låt $_n$ och $_b$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $_n$ och $_b$ och $_f$ och $__$ till element av $cic.Univ$ av $return_sort$. Låt $case_found_min_spec$ vara en funktion från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_b$ och $m$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $matita_arithmetics_nat.plus$ applicerat på $_n$ och $_b$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $m$ och $matita_basics_bool.true$ och funktioner $__3$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__3$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $_b$ och $i$ och element $__4$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $m$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $_f$ applicerat på $i$ och $matita_basics_bool.false$ till element av $cic.Term$ av $return_sort$ och $", "label": "postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f __)) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita", "predict": "postulate match_min_spec : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ return_sort) -> (case_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (__3 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f i) matita_basics_bool.false)) -> cic.Term return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) return_sort (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_basics_bool.andb (matita_basics_bool.notb (matita_basics_bool.andb (matita_arithmetics_nat.notb _n) _b)) m) (matita_basics_bool.andb (matita_basics_bool.notb (matita_basics_bool.andb (matita_arithmetics"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_4. Soit $x \\in R$. Alors si $0$ est inférieur à $x$ et $x$ est inférieur à $1$, alors la somme de la différence de la puissance de $x$ et de $2$ et du produit de $2$ et de $x$ et de $2$ est inégale à $0$.\nAssistant:", "label": "postulate noLabel_4 : (x : Real) -> if (and (Lt 0 x) (Lt x 1)) (Neq (plus (minus (pow x 2) (times 2 x)) 2) 0)", "predict": "postulate noLabel_4 : soit x : R -> and (and (Lt 0 x) (Lt x 1)) -> Eq (plus (minus (pow x 2) (times 2 x)) (times 2 x)) 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1561. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0 < p$. Assume that $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Then if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$, then if $a p - b m = 1$, then $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (divm : divisible p m) -> (c : Nat) -> (auto : Eq m n) -> (auto' : Eq (gcd p m) (gcd p m)) -> (auto'' : Eq (gcd p m) a (gcd p m)) -> (auto''' : Eq (gcd p m) a b) -> (auto'''' : Eq (gcd p m) a (gcd p m)) -> (H : Eq (gcd p m) a b) -> (H' : Eq (gcd p m) a (gcd p m)) -> (H'' : Eq (gcd p m) a b) -> Eq (gcd p m) a b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15321. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $posn$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $eqn0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $n$, för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_nat.O$ och $m$, för alla element $q$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $eqm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.O$ och $q$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $m$ och $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_15321 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAxiome. Soit $__, __1 \\in N$. Alors le produit de $__$ et de $__1$ est un nombre naturel.\nAssistant:", "label": "postulate times : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate soit : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_to_leb_false. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$ och $matita_basics_bool.false$.\nAssistant:", "label": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "postulate lt_to_leb_false : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $a$ and $b$, for all elements $__5$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $m$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $c$ and $d$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.And$ applied to $matita_arithmetics_primes.divides$ applied to $b", "label": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_arithmetics_nat.le a c))", "predict": "postulate divides_to_p_ord : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat a b))) -> (__5 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord m p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat c d))) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides b d) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_aux_Strue. For all natural numbers $n$ and $m$ and $p$ and $q$ and $r$, if $mod (n, m)= 0$, then if $p_ord_aux (p, n \\div m, m)= mk_Prod (Nat, Nat, q, r)$, then $p_ord_aux (p + 1, n, m)= mk_Prod (Nat, Nat, q + 1, r)$.\nAssistant:", "label": "postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Eq (mod n m) 0) -> (__1 : Eq (p_ord_aux p (div n m) m) (mk_Prod Nat Nat q r)) -> Eq (p_ord_aux (plus p 1) n m) (mk_Prod Nat Nat (plus q 1) r)", "predict": "postulate p_ord_aux_Strue : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : mod n m) -> (__1 : p_ord_aux (p, n / m, m)) -> (__2 : p_ord_aux (p + 1, n, m)) -> mk_Prod Nat Nat q r"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1506$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $c", "label": "postulate Aop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate låt : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1506 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1507 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin_spec_ind_body. Soient $_n$ et $_b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $Q_$ une fonction des éléments $x_1075$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_1076$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_minimization.min_spec$ appliqué à $_n$ et $_b$ et $_f$ et $x_1075$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_found_min_spec$ une fonction des éléments $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1080$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $m$ et des éléments $x_1079$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $matita_arithmetics_nat.plus$ appliqué à $_n$ et $_b$ et des éléments $x_1078$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué à $m$ et $matita_basics_bool.true$ et des fonctions $x_1077$ des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $_b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $m$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $_f$ appliqué", "label": "postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop (matita_arithmetics_minimization.min_spec _n _b _f x_1075)) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2", "predict": "postulate min_spec_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (Q_ : (x_1075 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1076 : cic.Term cic.prop matita_arithmetics_minimization.min_spec _n _b _f x_1075) -> cic.Univ cic.prop) -> (_H_found_min_spec : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le _b m)) -> (x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b))) -> (x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> (x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f m) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (_f x_1075) (matita_basics_bool.andb (matita_basics_bool.notb (matita_arithmetics_nat.leb _b m)) (matita_basics_bool.notb (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus _n _b)))))) -> (x_1081 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univ"}
{"prompt": "Human: Translate the following French statement into Agda.\nNmk. Soit $A$ un élément de $cic.Univ$ de $cic.prop$. Soit $__$ une fonction des éléments $__$ de $cic.Term$ de $cic.prop$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.Not$ appliqué à $A$.\nAssistant:", "label": "postulate nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)", "predict": "postulate Nmk : (A : cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (matita_basics_logic.Not A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nB_SSSSO. $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_chebyshev_factorization.B$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))", "predict": "postulate B_SSSSO : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_log_O. Pour tous les éléments $n$ et $m$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_log.log$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)", "predict": "postulate lt_to_log_O : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log n m) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1617. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : let p m n : Nat\n  and (Lt 0 p) (Eq (gcd p m) 1) (div m n) (Eq (times m n) (times p c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ och $x2515$ och $x2516$ vara naturliga tal. Då $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : nat (n) (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x2516) -> nat (x2515) (x251"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Supposons que $p2$ appliqué à $n1$ est égal à $true$. Supposons que $p1$ appliqué à $n1$ est égal à $true$. Alors pour tous les nombres naturels $x", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> bool Soient p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soient Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2 : (_ : Nat) -> Eq (p1 n1) true) -> (p1 : (_ : Nat) -> Eq (p1 n1) true) -> (xpostulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> bool Soient p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soient Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus"}
{"prompt": "Human: Translate the following English statement into Agda.\nOp. Let $A$ be a set. Let $nil$ be an element of $A$. Then for all elements $_xxx$ of $Aop$ of $A$ and $nil$, for all elements $_x_887$ and $_x_888$ of $A$, $A$.\nAssistant:", "label": "postulate op : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A", "predict": "postulate op : (A : Set) -> (nil : A) -> (_xxx : Aop A nil) -> (_x_887 : A) -> (_x_888 : A) -> A"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_891$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_891 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type4 (Q_ x_891)", "predict": "postulate ACop_rect_Type4_body : soit A un élément de cic.Univ univs.Type0. Soit _nil un élément de cic.Term univs.Type0 et A. Alors pour toutes les fonctions Q_ des _x_891 de cic.Term univs.Type0 et (matita_arithmetics_bigops.ACop A _nil) à des éléments de cic.Univ univs.Type4, pour toutes les fonctions _H_mk_ACop des (aop de cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) des (_comm de (a de cic.Term univs.Type0 A) et (b de cic.Term univs.Type0 A)) à des éléments de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a)) (cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm)) x_891))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10336. Let $n, m \\in N$. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi$ applied to $p$ and the product of $pred$ applied to $p$ and the exponentiation of $2$ and the difference of the product of $2$ and $p$ and $3$. Let $a$ be a natural number. Assume that $m$ is equal to the product of $2$ and $a$ or $m$ is equal to the sum of the product of $2$ and $a$ and $1$. Then if $m$ is equal to the sum of the product of $2$ and $a$ and $1$, then if $1$ is less than the sum of the product of $2$ and $a$ and $1$, then if $0$ is less than $a$, then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (auto : Eq m (times 2 a)) -> (auto' : Eq m (plus (times 2 a) 1)) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Ha : Lt 1 (plus (times 2 a) 1)) -> (Hx2515 : Lt a 0) -> (Hx2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1585. Let $n$ and $m$ be natural numbers. Assume that $0 < n$. Assume that $m$ is divisible by $n$. Let $d \\in N$. Assume that $0 = m$. Assume that $n = m d$. Then $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (divnm : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n m d) -> Eq 0 n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10334. Soit $n$ un nombre naturel. Supposons que $0$ est inférieur à $n$. Soit $x2515, x2516 \\in N$. Alors $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_10334 : (n : Nat) -> (posn : Lt 0 n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10334 : soit n un nombre naturel. Supposons que 0 est inférieur a n. Soit x2515, x2516 \\in N. Alors x2515 est egale à la somme du produit de x2516 et du quotient de x2515 et de x2516 et de modul x2515 x2516."}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Alors pour tous les nombres naturels $a$, si $m = 2 a$ ou $m = 2 a + 1$, alors si $m = 2 a + 1$, alors si $1 < 2 a + 1$, alors si $0 < a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (_clearme : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : Eq m 2 a + 1) -> (Ha : Lt 1 2 a + 1) -> (Ha0 : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Då om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (1 : Eq n m) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (auto : Eq c n - d m = 1) -> (auto' : Eq (minus (times d m) (times c n)) 1) -> (auto'' : Eq c n - d m = 1) -> Eq n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type2_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_897$ av $ACop$ av $A$ och $_nil$ till element av $Type2$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_897$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_transpose. Pour tous les nombres naturels $i$ et $j$ et $k$ et $n$, si $j$ n'est pas égal à $i$, alors si $i$ n'est pas égal à $k$, alors si $j$ n'est pas égal à $k$, alors $transpose (i, j, n)= transpose (i, k, transpose (k, j, transpose (i, k, n)))$.\nAssistant:", "label": "postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))", "predict": "postulate eq_transpose : (i : Nat) -> (j : Nat) -> (k : Nat) -> (n : Nat) -> (_ : not (Eq j i)) -> (__1 : not (Eq i k)) -> (__2 : not (Eq j k)) -> Eq (transpose i j n) (transpose i k (transpose k j (transpose i k n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_ord_O_to_divides. Let $p$ and $m$ be natural numbers. Assume that $0 < m$. Assume that $p$ is prime. Then if $ord (m, p)$ is not equal to $0$, then $p$ is divisible by $m$.\nAssistant:", "label": "postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m", "predict": "postulate not_ord_O_to_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (Eq (ord m p) 0)) -> divisible p m"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_gcd_aux_mn. Let $p, m, n \\in N$. Then if $0 < n$, then if $n \\leq m$, then if $n \\leq p$, then $gcd_aux (p, m, n)$ is divisible by $m$ and $gcd_aux (p, m, n)$ is divisible by $n$.\nAssistant:", "label": "postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)", "predict": "postulate divides_gcd_aux_mn : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n p) -> and (divisible (gcd_aux p m n) m) (divisible (gcd_aux p m n) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_gcd_aux_mn. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, för alla element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $p$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$ och $m$ och $matita_arithmetics_primes.divides$ applicerat på $matita_arithmetics_gcd.gcd_aux$ applicerat på $p$ och $m$ och $n$ och $n$.\nAssistant:", "label": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))", "predict": "postulate divides_gcd_aux_mn : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) m) (matita_arithmetics_primes.divides (matita_arithmetics_gcd.gcd_aux p m n) n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_transpose_l. Let $f$ be a function from natural numbers to natural numbers. Let $m$ and $i$ and $j$ be natural numbers. Assume that $i \\leq m$. Assume that $j \\leq m$. Then for all elements $__2$ of $permut$ of $f$ and $m$, $permut$ holds for the function that maps $n$ to $transpose (i, j, f (n))$ and $m$.\nAssistant:", "label": "postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (__1 : Leq j m) -> (__2 : permut f m) -> permut (\\ n : Nat -> transpose i j (f n)) m", "predict": "postulate permut_transpose_l : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i m) -> (j : Leq m) -> (__2 : permut f m) -> permut (\\ n : Nat -> transpose i j (f n)) m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_20. För alla heltal $a$, för alla heltal $c$, om $a$ är udda och $c$ är udda, så är $a b + b c$ jämnt för alla heltal $b$.\nAssistant:", "label": "postulate noLabel_20 : all Int (\\ b -> all Int (\\ a -> all Int (\\ c -> if (and (odd a) (odd c)) (even (plus (times a b) (times b c))))))", "predict": "postulate noLabel_20 : (a : Int) -> (c : Int) -> (u : not (odd a)) -> (v : not (odd c)) -> Eq (plus a b) (plus b c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Låt $g1$ och $g2$ vara funktioner från naturliga tal till naturliga tal. Låt $n1 \\in N$. Låt $Hind$ vara en funktion från funktioner från naturliga tal $i$ och element av $Lt$ av $i$ och $n1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$ och funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n1$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$ till element av $Leq$ av $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$ och $bigop$ applicerat på $n1$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$. Låt $H1$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$. Låt $H2$ vara en funktion från naturliga tal $i$ och element av $Lt$ av $i$ och $n1 + 1$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$. Anta att $p2 (n1)= true$ och $p1 (n1)= true$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : let n : Nat in Låt p1 och p2 vara funktioner från naturliga tal till sanningsvärden. Låt g1 och g2 vara funktioner från naturliga tal till naturliga tal. Låt n1 : Nat in Låt Hind : (i : Nat) -> (lt i n1) -> (__1 : Eq p1 (i)) -> Eq p2 (i) -> (__1 : Nat -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i g2) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_minus_associative. Soit $x, y, z \\in N$. Alors si $z$ est inférieur ou ágal à $y$, alors si $y$ est inférieur ou ágal à $x$, alors la différence de $x$ et de la différence de $y$ et de $z$ est égale à la somme de la différence de $x$ et de $y$ et de $z$.\nAssistant:", "label": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)", "predict": "postulate minus_minus_associative : soit x, y, z : N -> (_ : Lt z y) -> (__1 : Lt y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_inv_plus_l. Låt $x$ och $y$ och $z$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $x$ och $y$ och $z$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $x$ och $matita_arithmetics_nat.minus$ applicerat på $z$ och $y$ och $matita_arithmetics_nat.le$ applicerat på $y$ och $z$.\nAssistant:", "label": "postulate le_inv_plus_l : (x : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (y : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z)) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))", "predict": "postulate le_inv_plus_l : let x : cic.Term univs.Type0 matita_arithmetics_nat.nat in let y : cic.Term univs.Type0 matita_arithmetics_nat.nat in let z : cic.Term univs.Type0 matita_arithmetics_nat.nat in let __ : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus x y) z) -> cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le x (matita_arithmetics_nat.minus z y)) (matita_arithmetics_nat.le y z))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_body. Let $B$ be a set. Let $_R$ be an element of $relation$ of $B$. Then for all functions $Q_$ from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions, for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O (B, _R, b)$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of $l + 1$ and $b1$ and $b2$ and $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.\nAssistant:", "label": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : N) -> (_clearme : ex Nat (\\ d : Nat -> (\\ E : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (times m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_maxr. Soit $i, n, m \\in N$. Supposons que $max$ appliqué à $n$ et $m$ est inférieur ou ágal à $i$. Alors $m$ est inférieur ou ágal à $i$.\nAssistant:", "label": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> Leq m i", "predict": "postulate le_maxr : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (max n m) i) -> or (Lt m i) (Lt i m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDpi1__o__aop__o__op. Let $x0$ be a set. Let $x1$ be an element of $x0$. Let $x2$ be a function from elements of $ACop$ of $x0$ and $x1$ to sets. Then for all elements $x3$ of $DPair$ of $ACop$ applied to $x0$ and $x1$ and $x2$, for all elements $_x_887$ and $_x_888$ of $x0$, $x0$.\nAssistant:", "label": "postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0", "predict": "postulate dpi1__o__aop__o__op : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> (_x_887 : x0) -> (_x_888 : x0) -> x0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Supposons que la puissance de $2$ et de $7$ est inférieure ou ágale à $n$. Soit $p$ un nombre naturel. Supposons que la somme de la racine carrée du produit de $2$ et de $n$ et de $1$ est inférieure ou ágale à $p$. Supposons que $p$ est inférieur à la somme du produit de $2$ et de $n$ et de $1$. Supposons que $leb$ appliqué à $2$ et $k$ appliqué à le produit de $2$ et de $n$ et $p$ est égal à $true$. Alors si le produit de $2$ et de $n$ est inférieur à la puissance de $p$ et de $2$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515$ est égal à la somme du produit de $x2516$ et du quotient de $x2515$ et de $x2516$ et de $mod$ appliqué à $x2515$ et $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n un nombre naturel. supposons que la puissance de 2 et de 7 est inférieure ou àgale à n. soit p un nombre naturel. supposons que la somme de la racine carrée du produit de 2 et de n et de 1 est inférieure ou àgale à p. supposons que p est inférieur à la somme du produit de 2 et de n et de 1. supposons que lebbeau 2 et kbeau le produit de 2 et n et p est égal à true. alors si le produit de 2 et de n est inférieur à la puissance de p et de 2, alors pour tous les nombres naturels x2515 et x2516, x2515 est égal à la somme du produit x2516 et du quotient de x2515 et de x2516 et de mod x2515 x2516."}
{"prompt": "Human: Translate the following French statement into Agda.\nMod_mod. Pour tous les éléments $n$ et $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $p$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $p$ et $p$.\nAssistant:", "label": "postulate mod_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p))", "predict": "postulate mod_mod : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n p) (matita_arithmetics_div_and_mod.mod (matita_arithmetics_div_and_mod.mod n p) p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp1. Pour tous les éléments $_n$ et $_m$ et $_q$ et $_r$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour toutes les fonctions $Q_$ des éléments $_x_853$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_855$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $_r$ et $_m$ et des éléments $x_854$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_n$ et $matita_arithmetics_nat.plus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $_q$ et $_m$ et $_r$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_div_and_mod.div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_855$ et $x_854$, pour tous les éléments $x_853$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_div_and_mod.div_mod_spec$ appliqué à $_n$ et $_m$ et $_q$ et $_r$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_853$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)", "predict": "postulate div_mod_spec_rect_CProp1 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_855 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_854 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_855 x_854))) -> (x_853 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_853)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides_true. Låt $l$ vara en lista av naturliga tal. Låt $n$ vara ett naturligt tal. Då om $list_divides (l, n)= true$, så håller $ex$ för $Nat$ och funktionen som avbildar $p$ som konjunktionen av $mem$ applicerat på $Nat$ och $p$ och $l$ och $divisible$ applicerat på $p$ och $n$.\nAssistant:", "label": "postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) true) -> ex Nat (\\ p : Nat -> and (mem Nat p l) (divisible p n))", "predict": "postulate list_divides_true : (l : list Nat) -> (n : Nat) -> (_ : list_divides (l, n)) -> ex Nat (\\ p : Nat -> (\\ _ : divisible p n) -> p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnique. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $H$, $cic.Univ$ tient pour $cic.prop$.\nAssistant:", "label": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop", "predict": "postulate unique : (H : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Soit $a \\in N$. Supposons que $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$. Supposons que $1 < 2 a + 1$ et $0 < a$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (posn : Eq m 2 a) -> (posn1 : Eq m 2 a + 1) -> (posn2 : Eq 1 2 a + 1) -> (Hind0 : Lt 2 a + 1) -> (Hind1 : Lt 0 2 a) -> (Hind2 : Lt a 2) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_S_S_to_lt. Låt $n$ och $m$ vara naturliga tal. Då om $n + 1 < m + 1$, så $n < m$.\nAssistant:", "label": "postulate lt_S_S_to_lt : (n : Nat) -> (m : Nat) -> (_ : Lt (plus n 1) (plus m 1)) -> Lt n m", "predict": "postulate lt_S_S_to_lt : låt n m vara naturliga tal. då om n + 1 < m + 1, så n < m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_cases. För alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$, för alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $n$ och $matita_basics_bool.true$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $f$ och $n$ och $matita_basics_logic.And$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $f$ applicerat på $n$ och $matita_basics_bool.false$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.max$ applicerat på $matita_arithmetics_nat.S$ applicerat på $n$ och $f$ och $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$.\nAssistant:", "label": "postulate max_cases : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) n)) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f n) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) (matita_arithmetics_minimization.max n f))))", "predict": "postulate max_cases : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) f n) matita_basics_bool.true) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) n)) (matita_basics_logic.And (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) f n) matita_basics_bool.false) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.max (matita_arithmetics_nat.S n) f) (matita_arithmetics_minimization.max n f)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16004. Let $m, n, a, b \\in N$. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Then for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (gcd : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq m d (gcd m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_not_exists. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Låt $__$ vara en funktion från naturliga tal $i$ och element av $Leq$ av $b$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $n$ och $b$ till element av $Eq$ av $f$ applicerat på $i$ och kontradiktion. Då är $min$ applicerat på $n$ och $b$ och $f$ lika med summan av $n$ och $b$.\nAssistant:", "label": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)", "predict": "postulate min_not_exists : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) (contradiction)) -> Eq (min n b f) (plus n b)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type2_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_951$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $_nil$ et $_nil$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $prod$ appliqué à $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$", "label": "postulate Dop_rect_Type2_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)", "predict": "postulate Dop_rect_Type2_body : soit A un élément de cic.Univ univs.Type0. soit _nil un élément de cic.Term univs.Type0 et de A. Alors pour toutes les fonctions Q_ des éléments _x_951 de cic.Term univs.Type0 et de matita_arithmetics_bigops.Dop A _nil à des éléments de cic.Univ univs.Type2, pour toutes les fonctions _H_mk_Dop des éléments sum de cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil) des fonctions prod __ : cic.Term univs.Type0 A des éléments __1 de cic.Term univs.Type0 A et des cic.Term univs.Type0 A et __ : cic.Term univs.Type0 A des cic.Term univs.Type0 A, des cic.Term univs.Type0 A des cic.Term univs.Type0 A et (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> Q_ (matita_arithmetics_bigops.aop__o__op A _nil sum b c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Då om det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (same : Eq 1 (gcd p m)) -> (c : Nat) -> (nm : Nat) -> (auto : Eq m n) -> (auto' : Eq (times m n) p) -> (auto'' : Eq c (Nat (gcd p m) (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (auto' : Eq b (Nat p (gcd p m))) -> (auto'' : Eq (times p m) n) -> (auto''' : Eq c (Nat (gcd p m) (Eq (minus (times a p) (times b m)) (gcd p m))) (Eq (minus (times b m) (times a p)) (gcd p m))) -> Eq (times p m) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1569. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_1569 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1569 : soit m, n, a, b \\in N. supposons que 0 est inférieur à n. supposons que 0 est inférieur à m. supposons que le diviseur commun plus grand de n et de m est égal à 1. soit c \\in N. soit _clearme : ex Nat (\\ d : Nat -> disjonct ( Eq ( minus ( times c n) ( times d m)) 1) ( Eq ( minus ( times d m) ( times c n)) 1)) soit d : Nat. supposons que la différence du produit de c et de n et du produit de d et de m est égale à 1. ou la différence du produit de d et de m et du produit de c et de n est égale à 1. alors si la différence du produit de c et de n et du produit de d et de m est égale à 1, alors la différence du produit de n et de c et du produit de m et de d est égale à 1."}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_fact. Let $n$ and $i$ be natural numbers. Assume that $0$ is less than $i$. Then if $i$ is less than or equal to $n$, then $i$ is divisible by the factorial of $n$.\nAssistant:", "label": "postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)", "predict": "postulate divides_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 0 i) -> (__1 : Leq i n) -> divisible i (factorial n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1$ un nombre naturel. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Alors pour toutes les fonctions $H2$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$, si $p2 (n1)= true$, alors si $p1 (n1)= true$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n un nombre naturel. Soient p1 et p2 des fonctions des nombres naturels à des valeurs booléennes. Soient g1 et g2 des fonctions des nombres naturels à des nombres naturels. Soit n1 un nombre naturel. Soit Hind une fonction des fonctions des nombres naturels i et des éléments de Lt de i et n1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Eq de p2 (i) et true et des fonctions __1 des nombres naturels i et __1 de Lt de i et n1 et des éléments __2 de Eq de p1 (i) et true à des éléments de Leq de g1 (i) et g2 (i) à des éléments de Leq de bigop applied to n1 and the function which envoie i to p1 applied to i and Nat 0 plus the function which envoie i to g1 applied to i and bigop applied to n1 and the function which envoie i to p2 applied to i and Nat 0 plus the function which envoie i to g2 applied to i. Soit H1 une fonction des nombres naturels i et des éléments de Lt de i n1 + 1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Eq de p2 (i) et true. Alors pour toutes les fonctions H2 des nombres naturels i et des éléments de Lt de i n1 + 1 et des éléments __1 de Eq de p1 (i) et true à des éléments de Leq de g1 (i) et g2 (i) si p2 (n1) = true, si p1 (n1) = true, alors pour tous les nombres naturels x2515 et x2516, x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15601. Let $n$ and $m$ be natural numbers. Assume that $0$ is less than $m$. Assume that $0$ is equal to $n$. Assume that $0$ is divisible by $m$. Then for all natural numbers $q$, if $m$ is equal to the product of $0$ and $q$, then $n$ is equal to $0$.\nAssistant:", "label": "postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0", "predict": "postulate let_clause_15601 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (divnm : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq n 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_exp2. Låt $p, n, m \\in N$. Anta att $1 < p$. Då om $0 < n$, så $m \\log_ p {n}\\leq \\log_ p {(n ^ m)}$.\nAssistant:", "label": "postulate log_exp2 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Leq (times m (log p n)) (log p (pow n m))", "predict": "postulate log_exp2 : let p : Nat -> n : Nat -> m : Nat -> anta att 1 < p -> då om 0 < n -> m log_ p n <= log_ p (n ^ m))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n \\in N$. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Anta att $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : let n : Nat in let (a : Nat) -> let (m : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let (s : Nat) -> let (t : Nat) -> let (u : Nat) -> let (v : Nat) -> let (w : Nat) -> let (x : Nat) -> let (y : Nat) -> let (z : Nat) -> let (a : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let (s : Nat) -> let (t : Nat) -> let (u : Nat) -> let (v : Nat) -> let (w : Nat) -> let (x : Nat) -> let (y : Nat) -> let (z : Nat) -> let (a : Nat) -> let (b : Nat) -> let (c : Nat) -> let (d : Nat) -> let (e : Nat) -> let (f : Nat) -> let (g : Nat) -> let (h : Nat) -> let (i : Nat) -> let (j : Nat) -> let (k : Nat) -> let (l : Nat) -> let (m : Nat) -> let (n : Nat) -> let (o : Nat) -> let (p : Nat) -> let (q : Nat) -> let (r : Nat) -> let ("}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1686. Låt $n, m \\in N$. Låt $Hind$ vara en funktion från naturliga tal $p$ och element av $Lt$ av $p$ och $m$ och element $__1$ av $Lt$ av $1$ och $p$ till element av $Leq$ av $Psi (p)$ och $pred (p)\\times (2 ^ (2 p - 3))$. Låt $a$ vara ett naturligt tal. Anta att $m = 2 a$ eller $m = 2 a + 1$ och $m = 2 a + 1$. Anta att $1 < 2 a + 1$ och $0 < a$. Då $pred (m)= a + a$.\nAssistant:", "label": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> Eq (pred m) (plus a a)", "predict": "postulate let_clause_1686 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> Lt p m) -> (__1 : Lt 1 p) -> (Leq : (Psi : Nat) -> pred p) -> (a : Nat) -> or (and (Leq m 2 a) (and (Lt 1 2 a) (and (Lt a 2) (pow 2 (2 * p))))) (and (Lt 1 2 a) (and (Lt a 2) (pow 2 (2 * p))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Låt $return$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$. Då för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_O_to_not_divides. Låt $p$ och $m$ vara naturliga tal. Anta att $0 < m$. Anta att $p$ är primt. Anta att $ord (m, p)= 0$. Då är $p$ inte delbart med $m$.\nAssistant:", "label": "postulate ord_O_to_not_divides : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : Eq (ord m p) 0) -> not (divisible p m)", "predict": "postulate ord_O_to_not_divides : let (p : Nat) -> (m : Nat) -> (posp : Lt 0 m) -> (primp : prim p) -> (H : Eq (ord m p) 0) -> not (divisible p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDividesb_div_true. Let $d, n \\in N$. Then if $0 < n$ and $dividesb (d, n)= true$, then $dividesb (n \\div d, n)= true$.\nAssistant:", "label": "postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (dividesb d n) true) -> Eq (dividesb (div n d) n) true", "predict": "postulate dividesb_div_true : (d : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (dividesb (d, n) true) -> Eq (dividesb (n \\ div d) n) true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16004. För alla naturliga tal $m$ och $n$ och $a$ och $b$, om $0 < n$, så om $0 < m$, så om $1$ är lika med det största gemensama delaret av $n$ och $m$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16004 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (one : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq c n) (Eq d m)) -> (H : Eq (times d m) c) -> Eq (times m d) n"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_961$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a, _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a, aop__o__op (A, _nil, sum, b, c))$ and $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ to elements of $Q_$ of $mk_Dop (A, _nil, sum, prod, _null, _distr)$, for all elements $x_961$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_961$.\nAssistant:", "label": "postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961", "predict": "postulate Dop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_961 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_961 : Dop A _nil) -> Q_ x_961"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMax_spec_ind. Låt $_n \\in N$. Låt $_f$ vara en funktion från naturliga tal till sanningsvärden. Då för alla funktioner $Q_$ från naturliga tal $x_971$ och element $_x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$ till påståenden, för alla funktioner $_H_found_max_spec$ från naturliga tal $m$ och element $x_975$ av $Lt$ av $m$ och $_n$ och element $x_974$ av $Eq$ av $_f$ applicerat på $m$ och $true$ och funktioner $x_973$ från naturliga tal $i$ och element av $Lt$ av $m$ och $i$ och element $__1$ av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f$ applicerat på $i$ och kontradiktion till element av $Q_$ av $m$ och $found_max_spec$ applicerat på $_n$ och $_f$ och $m$ och $x_975$ och $x_974$ och $x_973$, för alla funktioner $_H_not_found_max_spec$ från funktioner $x_976$ från naturliga tal $i$ och element av $Lt$ av $i$ och $_n$ till element av $Eq$ av $_f$ applicerat på $i$ och kontradiktion till element av $Q_$ av $0$ och $not_found_max_spec$ applicerat på $_n$ och $_f$ och $x_976$, för alla naturliga tal $x_971$, för alla element $x_972$ av $max_spec$ av $_n$ och $_f$ och $x_971$, håller $Q_$ för $x_971$ och $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> Prop) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) (contradiction m (found_max_spec _n _f m x_975 x_974 x_973))) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) (contradiction m (found_max_spec _n _f m x_975 x_974 x_973))) -> (_H : (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15625. Let $m, n, a, b \\in N$. Assume that $0 < n$. Then if $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (eqm : Lt 0 m) -> (gcd : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq m d"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $permf$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.permut$ applicerat på $f$ och $n$. Låt $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lein$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Låt $lejn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Låt $a$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $_clearme$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $a$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $lean$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $a$ och $n$, för alla element $fa$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $f$ applicerat på $a$ och $i$, för alla element $b$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $matita_arithmetics_nat.le$ applicerat på $b$ och $n$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på", "label": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita", "predict": "postulate let_clause_1063 : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (permf : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lein : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (lejn : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le a n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (lean : cic.Term cic.prop (matita_arithmetics_nat.le a n)) -> (fa : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.And (matita_arithmetics_nat.le b n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f a) i)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus n (matita_arithmetics_nat.times b a)) (matita_arithmetics_nat.times (matita_arithmetics_nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_rect_CProp5. For all functions $Q_$ from elements $_x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $cic.prop$, for all elements $_H_I$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.I$, for all elements $x_56$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_56$.\nAssistant:", "label": "postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)", "predict": "postulate True_rect_CProp5 : (Q_ : (_x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_56 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_56)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_73. Let $n, m, p \\in N$. Then if $0 < p$, then for all natural numbers $x134$ and $x135$ and $x136$, $x134 + (x135 + x136)= x135 + (x134 + x136)$.\nAssistant:", "label": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> Eq (plus x134 (plus x135 x136)) (plus x135 (plus x134 x136))", "predict": "postulate let_clause_73 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x134 : Nat) -> (x135 : Nat) -> (x136 : Nat) -> x134 + (x135 + x136) = x135 + (x134 + x136)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1545. Soient $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $H$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.O$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $q1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $H1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.O$ et $q1$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $q2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $H2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.O$ et $q2$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_le_to_lt_times. Soient $n$ et $m$ et $p$ et $q$ des nombres naturels. Supposons que $n < m$ et $p \\leq q$. Supposons que $0 < q$. Alors $n p < m q$.\nAssistant:", "label": "postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt n m) -> (__1 : Leq p q) -> (__2 : Lt 0 q) -> Lt (times n p) (times m q)", "predict": "postulate lt_to_le_to_lt_times : (n : Nat) -> (m : Nat) -> (p : Nat) -> (q : Nat) -> (Hn : Lt n m) -> (Hp : Lt p q) -> (Hq : Lt 0 q) -> and (Lt n p) (Lt m q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i$ is less than or equal to $n$. Assume that $j$ is less than or equal to $n$. Let $a$ be a natural number. Assume that $a$ is less than or equal to $n$ and $f$ applied to $a$ is equal to $i$. Assume that $a$ is less than or equal to $n$. Assume that $f$ applied to $a$ is equal to $i$. Let $b \\in N$. Assume that $b$ is less than or equal to $n$ and $f$ applied to $b$ is equal to $j$. Assume that $b$ is less than or equal to $n$. Assume that $f$ applied to $b$ is equal to $j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f$ applied to $i0$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a$ is equal to $b$, then $f$ applied to $a$ is equal to $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (lea : Leq a n) -> (fa : Eq (f a) i) -> (ab : Nat) -> (lb : Leq a n) -> (fb : Eq (f a) i) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> injf : injn f n -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15624. Let $m, n, a, b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that $c n - d m = 1$ or $d m - c n = 1$. Then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt n 0) -> (posm : Lt m 0) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (Hm : Eq (minus (times d m) (times c n)) 1) -> Eq m d n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1$ and $n2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $ACop$ of $B$ and $nil$. Let $f1$ and $f2$ be functions from natural numbers to elements of $B$. Let $_clearme$ be an element of $iso$ of $B$ and $mk_range (B, f1, n1, p1)$ and $mk_range (B, f2, n2, p2)$. Let $h$ be a function from natural numbers to natural numbers. Let $_clearme0$ be an element of $ex$ of $prod$ applied to $Set$ and $Set$ and $Nat$ and the function that maps $__$ to $Nat$ and the function that maps $k$ to the conjunction of the conjunction of $prod$ applied to $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$ and $sub_hk$ applied to $h$ and $k$ and $B$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $sub_hk$ applied to $k$ and $h$ and $B$ and $mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$ and $mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$. Let $k$ be a function from natural numbers to natural numbers. Assume that $prod$ holds for $Set$ and $Prop$ and $Nat$ and the function that maps $i$ to $prod$ applied to $Prop$ and $Prop$ and $Lt$ applied to $i$ and $n1$ and the function that maps $__$ to $prod$ applied to $Prop$ and $Prop$ and $Eq$ applied to $p1$ applied to $i$ and $true$ and the function that maps $__1$ to $Eq$ applied to $f1$ applied to $i$ and $f2$ applied to $h$ applied to $i$, $sub_h", "label": "postulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : ((_ : Nat) -> Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1)))) -> (k : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk h k B (mk_range B", "predict": "kpostulate let_clause_10471 : (n1 : Nat) -> (n2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f1 : (_ : Nat) -> B) -> (f2 : (_ : Nat) -> B) -> (_clearme : iso B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2)) -> (h : (_ : Nat) -> Nat) -> (_clearme0 : ex (prod Set Set Nat (\\ _ : Nat -> Nat)) (\\ k : (_ : Nat) -> and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk (h k) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (k : (_ : Nat) -> Nat) -> (B0 : Set) -> (k0 : (_ : Nat) -> Nat) -> (_clearme1 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1) (\\ _ : Lt i n1 -> prod Prop Prop (Eq (p1 i) true) (\\ __1 : Eq (p1 i) true -> Eq (f1 i) (f2 (h i)))))) (sub_hk (h k) B (mk_range B f1 n1 p1) (mk_range B f2 n2 p2))) (sub_hk k h B (mk_range B f2 n2 p2) (mk_range B f1 n1 p1))) -> (i : Nat) -> (j : Nat) -> (k : (_ : Nat) -> Nat) -> (l : (_ : Nat) -> Nat) -> (_clearme2 : and (and (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type3_body. Låt $_n, _m, _q, _r \\in N$. Då för alla funktioner $Q_$ från element $_x_821$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till element av $Type3$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_823$ av $Lt$ av $_r$ och $_m$ och element $x_822$ av $Eq$ av $_n$ och summan av produkten av $_q$ och $_m$ och $_r$ till element av $Q_$ av $div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_823$ och $x_822$, för alla element $x_821$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_821$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type3_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_821 : div_mod_spec _n _m _q _r) -> Type3) -> (_H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)) -> (x_821 : div_mod_spec _n _m _q _r) -> Q_ x_821", "predict": "postulate div_mod_spec_rect_Type3_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> Då för alla funktioner Q_ från (_x_821 : div_mod_spec _n _m _q _r) till Type3, för alla funktioner _H_div_mod_spec_intro : (x_823 : Lt _r _m) -> (x_822 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_823 x_822)"}
{"prompt": "Human: Translate the following English statement into Agda.\nExists_append. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$. Then for all elements $l1$ and $l2$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l1$ and $matita_basics_lists_list.Exists$ applied to $A$ and $P$ and $l2$.\nAssistant:", "label": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))", "predict": "postulate Exists_append : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Exists A P (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_logic.Or (matita_basics_lists_list.Exists A P l1) (matita_basics_lists_list.Exists A P l2))"}
{"prompt": "Human: Translate the following French statement into Agda.\nIter_body. Pour tous les éléments $H$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $__$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $H$ à des éléments de $cic.Term$ de $univs.Type0$ et de $H$, pour tous les éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $H$, $cic.Term$ tient pour $univs.Type0$ et $H$.\nAssistant:", "label": "postulate iter_body : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate iter_body : (H : cic.Univ univs.Type0) -> (__ : (__ : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_n_nth_prime_n. Soit $n \\in N$. Alors $n < nth_prime (n)$.\nAssistant:", "label": "postulate lt_n_nth_prime_n : (n : Nat) -> Lt n (nth_prime n)", "predict": "postulate lt_n_nth_prime_n : soit n N. alors n < nth_prime n"}
{"prompt": "Human: Translate the following French statement into Agda.\nFalse_rect_CProp5_body. Pour toutes les fonctions $Q_$ des éléments $_x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_74$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.False$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_74$.\nAssistant:", "label": "postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)", "predict": "postulate False_rect_CProp5_body : (Q_ : (_x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_74 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_74)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSub_hk. För alla funktioner $__$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $A$ av $cic.Univ$ av $univs.Type0$, håller $cic.Term$ för $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $matita_arithmetics_bigops.range$ applicerat på $A$.\nAssistant:", "label": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_to_eq2. Let $a$ and $b$ and $q$ and $r$ and $q1$ and $r1$ be natural numbers. Then for all elements $__$ of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$, for all elements $__1$ of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$, $r = r1$.\nAssistant:", "label": "postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1", "predict": "postulate div_mod_spec_to_eq2 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_ : div_mod_spec a b q r) -> (__1 : div_mod_spec a b q1 r1) -> Eq r r1"}
{"prompt": "Human: Translate the following French statement into Agda.\nMonotonic_sqrt. $monotonic$ tient pour $Nat$ et $Leq$ et $sqrt$.\nAssistant:", "label": "postulate monotonic_sqrt : monotonic Nat Leq sqrt", "predict": "postulate monotonic_sqrt : monotonic Nat Leq sqrt"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_minus. Soit $m, n, p \\in N$. Supposons que $m \\leq n$. Alors $n - m + p = n + p - m$.\nAssistant:", "label": "postulate plus_minus : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Leq m n) -> Eq (plus (minus n m) p) (minus (plus n p) m)", "predict": "postulate plus_minus : soit m : Nat, n : Nat, p : Nat -> (le m n) -> Eq n (m + p)"}
{"prompt": "Human: Translate the following English statement into Agda.\nFalse_to_lt_max. Let $f$ be a function from natural numbers to booleans. Then for all natural numbers $n$ and $m$, if $0 < n$, then if absurdity is equal to $f (n)$, then if $max (m, f)\\leq n$, then $max (m, f)< n$.\nAssistant:", "label": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n", "predict": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq false (f n)) -> (__2 : Leq (max m f) n) -> Lt (max m f) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_CProp1_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_965$ av $Dop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_965$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_965$.\nAssistant:", "label": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965", "predict": "postulate Dop_rect_CProp1_body : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Then for all functions $Q_$ from elements $_x_799$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_799$ of $cic.Term$ of $univ", "label": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)", "predict": "postulate Aop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_799 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_799)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp5. För alla element $_A$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_nmk$ från funktioner $x_104$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_104$, för alla element $x_103$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_103$.\nAssistant:", "label": "postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)", "predict": "postulate Not_rect_CProp5 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_104 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) -> (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_103)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_body. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $Q_$ une fonction des nombres naturels $x_1233$ et des éléments $x_1232$ de $B$ et des éléments $x_1231$ de $B$ et des éléments $_x_1234$ de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$ à des propositions. Soit $_H_lstar_O$ une fonction des éléments $b$ de $B$ à des éléments de $Q_$ de $0$ et de $b$ et de $b$ et de $lstar_O (B, _R, b)$. Soit $_H_lstar_S$ une fonction des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $x_1236$ de $_R$ de $b1$ et de $b$ et des nombres naturels $l$ et des éléments $b2$ de $B$ et des éléments $x_1235$ de $lstar$ de $B$ et de $_R$ et de $l$ et de $b$ et de $b2$ et des éléments $_x_1238$ de $Q_$ de $l$ et de $b$ et de $b2$ et de $x_1235$ à des éléments de $Q_$ de $l + 1$ et de $b1$ et de $b2$ et de $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Soit $x_1233 \\in N$. Soient $x_1232$ et $x_1231$ des éléments de $B$. Soit $x_1234$ un élément de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$. Alors $Q_$ tient pour $x_1233$ et $x_1232$ et $x_1231$ et $x_1234$.\nAssistant:", "label": "postulate lstar_ind_body : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind_body : soit B un ensemble. soit _R un element de relation de B. soit Q_ une fonction des nombres naturels x_1233 et des elements x_1232 de B et des elements x_1231 de B et des elements _x_1234 de lstar de B _R x_1233 x_1232 x_1231 et des propositions. soit _H_lstar_O une fonction des elements b de B a des elements Q_ 0 b b et b et lstar_O (B _R b). soit _H_lstar_S une fonction des elements b1 de B et des elements b de B et des elements x_1236 de _R b1 b et des nombres l et des elements b2 de B et des elements x_1235 de lstar de B _R l b b2 et des elements _x_1238 de Q_ l b b2 x_1235 et des elements Q_ l + 1 b1 b2 lstar_S (B _R b1 b x_1236 l b2 x_1235). soit x_1233 in N. soit x_1232 et x_1231 des elements de B. soit x_1234 un element de lstar de B _R x_1233 x_1232 x_1231. alors Q_ tient pour x_1233 x_1232 x_1231 x_1234."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $n$ och $c$ och produkten av $m$ och $d$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : N) -> (n : N) -> (a : N) -> (b : N) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (D : Eq 0 n) -> (posc : Eq 0 m) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_plus_div. Let $m$ and $n$ and $q$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $q$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_div_and_mod.div$ applied to $m$ and $q$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $q$ and $matita_arithmetics_div_and_mod.div$ applied to $matita_arithmetics_nat.plus$ applied to $m$ and $n$ and $q$.\nAssistant:", "label": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))", "predict": "postulate le_plus_div : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.plus (matita_arithmetics_div_and_mod.div m q) (matita_arithmetics_div_and_mod.div n q)) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.plus m n) q))"}
{"prompt": "Human: Translate the following French statement into Agda.\nF_false_to_le_max. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n, p \\in N$. Alors pour tous les éléments $__$ de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$, pour toutes les fonctions $__1$ des nombres naturels $m$ et des éléments $__1$ de $Lt$ de $p$ et de $m$ à des éléments de $Eq$ de $f (m)$ et de contradiction, $max (n, f)\\leq p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p", "predict": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (__ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nFold. Let $A$ and $B$ be elements of $cic.Univ$ of $univs.Type0$. Let $_op$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_b$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Then for all functions $_p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all functions $_f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $B$.\nAssistant:", "label": "postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B", "predict": "postulate fold : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (_op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (_b : cic.Term univs.Type0 B) -> (_p : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term univs.Type0 B"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_SO_smallest_factor. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_primes.smallest_factor$ applicerat på $n$.\nAssistant:", "label": "postulate lt_SO_smallest_factor : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))", "predict": "postulate lt_SO_smallest_factor : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_primes.smallest_factor n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_SO_to_le_B_exp. For all natural numbers $n$, if $1 < n$, then $B (2 n)\\leq 2 ^ pred (2 n)$.\nAssistant:", "label": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))", "predict": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq B (2 n) 2 ^ pred (2 n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_not_ord_O. Let $p, m \\in N$. Assume that $0 < m$ and $p$ is prime. Then if $p$ is divisible by $m$, then $ord (m, p)$ is not equal to $0$.\nAssistant:", "label": "postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : divisible p m) -> not (Eq (ord m p) 0)", "predict": "postulate divides_to_not_ord_O : (p : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : prime p) -> (__2 : not (divisible p m)) -> not (Eq (ord m p) 0)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_previous_prime5. För alla naturliga tal $n$ och $m$, om $nth_prime (n)< m$, så $Nat$.\nAssistant:", "label": "postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_previous_prime5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_S_to_permut. Let $f$ be a function from natural numbers to natural numbers. Let $m \\in N$. Then for all elements $__$ of $permut$ of $f$ and the sum of $m$ and $1$, if $f$ applied to the sum of $m$ and $1$ is equal to the sum of $m$ and $1$, then $permut$ holds for $f$ and $m$.\nAssistant:", "label": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m", "predict": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_ord_rem. Låt $n, m \\in N$. Anta att $n$ är primt och $0 < m$. Anta att $n$ är delbart med $m$. Då $ord_rem (m, n)< m$.\nAssistant:", "label": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m", "predict": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (prime : prim n) -> (lt0m : Lt n m) -> (divn : divisible n m) -> Lt (ord_rem m n) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1545. Let $m$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $n$. Let $q1$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q1$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_nat.O$ and $m$. Let $q2$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $H2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.O$ and $q2$. Then $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $m$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)", "predict": "postulate let_clause_1545 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd m n) matita_arithmetics_nat.O)) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O n)) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times matita_arithmetics_nat.O q1))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_primes.divides matita_arithmetics_nat.O m)) -> (q2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times matita_arithmetics_nat.O q2))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type5. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_785$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_basics_lists_list.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_", "label": "postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)", "predict": "785postulate Aop_rect_Type5 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_785 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_785)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax. For all natural numbers $_n$, for all functions $_f$ from natural numbers to booleans, $Nat$.\nAssistant:", "label": "postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat", "predict": "postulate max : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_inv_rect_CProp1. For all sets $x1$, for all elements $x2$ of $x1$, for all elements $Hterm$ of $ACop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1620$ of $ACop$ of $x1$ and $x2$ to propositions, for all functions $_H1$ from elements $aop$ of $Aop$ of $x1$ and $x2$ and functions $_comm$ from elements $a$ of $x1$ and elements $b$ of $x1$ to elements of $Eq$ of $op (x1, x2, aop, a, b)$ and $op (x1, x2, aop, b, a)$ and elements $_z1621$ of $Eq$ of $Hterm$ and $mk_ACop (x1, x2, aop, _comm)$ to elements of $P$ of $mk_ACop (x1, x2, aop, _comm)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp1 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1620 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1621 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_O_n. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nAssistant:", "label": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)", "predict": "postulate le_O_n : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_nat.le matita_arithmetics_nat.O n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAxiom. Låt $__$ och $__1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då är $__ \\div __1$ ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate div : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate låt : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_925$.\nAssistant:", "label": "postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)", "predict": "postulate range_rect_Type1 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_n_times_nm. For all natural numbers $n$ and $m$, if $0$ is less than $m$, then the greatest common divisor of $n$ and the product of $n$ and $m$ is equal to $n$.\nAssistant:", "label": "postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n", "predict": "postulate gcd_n_times_nm : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Eq (gcd n (times n m)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_I_gen. Låt $a$ och $b$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Då för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $a \\leq b$, så är $bigop$ applicerat på $b$ och funktionen som avbildar $i$ som $andb$ applicerat på $leb$ applicerat på $a$ och $i$ och $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på skillnaden mellan $b$ och $a$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $p$ applicerat på $i0$ applicerat på summan av $i$ och $a$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som funktionen som avbildar $i0$ som $f$ applicerat på $i0$ applicerat på summan av $i$ och $a$.\nAssistant:", "label": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (bigop b (\\ i : Nat -> andb (leb a i) (p i)) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate bigop_I_gen : (a : Nat) -> (b : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : Aop B nil) -> Nat) -> (f : (_ : Nat) -> B) -> (a : Nat) -> (b : Nat) -> (leb : (_ : Nat) -> (_ : Nat) -> bool) -> (i : Nat) -> andb (leb a i) (p i B nil op B nil op) (\\ i : Nat -> f i) (bigop (b i) (\\ i : Nat -> andb (leb a i) (p i)) B nil op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (sum i a) B nil op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (sum i a))"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_CProp3. Soit $x1$ un ensemble. Alors pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $Aop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1542$ de $Aop$ de $x1$ et de $x2$ à des propositions, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_nill$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (x2, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (a, x2)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ et des éléments $_z1543$ de $Eq$ de $Hterm$ et de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ à des éléments de $P$ de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1542 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1543 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type4_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_891$ de $ACop$ de $A$ et de $_nil$ à des éléments de $Type4$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op (A, _nil, aop, a, b)$ et de $op (A, _nil, aop, b, a)$ à des éléments de $Q_$ de $mk_ACop (A, _nil, aop, _comm)$, pour tous les éléments $x_891$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891", "predict": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891"}
{"prompt": "Human: Translate the following French statement into Agda.\nFact_to_exp. Soit $n \\in N$. Alors la factorielle du produit de $2$ et de $n$ est inférieure ou ágale au produit du produit de la puissance de $2$ et de $pred$ appliqué à le produit de $2$ et de $n$ et de la factorielle de $n$ et de la factorielle de $n$.\nAssistant:", "label": "postulate fact_to_exp : (n : Nat) -> Leq (factorial (times 2 n)) (times (times (pow 2 (pred (times 2 n))) (factorial n)) (factorial n))", "predict": "postulate fact_to_exp : soit n : Nat -> ainsi la factorielle du produit de 2 et de n est inférieure ou àgale au produit du produit de la puissance de 2 et de (pred (times 2 n)) et de la factorielle de n et de la factorielle de n."}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_ind_body. Soit $_A$ un ensemble. Alors pour toutes les fonctions $Q_$ des éléments $_x_915$ de $range$ de $_A$ à des propositions, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$, pour tous les éléments $x_915$ de $range$ de $_A$, $Q_$ tient pour $x_915$.\nAssistant:", "label": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915", "predict": "postulate range_ind_body : (_A : Set) -> (Q_ : (_x_915 : range _A des propositions) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_915 : range _A) -> Q_ x_915) -> (x_915 : range _A) -> Q_ x_915"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1595. For all natural numbers $p$ and $n$ and $m$, if $0 < n$ and $0 < m$, then if $1$ is both equal to the greatest common divisor of $p$ and $n$ and equal to the greatest common divisor of $p$ and $m$, then if the greatest common divisor of $p$ and the product of $n$ and $m$ is less than $1$ and $smallest_factor$ applied to the greatest common divisor of $p$ and the product of $n$ and $m$ is divisible by $m$, then the greatest common divisor of $p$ and $m$ is equal to the greatest common divisor of $p$ and $n$.\nAssistant:", "label": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (primepn : Eq (gcd p n) 1) -> (primepm : Eq (gcd p m) 1) -> (lt1gcd : Lt 1 (gcd p (times n m))) -> (H : divisible (smallest_factor (gcd p (times n m))) m) -> Eq (gcd p n) (gcd p m)", "predict": "postulate let_clause_1595 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd p n)) -> (Hm : Eq (gcd p (times n m)) (gcd p (times n m))) -> Eq (gcd p m) (gcd p n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPrime_to_divides_M. Låt $m, p \\in N$. Anta att $p$ är primt. Anta att summan av $m$ och $1$ är mindre än $p$. Anta att $p$ är mindre än eller lika med summan av produkten av $2$ och $m$ och $1$. Då är $p$ delbart med $M$ applicerat på $m$.\nAssistant:", "label": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (_ : prime p) -> (__1 : Lt (plus m 1) p) -> (__2 : Leq p (plus (times 2 m) 1)) -> divisible p (M m)", "predict": "postulate prime_to_divides_M : (m : Nat) -> (p : Nat) -> (ant : prim p) -> (H : Lt (plus m 1) p) -> (ltml : Lt p (plus (times 2 m) 1)) -> Eq p (div m (times m 2))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soit $p, m, n \\in N$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (eqn : Eq 1 (div (comm p m) m)) -> (divp : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))))) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\\ _ : Eq (minus (times a p) (times b m)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (H : Eq (div (times a b) (times m n)) (div (times p m) (times (div p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m))))) -> (H0 : Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))) -> (H1 : Eq (div (times a b) (times m n)) (div (times p m) (times (div p m) (Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m) m)))))) -> (H2 : Eq (minus (times b m) (times a p)) (div (comm p m) (Eq (minus (times b m) (times a p)) (div (comm p m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_S_times_2. Soit $n \\in N$. Supposons que $0$ est inférieur à $n$. Alors la somme de $n$ et de $1$ est inférieure ou ágale au produit de $2$ et de $n$.\nAssistant:", "label": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)", "predict": "postulate le_S_times_2 : soit n : Nat -> suppos (Eq 0 n) (Lt (plus n 1) (times 2 n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_to_log_r. Soient $b$ et $n$ et $m$ des nombres naturels. Supposons que $1$ est inférieur à $b$. Supposons que $n$ est inférieur à $m$. Alors si la puissance de $b$ et de $n$ est inférieure ou ágale à $m$, alors $n$ est inférieur ou ágal au logarithme de $b$ et de $m$.\nAssistant:", "label": "postulate exp_to_log_r : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Leq (pow b n) m) -> Leq n (log b m)", "predict": "postulate exp_to_log_r : sont_b_n_m : (b : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 b) -> (__1 : Lt n m) -> (__2 : Lt (pow b n) m) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m))) -> and (and (Lt n (log b m)) (Lt (log b m) (pow n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_15. För alla heltal $n$, om $n$ är udda, så är skillnaden mellan summan av produkten av $4$ och potensen av $n$ och $3$ och produkten av $2$ och $n$ och $1$ udda.\nAssistant:", "label": "postulate noLabel_15 : all Int (\\ n -> if (odd n) (odd (minus (plus (times 4 (pow n 3)) (times 2 n)) 1)))", "predict": "postulate noLabel_15 : forall n, (odd n) -> (plus (times 4 (pow n 3)) (times 2 n)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15611. Låt $p, m, n \\in N$. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att $b m - a p = 1$. Då $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ltml : Lt 0 p) -> (eqn1 : Eq 1 (gcd p m)) -> (ltml2 : Eq p (gcd m n)) -> (p : Nat) -> (c : Nat) -> (nm : Eq m n) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (p : Nat) (c : Nat) -> Eq (m : Nat) n)) -> (b : Nat) -> (_clearme1 : Eq (gcd p m) (gcd p m)) -> (Hc : Eq (gcd p m) (gcd p m)) -> Eq (gcd p m) (a : Nat) -> Eq (gcd p m) (b : Nat) -> Eq (gcd p m) (a : Nat)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_inv_rect_CProp2. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $x1$. Då för alla element $Hterm$ av $ACop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1614$ av $ACop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från element $aop$ av $Aop$ av $x1$ och $x2$ och funktioner $_comm$ från element $a$ av $x1$ och element $b$ av $x1$ till element av $Eq$ av $op$ applicerat på $x1$ och $x2$ och $aop$ och $a$ och $b$ och $op$ applicerat på $x1$ och $x2$ och $aop$ och $b$ och $a$ och element $_z1615$ av $Eq$ av $Hterm$ och $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$ till element av $P$ av $mk_ACop$ applicerat på $x1$ och $x2$ och $aop$ och $_comm$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate låt : (x1 : Mngd) -> (x2 : Mngd) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Påstånd) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEx. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop", "predict": "postulate let : (A : cic.Univ univs.Type0) -> (P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following French statement into Agda.\nChecker_abl. Soit $a, b \\in N$. Soit $l$ une liste de nombres naturels. Alors si $checker (cons (Nat, a, cons (Nat, b, l)))= true$, alors $a < b$, $b \\leq 2 a$ et $checker (cons (Nat, b, l))= true$.\nAssistant:", "label": "postulate checker_abl : (a : Nat) -> (b : Nat) -> (l : list Nat) -> (_ : Eq (checker (cons Nat a (cons Nat b l))) true) -> and (and (Lt a b) (Leq b (times 2 a))) (Eq (checker (cons Nat b l)) true)", "predict": "postulate checker_abl : soit a, b \\in N. soit l une liste de nombres naturels. alors si checker (cons (Nat, a, cons (Nat, b, l)))= true, alors a < b, b \\leq 2 a et checker (cons (Nat, b, l))= true"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_S_mod. Let $n$ be a natural number. Then $permut$ holds for $S_mod (n + 1)$ and $n$.\nAssistant:", "label": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n", "predict": "postulate permut_S_mod : (n : Nat) -> permut (S_mod n + 1) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExample12. $nth_prime (3)= 7$.\nAssistant:", "label": "postulate example12 : Eq (nth_prime 3) 7", "predict": "postulate example12 : Eq (nth_prime 3) 7"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ vara ett naturligt tal. Anta att potensen av $2$ och $7$ är mindre än eller lika med $n$. Låt $p$ vara ett naturligt tal. Anta att summan av kvadratroten av produkten av $2$ och $n$ och $1$ är mindre än eller lika med $p$. Anta att $p$ är mindre än summan av produkten av $2$ och $n$ och $1$. Anta att $leb$ applicerat på $2$ och $k$ applicerat på produkten av $2$ och $n$ och $p$ är lika med $true$. Då om produkten av $2$ och $n$ är mindre än potensen av $p$ och $2$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : let n : Nat -> (p : Nat) -> (leb : Lt (pow 2 7) n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1) -> (p : Nat) -> (leb2 : Lt (pow 2 n) p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1) -> (leb3 : Lt (pow p 2) (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (sqrt (times 2 n))) 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_plus_to_minus. Let $n$ and $m$ and $p$ be natural numbers. Then if $m \\leq n$ and $n < p + m$, then $n - m < p$.\nAssistant:", "label": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n (plus p m)) -> Lt (minus n m) p", "predict": "postulate lt_plus_to_minus : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Leq m n) -> (__1 : Lt n p + m) -> Lt n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_8. För alla instanser $n$ av naturliga tal, kan vi bevisa att om summan av $n$ och kvoten av $1$ och $n$ är mindre än $2$, så är summan av potensen av $n$ och $2$ och kvoten av $1$ och potensen av $n$ och $2$ mindre än $4$.\nAssistant:", "label": "postulate noLabel_8 : (n : Nat) -> if (Lt (plus n (div 1 n)) 2) (Lt (plus (pow n 2) (div 1 (pow n 2))) 4)", "predict": "postulate noLabel_8 : forall n : Nat -> beq (plus n (div 1 n)) 2 -> Lt (plus (pow n 2) (div 1 (pow n 2))) 4"}
{"prompt": "Human: Translate the following English statement into Agda.\nMem_single. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_lists_list.mem$ applied to $A$ and $a$ and $matita_basics_lists_list.cons$ applied to $A$ and $b$ and $matita_basics_lists_list.nil$ applied to $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $a$ and $b$.\nAssistant:", "label": "postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)", "predict": "postulate mem_single : (A : cic.Univ univs.Type0) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (matita_basics_lists_list.mem A a (matita_basics_lists_list.cons A b (matita_basics_lists_list.nil A)))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) a b)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n \\in N$. Assume that the exponentiation of $2$ and $8$ is less than or equal to $n$. Let $m$ be a natural number. Assume that $3$ is less than or equal to $m$. Assume that the sum of the logarithm of $2$ and $m$ and $2$ is less than or equal to $m$. Then for all natural numbers $x2515$ and $x2516$, $x2515$ is equal to the sum of the product of $x2516$ and the quotient of $x2515$ and $x2516$ and $mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (len : Leq (pow 2 8) n) -> (m : Nat) -> (lt2m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (le_n : Leq (pow 2 8) n) -> (m : Nat) -> (lt_m : Leq 3 m) -> (Hind : Leq (plus (log 2 m) 2) m) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp4. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_875$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, for all elements $x_875$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_875$.\nAssistant:", "label": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875", "predict": "postulate Aop_rect_CProp4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_875 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_875 : Aop A _nil) -> Q_ x_875"}
{"prompt": "Human: Translate the following French statement into Agda.\nGcd_times_SO_to_gcd_SO. Soient $m$ et $n$ et $p$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < p$. Supposons que $1$ est égal au diviseur commun plus grand de $m$ et du produit de $n$ et de $p$. Alors $1$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1", "predict": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (posn : Lt 0 n) -> (posp : Lt 0 p) -> (H : Eq 1 (div (gcd m (times n p)) (gcd m p))) -> Eq 1 (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLeb_false_to_not_le. Pour tous les nombres naturels $n$ et $m$, si contradiction est égal à $leb (n, m)$, alors $n$ n'est pas inférieur ou ágal à $m$.\nAssistant:", "label": "postulate leb_false_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Eq (leb n m) false) -> not (Leq n m)", "predict": "postulate leb_false_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Eq (contradiction (leb n m)) (not (infelible n m))) -> not (infelible n m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Då för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : let m n a b : N"}
{"prompt": "Human: Translate the following French statement into Agda.\nAnd_inv_rect_CProp4. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $cic.prop$. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z359$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.And$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_148$ de $cic.Term$ de $cic.prop$ et de $x1$ et des éléments $x_147$ de $cic.Term$ de $cic.prop$ et de $x2$ et des éléments $_z360$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.And$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_148$ et $x_147$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.conj$ appliqué à $x1$ et $x2$ et $x_148$ et $x_147$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp4 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_148 : cic.Term cic.prop x1) -> (x_147 : cic.Term cic.prop x2) -> (_z360 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_inv_rect_CProp1. Pour tous les éléments $x1$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $Hterm$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$, pour toutes les fonctions $P$ des éléments $_z1356$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.nil$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.nil$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_773$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $x_772$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $x1$ et des fonctions $_x_775$ des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $x_772$ et des éléments $_z1357$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $x1$ et $Hterm$ et $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_lists_list.cons$ appliqué à $x1$ et $x_773$ et $x_772$, $cic.Term$ tient pour $cic.prop", "label": "postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate list_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (P : (_z1356 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.nil x1))) -> cic.Term cic.prop (P (matita_basics_lists_list.nil x1))) -> (_H2 : (x_773 : cic.Term univs.Type0 x1) -> (x_772 : cic.Term univs.Type0 (matita_basics_lists_list.list x1)) -> (_x_775 : (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm x_772)) -> cic.Term cic.prop (P x_772)) -> (_z1357 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list x1)) Hterm (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P (matita_basics_lists_list.cons x1 x_773 x_772))) -> cic.Term cic.prop (P x_773)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nK1. Låt $n, p \\in N$. Anta att $18 \\leq n$ och $p \\leq n$. Anta att $2 n \\div 3 < p$. Då $k (2 n, p)= 0$.\nAssistant:", "label": "postulate k1 : (n : Nat) -> (p : Nat) -> (_ : Leq 18 n) -> (__1 : Leq p n) -> (__2 : Lt (div (times 2 n) 3) p) -> Eq (k (times 2 n) p) 0", "predict": "postulate k1 : let n : Nat, p : Nat -> let (le18 : Leq n p) (le : Lt p n) -> let (lt2np : Lt 2 n) (p : Nat) -> Eq (k (2 n, p)) 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_CProp0. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $_z713$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.O$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.O$. Då för alla funktioner $_H2$ från element $x_414$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $_x_416$ från element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $x_414$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $x_414$ och element $_z714$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $Hterm$ och $matita_arithmetics_nat.S$ applicerat på $x_414$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.S$ applicerat på $x_414$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTrue_to_le_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $m$ och $b$ vara naturliga tal. Då om $b \\leq m$ och $f (m)= true$, så $min (n, b, f)\\leq m$.\nAssistant:", "label": "postulate true_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__1 : Eq (f m) true) -> Leq (min n b f) m", "predict": "postulate true_to_le_min : låt f vara en funktion från naturliga tal till sanningsvärden. låt n och m och b vara naturliga tal. Då om b leq m och f (m) = true, så min (n, b, f) leq m"}
{"prompt": "Human: Translate the following French statement into Agda.\nMem_filter_l. Pour tous les éléments $S$ de $cic.Univ$ de $univs.Type0$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $S$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, pour tous les éléments $x$ de $cic.Term$ de $univs.Type0$ et de $S$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $S$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $x$ et $matita_basics_bool.true$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.mem$ appliqué à $S$ et $x$ et $l$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.mem$ appliqué à $S$ et $x$ et $matita_basics_lists_list.filter$ appliqué à $S$ et $f$ et $l$.\nAssistant:", "label": "postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))", "predict": "postulate mem_filter_l : (S : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 S) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x : cic.Term univs.Type0 S) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list S)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f x) matita_basics_bool.true)) -> (__1 : cic.Term cic.prop (matita_basics_lists_list.mem S x l)) -> cic.Term cic.prop (matita_basics_lists_list.mem S x (matita_basics_lists_list.filter S f l))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNoLabel_34. For all instances $x$ of integers, we can prove that if the sum of the product of $7$ and $x$ and $4$ is even, then the difference of the product of $3$ and $x$ and $11$ is odd.\nAssistant:", "label": "postulate noLabel_34 : (x : Int) -> if (even (plus (times 7 x) 4)) (odd (minus (times 3 x) 11))", "predict": "postulate noLabel_34 : (x : Int) -> if (even (plus (times 7 x) 4)) (odd (minus (times 3 x) 11))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPi_1. Soit $n$ un nombre naturel. Alors pour toutes les fonctions $p$ des nombres naturels à des valeurs booléennes, $1$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $1$.\nAssistant:", "label": "postulate pi_1 : (n : Nat) -> (p : (_ : Nat) -> bool) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> 1)) 1", "predict": "postulate pi_1 : soit n un nombre naturel. Alors pour toutes les fonctions p des nombres naturels à des valeurs booléennes, 1 est égal à bigop n (p i) (Nat 1 times (\\ i : Nat -> p i)) Nat 1 times (\\ i : Nat -> 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp3. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_961$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Dop$ be a function from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$. Let $x_961$ be an", "label": "postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)", "predict": "postulate Dop_rect_CProp3 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_961 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_961)"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_p. Soit $p$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $p$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate p_ord_p : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))", "predict": "postulate p_ord_p : soit p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord p p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S matita_arithmetics_nat.O))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_SO_to_le_B_exp. Låt $n \\in N$. Anta att $1$ är mindre än $n$. Då är $B$ applicerat på produkten av $2$ och $n$ mindre än eller lika med potensen av $2$ och $pred$ applicerat på produkten av $2$ och $n$.\nAssistant:", "label": "postulate lt_SO_to_le_B_exp : (n : Nat) -> (_ : Lt 1 n) -> Leq (B (times 2 n)) (pow 2 (pred (times 2 n)))", "predict": "postulate lt_SO_to_le_B_exp : låt n : N -> anta att 1 < n -> Då är B (produkten av 2 och n) mindre eller lika med potensen av 2 och pred (produkten av 2 och n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_exists. Let $f$ be a function from natural numbers to booleans. Let $t$ and $m$ be natural numbers. Assume that $m$ is less than $t$. Assume that $f$ applied to $m$ is equal to $true$. Let $k, b \\in N$. Then if $b$ is less than or equal to $m$, then for all functions $__3$ from natural numbers $i$ and elements $__3$ of $Leq$ of $b$ and $i$ and elements $__4$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $f$ applied to $i$ and absurdity, if $t$ is equal to the sum of $k$ and $b$, then $min$ applied to $k$ and $b$ and $f$ is equal to $m$.\nAssistant:", "label": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (_ : Lt m t) -> (__1 : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (__2 : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m", "predict": "postulate min_exists : (f : (_ : Nat) -> bool) -> (t : Nat) -> (m : Nat) -> (ltm : Lt m t) -> (f_m : Eq (f m) true) -> (k : Nat) -> (b : Nat) -> (_ : Leq b m) -> (__3 : (i : Nat) -> (__3 : Leq b i) -> (__4 : Lt i m) -> Eq (f i) false) -> (__4 : Eq t (plus k b)) -> Eq (min k b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_rect_Type3_body. Let $Q_$ be a function from elements $_x_46$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $univs.Type3$. Let $_H_I$ be an element of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $matita_basics_logic.I$. Let $x_46$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_46$.\nAssistant:", "label": "postulate True_rect_Type3_body : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)", "predict": "postulate True_rect_Type3_body : (Q_ : (_x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ univs.Type3) -> (_H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I)) -> (x_46 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term univs.Type3 (Q_ x_46)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b, m \\in N$. Då för alla element $__$ av $min_spec$ av $n$ och $b$ och $f$ och $m$, $min (n, b, f)= m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m", "predict": "postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> min (n, b, f) = m"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Soit $_H_not_found_max_spec$ une fonction des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$. Soit $x_971 \\in N$. Soit $x_972$ un élément de $max_spec$ de $_n$ et de $_f$ et de $x_971$. Alors $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> (_ : Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq _f i) -> (Q_ 0 (not_found_max_spec _n _f x_976)) -> x_971 -> x_972) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $g1$ and $g2$ be functions from natural numbers to natural numbers. Let $n1 \\in N$. Let $Hind$ be a function from functions from natural numbers $i$ and elements of $Lt$ of $i$ and $n1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$ and functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n1$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$ to elements of $Leq$ of $bigop$ applied to $n1$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ and $bigop$ applied to $n1$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$. Let $H1$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$. Let $H2$ be a function from natural numbers $i$ and elements of $Lt$ of $i$ and $n1 + 1$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$. Assume that $p2 (n1)= true$. Assume that $p1 (n1)= true$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> (bigop : (n1 : Nat) -> (_ : (i : Nat) -> p1 i) -> Nat 0 plus (\\ i : Nat -> g1 i)) -> (H1 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Eq p2 i) -> (H2 : (i : Nat) -> (_ : Lt i n1 + 1) -> (__1 : Eq p1 i) -> Leq g1 i) -> (p2 : (n1 : Nat) -> true) -> (p1 : (n1 : Nat) -> true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_times. Soient $n1$ et $n2$ et $m1$ et $m2$ des nombres naturels. Supposons que $n1 \\leq n2$. Supposons que $m1 \\leq m2$. Alors $n1 m1 \\leq n2 m2$.\nAssistant:", "label": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (times n1 m1) (times n2 m2)", "predict": "postulate le_times : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (Hn1 : Leq n1 n2) -> (Hm1 : Leq m1 m2) -> Leq n1 m1 n2 m2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_Type2. Låt $Hterm \\in N$. Låt $P$ vara en funktion från naturliga tal $_z671$ till element av $Type2$. Då för alla funktioner $_H1$ från element $_z672$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$, för alla funktioner $_H2$ från naturliga tal $x_382$ och funktioner $_x_384$ från element $_z672$ av $Eq$ av $Hterm$ och $x_382$ till element av $P$ av $x_382$ och element $_z672$ av $Eq$ av $Hterm$ och summan av $x_382$ och $1$ till element av $P$ av summan av $x_382$ och $1$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type2 : låt Hterm : N. låt P : (_z671 : Nat) -> Type2. då för alla funktioner _H1 : (_z672 : Eq Hterm 0) -> P 0, för alla funktioner _H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEqb_elim. Soient $n$ et $m$ des nombres naturels. Alors pour toutes les fonctions $P$ des valeurs booléennes à des propositions, pour toutes les fonctions $__$ des éléments de $Eq$ de $n$ et de $m$ à des éléments de $P$ de $true$, pour toutes les fonctions $__1$ des éléments $__1$ de $not$ de $Eq (n, m)$ à des éléments de $P$ de contradiction, $P$ tient pour $eqb (n, m)$.\nAssistant:", "label": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)", "predict": "postulate eqb_elim : (n : Nat) -> (m : Nat) -> (P : (_ : bool) -> Prop) -> (_ : (_ : Eq n m) -> P true) -> (__1 : (__1 : not (Eq n m)) -> P false) -> P (eqb n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_transpose. For all natural numbers $n$ and $i$ and $j$, if $i$ is less than or equal to $n$, then if $j$ is less than or equal to $n$, then $bijn$ holds for $transpose$ applied to $i$ and $j$ and $n$.\nAssistant:", "label": "postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n", "predict": "postulate bijn_transpose : (n : Nat) -> (i : Nat) -> (j : Nat) -> (_ : Leq i n) -> (__1 : Leq j n) -> bijn (transpose i j) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1648. Låt $n$ och $q$ vara naturliga tal. Anta att $0 < q$. Låt $n1$ vara ett naturligt tal. Anta att summan av produkten av $bigop$ applicerat på summan av $n1$ och $1$ och funktionen som avbildar $m$ som $andb$ applicerat på $leb$ applicerat på $1$ och $m$ och $dividesb$ applicerat på $q$ och $m$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $m$ som $1$ och $q$ och $mod (n1, q)$ är lika med $n1$. Anta att $q$ är delbart med $n1 + 1$ och $n1 + 1 = (n1 \\div q + 1)q$. Anta att $q$ är delbart med $n1 + 1$. Då om $n1 + 1 = (n1 \\div q + 1)q$, så $n1 + 1 = q + q (n1 \\div q)$.\nAssistant:", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : let n : Nat -> let q : Nat -> let n1 : Nat -> let sum : (p : Nat) -> let p : (m : Nat) -> andb (leb 1 m) (dividesb q m) -> Nat 0 plus (\\ m : Nat -> 1) q -> (q : Nat) -> Eq (mod n1 q) n1"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_minus_associative. Soient $x$ et $y$ et $z$ des nombres naturels. Alors si $z \\leq y$, alors $x + (y - z)= x + y - z$.\nAssistant:", "label": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (plus x (minus y z)) (minus (plus x y) z)", "predict": "postulate plus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> Eq (x + (y - z)) (x + y - z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_lop. Pour tous les nombres naturels $n$, si $1 \\leq n$, alors $list_of_primes (n)= cons (Nat, 2, tail (Nat, list_of_primes (n)))$.\nAssistant:", "label": "postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))", "predict": "postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> list_of_primes n -> cons Nat 2 (tail Nat (list_of_primes n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_Type1_body. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$ à des éléments de $cic.Univ$ de $univs.Type1$. Soit $_H_mk_range$ une fonction des fonctions $_enum$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_upto$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des fonctions $_filter$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Term$ de $univs.Type1$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_range$ appliqué à $_A$ et $_enum$ et $_upto$ et $_filter$. Alors pour tous les éléments $x_925$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.range$ appliqué à $_A$, $cic.Term$ tient pour $univs.Type1$ et $Q_$ appliqué à $x_925$.\nAssistant:", "label": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)", "predict": "postulate range_rect_Type1_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A) -> cic.Univ univs.Type1) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type1 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_925 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type1 (Q_ x_925)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_previous_prime7. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $ltml$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_primes.nth_prime$ applied to $n$ and $m$, $cic.Term$ holds for $univs.Type0$ and $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate let_previous_prime7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate let_previous_prime7 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ltml : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_primes.nth_prime n) m)) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nPred_Sn. Let $n$ be a natural number. Then $n$ is equal to $pred$ applied to the sum of $n$ and $1$.\nAssistant:", "label": "postulate pred_Sn : (n : Nat) -> Eq n (pred (plus n 1))", "predict": "postulate pred_Sn : (n : Nat) -> Eq n (pred (plus n 1))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound7. Soit $n, m \\in N$. Supposons que $nth_prime (n)< m$. Alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound7 : soit n m : Nat -> (H : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_Type2. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour toutes les fonctions $Q_$ des éléments $_x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $univs.Type2$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_897$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)", "predict": "postulate ACop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_897 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term univs.Type2 (Q_ x_897)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_ex. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_P$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $case_ex_intro$ från element $x$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__$ av $cic.Term$ av $cic.prop$ och $_P$ applicerat på $x$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $matita_basics_logic.ex_intro$ applicerat på $A$ och $_P$ och $x$ och $__$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $A$ och $_P$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)", "predict": "postulate match_ex : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ return_sort) -> (case_ex_intro : (x : cic.Term univs.Type0 A) -> (__ : cic.Term cic.prop (_P x)) -> cic.Term return_sort (return_type (matita_basics_logic.ex_intro A _P x __))) -> (z : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nTheta_pi_p_theta. Let $m \\in N$. Then the product of $bigop$ applied to the sum of the product of $2$ and $m$ and $2$ and the function that maps $p$ to $andb$ applied to $leb$ applied to the sum of $m$ and $2$ and $p$ and $primeb$ applied to $p$ and $Nat$ and $1$ and $times$ and the function that maps $p$ to $p$ and $theta (m + 1)$ is equal to $theta (2 m + 1)$.\nAssistant:", "label": "postulate theta_pi_p_theta : (m : Nat) -> Eq (theta (plus (times 2 m) 1)) (times (bigop (plus (times 2 m) 2) (\\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\\ p : Nat -> p)) (theta (plus m 1)))", "predict": "postulate theta_pi_p_theta : (m : Nat) -> Eq (times (bigop (plus (times 2 m) 2) (\\ p : Nat -> andb (leb (plus m 2) p) (primeb p)) Nat 1 times (\\ p : Nat -> p)) (theta (m + 1))) (theta (2 m + 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_5. För alla naturliga tal $n$, om summan av absolutbeloppet av skillnaden mellan $n$ och $1$ och absolutbeloppet av summan av $n$ och $1$ är mindre än eller lika med $1$, så är absolutbeloppet av skillnaden mellan potensen av $n$ och $2$ och $1$ mindre än eller lika med $4$.\nAssistant:", "label": "postulate noLabel_5 : (n : Nat) -> if (Leq (plus (abs (minus n 1)) (abs (plus n 1))) 1) (Leq (abs (minus (pow n 2) 1)) 4)", "predict": "postulate noLabel_5 : forall n, (min (abs (minus n 1)) (abs (plus n 1))) -> (Leq (abs (minus (pow n 2) 1)) 4)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_rect_CProp2. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z701$ till påståenden. Låt $_H1$ vara en funktion från element $_z702$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$. Låt $_H2$ vara en funktion från naturliga tal $x_406$ och funktioner $_x_408$ från element $_z702$ av $Eq$ av $Hterm$ och $x_406$ till element av $P$ av $x_406$ och element $_z702$ av $Eq$ av $Hterm$ och summan av $x_406$ och $1$ till element av $P$ av summan av $x_406$ och $1$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp2 : (Hterm : Nat) -> (P : (_z701 : Nat) -> Prop) -> (_H1 : (_z702 : Eq Hterm 0) -> P 0) -> (_H2 : (x_406 : Nat) -> (_x_408 : (_z702 : Eq Hterm x_406) -> P x_406) -> (_z702 : Eq Hterm (plus x_406 1)) -> P (plus x_406 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp2 : låt Hterm vara ett naturligt tal. låt P vara en funktion från naturliga tal _z701 till påståenden. låt _H1 vara en funktion från element _z702 av Eq Hterm 0 till element av P 0. låt _H2 vara en funktion från naturliga tal x_406 och funktioner _x_408 från element _z702 av Eq Hterm x_406 till element av P x_406 och element _z702 av Eq Hterm (plus x_406 1) till element av P (plus x_406 1). då håller P Hterm."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExp_pi. Låt $n, m \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Då är potensen av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $m$ lika med $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $Nat$ och $1$ och $times$ och funktionen som avbildar $i$ som potensen av $f$ applicerat på $i$ och $m$.\nAssistant:", "label": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> bool) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m)) (pow (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) m)", "predict": "postulate exp_pi : (n : Nat) -> (m : Nat) -> (p : (_ : Nat) -> Prop) -> (f : (_ : Nat) -> Nat) -> Eq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> f i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> pow (f i) m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_rect_Type3. Let $A$ be an element of $cic.Univ$ of $univs.Type2$. Let $_x$ be an element of $cic.Term$ of $univs.Type2$ and $A$. Let $Q_$ be a function from elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$ and elements $_x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$ to elements of $cic.Univ$ of $univs.Type3$. Then for all elements $_H_refl$ of $cic.Term$ of $univs.Type3$ and $Q_$ applied to $_x$ and $matita_basics_logic.refl$ applied to $A$ and $_x$, for all elements $x_10$ of $cic.Term$ of $univs.Type2$ and $A$, for all elements $x_11$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $A$ and $_x$ and $x_10$, $cic.Term$ holds for $univs.Type3$ and $Q_$ applied to $x_10$ and $x_11$.\nAssistant:", "label": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)", "predict": "postulate eq_rect_Type3 : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_10 : cic.Term univs.Type2 A) -> (_x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Univ univs.Type3) -> (_H_refl : cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x))) -> (x_10 : cic.Term univs.Type2 A) -> (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10)) -> cic.Term univs.Type3 (Q_ x_10 x_11)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n \\in N$. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Soit $_H_not_found_max_spec$ une fonction des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$. Soit $x_971$ un nombre naturel. Alors pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> (_ : Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (_ : Nat) -> (i : Nat) -> (_ : Lt i _n) -> Eq _f i) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1551. För alla naturliga tal $m$ och $n$, om $0$ är lika med $n$, så för alla naturliga tal $x347$, är $n$ lika med produkten av $x347$ och $n$.\nAssistant:", "label": "postulate let_clause_1551 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x347 : Nat) -> Eq n (times x347 n)", "predict": "postulate let_clause_1551 : (m : Nat) -> (n : Nat) -> (eqn0 : Eq 0 n) -> (x347 : Nat) -> Eq n (times x347 n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop_nil. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla element $op$ av $Aop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Leq$ av $n$ och $i$ och element $__2$ av $Lt$ av $i$ och $k$ till element av $or$ av $Eq$ applicerat på $p$ applicerat på $i$ och kontradiktion och $Eq$ applicerat på $f$ applicerat på $i$ och $nil$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ applicerat på $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Lt n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) (contradiction)) (Eq (f i) nil)) -> bigop n (\\ i : Nat -> p i) B nil op (\\ B : Set -> nil) op (\\ i : Nat -> f i) (bigop k (\\ i : Nat -> p i) B nil op (\\ B : Set -> nil)) op (\\ i : Nat -> f i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nSame_bigop. Soit $k \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Soit $op$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$. Soient $f$ et $g$ des fonctions des nombres naturels à des éléments de $B$. Alors pour tous les éléments $__$ de $sameF_upto$ de $k$ et de $bool$ et de $p1$ et de $p2$, pour tous les éléments $__1$ de $sameF_p$ de $k$ et de $p1$ et de $B$ et de $f$ et de $g$, $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$.\nAssistant:", "label": "postulate same_bigop : (k : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\\ i : Nat -> p1 i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p2 i) B nil op (\\ i : Nat -> g i))", "predict": "postulate same_bigop : soit k : Nat -> soit p1 : (_ : Nat) -> soit p2 : (_ : Nat) -> soit B : Set -> soit nil : B -> soit op : (_ : B) -> (__1 : B) -> B -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> (_ : sameF_upto k bool p1 p2) -> (__1 : sameF_p k p1 B f g) -> Eq (bigop k (\\ i : Nat -> p1) B nil op (\\ i : Nat -> f) (\\ i : Nat -> g)) (bigop k (\\ i : Nat -> p2) B nil op (\\ i : Nat -> f) (\\ i : Nat -> g))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExp_to_fact2. Låt $n$ vara ett naturligt tal. Då om $0$ är mindre än $n$, så är produkten av potensen av $2$ och produkten av $2$ och $n$ och potensen av fakulteten av $n$ och $2$ mindre än eller lika med produkten av produkten av $2$ och $n$ och fakulteten av produkten av $2$ och $n$.\nAssistant:", "label": "postulate exp_to_fact2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (times (pow 2 (times 2 n)) (pow (factorial n) 2)) (times (times 2 n) (factorial (times 2 n)))", "predict": "postulate exp_to_fact2 : låt n vara ett naturligt tal. Då om 0 är mindre än n, så är produkten av potensen av 2 och produkten av 2 n och potensen av fakulteten av n och 2 mindre eller lika med produkten av produkten av 2 n och fakulteten av produkten 2 n."}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_max_n. Let $f$ be a function from natural numbers to booleans. Let $n$ be a natural number. Then $max (n, f)\\leq n$.\nAssistant:", "label": "postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n", "predict": "postulate le_max_n : (f : (_ : Nat) -> bool) -> (n : Nat) -> Leq (max n f) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides_false. Låt $l$ vara en lista av naturliga tal. Låt $n \\in N$. Anta att kontradiktion är lika med $list_divides (l, n)$. Låt $p \\in N$. Låt $__1$ vara ett element av $mem$ av $Nat$ och $p$ och $l$. Då är $p$ inte delbart med $n$.\nAssistant:", "label": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)", "predict": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> Eq (contradiction (list_divides (l, n))) (p) -> (__1 : mem Nat p l) -> not (divisible p n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum. Låt $A$ vara en mängd. Låt $_xxx$ vara ett element av $range$ av $A$. Då för alla naturliga tal $_x_942$, $A$.\nAssistant:", "label": "postulate enum : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate låt : (A : Set) -> (lätt : Nat) -> (_xxx : range A) -> (x : Nat) -> A"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_ind. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Då för alla funktioner $Q_$ från element $_x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_ACop$ från element $aop$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_889$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_889$.\nAssistant:", "label": "postulate ACop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)", "predict": "postulate ACop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_889 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_889)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5 < n$. Låt $m \\in N$. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Då om $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : let n : Nat -> let m : Nat -> let a : Nat -> let H : Lt 5 n -> let g : Nat -> let F : Nat -> let x2515 : Nat -> let x2516 : Nat -> let x2517 : Nat -> let H0 : Leq 6 a -> Lt (2 (a + 1)) 2 ^ a -> let x2518 : Nat -> let H1 : Nat -> let F0 : Nat -> let H2 : Nat -> let a0 : Nat -> let H3 : Nat -> let P : Nat -> let q : Nat -> let R : Nat -> let S : Nat -> let T : Nat -> let U : Nat -> let V : Nat -> let W : Nat -> let X : Nat -> let Y : Nat -> let Z : Nat -> let AA : Nat -> let BB : Nat -> let CC : Nat -> let DD : Nat -> let EE : Nat -> let FF : Nat -> let GG : Nat -> let HH : Nat -> let II : Nat -> let III : Nat -> let IV : Nat -> let V0 : Nat -> let W0 : Nat -> let X0 : Nat -> let Y0 : Nat -> let Z0 : Nat -> let AA0 : Nat -> let BB0 : Nat -> let CC0 : Nat -> let DD0 : Nat -> let EE0 : Nat -> let FF0 : Nat -> let GG0 : Nat -> let HH0 : Nat -> let I00 : Nat -> let II0 : Nat -> let III0 : Nat -> let IV0 : Nat -> let V10 : Nat -> let W10 : Nat -> let X10 : Nat -> let Y10 : Nat -> let Z10 : Nat -> let AA10 : Nat -> let BB10 : Nat -> let CC10 : Nat -> let DD10 : Nat -> let EE10 : Nat -> let FF10 : Nat -> let GG10 : Nat -> let HH10 : Nat -> let I100 : Nat -> let II100 : Nat -> let III100 : Nat -> let IV100 : Nat -> let V110 : Nat -> let W110 : Nat -> let X110 : Nat -> let Y110 : Nat -> let Z110 : Nat -> let AA110 : Nat -> let BB110 : Nat -> let CC110 : Nat -> let DD110 : Nat -> let EE110 : Nat -> let FF110 : Nat -> let GG110 : Nat -> let HH110"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp1. Pour tous les nombres naturels $n$ et $m$ et $a$, si $0$ est inférieur à $a$, alors si $n$ est inférieur ou ágal à $m$, alors la puissance de $n$ et de $a$ est inférieure ou ágale à la puissance de $m$ et de $a$.\nAssistant:", "label": "postulate le_exp1 : (n : Nat) -> (m : Nat) -> (a : Nat) -> (_ : Lt 0 a) -> (__1 : Leq n m) -> Leq (pow n a) (pow m a)", "predict": "postulate le_exp1 : tous les nombres naturels n et m et a -> (0 : Nat) -> (inf : Lt 0 a) -> (_ : Leq n m) -> (__1 : Lt a n) -> Leq (pow n a) (pow m a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Supposons que la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $m$ et de $d$ et du produit de $n$ et de $c$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : soit m, n, a, b \\in N"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_exists_to_forall. Let $P$ be a function from natural numbers to propositions. Let $n \\in N$. Assume that it is not the case that $ex$ holds for $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and $P$ applied to $i$. Let $i \\in N$. Then if $i < n$, then it is not the case that $P$ holds for $i$.\nAssistant:", "label": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)", "predict": "postulate not_exists_to_forall : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : not (ex Nat (\\ i : Nat -> and (Lt i n) (P i)))) -> (i : Nat) -> (__1 : Lt i n) -> not (P i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_prim_n3. Soit $n$ un nombre naturel. Supposons que $15$ est inférieur ou ágal à $n$. Alors $prim$ appliqué à $n$ est inférieur ou ágal à $pred$ appliqué à le quotient de $n$ et de $2$.\nAssistant:", "label": "postulate le_prim_n3 : (n : Nat) -> (_ : Leq 15 n) -> Leq (prim n) (pred (div n 2))", "predict": "postulate le_prim_n3 : soit n un nombre naturel. supposons que 15 est inférieur ou ágal à n. alors prim (n) est inférieur ou ágal à pred (div n 2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$. Då för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (auto : Eq c n - d m) -> (auto' : Eq (minus (times d m) (times c n)) 1) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_n_Sn. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $__$ be an element of $bijn$ of $f$ and $n$. Then if $f (n + 1)= n + 1$, then $bijn$ holds for $f$ and $n + 1$.\nAssistant:", "label": "postulate bijn_n_Sn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f (plus n 1)", "predict": "postulate bijn_n_Sn : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n) -> (__1 : f n + 1) -> bijn f n + 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Då för alla funktioner $P$ från element $_z1536$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H1$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univs.Type", "label": "postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1536 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1537 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_times. Soient $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.div$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $b$ et $b$ et $a$.\nAssistant:", "label": "postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)", "predict": "postulate div_times : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.div (matita_arithmetics_nat.times a b) b) a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1258. Låt $b \\in N$. Anta att $1 < b$. Låt $n$ vara ett naturligt tal. Anta att $b ^ n b = 1$. Då $b (b ^ n)= 1$.\nAssistant:", "label": "postulate let_clause_1258 : (b : Nat) -> (lt1b : Lt 1 b) -> (n : Nat) -> (H : Eq (times (pow b n) b) 1) -> Eq (times b (pow b n)) 1", "predict": "postulate let_clause_1258 : let (b : Nat) -> anta (Lt 1 b) (latt (Nat) (pow b 1)) (dagar (Nat) (and (Eq b 1) (Eq (b ^ n) b)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_range. Let $_A$ be a set. Let $return_sort$ be an element of $Sort$. Then for all functions $return_type$ from elements $z$ of $range$ of $_A$ to elements of $return_sort$, for all functions $case_mk_range$ from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $return_type$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $z$ of $range$ of $_A$, $return_type$ holds for $z$.\nAssistant:", "label": "postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z", "predict": "postulate match_range : (_A : Set) -> (return_sort : Sort) -> (return_type : (z : range _A) -> return_sort) -> (case_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> return_type (mk_range _A _enum _upto _filter)) -> (z : range _A) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type0. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1068$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type0$. Låt $_H1$ vara en funktion från element $_z1069$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$. Låt $_H2$ vara en funktion från element $x_611$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1069$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_611$ till element av $cic.Term$ av $univs.Type0$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_611$. Då håller $cic.Term$ för $univs.Type0$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate option_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1068 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type0) -> (_H1 : (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type0 (P (matita_basics_types.None x1))) -> (_H2 : (x_611 : cic.Term univs.Type0 x1) -> (_z1069 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P (matita_basics_types.Some x1 x_611))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type3. For all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $P$ from elements $_z665$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $univs.Type3$, for all functions $_H1$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.O$, for all functions $_H2$ from elements $x_378$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_380$ from elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $x_378$ and elements $_z666$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_378$ to elements of $cic.Term$ of $univs.Type3$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_378$, $cic.Term$ holds for $univs.Type3$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> (_H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378)) -> cic.Term univs.Type3 (P x_378)) -> (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate nat_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z665 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ univs.Type3) -> (_H1 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term univs.Type3 (P matita_arithmetics_nat.O)) -> (_H2 : (x_378 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_380 : (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_378)) -> cic.Term univs.Type3 (P x_378)) -> (_z666 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P (matita_arithmetics_nat.S x_378))) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_i_j_j_i. Låt $i$ och $j$ och $n$ vara naturliga tal. Då $transpose (i, j, n)= transpose (j, i, n)$.\nAssistant:", "label": "postulate transpose_i_j_j_i : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j n) (transpose j i n)", "predict": "postulate transpose_i_j_j_i : let i : Nat -> let j : Nat -> let n : Nat -> let transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> let transpose (i, j, n) -> transpose (j, i, n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_ord_sigma_p. Soit $n, m, x \\in N$. Supposons que $0 < n$. Alors si $x$ est premier, alors si $x ^ m \\leq n$, alors si $n < x ^ (m + 1)$, alors $bigop$ appliqué à $m$ et la fonction qui envoie $i$ à $dividesb$ appliqué à la puissance de $x$ et de la somme de $i$ et de $1$ et $n$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $1$ est égal à $ord (n, x)$.\nAssistant:", "label": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate eq_ord_sigma_p : soit n, m, x : Nat -> (posn : Lt 0 n) -> (x' : Nat) -> (posm : Leq x m) -> (n' : Lt n x) -> Eq (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1)) (ord n x)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_n_Sm_elim. För alla naturliga tal $n$ och $m$, om $n \\leq m + 1$, så för alla påståenden $P$, för alla funktioner $__1$ från element $__1$ av $Leq$ av $n + 1$ och $m + 1$ till element av $P$, för alla funktioner $__2$ från element $__2$ av $Eq$ av $n$ och $m + 1$ till element av $P$, $P$.\nAssistant:", "label": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (_ : Leq n (plus m 1)) -> (P : Prop) -> (__1 : (__1 : Leq (plus n 1) (plus m 1)) -> P) -> (__2 : (__2 : Eq n (plus m 1)) -> P) -> P", "predict": "postulate le_n_Sm_elim : (n : Nat) -> (m : Nat) -> (P : Prop) -> (_ : Leq n m + 1) -> (P' : Prop) -> (__1 : (__1 : Leq n + 1) -> M : P) -> (__2 : (__2 : Eq n m + 1) -> P) -> P"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16921. Soit $m$ un nombre naturel. Supposons que $0$ est inférieur à $m$. Alors pour tous les nombres naturels $a$ et $x358$ et $x359$, $aop__o__op$ appliqué à $Nat$ et $0$ et $plusAC$ et $x358$ et le produit de $x358$ et de $x359$ est égal au produit de $x358$ et de la somme de $x359$ et de $1$.\nAssistant:", "label": "postulate let_clause_16921 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))", "predict": "postulate let_clause_16921 : soit m un nombre naturel. supposons que 0 est inférieur a m. alors pour tous les nombres naturels a et x358 et x359, aop__o__op nat 0 plusAC x358 (times x358 x359) = times x358 (plus x359 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nPi_p_primeb4. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $p$ to $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_log.log$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and the function that maps $i$ to $matita_basics_bool.true$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $i$ to $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_div_and_mod.div$ applied to $n$ and $matita_arithmetics_exp.exp$ applied to $p$ and $matita_arithmetics_nat.S$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $mat", "label": "postulate pi_p_primeb4 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S n) (\\ p : cic.Term univs", "predict": "postulate pi_p_primeb4 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.bigop (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_exp.exp p (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_div_and_mod.div n (matita_arithmetics_exp.exp p (matita_arithmetics_nat.S i))))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_primes.primeb p) matita_arithmetics_nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_fact_to_divides. Soit $p, n \\in N$. Supposons que $p$ est premier. Alors si $p$ est divisible par $n!$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $m$ à la conjonction de la conjonction de $Lt$ appliqué à $0$ et $m$ et de $Leq$ appliqué à $m$ et $n$ et de $divisible$ appliqué à $p$ et $m$.\nAssistant:", "label": "postulate divides_fact_to_divides : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> ex Nat (\\ m : Nat -> and (and (Lt 0 m) (Leq m n)) (divisible p m))", "predict": "postulate divides_fact_to_divides : soit p, n : Nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1063. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $n \\in N$. Soit $permf$ un élément de $permut$ de $f$ et de $n$. Soient $i$ et $j$ des nombres naturels. Supposons que $i \\leq n$. Supposons que $j \\leq n$. Soit $a$ un nombre naturel. Supposons que $a \\leq n$ et $f (a)= i$. Supposons que $a \\leq n$. Supposons que $f (a)= i$. Soit $b$ un nombre naturel. Alors si $b \\leq n$ et $f (b)= j$, alors si $b \\leq n$, alors si $f (b)= j$, alors pour toutes les fonctions $__$ des nombres naturels $i0$ et des éléments de $Leq$ de $i0$ et de $n$ à des éléments de $Leq$ de $f (i0)$ et de $n$, pour tous les éléments $injf$ de $injn$ de $f$ et de $n$, si $a = b$, alors $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq i n) -> (H0 : Leq j n) -> (H1 : Leq a n) -> (H2 : Leq b n) -> (H3 : Leq b n) -> (H4 : Leq (f b) j) -> (H5 : Leq b n) -> (H6 : Leq (f b) j) -> (H7 : (__ : Nat) -> (_ : Leq i0 n) -> (_ : Leq f (i0)) -> n) -> (injf : injn f n) -> (H8 : Eq a b) -> f a"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_CProp2. Pour tous les ensembles $x1$, pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $ACop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1614$ de $ACop$ de $x1$ et de $x2$ à des propositions, pour toutes les fonctions $_H1$ des éléments $aop$ de $Aop$ de $x1$ et de $x2$ et des fonctions $_comm$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ à des éléments de $Eq$ de $op (x1, x2, aop, a, b)$ et de $op (x1, x2, aop, b, a)$ et des éléments $_z1615$ de $Eq$ de $Hterm$ et de $mk_ACop (x1, x2, aop, _comm)$ à des éléments de $P$ de $mk_ACop (x1, x2, aop, _comm)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_CProp2 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1614 : ACop x1 x2) -> Prop) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1615 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Alors si $0 < n$ et $0 < m$, alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) 1) (d m)) (Eq (minus (times d m) (times c n)) 1)) -> Eq m d - n c"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_CProp0. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $P$ be a function from elements $_z713$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$. Let $_H1$ be a function from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.O$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$. Then for all functions $_H2$ from elements $x_414$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_x_416$ from elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $x_414$ and elements $_z714$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $Hterm$ and $matita_arithmetics_nat.S$ applied to $x_414$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.S$ applied to $x_414$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (_z713 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm matita_arithmetics_nat.O)) -> cic.Term cic.prop (P matita_arithmetics_nat.O)) -> (_H2 : (x_414 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_416 : (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm x_414)) -> cic.Term cic.prop (P x_414)) -> (_z714 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) Hterm (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P (matita_arithmetics_nat.S x_414))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDPair_inv_ind. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1104$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $dpi1$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_dpi2$ de $cic.Term$ de $univs.Type0$ et de $x2$ appliqué à $dpi1$ et des éléments $_z1105$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.DPair$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.mk_DPair$ appliqué à $x1$ et $x2$ et $dpi1$ et $_dpi2$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate DPair_inv_ind : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate DPair_inv_ind : soit x1 un élément de cic.Univ univs.Type0. soit x2 une fonction des elements __ de cic.Term univs.Type0 x1 à des elements cic.Univ univs.Type0. soit Hterm un élément cic.Term univs.Type0 (matita_basics_types.DPair x1 x2). soit P une fonction (_z1104 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ cic.prop. soit (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1105 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nOr_introl. For all elements $A$ and $B$ of $cic.Univ$ of $cic.prop$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.Or$ applied to $A$ and $B$.\nAssistant:", "label": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)", "predict": "postulate or_introl : (A : cic.Univ cic.prop) -> (B : cic.Univ cic.prop) -> (__ : cic.Term cic.prop A) -> cic.Term cic.prop (matita_basics_logic.Or A B)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1062. Låt $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ vara naturliga tal. Låt $_clearme$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$. Anta att $r < b$. Anta att $a = q b + r$. Låt $_clearme0$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$. Anta att $r1 < b$. Då om $a = q1 b + r1$, så om $q$ inte är mindre än eller lika med $q1$, så $a = r1 + b q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : naturala tal."}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_inv_ind. Let $x1$ and $x2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all functions $x3$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $x4$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $_Hterm$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_minimization.min_spec$ applied to $x1$ and $x2$ and $x3$ and $x4$, for all functions $P$ from elements $_z1890$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $_x_1080$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $m$ and elements $_x_1079$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.plus$ applied to $x1$ and $x2$ and elements $_x_1078$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to $m$ and $matita_basics_bool.true$ and functions $_x_1077$ from elements $i$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $x2$ and $i$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $x3$ applied to", "label": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univ", "predict": "postulate min_spec_inv_ind : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_Hterm : cic.Term cic.prop (matita_arithmetics_minimization.min_spec x1 x2 x3 x4)) -> (P : (_z1890 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_1080 : cic.Term cic.prop (matita_arithmetics_nat.le x2 m)) -> (_x_1079 : cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.plus x1 x2))) -> (_x_1078 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true)) -> (_x_1077 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le x2 i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) (matita_basics_bool.andb (matita_basics_bool.or (matita_basics_bool.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (x3 m) matita_basics_bool.true) (matita_basics_bool.notb (matita_b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCongruent_ab_lt. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Då håller $ex$ för $Nat$ och funktionen som avbildar $x$ som konjunktionen av konjunktionen av $congruent$ applicerat på $x$ och $a$ och $m$ och $congruent$ applicerat på $x$ och $b$ och $n$ och $Lt$ applicerat på $x$ och produkten av $m$ och $n$.\nAssistant:", "label": "postulate congruent_ab_lt : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd n m) 1) -> ex Nat (\\ x : Nat -> and (and (congruent x a m) (congruent x b n)) (Lt x (times m n)))", "predict": "postulate congruent_ab_lt : let m : Nat, n : Nat, a : Nat, b : Nat -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16003. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16003 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16003 : let m n a b : Nat -> let n m a b : Nat -> let a b : Nat -> let c : Nat -> let _clearme : ex Nat (\\ d : Nat -> if (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> let d : Nat -> let c : Nat -> let _clearme0 : ex Nat (\\ e : Nat -> if (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> let e : Nat -> let f : Nat -> let g : Nat -> let h : Nat -> let i : Nat -> let j : Nat -> let k : Nat -> let l : Nat -> let m : Nat -> let n : Nat -> let o : Nat -> let p : Nat -> let q : Nat -> let r : Nat -> let s : Nat -> let t : Nat -> let u : Nat -> let v : Nat -> let w : Nat -> let x : Nat -> let y : Nat -> let z : Nat -> let aa : Nat -> let ab : Nat -> let ac : Nat -> let ad : Nat -> let ae : Nat -> let af : Nat -> let ag : Nat -> let ah : Nat -> let ai : Nat -> let aj : Nat -> let ak : Nat -> let al : Nat -> let am : Nat -> let an : Nat -> let ap : Nat -> let a0 : Nat -> let b0 : Nat -> let c0 : Nat -> let d0 : Nat -> let e0 : Nat -> let f0 : Nat -> let g0 : Nat -> let h0 : Nat -> let i0 : Nat -> let j0 : Nat -> let k0 : Nat -> let l0 : Nat -> let m0 : Nat -> let n0 : Nat -> let o0 : Nat -> let p0 : Nat -> let q0 : Nat -> let r0 : Nat -> let s0 : Nat -> let t0 : Nat -> let u0 : Nat -> let v0 : Nat -> let w0 : Nat -> let x0 : Nat -> let y0 : Nat -> let"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSum_rect_CProp0_body. Låt $_A$ och $_B$ vara element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $Q_$ från element $_x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_inl$ från element $x_582$ av $cic.Term$ av $univs.Type0$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inl$ applicerat på $_A$ och $_B$ och $x_582$, för alla funktioner $_H_inr$ från element $x_583$ av $cic.Term$ av $univs.Type0$ och $_B$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.inr$ applicerat på $_A$ och $_B$ och $x_583$, för alla element $x_581$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sum$ applicerat på $_A$ och $_B$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$. Anta att $b m - a p = 1$. Då är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (pnm : Eq 1 (gcd p m)) -> (pnm0 : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> disjunk (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\\ _ : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H : Eq (gcd p m) (a p - b m)) -> (H0 : Eq (gcd p m) (b m - a p)) -> (H1 : Eq (gcd p m) (b m - a p)) -> Eq (times b a) (gcd p m)) -> Eq (times b a) (gcd p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nMod_times_mod. Let $n, m, p \\in N$. Then if $0 < p$, then if $0 < m$, then $mod (n, p)= mod (mod (n, m p), p)$.\nAssistant:", "label": "postulate mod_times_mod : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> Eq (mod n p) (mod (mod n (times m p)) p)", "predict": "postulate mod_times_mod : (n : Nat) -> (m : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : Lt 0 m) -> mod (n p) (mod (mod n m p) p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Hind$ des éléments $p$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $p$ et $m$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_chebyshev_chebyshev_psi.Psi$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.pred$ appliqué à $p$ et $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $p$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univ", "label": "postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univ", "predict": "postulate let_clause_10336 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hind : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) p) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) m (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a)))) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_chebyshev_chebyshev_psi.Psi p) (matita_arithmetics_nat.times (matita_arithmetics_nat.pred p) (matita_arithmetics_exp.exp (matita_arith"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_Sfalse. Let $k$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $B$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $p$ applied to $k$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $matita_arithmetics_bigops.bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_Sfalse : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p k) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S k) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSig_rect_Type0. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $Q_$ une fonction des éléments $_x_676$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$ à des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $_H_mk_Sig$ des éléments $pi1$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $_pi2$ de $cic.Term$ de $cic.prop$ et de $_f$ appliqué à $pi1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $Q_$ appliqué à $matita_basics_types.mk_Sig$ appliqué à $A$ et $_f$ et $pi1$ et $_pi2$, pour tous les éléments $x_676$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sig$ appliqué à $A$ et $_f$, $cic.Term$ tient pour $univs.Type0$ et $Q_$ appliqué à $x_676$.\nAssistant:", "label": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)", "predict": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f x_676 _pi2)) (Q_ _pi1 (matita_basics_types.mk_Sig A _f x_676 _pi2))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n \\in N$. Anta att $5 < n$. Låt $m$ vara ett naturligt tal. Anta att $6 \\leq m$ och $(m + 1)^ 2 \\leq 2 ^ m$. Låt $a$ vara ett naturligt tal. Anta att $6 \\leq a$ och $2 (a + 1)+ 1 \\leq 2 ^ a$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (antata : Lt 5 n) -> (m : Nat) -> (lemm : Leq 6 m) -> (H : Nat) -> (a : Nat) -> (lema : Leq 6 a) -> (H0 : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) (mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTranspose_transpose. För alla naturliga tal $i$ och $j$ och $n$, $transpose (i, j, transpose (i, j, n))= n$.\nAssistant:", "label": "postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j (transpose i j n)) n", "predict": "postulate transpose_transpose : (i : Nat) -> (j : Nat) -> (n : Nat) -> Eq (transpose i j (transpose i j n)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_distr. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $B$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $R$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $B$ och $nil$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $B$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $B$ och $matita_arithmetics_bigops.let_mop$ applicerat på $n$ och $p$ och $B$ och $nil$ och $R$ och $f$ och $a$ och $a$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $matita_arithmetics_bigops.let_aop$ applicerat på $n$ och $p$ och $B$ och $nil$ och $R$ och $f$ och $a$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $matita_arithmetics_bigops.bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $B$ och $nil$ och $matita_arithmetics_bigops", "label": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i))) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil (matita_arithmetics_bigops.aop__o__op B nil (matita_arithmetics_bigops.let_aop n p B nil R f a)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_bigops.let_mop n p B nil R f a a (f i))))", "predict": "postulate bigop_distr : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (a : cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.let_mop n p B nil R f a) a (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (R"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_Type5. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_865$ de $Aop$ de $A$ et de $_nil$ à des éléments de $Type5$. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (_nil, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op (a, _nil)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ à des éléments de $Q_$ de $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, pour tous les éléments $x_865$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_865$.\nAssistant:", "label": "postulate Aop_rect_Type5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_865 : Aop A _nil) -> Type5) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865", "predict": "postulate Soit : Aunenom : EnsemeleApostulate _nil : UnelmaApostulate Q_ : (_x_865 : Aop A _nil) -> Type5 -> All (_H_mk_Aop (op _ : (_ : A) -> (__1 : A) -> A) (_nill : (a : A) -> Eq (op _ a) a) (_nilr : (a : A) -> Eq (op a _nil) a) (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_865 : Aop A _nil) -> Q_ x_865"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNull_body. Låt $A$ vara en mängd. Då för alla element $nil$ av $A$, för alla element $xxx$ av $Dop$ av $A$ och $nil$, för alla element $a$ av $A$, $prod (A, nil, xxx, a, nil)= nil$.\nAssistant:", "label": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> Eq (prod A nil xxx a nil) nil", "predict": "postulate null_body : (A : Set) -> (nil : A) -> (xxx : Dop A nil) -> (a : A) -> prod A nil xxx a nil"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Låt $b$ vara ett naturligt tal. Anta att $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$. Anta att $b$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $b$ är lika med $j$. Då för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (i0 : Nat) -> (Leq i0 n) -> (a : Nat) -> (Ha : Eq a n) -> (f : (_ : Nat) -> Nat) -> (b : Nat) -> (Hb : Eq b n) -> (f' : (_ : Nat) -> Nat) -> (Hind : injn f n) -> (Hind0 : Eq a b) -> Eq (f a) i"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c \\in N$. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Alors pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eqnm : Eq 1 (div (comm p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m) (div (div p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ H : Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) m) (times c n))) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> (\\ H : Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) m) (times c n))) -> (H : Eq c n - d m) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))"}
{"prompt": "Human: Translate the following English statement into Agda.\nUnit_rect_Type2. Let $Q_$ be a function from elements $_x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Then for all elements $_H_it$ of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_basics_types.it$, for all elements $x_503$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_503$.\nAssistant:", "label": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)", "predict": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_CProp0. Låt $x1$ och $x2$ och $x3$ och $x4$ vara naturliga tal. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Låt $P$ vara en funktion från element $_z1494$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till påståenden. Låt $_H1$ vara en funktion från element $x_859$ av $Lt$ av $x4$ och $x2$ och element $x_858$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1495$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_859$ och $x_858$. Då håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_CProp0 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1494 : div_mod_spec x1 x2 x3 x4) -> Prop) -> (_H1 : (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1495 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> (x_859 : Lt x4 x2) -> (x_858 : Eq x1 (plus (times x3 x2) x4)) -> (_z1496 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_858)) -> (x_8590 : Lt x4 x2) -> (x_8580 : Eq x1 (plus (times x3 x2) x4)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_859 x_8580)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type2_body. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_825$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type2$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_827$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_826$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_827$ och $x_826$, för alla element $x_825$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type2$ och $Q_$ applicerat på $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type2) -> (_H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> (x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type2 (Q_ x_825)", "predict": "postulate div_mod_spec_rect_Type2_body : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type2) -> (_H_div_mod_spec_intro : (x_827 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_826 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_827 x_826))) -> (x_825 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type2 (Q_ x_825)"}
{"prompt": "Human: Translate the following French statement into Agda.\nVoid_rect_CProp2_body. Pour toutes les fonctions $Q_$ des éléments $_x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$ à des éléments de $cic.Univ$ de $cic.prop$, pour tous les éléments $x_492$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.void$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_492$.\nAssistant:", "label": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)", "predict": "postulate void_rect_CProp2_body : (Q_ : (_x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Univ cic.prop) -> (x_492 : cic.Term univs.Type0 matita_basics_types.void) -> cic.Term cic.prop (Q_ x_492)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n \\in N$. Anta att $2 ^ 7 \\leq n$. Låt $p \\in N$. Då om $\\sqrt{ (2 n)}+ 1 \\leq p$, så om $p < 2 n + 1$, så om $leb (2, k (2 n, p))= true$, så om $2 n < p ^ 2$, så för alla naturliga tal $x2515$ och $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (len : Leq (pow 2 7) n) -> (p : Nat) -> (lep : Leq (plus (sqrt (times 2 n)) 1) p) -> (ltp : Lt p (plus (times 2 n) 1)) -> (Hc : Eq (leb 2 (k (times 2 n) p)) true) -> (H2n : Lt (times 2 n) (pow p 2)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : let n : Nat in let (2 : Nat) -> let (p : Nat) -> let (l : Lt (sqrt (2 n)) p) -> let (k : Nat -> Nat -> Nat) -> let (H : Lt p 2 n + 1) -> let (leb : Lt (2 n) p) -> let (H0 : Lt p 2 n) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNth_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $H$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $H$, för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $H$, håller $cic.Term$ för $univs.Type0$ och $H$.\nAssistant:", "label": "postulate nth_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Univ univs.Type0) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list H)) -> (__2 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate nth_body : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15621. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 n) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H1 : Eq c n - d m) -> (H2 : Eq (minus (times d m) (times c n)) 1) -> Eq n c - m d"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $__$ and $__1$ be natural numbers. Then $__ ^ __1$ is a natural number.\nAssistant:", "label": "postulate pow : (_ : Nat) -> (__1 : Nat) -> Nat", "predict": "postulate let : (_ : Nat) -> (__1 : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSub_lt. Låt $A$ vara en mängd. Då för alla funktioner $e$ från naturliga tal till element av $A$, för alla funktioner $p$ från naturliga tal till sanningsvärden, för alla naturliga tal $n$ och $m$, om $n$ är mindre än eller lika med $m$, så håller $sub_hk$ för funktionen som avbildar $x$ som $x$ och funktionen som avbildar $x$ som $x$ och $A$ och $mk_range$ applicerat på $A$ och $e$ och $n$ och $p$ och $mk_range$ applicerat på $A$ och $e$ och $m$ och $p$.\nAssistant:", "label": "postulate sub_lt : (A : Set) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> sub_hk (\\ x : Nat -> x) (\\ x : Nat -> x) A (mk_range A e n p) (mk_range A e m p)", "predict": "postulate sub_lt : (A : Mngd) -> (e : (_ : Nat) -> A) -> (p : (_ : Nat) -> Sann) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (H : sub_hk (x : Mngd) (\\ x : Mngd -> x) (\\ x : Mngd -> x) A (mk_range A e n p) (mk_range A e m p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nTrue_to_le_max. Let $f$ be a function from natural numbers to booleans. Let $n$ and $m$ be natural numbers. Assume that $m < n$ and $f (m)= true$. Then $m \\leq max (n, f)$.\nAssistant:", "label": "postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> Leq m (max n f)", "predict": "postulate true_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt m n) -> and (f m) true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type2. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_897$ av $ACop$ av $A$ och $_nil$ till element av $Type2$. Låt $_H_mk_ACop$ vara en funktion från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$. Då för alla element $x_897$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_plus. Let $n1$ and $n2$ and $m1$ and $m2$ be natural numbers. Then if $n1$ is less than or equal to $n2$, then if $m1$ is less than or equal to $m2$, then the sum of $n1$ and $m1$ is less than or equal to the sum of $n2$ and $m2$.\nAssistant:", "label": "postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)", "predict": "postulate le_plus : (n1 : Nat) -> (n2 : Nat) -> (m1 : Nat) -> (m2 : Nat) -> (_ : Leq n1 n2) -> (__1 : Leq m1 m2) -> Leq (plus n1 m1) (plus n2 m2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBijn_transpose_l. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $n$ och $i$ och $j$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $i$ och $n$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $j$ och $n$. Låt $__2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på $f$ och $n$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_permutation.bijn$ applicerat på funktionen som avbildar $p$ som $matita_arithmetics_permutation.transpose$ applicerat på $i$ och $j$ och $f$ applicerat på $p$ och $n$.\nAssistant:", "label": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_permutation.transpose i j (f p)) n)", "predict": "postulate bijn_transpose_l : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (j : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le j n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_exp1. Let $p$ and $n$ and $q$ and $r$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.Not$ applied to $matita_arithmetics_primes.divides$ applied to $p$ and $r$. Then for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $p$ and $q$ and $r$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $n$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $q$ and $r$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))", "predict": "postulate p_ord_exp1 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_primes.divides p r))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p q) r))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord n p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat q r))"}
{"prompt": "Human: Translate the following French statement into Agda.\nBijn_Sn_n. Pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, pour tous les nombres naturels $n$, pour tous les éléments $__$ de $bijn$ de $f$ et de $n + 1$, si $f (n + 1)= n + 1$, alors $bijn$ tient pour $f$ et $n$.\nAssistant:", "label": "postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f (plus n 1)) -> (__1 : Eq (f (plus n 1)) (plus n 1)) -> bijn f n", "predict": "postulate bijn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : bijn f n + 1) -> (__1 : f n + 1) -> bijn f n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p, m, n \\in N$. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a$ vara ett naturligt tal. Då för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ant : Lt 0 p) -> (same : Eq (times p m) 1) -> (c : Nat) -> Eq (times m n) (times p c) -> (a : Nat) -> Eq (times m n) (times p c) -> (b : Nat) -> Eq (times m n) (times p c) -> (H : all (_clearme0 : ex Nat (\\ b : Nat -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) Eq (minus (times b m) (times a p)) (stort delar p m))) -> (H0 : all (_clearme1 : ex Nat (\\ b : Nat -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) Eq (minus (times a p) (times b m)) (stort delar p m))) -> (H1 : Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m)))) -> Eq (minus (times a p) (times b m)) (times (stort delar p m) (Eq (minus (times b m) (times a p)) (stort delar p m))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nTimes_Sn_m. Soit $n, m \\in N$. Alors $m + n m = (n + 1)m$.\nAssistant:", "label": "postulate times_Sn_m : (n : Nat) -> (m : Nat) -> Eq (plus m (times n m)) (times (plus n 1) m)", "predict": "postulate times_Sn_m : soit n m : N -> alors m n : N -> m + n m = (n + 1) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nGcd_1_to_lt_O. Soient $i$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $i$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $i$.\nAssistant:", "label": "postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)", "predict": "postulate gcd_1_to_lt_O : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_inv_rect_CProp1. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1686$ de $range$ de $x1$ à des propositions. Soit $_H1$ une fonction des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1687$ de $Eq$ de $Hterm$ et de $mk_range (x1, _enum, _upto, _filter)$ à des éléments de $P$ de $mk_range (x1, _enum, _upto, _filter)$. Alors $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_CProp1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1686 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1687 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_CProp1 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1686 : range x1) -> Prop) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1687 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nBool_rect_CProp4_body. Let $Q_$ be a function from elements $_x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_true$ be an element of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.true$. Then for all elements $_H_false$ of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_bool.false$, for all elements $x_347$ of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_347$.\nAssistant:", "label": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)", "predict": "postulate bool_rect_CProp4_body : (Q_ : (_x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H_true : cic.Term cic.prop (Q_ matita_basics_bool.true)) -> (_H_false : cic.Term cic.prop (Q_ matita_basics_bool.false)) -> (x_347 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term cic.prop (Q_ x_347)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_S_to_permut. Soit $f$ une fonction des nombres naturels à des nombres naturels. Soit $m$ un nombre naturel. Soit $__$ un élément de $permut$ de $f$ et de la somme de $m$ et de $1$. Supposons que $f$ appliqué à la somme de $m$ et de $1$ est égal à la somme de $m$ et de $1$. Alors $permut$ tient pour $f$ et $m$.\nAssistant:", "label": "postulate permut_S_to_permut : (f : (_ : Nat) -> Nat) -> (m : Nat) -> (_ : permut f (plus m 1)) -> (__1 : Eq (f (plus m 1)) (plus m 1)) -> permut f m", "predict": "postulate permut_S_to_permut : soit f : (_ : Nat) -> Nat -> (m : Nat) -> (_ : permut f (plus m 1)) -> (H : Eq (f (plus m 1)) (plus m 1)) -> permut f m"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_a. Let $a$ and $b$ be natural numbers. Then for all sets $B$, for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a \\leq b$, then $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to the successor of $i0$ applied to the sum of $i$ and $a$ and $f$ applied to $a$ is equal to $bigop$ applied to the difference of the sum of $b$ and $1$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $true$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nAssistant:", "label": "postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (bigop (minus (plus b 1) a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f (succ i0)) (plus i a))) (f a))", "predict": "postulate bigop_a : (a : Nat) -> (b : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> Eq (op B nil op (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil op (\\ i : Nat -> (\\ i0 : Nat -> f (succ i0)) (plus i a))) (f a)) (bigop (minus (plus b 1) a) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i a)) B nil op (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp5. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_905$ of $ACop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_ACop$ from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$, for all elements $x_905$ of $ACop$ of $A$ and $_nil$, $Q_$ holds for $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1600. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Then if $0 < n$ and $0 < m$, then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then $n c - m d$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_1600 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> Eq n c - m d"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_div. Soient $n$ et $d$ des nombres naturels. Supposons que $0 < n$. Alors si $d$ est divisible par $n$, alors $n \\div (n \\div d)= d$.\nAssistant:", "label": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d", "predict": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div (div n d) d) d"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_gen. Soit $P$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ une fonction des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $i$ et $n$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $i$. Alors $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $n$.\nAssistant:", "label": "postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> cic.Term cic.prop (P n)", "predict": "postulate le_gen : (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P i)) -> (c : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> cic.Term cic.prop (P n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type4. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $Dop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1704$ of $Dop$ of $x1$ and $x2$ to elements of $Type4$. Then for all functions $_H1$ from elements $sum$ of $ACop$ of $x1$ and $x2$ and functions $prod$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_null$ from elements $a$ of $x1$ to elements of $Eq$ of $prod (a, x2)$ and $x2$ and functions $_distr$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $prod (a, aop__o__op (x1, x2, sum, b, c))$ and $aop__o__op (x1, x2, sum, prod (a, b), prod (a, c))$ and elements $_z1705$ of $Eq$ of $Hterm$ and $mk_Dop (x1, x2, sum, prod, _null, _distr)$ to elements of $P$ of $mk_Dop (x1, x2, sum, prod, _null, _distr)$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm", "predict": "postulate Dop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1704 : Dop x1 x2) -> Type4) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1705 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type3. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_867$ av $Aop$ av $A$ och $_nil$ till element av $Type3$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $Q_$ av $mk_Aop$ applicerat på $A$ och $_nil$ och $op$ och $_nill$ och $_nilr$ och $_assoc$. Låt $x_867$ vara ett element av $Aop$ av $A$ och $_nil$. Då håller $Q_$ för $x_867$.\nAssistant:", "label": "postulate Aop_rect_Type3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_867 : Aop A _nil) -> Q_ x_867", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_867 : Aop A _nil) -> Type3) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> Eq (Q_ (\\ a : A -> Eq (op a _nil) a) (\\ a : A -> Eq (op _nil a) a)) (\\ a : A -> Eq (op a _nil) a)) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc) A _nil op _nill _nilr _assoc) -> (x_867 : Aop A _nil) -> Q_ x_867"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_times. Soient $p$ et $a$ et $b$ et $qa$ et $ra$ et $qb$ et $rb$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.prime$ appliqué à $p$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $a$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $b$. Soit $__3$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $a$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $qa$ et $ra$. Soit $__4$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_ord.p_ord$ appliqué à $b$ et $p$ et $matita_basics_types.mk_Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.nat$ et $qb$ et $rb$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Prod$ appliqué à $matita_arithmetics_nat.nat$ et $matita_ar", "label": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics", "predict": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__4 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord a p))) -> (__5 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.nat (matita_arithmetics_ord.p_ord b p))) -> (__6 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__7 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> (__8 : cic.Term cic.prop (matita_basics"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_divides_ord_rem. Soient $m$ et $p$ des nombres naturels. Supposons que $0$ est inférieur à $m$. Supposons que $1$ est inférieur à $p$. Alors $p$ n'est pas divisible par $ord_rem$ appliqué à $m$ et $p$.\nAssistant:", "label": "postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 1 p) -> not (divisible p (ord_rem m p))", "predict": "postulate not_divides_ord_rem : (m : Nat) -> (p : Nat) -> (posp : Lt 0 m) -> (inp : Lt 1 p) -> not (divisible p (ord_rem m p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1648. Soit $n, q \\in N$. Supposons que $0$ est inférieur à $q$. Soit $n1$ un nombre naturel. Supposons que $n1$ est égal à la somme du produit de $bigop$ appliqué à la somme de $n1$ et de $1$ et la fonction qui envoie $m$ à $andb$ appliqué à $leb$ appliqué à $1$ et $m$ et $dividesb$ appliqué à $q$ et $m$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $m$ à $1$ et de $q$ et de $mod$ appliqué à $n1$ et $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$ et la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Supposons que $q$ est divisible par la somme de $n1$ et de $1$. Supposons que la somme de $n1$ et de $1$ est égale au produit de la somme du quotient de $n1$ et de $q$ et de $1$ et de $q$. Alors la somme de $n1$ et de $1$ est égale à la somme de $q$ et du produit de $q$ et du quotient de $n1$ et de $q$.\nAssistant:", "label": "postulate let_clause_1648 : (n : Nat) -> (q : Nat) -> (posq : Lt 0 q) -> (n1 : Nat) -> (Hind : Eq n1 (plus (times (bigop (plus n1 1) (\\ m : Nat -> andb (leb 1 m) (dividesb q m)) Nat 0 plus (\\ m : Nat -> 1)) q) (mod n1 q))) -> (_clearme : and (divisible q (plus n1 1)) (Eq (plus n1 1) (times (plus (div n1 q) 1) q))) -> (divq : divisible q (plus n1 1)) -> (eqn1 : Eq (plus n1 1) (times (plus (div n1 q) 1) q)) -> Eq (plus n1 1) (plus q (times q (div n1 q)))", "predict": "postulate let_clause_1648 : soit n, q : N"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p$ och $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posn$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $gcd1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_gcd.gcd$ applicerat på $p$ och $m$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_primes.divides$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$. Låt $c$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $nm$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.times$ applicerat på $m$ och $n$ och $matita_arithmetics_nat.times$ applicerat på $p$ och $c$, för alla element $a$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.ex$ applicerat på $matita_arithmetics_nat.nat$ och funktionen som avbildar $b$ som $matita_basics_logic.Or$ applicerat på $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $a$ och $p$ och $matita_arithmetics_nat.times$ applicerat på $b$ och $m$ och $matita_arithmetics_gcd.g", "label": "postulate let_clause_16171 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_ar", "predict": "cdpostulate let_clause_16171 : cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> cic.Term univs.Type0 (matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term univs.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term univs.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme1 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term un"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMk_Dop. Låt $A$ vara en mängd. Låt $nil$ vara ett element av $A$. Låt $sum$ vara ett element av $ACop$ av $A$ och $nil$. Då för alla funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$, för alla funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod (a, nil)$ och $nil$, för alla funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod (a, aop__o__op (A, nil, sum, b, c))$ och $aop__o__op (A, nil, sum, prod (a, b), prod (a, c))$, håller $Dop$ för $A$ och $nil$.\nAssistant:", "label": "postulate mk_Dop : (A : Set) -> (nil : A) -> (sum : ACop A nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil", "predict": "postulate Mk_Dop : (A : Mngd) -> (nil : A) -> (sum : ACop A nil) -> (Dop : (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a nil) nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A nil sum b c)) (aop__o__op A nil sum (prod a b) (prod a c))) -> Dop A nil) -> Dop A nil"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMinus_pred_pred. För alla element $n$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $n$ och $matita_arithmetics_nat.pred$ applicerat på $m$ och $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))", "predict": "postulate minus_pred_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.pred n) (matita_arithmetics_nat.pred m)) (matita_arithmetics_nat.minus n m))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLeb_elim. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Låt $__$ vara en funktion från element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$. Då för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))", "predict": "postulate let : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P (matita_basics_bool.true))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P (matita_basics_bool.false))) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_ind. Soit $Q_$ une fonction des nombres naturels $_x_365$ à des propositions. Soit $_H_O$ un élément de $Q_$ de $0$. Alors pour toutes les fonctions $_H_S$ des nombres naturels $x_366$ et des éléments $_x_368$ de $Q_$ de $x_366$ à des éléments de $Q_$ de la somme de $x_366$ et de $1$, pour tous les nombres naturels $x_365$, $Q_$ tient pour $x_365$.\nAssistant:", "label": "postulate nat_ind : (Q_ : (_x_365 : Nat) -> Prop) -> (_H_O : Q_ 0) -> (_H_S : (x_366 : Nat) -> (_x_368 : Q_ x_366) -> Q_ (plus x_366 1)) -> (x_365 : Nat) -> Q_ x_365", "predict": "postulate nat_ind : soit Q_ une fonction des nombres naturels _x_365 à des propositions. Soit _H_O un élément de Q_ de 0. Alors pour toutes les fonctions _H_S des nombres naturels x_366 et des éléments _x_368 de Q_ de x_366 à des éléments de Q_ de la somme de x_366 et 1, pour tous les nombres naturels x_365, Q_ tient pour x_365."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1585. Låt $n, m \\in N$. Anta att $0 < n$ och $m$ är delbart med $n$. Låt $d \\in N$. Då om $0 = m$ och $n = m d$, så $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (d : Nat) -> (auto : Lt 0 n) -> (auto' : Eq 0 m) -> (auto'' : Eq n m) -> let (d : Nat) -> (auto'' : Eq 0 m) -> Eq 0 n"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_0. Let $n$ be a natural number. Let $B$ be a set. Then for all elements $nil$ of $B$, for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $n$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to the sum of $i$ and $1$ and $f$ applied to $0$ is equal to $bigop$ applied to the sum of $n$ and $1$ and the function that maps $i$ to $true$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (bigop (plus n 1) (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f i)) (op B nil op (bigop n (\\ i : Nat -> true) B nil (op B nil op) (\\ i : Nat -> f (plus i 1))) (f 0))", "predict": "postulate bigop_0 : (n : Nat) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> Eq (op B nil op (bigop n (\\ i : Nat -> true) B nil op (\\ i : Nat -> f (plus i 1)) (f 0))) (bigop (plus n 1) (\\ i : Nat -> true) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_Type5. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type5$. Alors pour toutes les fonctions $_H_inl$ des éléments $x_532$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_532$, pour toutes les fonctions $_H_inr$ des éléments $x_533$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type5$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_533$, pour tous les éléments $x_531$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type5$ et $Q_$ appliqué à $x_531$.\nAssistant:", "label": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)", "predict": "postulate Sum_rect_Type5 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ univs.Type5) -> (_H_inl : (x_532 : cic.Term univs.Type0 _A) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inl _A _B x_532))) -> (_H_inr : (x_533 : cic.Term univs.Type0 _B) -> cic.Term univs.Type5 (Q_ (matita_basics_types.inr _A _B x_533))) -> (x_531 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term univs.Type5 (Q_ x_531)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_n_8_to_le_Psi_exp. Låt $n \\in N$. Då om $n \\leq 8$, så $Psi (n)\\leq 2 ^ (2 n - 3)$.\nAssistant:", "label": "postulate le_n_8_to_le_Psi_exp : (n : Nat) -> (_ : Leq n 8) -> Leq (Psi n) (pow 2 (minus (times 2 n) 3))", "predict": "postulate le_n_8_to_le_Psi_exp : låt n : Nat -> då om n <= 8 så Psi n <= 2 ^ (2 n - 3)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp3. Let $A$ be a set. Let $_nil$ be an element of $A$. Then for all functions $Q_$ from elements $_x_879$ of $Aop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_879$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_879$.\nAssistant:", "label": "postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879", "predict": "postulate Aop_rect_CProp3 : (A : Set) -> (_nil : A) -> (Q_ : (_x_879 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_879 : Aop A _nil) -> Q_ x_879"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_divides. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Låt $__1$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nAssistant:", "label": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate list_divides : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_elim1. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $__$ från element $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och funktioner $__$ från element $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $p$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $m$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $n$.\nAssistant:", "label": "postulate nat_elim1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p)) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P n)", "predict": "postulate nat_elim1 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (__ : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (P p) -> cic.Term cic.prop (P m)) -> cic.Term cic.prop (P n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a \\in N$. Assume that $a \\leq n$ and $f (a)= i$. Assume that $a \\leq n$. Assume that $f (a)= i$. Then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (Hind : and (Leq i n) (Leq j n)) -> (b : Nat) -> (Hind0 : and (Leq b n) (f (b))) -> (Hind1 : and (Leq b n) (f (b))) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (Hind2 : Eq a b) -> f a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_Type3. Låt $x1, x2, x3, x4 \\in N$. Låt $Hterm$ vara ett element av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1446$ av $div_mod_spec$ av $x1$ och $x2$ och $x3$ och $x4$ till element av $Type3$, för alla funktioner $_H1$ från element $x_823$ av $Lt$ av $x4$ och $x2$ och element $x_822$ av $Eq$ av $x1$ och summan av produkten av $x3$ och $x2$ och $x4$ och element $_z1447$ av $Eq$ av $Hterm$ och $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$ till element av $P$ av $div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_823$ och $x_822$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_Type3 : (x1 : Nat) -> (x2 : Nat) -> (x3 : Nat) -> (x4 : Nat) -> (Hterm : div_mod_spec x1 x2 x3 x4) -> (P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3) -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm", "predict": "postulate div_mod_spec_inv_rect_Type3 : let x1 : N, x2 : N, x3 : N, x4 : N -> let Hterm : div_mod_spec x1 x2 x3 x4 -> let P : (_z1446 : div_mod_spec x1 x2 x3 x4) -> Type3 -> (_H1 : (x_823 : Lt x4 x2) -> (x_822 : Eq x1 (plus (times x3 x2) x4)) -> (_z1447 : Eq Hterm (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P (div_mod_spec_intro x1 x2 x3 x4 x_823 x_822)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15623. Let $m, n, a, b \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15623 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt n m) -> (posm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (H : Eq (minus (times d m) c) n) -> Eq m d"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_discr. Let $a1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x$ and $y$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $a1$. Let $_e$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $a1$ and $x$ and $y$. Then $cic.Term$ holds for $univs.Type2", "label": "postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\\ t0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ t1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ t2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> matita_arithmetics_bigops.match_range a1 (cic.succ univs.Type2) (\\ __ : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1) -> cic.univ univs.Type2) (\\ u0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ u1 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> \\ u2 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.prod (cic.succ univs.Type1) univs.Type1 (cic.univ univs.Type1) (\\ P : cic.Univ univs.Type1 -> cic.prod univs.Type1 univs.Type1 (cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1)) t0) u0) (\\ e0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1))) (matita_basics_logic.R0 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> a1)) t0) u0) -> cic.prod cic.prop univs.Type1 (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 ((\\ x0 : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 a1) -> \\ p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type", "predict": "postulate range_discr : (a1 : cic.Univ univs.Type0) -> (x : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (y : cic.Term univs.Type0 (matita_arithmetics_bigops.range a1)) -> (_e : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range a1)) x y)) -> cic.Term univs.Type2 (matita_arithmetics_bigops.range a1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1047. Let $k, n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all natural numbers $j$, if $n$ is less than or equal to $j$, then for all functions $Hind$ from functions from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and $j$ to elements of $Eq$ of $p$ applied to $i$ and absurdity to elements of $Eq$ of $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $j$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$, for all functions $Hfalse$ from natural numbers $i$ and elements of $Leq$ of $n$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $j$ and $1$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, for all natural numbers $x2571$ and $x2572$, $x2571$ is equal to the sum of the product of $x2572$ and the quotient of $x2571$ and $x2572$ and $mod$ applied to $x2571$ and $x2572$.\nAssistant:", "label": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))", "predict": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (len : Leq n k) -> (j : Nat) -> (le : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp4. För alla mängder $x1$, för alla element $x2$ av $x1$, för alla element $Hterm$ av $Aop$ av $x1$ och $x2$, för alla funktioner $P$ från element $_z1536$ av $Aop$ av $x1$ och $x2$ till påståenden, för alla funktioner $_H1$ från funktioner $op$ från element av $x1$ och element $__1$ av $x1$ till element av $x1$ och funktioner $_nill$ från element $a$ av $x1$ till element av $Eq$ av $op (x2, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $x1$ till element av $Eq$ av $op (a, x2)$ och $a$ och funktioner $_assoc$ från element $a$ av $x1$ och element $b$ av $x1$ och element $c$ av $x1$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ och element $_z1537$ av $Eq$ av $Hterm$ och $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ till element av $P$ av $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_CProp4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Prop) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_CProp4 : (x1 : Mngd x1) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1536 : Aop x1 x2) -> Påstånd) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (a b) c)) -> (_z1537 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> håller P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (H : Leq i n) -> (j : Nat) -> (a : Nat) -> (H' : Leq a n) -> (f' : (_ : Nat) -> Nat) -> (b : Nat) -> (H'' : Leq b n) -> (H' : f' b = j) -> (H : all (\\ i0 : Nat -> Leq i0 n) (\\ f : (_ : Nat) -> Nat) -> (\\ i : Nat -> Leq f i0) n) -> (\\ injn : injn f n) -> (a : Nat) -> (H : Eq a b) -> f' a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1549. Låt $m$ och $n$ vara naturliga tal. Anta att $0 < n$. Då om $0 = m$, så för alla naturliga tal $x1106$, $x1106 = x1106 - m$.\nAssistant:", "label": "postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (eqm0 : Eq 0 m) -> (x1106 : Nat) -> Eq x1106 (minus x1106 m)", "predict": "postulate let_clause_1549 : (m : Nat) -> (n : Nat) -> let (x1106 : Nat) -> x1106 = x1106 - m"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_ord_sigma_p. Let $n$ and $m$ and $x$ be natural numbers. Assume that $0$ is less than $n$. Assume that $x$ is prime. Assume that the exponentiation of $x$ and $m$ is less than or equal to $n$. Assume that $n$ is less than the exponentiation of $x$ and the sum of $m$ and $1$. Then $ord$ applied to $n$ and $x$ is equal to $bigop$ applied to $m$ and the function that maps $i$ to $dividesb$ applied to the exponentiation of $x$ and the sum of $i$ and $1$ and $n$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $1$.\nAssistant:", "label": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (__1 : prime x) -> (__2 : Leq (pow x m) n) -> (__3 : Lt n (pow x (plus m 1))) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))", "predict": "postulate eq_ord_sigma_p : (n : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt 0 n) -> (x : prime x) -> (H : Leq (pow x m) n) -> (n : Nat) -> Eq (ord n x) (bigop m (\\ i : Nat -> dividesb (pow x (plus i 1)) n) Nat 0 plus (\\ i : Nat -> 1))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_Type2. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_951$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H_mk_Dop$ be a function from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_", "label": "postulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)", "predict": "distrpostulate Dop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_951 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term univs.Type2 (Q_ x_951)"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_p_ord_q_O. Soit $p, n, q \\in N$. Supposons que $p_ord$ appliqué à $n$ et $p$ est égal à $mk_Prod$ appliqué à $Nat$ et $Nat$ et $q$ et $0$. Alors $n$ est égal à $0$ et $q$ est égal à $0$.\nAssistant:", "label": "postulate eq_p_ord_q_O : (p : Nat) -> (n : Nat) -> (q : Nat) -> (_ : Eq (p_ord n p) (mk_Prod Nat Nat q 0)) -> and (Eq n 0) (Eq q 0)", "predict": "postulate eq_p_ord_q_O : soit p, n, q : N -> quebe (Eq (p_ord n p) (mk_Prod Nat Nat q 0)) -> and (Eq n 0) (Eq q 0)"}
{"prompt": "Human: Translate the following French statement into Agda.\nCongruent_times. Soit $n, m, n1, m1, p \\in N$. Supposons que $0 < p$. Soit $__1$ un élément de $congruent$ de $n$ et de $n1$ et de $p$. Soit $__2$ un élément de $congruent$ de $m$ et de $m1$ et de $p$. Alors $congruent$ tient pour $n \\times m$ et $n1 \\times m1$ et $p$.\nAssistant:", "label": "postulate congruent_times : (n : Nat) -> (m : Nat) -> (n1 : Nat) -> (m1 : Nat) -> (p : Nat) -> (_ : Lt 0 p) -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent (times n m) (times n1 m1) p", "predict": "postulate congruent_times : soit n, m, n1, m1, p : N -> (__1 : congruent n n1 p) -> (__2 : congruent m m1 p) -> congruent n (times n m) n1 (times m m1) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_not_exists. Let $f$ be a function from natural numbers to booleans. Let $n$ and $b$ be natural numbers. Let $__$ be a function from natural numbers $i$ and elements of $Leq$ of $b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $n + b$ to elements of $Eq$ of $f (i)$ and absurdity. Then $min (n, b, f)= n + b$.\nAssistant:", "label": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i (plus n b)) -> Eq (f i) false) -> Eq (min n b f) (plus n b)", "predict": "postulate min_not_exists : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : (i : Nat) -> (_ : Leq b i) -> (__1 : Lt i n + b) -> Eq (f i) false) -> Eq (min n b f) n + b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLprim_invariant. För alla naturliga tal $n$ och $i$, för alla listor $acc$ av naturliga tal, om $1 < i$, så för alla element $__1$ av $primes_below$ av $acc$ och $i$, håller $primes_below$ för $lprim (n, i, acc)$ och $n + i$.\nAssistant:", "label": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) (plus n i)", "predict": "postulate lprim_invariant : (n : Nat) -> (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> primes_below (lprim n i acc) n i"}
{"prompt": "Human: Translate the following French statement into Agda.\nDpi1__o__aop. Soit $x0$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x1$ un élément de $cic.Term$ de $univs.Type0$ et de $x0$. Alors pour toutes les fonctions $x2$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ à des éléments de $cic.Univ$ de $univs.Type0$, pour tous les éléments $x3$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.DPair$ appliqué à $matita_arithmetics_bigops.ACop$ appliqué à $x0$ et $x1$ et $x2$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_bigops.Aop$ appliqué à $x0$ et $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)", "predict": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_rect_CProp3. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_nil$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.nil$ appliqué à $_A$. Alors pour toutes les fonctions $_H_cons$ des éléments $x_763$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $x_762$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$ et des éléments $_x_765$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_762$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_lists_list.cons$ appliqué à $_A$ et $x_763$ et $x_762$, pour tous les éléments $x_761$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $_A$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_761$.\nAssistant:", "label": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)", "predict": "postulate list_rect_CProp3 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (x_763 : cic.Term univs.Type0 _A) -> (x_762 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_765 : cic.Term cic.prop (Q_ x_762) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_763 x_762))) -> (x_761 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_761)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPad_bigop_nil. Soient $k$ et $n$ des nombres naturels. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $n \\leq k$, alors pour toutes les fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Leq$ de $n$ et de $i$ et des éléments $__2$ de $Lt$ de $i$ et de $k$ à des éléments de $or$ de $Eq$ appliqué à $p$ appliqué à $i$ et contradiction et de $Eq (f (i), nil)$, $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) (contradiction)) (Eq (f i) nil)) -> Eq (bigop k (\\ i : Nat -> p i) B nil op) (bigop n (\\ i : Nat -> p i) B nil op) (\\ i : Nat -> f i)"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_inv_rect_CProp0. For all elements $x1$ of $cic.Univ$ of $univs.Type0$, for all elements $Hterm$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$, for all functions $P$ from elements $_z1692$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $x1$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H1$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ and elements $_z1693$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.range$ applied to $x1$ and $Hterm$ and $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_bigops.mk_range$ applied to $x1$ and $_enum$ and $_upto$ and $_filter$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate range_inv_rect_CProp0 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> (P : (_z1692 : cic.Term univs.Type0 (matita_arithmetics_bigops.range x1)) -> cic.Univ cic.prop) -> (_H1 : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 x1) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_z1693 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.range x1)) Hterm (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_range x1 _enum _upto _filter))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_discr. Låt $a1$ och $a2$ och $a3$ och $a4$ vara naturliga tal. Då för alla element $x$ och $y$ av $div_mod_spec$ av $a1$ och $a2$ och $a3$ och $a4$, om $x = y$, så håller $match_div_mod_spec$ för $a1$ och $a2$ och $a3$ och $a4$ och $Type2 + 1$ och funktionen som avbildar $__$ som $univ (Type2)$ och funktionen som avbildar $t0$ och $t1$ som $match_div_mod_spec$ applicerat på $a1$ och $a2$ och $a3$ och $a4$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar $u0$ och $u1$ som $prod$ applicerat på summan av $Type1$ och $1$ och $Type1$ och $univ$ applicerat på $Type1$ och funktionen som avbildar $P$ som $prod$ applicerat på $Type1$ och $Type1$ och $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R0$ applicerat på $Lt$ applicerat på $a4$ och $a2$ och $t0$ och $u0$ och funktionen som avbildar $e0$ som $prod$ applicerat på $Prop$ och $Type1$ och $Eq$ applicerat på $R1$ applicerat på $Lt$ applicerat på $a4$ och $a2$ och $t0$ och funktionen som avbildar $x_19$ och $_x_20$ som funktionen som avbildar $x0$ och $p0$ som $Eq$ applicerat på $a1$ och summan av produkten av $a3$ och $a2$ och $a4$ applicerat", "label": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Lt a4 a2 -> \\ t1 : Eq a1 (plus (times a3 a2) a4) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Lt a4 a2 -> \\ u1 : Eq a1 (plus (times a3 a2) a4) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (\\ _e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P))) (\\ _z53 : ((e0 : Eq (R0 (Lt a4 a2) t0) u0) -> (_e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4", "predict": " påpostulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (x = y) -> match_div_mod_spec a1 a2 a3 a4 (Type2 + 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ __ : univ Type2 -> (\\ t0 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ t1 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ __ : univ Type2 -> (\\ u0 : div_mod_spec a1 a2 a3 a4 -> (\\ u1 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u2 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u3 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u4 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u5 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u6 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u7 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u8 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u9 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u10 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u11 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u12 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u13 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u14 : div_mod_spec a1 a2 a3 a4 -> Type2 + 1) (\\ u15 : div_mod_spec a1 a2 a3"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp5_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk", "label": "postulate Aop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_877)", "predict": "_Aoppostulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (Q_ : (matita_arithmetics_bigops.mk_Aop A _nil) -> cic.Univ cic.prop) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_x_877 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil) (op _nil a) a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_ind_body. Soit $Q_$ une fonction des éléments $_x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour tous les éléments $_H_O$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.O$, pour toutes les fonctions $_H_S$ des éléments $x_366$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $_x_368$ de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $x_366$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_nat.S$ appliqué à $x_366$, pour tous les éléments $x_365$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_365$.\nAssistant:", "label": "postulate nat_ind_body : (Q_ : (_x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> (_H_O : cic.Term cic.prop (Q_ matita_arithmetics_nat.O)) -> (_H_S : (x_366 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_x_368 : cic.Term cic.prop (Q_ x_366)) -> cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366))) -> (x_365 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (Q_ x_365)", "predict": "postulate nat_ind_body : soit Q_ une fonction des éléments _x_365 de cic.Term univs.Type0 matita_arithmetics_nat.nat à des éléments de cic.Univ cic.prop. Alors pour tous les éléments _H_O de cic.Term cic.prop (Q_ matita_arithmetics_nat.O) pour toutes les fonctions _H_S des éléments x_366 de cic.Term univs.Type0 matita_arithmetics_nat.nat et (_x_368 de cic.Term cic.prop (Q_ x_366)) de cic.Term cic.prop (Q_ (matita_arithmetics_nat.S x_366)) pour tous les éléments x_365 de cic.Term univs.Type0 matita_arithmetics_nat.nat, cic.Term cic.prop (Q_ x_365)"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter_le. For all natural numbers $_n$ and $__$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$, for all functions $return$ from elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_type$ of $z$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $z$.\nAssistant:", "label": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z", "predict": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1545. Låt $m, n \\in N$. Anta att $0$ är både lika med det största gemensama delaret av $m$ och $n$ och delbart med $n$. Låt $q1 \\in N$. Anta att $n = 0 q1$ och $0$ är delbart med $m$. Låt $q2 \\in N$. Anta att $m = 0 q2$. Då $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (antata : Eq 0 (gcd m n) (div n m)) -> (q1 : Nat) -> (nq1 : Eq n 0) -> (q2 : Nat) -> (m0 : Eq m 0) -> Eq (gcd m n) (div n m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_min_f_min_g. Soient $f$ et $g$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soient $n$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ une fonction des éléments $i$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $b$ et $i$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $i$ et $matita_arithmetics_nat.plus$ appliqué à $n$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $f$ appliqué à $i$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $g$ appliqué à $i$ et $matita_basics_bool.true$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $g$ et $matita_arithmetics_minimization.min$ appliqué à $n$ et $b$ et $f$.\nAssistant:", "label": "postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))", "predict": "postulate le_min_f_min_g : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le b i)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt i (matita_arithmetics_nat.plus n b))) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (g i) matita_basics_bool.true)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.min n b g) (matita_arithmetics_minimization.min n b f))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_exp_to_lt. Let $a, n, m \\in N$. Assume that $0$ is less than $a$. Assume that the exponentiation of $a$ and $n$ is less than the exponentiation of $a$ and $m$. Then $n$ is less than $m$.\nAssistant:", "label": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 a) -> (__1 : Lt (pow a n) (pow a m)) -> Lt n m", "predict": "postulate lt_exp_to_lt : (a : Nat) -> (n : Nat) -> (m : Nat) -> Lt 0 a -> Lt (pow a n) (pow a m) -> Lt n m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nList_rect_CProp2_body. För alla element $_A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $Q_$ från element $_x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla element $_H_nil$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.nil$ applicerat på $_A$, för alla funktioner $_H_cons$ från element $x_768$ av $cic.Term$ av $univs.Type0$ och $_A$ och element $x_767$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$ och element $_x_770$ av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $x_767$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_lists_list.cons$ applicerat på $_A$ och $x_768$ och $x_767$, för alla element $x_766$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_766$.\nAssistant:", "label": "postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)", "predict": "postulate list_rect_CProp2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Univ cic.prop) -> (_H_nil : cic.Term cic.prop (Q_ (matita_basics_lists_list.nil _A))) -> (_H_cons : (x_768 : cic.Term univs.Type0 _A) -> (x_767 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> (_x_770 : cic.Term cic.prop (Q_ x_767)) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.cons _A x_768 x_767))) -> (x_766 : cic.Term univs.Type0 (matita_basics_lists_list.list _A)) -> cic.Term cic.prop (Q_ x_766)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15692. Soit $m, n, a, b \\in N$. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Alors si $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (p : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posd : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (times d m) (times c n)) -> (H0 : Eq m c) -> Eq d n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_to_le_min. Let $f$ be a function from natural numbers to booleans. Let $n, m \\in N$. Assume that $n \\leq m$. Then for all natural numbers $b$, $min (n, b, f)\\leq min (m, b, f)$.\nAssistant:", "label": "postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> Leq (min n b f) (min m b f)", "predict": "postulate le_to_le_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> (b : Nat) -> min n b f <= min m b f"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be a natural number. Assume that $1 < n$. Assume that $2 \\times n$ is prime. Assume that $1 < 2 n$. Let $H1$ be a function from natural numbers $m$ and elements of $divisible$ of $m$ and $2 \\times n$ and elements $__1$ of $Lt$ of $1$ and $m$ to elements of $Eq$ of $m$ and $2 \\times n$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (lt1n : Lt 1 n) -> (H1 : (m : Nat) -> (_ : divisible m 2 * n) -> (__1 : Lt 1 m) -> Eq m 2 * n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d \\in N$. Supposons que $c n - d m = 1$ ou $d m - c n = 1$. Alors si $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (div (times d m) (gcd m n)) (plus m n)) -> Eq (times d m) (div (times d m) (gcd m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $match_bool$ applicerat på $Set$ och funktionen som avbildar $_0$ som $bool$ och kontradiktion och $p$ applicerat på $i$ och $leb$ applicerat på $n$ och $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> match_bool Set (\\ _0 : bool -> bool) false (p i) (leb n i)) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (_ : all (lambda nil : B) (\\ op : (_ : B) -> __1) B) -> (f : (_ : Nat) -> B) -> (n : Nat) -> (ltml : or (Eq n k) (Eq n k)) -> bigop n (\\ i : B -> p i) B nil op (\\ i : B -> f i) (bigop k (\\ i : B -> match_bool Set (\\ _0 : bool -> bool) false (p i) (leb n i)) i B nil op (\\ i : B -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_ind_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_521$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_inl$ des éléments $x_522$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_522$, pour toutes les fonctions $_H_inr$ des éléments $x_523$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_523$, pour tous les éléments $x_521$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_521$.\nAssistant:", "label": "postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)", "predict": "postulate Sum_ind_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_522 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_522))) -> (_H_inr : (x_523 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_523))) -> (x_521 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_521)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_to_not_eq_O. Låt $n, p, q, r \\in N$. Då om $1$ är mindre än $n$, så om $p_ord$ applicerat på $n$ och $nth_prime$ applicerat på $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $q$ och $r$, så är $r$ inte lika med $0$.\nAssistant:", "label": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (p_ord n (nth_prime p)) (mk_Prod Nat Nat q r)) -> not (Eq r 0)", "predict": "postulate p_ord_to_not_eq_O : (n : Nat) -> (p : Nat) -> (q : Nat) -> (r : Nat) -> då om 1 < n, så om p_ord n (nth_prime p) är lika med mk_Prod Nat Nat q r, så är r inte lika med 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_diff. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour tous les éléments $op$ de $ACop$ de $B$ et de $nil$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, pour tous les nombres naturels $i$ et $n$, si $i < n$ et $p (i)= true$, alors $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et $f$ appliqué à $i$ et $bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $andb$ appliqué à $notb$ appliqué à $eqb$ appliqué à $i$ et $x$ et $p$ appliqué à $x$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$ est égal à $bigop$ appliqué à $n$ et la fonction qui envoie $x$ à $p$ appliqué à $x$ et $B$ et $nil$ et $aop__o__op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $x$ à $f$ appliqué à $x$.\nAssistant:", "label": "postulate bigop_diff : (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Eq (bigop n (\\ x : Nat -> p x) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)) (aop__o__op B nil op (f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op) (\\ x : Nat -> f x)))", "predict": "postulate bigop_diff : soit p : (_ : Nat) -> (B : Set) -> (nil : B) -> (op : ACop B nil) -> (f : (_ : Nat) -> B) -> (i : Nat) -> (n : Nat) -> (_ : Lt i n) -> (H : p i) -> Eq (aop__o__op B nil op f i) (bigop n (\\ x : Nat -> andb (notb (eqb i x)) (p x)) B nil (aop__o__op B nil op (\\ x : Nat -> f x)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_times. Låt $p, a, b, qa, ra, qb, rb \\in N$. Anta att $p$ är primt. Då om $0$ är mindre än $a$, så om $0$ är mindre än $b$, så om $p_ord$ applicerat på $a$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $qa$ och $ra$, så om $p_ord$ applicerat på $b$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $qb$ och $rb$, så är $p_ord$ applicerat på produkten av $a$ och $b$ och $p$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och summan av $qa$ och $qb$ och produkten av $ra$ och $rb$.\nAssistant:", "label": "postulate p_ord_times : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> (_ : prime p) -> (__1 : Lt 0 a) -> (__2 : Lt 0 b) -> (__3 : Eq (p_ord a p) (mk_Prod Nat Nat qa ra)) -> (__4 : Eq (p_ord b p) (mk_Prod Nat Nat qb rb)) -> Eq (p_ord (times a b) p) (mk_Prod Nat Nat (plus qa qb) (times ra rb))", "predict": "postulate låt : (p : Nat) -> (a : Nat) -> (b : Nat) -> (qa : Nat) -> (ra : Nat) -> (qb : Nat) -> (rb : Nat) -> prim p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $return_sort$ vara ett element av $Sort$. Låt $return_type$ vara en funktion från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$. Låt $case_lstar_O$ vara en funktion från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $case_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $__1$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, __, l, b2, __1)$. Låt $__ \\in N$. Låt $__1$ och $__2$ vara element av $B$. Då för alla element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar : let B : Mngd -> let _R : relation B -> let return_sort : Sort -> let return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort -> (case_lstar_O : (b : B) -> return_type 0 b b) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : relation b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type l + 1 b1 b2) -> (_ : N) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sigma. Let $n$ be a natural number. Then for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Eq$ of $p2$ applied to $i$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1$ applied to $i$ and $true$ to elements of $Leq$ of $g1$ applied to $i$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$ is less than or equal to $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$.\nAssistant:", "label": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1561. Soit $p, m, n \\in N$. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Alors pour tous les nombres naturels $a$, pour tous les éléments $_clearme0$ de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$, pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : soit p, m, n : Nat\n  -> (posp : Lt 0 p) -> (eqm : Eq 1 (div comm p m)) -> (pdiv : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (ac : Nat) -> (b : Nat) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) c)) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times b m) (times a p))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> (Hc : Eq m n) -> (Hb : Eq (div comm p m) (Eq (times a p) (times b m))) -> Eq (p a) m b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nCr_pair4. $cr_pair$ applicerat på $5$ och $7$ och $3$ och $2$ är lika med $23$.\nAssistant:", "label": "postulate cr_pair4 : Eq (cr_pair 5 7 3 2) 23", "predict": "postulate cr_pair4 : Eq (cr_pair 5 7 3 2) 23"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type4. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_945$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type4$. Alors pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a, _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a, aop__o__op (A, _nil, sum, b, c))$ et de $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ à des éléments de $Q_$ de $mk_Dop (A, _nil, sum, prod, _null, _distr)$, pour tous les éléments $x_945$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_945$.\nAssistant:", "label": "postulate Dop_rect_Type4 : (A : Set) -> (_nil : A) -> (Q_ : (_x_945 : Dop A _nil) -> Type4) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945", "predict": "postulate Dop_rect_Type4 : soit A un ensemble. soit _nil un élément de A. soit Q_ une fonction des _x_945 de Dop de A _nil à des éléments de Type4. Alors pour toutes les fonctions _H_mk_Dop des éléments sum de ACop de A _nil et des fonctions prod des éléments de A __1 de A à des éléments de A et des (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_945 : Dop A _nil) -> Q_ x_945"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_to_or_lt_eq. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.Or$ applicerat på $matita_arithmetics_nat.lt$ applicerat på $n$ och $m$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $n$ och $m$.\nAssistant:", "label": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))", "predict": "postulate le_to_or_lt_eq : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (matita_basics_logic.Or (matita_arithmetics_nat.lt n m) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1585. Soient $n$ et $m$ des nombres naturels. Supposons que $0 < n$. Alors si $m$ est divisible par $n$, alors pour tous les nombres naturels $d$, si $0 = m$, alors si $n = m d$, alors $0 = n$.\nAssistant:", "label": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq 0 n", "predict": "postulate let_clause_1585 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (Hind : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n m) -> Eq 0 n"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_rect_CProp1_body. Soient $_n$ et $_m$ et $_q$ et $_r$ des nombres naturels. Soit $Q_$ une fonction des éléments $_x_853$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Soit $_H_div_mod_spec_intro$ une fonction des éléments $x_855$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_854$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_855$ et $x_854$. Alors pour tous les éléments $x_853$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_853$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853", "predict": "postulate div_mod_spec_rect_CProp1_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_853 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_855 : Lt _r _m) -> (x_854 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_855 x_854)) -> (x_853 : div_mod_spec _n _m _q _r) -> Q_ x_853"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_863$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type4$, for all functions $_H_mk_Aop$ from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type4$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements", "label": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)", "predict": "postulate Aop_rect_Type4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type4) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type4 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_863 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type4 (Q_ x_863)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_div_O. Let $n$ and $m$ be natural numbers. Assume that $n < m$. Then $n \\div m = 0$.\nAssistant:", "label": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0", "predict": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nMatch_divides. Soit $_n, _m \\in N$. Soit $return_sort$ un élément de $Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $divisible$ de $_n$ et de $_m$ à des éléments de $return_sort$, pour toutes les fonctions $case_quotient$ des nombres naturels $q$ et des éléments de $Eq$ de $_m$ et du produit de $_n$ et de $q$ à des éléments de $return_type$ de $quotient$ appliqué à $_n$ et $_m$ et $q$ et $__$, si $_n$ est divisible par $_m$, alors $return_type$ tient pour $z$.\nAssistant:", "label": "postulate match_divides : (_n : Nat) -> (_m : Nat) -> (return_sort : Sort) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z", "predict": "postulate match_divides : (_n : N) -> (_m : N) -> (return_sort : Sort) -> (z : divisible _n _m) -> (return_type : (z : divisible _n _m) -> return_sort) -> (case_quotient : (q : Nat) -> (_ : Eq _m (times _n q)) -> return_type (quotient _n _m q __)) -> (z : divisible _n _m) -> return_type z"}
{"prompt": "Human: Translate the following French statement into Agda.\nList_divides_false. Soit $l$ une liste de nombres naturels. Alors pour tous les nombres naturels $n$, si $list_divides$ appliqué à $l$ et $n$ est égal à contradiction, alors pour tous les nombres naturels $p$, pour tous les éléments $__1$ de $mem$ de $Nat$ et de $p$ et de $l$, $p$ n'est pas divisible par $n$.\nAssistant:", "label": "postulate list_divides_false : (l : list Nat) -> (n : Nat) -> (_ : Eq (list_divides l n) false) -> (p : Nat) -> (__1 : mem Nat p l) -> not (divisible p n)", "predict": "postulate list_divides_false : soit l : liste Nat -> tous (fun n -> (eqn (list_divides l n) false) -> (fun p : Nat -> (__1 : mem Nat p l) -> not (divisible p n))) -> tous (\\ p : Nat -> (__1 : mem Nat p l) -> not (divisible p n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (b : Nat) -> (H : Leq a n) -> (f a) i -> (f b) j -> (H0 : Leq f b) -> (injf : injn f n) -> (H1 : Eq a b) -> f a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Då om $c n - d m = 1$ eller $d m - c n = 1$ och $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (antatt : Lt 0 n) -> (antatt2 : Lt 0 m) -> (eqn1 : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ e : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (H : Eq c n - d m) -> Eq (minus (times d m) (times c n)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_gcd. Låt $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $n$. Då om $n$ är delbart med $m$, så är det största gemensama delaret av $n$ och $m$ lika med $n$.\nAssistant:", "label": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (gcd n m) n", "predict": "postulate divides_to_gcd : (m : Nat) -> (n : Nat) -> let (posn : Lt 0 n) -> (posn0 : divisible n m) -> Eq (gcd n m) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1078. Låt $a$ och $b$ och $q$ och $r$ och $q1$ och $r1$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $_clearme$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q$ och $r$. Låt $ltrb$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $r$ och $b$. Då för alla element $spec$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $a$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $q$ och $b$ och $r$, för alla element $_clearme0$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $a$ och $b$ och $q1$ och $r1$, för alla element $ltr1b$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $r1$ och $b$, för alla element $spec1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $a$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $q1$ och $b$ och $r1$, för alla element $leqq1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $q$ och $q1$, för alla element $ltqq1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $q$ och $q1$, håller", "label": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q r)) -> (ltrb : cic.Term cic.prop (matita_arithmetics_nat.lt r b)) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus r (matita_arithmetics_nat.times b q)))", "predict": "postulate let_clause_1078 : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (spec : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q b) r))) -> (_clearme0 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec a b q1 r1)) -> (ltr1b : cic.Term cic.prop (matita_arithmetics_nat.lt r1 b)) -> (spec1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) a (matita_arithmetics_nat.plus (matita_arithmetics_nat.times q1 b) r1))) -> (leqq1 : cic.Term cic.prop (matita_arithmetics_nat.le q q1)) -> (ltqq1 : cic.Term cic.prop (matita_arithmetics_nat.lt q q1))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_times_div_m_m. Soient $n$ et $m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.le$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_div_and_mod.div$ appliqué à $n$ et $m$ et $m$ et $n$.\nAssistant:", "label": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)", "predict": "postulate le_times_div_m_m : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_div_and_mod.div n m) m) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n \\in N$. Assume that $1 < n$. Assume that $2 \\times n$ is prime. Then if $1 < 2 n$, then for all functions $H1$ from natural numbers $m$ and elements of $divisible$ of $m$ and $2 \\times n$ and elements $__1$ of $Lt$ of $1$ and $m$ to elements of $Eq$ of $m$ and $2 \\times n$, for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (ltn : Lt 1 n) -> (_clearme : prime (times 2 n)) -> (H : Lt 1 (times 2 n)) -> (H1 : (m : Nat) -> (_ : divisible m (times 2 n)) -> (__1 : Lt 1 m) -> Eq m (times 2 n)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : (n : Nat) -> (lt1n : Lt 1 n) -> (prime2n : prime 2 * n) -> (H1 : (m : Nat) -> (_ : divisible m 2 * n) -> (__1 : Lt 1 m) -> Eq m 2 * n) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1575. Let $m, n, a, b \\in N$. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$ and $c n - d m = 1$, then for all natural numbers $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (Hind : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (x1029 : Nat) -> Eq x1029 (x1029 (n c - m d))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n$ un nombre naturel. Supposons que $5 < n$. Soit $m \\in N$. Supposons que $6 \\leq m$. Supposons que $(m + 1)^ 2 \\leq 2 ^ m$. Soit $a \\in N$. Alors si $6 \\leq a$, alors si $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : soit n un nombre naturel. Supposons que 5 < n. Soit m \\in N. Supposons que 6 \\leq m. Supposons que (m + 1)^ 2 \\leq 2 ^ m. Soit a \\in N. Alors si 6 \\leq a, alors si 2 (a + 1)+ 1 \\leq 2 ^ a, alors pour tous les nombres naturels x2515 et x2516, x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)."}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_sum. Let $k1$ and $k2$ be natural numbers. Let $p1$ and $p2$ be functions from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be an element of $Aop$ of $B$ and $nil$. Let $f$ and $g$ be functions from natural numbers to elements of $B$. Then $bigop$ applied to the sum of $k1$ and $k2$ and the function that maps $i$ to $match_bool$ applied to $Set$ and the function that maps $__$ to $bool$ and $p1$ applied to the difference of $i$ and $k2$ and $p2$ applied to $i$ and $leb$ applied to $k2$ and $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $match_bool$ applied to $Set$ and the function that maps $__$ to $B$ and $f$ applied to the difference of $i$ and $k2$ and $g$ applied to $i$ and $leb$ applied to $k2$ and $i$ is equal to $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to $k1$ and the function that maps $i$ to $p1$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ and $bigop$ applied to $k2$ and the function that maps $i$ to $p2$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $g$ applied to $i$.\nAssistant:", "label": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i))) (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))", "predict": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op (\\ i : Nat -> match_bool Set (\\ __ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i))) (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op (\\ i : Nat -> p1 i)) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op (\\ i : Nat -> p2 i)) (\\ i : Nat -> g i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_nth_prime_to_not_prime. Låt $n$ och $m$ vara naturliga tal. Anta att $nth_prime (n)< m$. Då om $m < nth_prime (n + 1)$, så är $m$ inte primt.\nAssistant:", "label": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> (_ : Lt (nth_prime n) m) -> (__1 : Lt m (nth_prime (plus n 1))) -> not (prime m)", "predict": "postulate lt_nth_prime_to_not_prime : (n : Nat) -> (m : Nat) -> let n : Nat -> let m : Nat -> let (nth_prime : (_ : Nat) -> Lt (nth_prime n) m) -> (posn : Lt m (nth_prime n + 1)) -> not (prime m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAnd_inv_rect_CProp2. Låt $x1$ och $x2$ vara element av $cic.Univ$ av $cic.prop$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z371$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $x_160$ av $cic.Term$ av $cic.prop$ och $x1$ och element $x_159$ av $cic.Term$ av $cic.prop$ och $x2$ och element $_z372$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_basics_logic.And$ applicerat på $x1$ och $x2$ och $Hterm$ och $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_logic.conj$ applicerat på $x1$ och $x2$ och $x_160$ och $x_159$. Då håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate And_inv_rect_CProp2 : (x1 : cic.Univ cic.prop) -> (x2 : cic.Univ cic.prop) -> (Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> (P : (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_160 : cic.Term cic.prop x1) -> (x_159 : cic.Term cic.prop x2) -> (_z372 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2)) Hterm (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Då om $5$ är mindre än $n$, så för alla naturliga tal $m$, om $6$ är mindre än eller lika med $m$, så om potensen av summan av $m$ och $1$ och $2$ är mindre än eller lika med potensen av $2$ och $m$, så för alla naturliga tal $a$, om $6$ är mindre än eller lika med $a$, så om summan av produkten av $2$ och summan av $a$ och $1$ och $1$ är mindre än eller lika med potensen av $2$ och $a$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : let n : Nat -> (k : Nat) -> (l : Nat) -> (lt4n : Lt 5 n) -> (auto : Eq m (min (pow (plus m 1) 2) (pow 2 m))) -> (auto' : Eq a (min (pow 2 (plus m 1)) 1)) -> (auto\" : Eq x2515 (plus (times 2 (plus a 1)) 1)) -> (auto' : Eq x2516 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))) -> (auto'' : Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1078. Låt $a, b, q, r, q1, r1 \\in N$. Låt $_clearme$ vara ett element av $div_mod_spec$ av $a$ och $b$ och $q$ och $r$. Anta att $r$ är mindre än $b$. Anta att $a$ är lika med summan av produkten av $q$ och $b$ och $r$. Då för alla element $_clearme0$ av $div_mod_spec$ av $a$ och $b$ och $q1$ och $r1$, om $r1$ är mindre än $b$, så om $a$ är lika med summan av produkten av $q1$ och $b$ och $r1$, så om $q$ är mindre än eller lika med $q1$, så om $q$ är mindre än $q1$, så är $a$ lika med summan av $r$ och produkten av $b$ och $q$.\nAssistant:", "label": "postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : Leq q q1) -> (ltqq1 : Lt q q1) -> Eq a (plus r (times b q))", "predict": "postulate let_clause_1078 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (clearme : div_mod_spec a b q r) -> (r : Lt r b) -> (auto : Eq a (plus (times q b) r)) -> (auto0 : (_clearme0 : div_mod_spec a b q1 r1) -> (r1 : Lt r1 b) -> Eq a (plus (times q1 b) r1)) -> (auto1 : Lt q r1) -> Eq a (plus r (times b q))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16171. Let $p$ and $m$ and $n$ be natural numbers. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b \\in N$. Assume that the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$. Assume that the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$. Then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $m$ and $b$ and the product of $p$ and $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (gcd p m) (minus (times m b) (times p a))) -> Eq (gcd p m) (minus (times m b) (times p a))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_divides_times_to_divides. Låt $p, n, m \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $n$. Anta att $p$ är delbart med $n \\times m$. Då är $p$ delbart med $m$.\nAssistant:", "label": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m", "predict": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> let p : Nat in let n : Nat in let m : Nat in let zero : Lt p 1 == (max (gcd p n) m) -> (div p m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16002. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $posn$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $posm$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$, pour tous les éléments $pnm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $c$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$, pour tous les éléments $", "label": "postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (mat", "predict": "postulate let_clause_16002 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> (pos : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_Type5. Låt $_n$ och $_m$ och $_q$ och $_r$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla funktioner $Q_$ från element $_x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $univs.Type5$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_819$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_818$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $univs.Type5$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_819$ och $x_818$, för alla element $x_817$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $univs.Type5$ och $Q_$ applicerat på $x_817$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type5 : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)", "predict": "postulate div_mod_spec_rect_Type5 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ univs.Type5) -> (_H_div_mod_spec_intro : (x_819 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_818 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_819 x_818))) -> (x_817 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term univs.Type5 (Q_ x_817)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_p_ord_inv. Let $p, m, x \\in N$. Assume that $ord (x, p)< m$. Then $p_ord_inv (p, m, x)\\div m = ord_rem (x, p)$.\nAssistant:", "label": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> Eq (div (p_ord_inv p m x) m) (ord_rem x p)", "predict": "postulate div_p_ord_inv : (p : Nat) -> (m : Nat) -> (x : Nat) -> (_ : Lt (ord x p) m) -> div (ord_rem x p) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_Sfalse. For all natural numbers $k$, for all functions $p$ from natural numbers to booleans, for all sets $B$, for all elements $nil$ of $B$, for all functions $op$ from elements of $B$ and elements $__1$ of $B$ to elements of $B$, for all functions $f$ from natural numbers to elements of $B$, if absurdity is equal to $p (k)$, then $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to the sum of $k$ and $1$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq false (p k)) -> Eq (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_inv_ind. Låt $x1$ och $x2$ vara naturliga tal. Låt $x3$ vara en funktion från naturliga tal till sanningsvärden. Låt $x4 \\in N$. Låt $_Hterm$ vara ett element av $min_spec$ av $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från naturliga tal $_z1890$ till påståenden, för alla funktioner $_H1$ från naturliga tal $m$ och element $_x_1080$ av $Leq$ av $x2$ och $m$ och element $_x_1079$ av $Lt$ av $m$ och summan av $x1$ och $x2$ och element $_x_1078$ av $Eq$ av $x3$ applicerat på $m$ och $true$ och funktioner $_x_1077$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och $m$ till element av $P$ av $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $x1$ och $x2$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och summan av $x1$ och $x2$ till element av $P$ av summan av $x1$ och $x2$, håller $P$ för $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : let (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Sann) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Påstånd) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_z1891 : Eq x4 m) -> (_z1892 : Eq x4 (plus x1 x2)) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_z1891 : Eq x4 (plus x1 x2)) -> Eq (x3 i) (contradiktion)) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_plus_to_le_r. Pour tous les nombres naturels $a$ et $n$ et $m$, si $n + a \\leq m + a$, alors $n \\leq m$.\nAssistant:", "label": "postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq (plus n a) (plus m a)) -> Leq n m", "predict": "postulate le_plus_to_le_r : (a : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq n (plus a m)) -> Leq n m"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_div_O. Pour tous les nombres naturels $n$ et $m$, si $n < m$, alors $n \\div m = 0$.\nAssistant:", "label": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0", "predict": "postulate eq_div_O : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> Eq (div n m) 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1033. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $lt1n$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $x2515$ and $x2516$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $x2515$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_nat.times$ applied to $x2516$ and $matita_arithmetics_div_and_mod.div$ applied to $x2515$ and $x2516$ and $matita_arithmetics_div_and_mod.mod$ applied to $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))", "predict": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lt1n : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (x2515 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2516 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x2515 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x2516 (matita_arithmetics_div_and_mod.div x2515 x2516)) (matita_arithmetics_div_and_mod.mod x2515 x2516)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c$ un nombre naturel. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b$ un nombre naturel. Supposons que la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale à $1$. Alors la différence du produit de $m$ et de $b$ et du produit de $p$ et de $a$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : soit p, m, n : N"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15441. Let $p$ and $q$ be natural numbers. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m, n \\in N$. Assume that $0$ is less than $n$. Assume that $n$ is less than or equal to $m$. Assume that $n$ is less than or equal to the sum of $q$ and $1$. Assume that $n$ is not divisible by $m$. Then for all natural numbers $a$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, for all natural numbers $b$, if the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ or the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$, then if the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ is equal to $gcd_aux$ applied to $", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (leqn : Leq n m) -> (eqm : Leq n (plus q 1)) -> (Hind' : (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind'' : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times a n) (times b m)) (gcd_aux q m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_times_r. Låt $c \\in N$. Anta att $0 < c$. Då håller $monotonic$ för $Nat$ och $Lt$ och funktionen som avbildar $t$ som $c \\times t$.\nAssistant:", "label": "postulate monotonic_lt_times_r : (c : Nat) -> (_ : Lt 0 c) -> monotonic Nat Lt (\\ t : Nat -> times c t)", "predict": "postulate monotonic_lt_times_r : let c : Nat in let _ : Lt 0 c in monotonic Nat Lt (\\ t : Nat -> c * t)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16005. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : soit m, n, a, b : N"}
{"prompt": "Human: Translate the following English statement into Agda.\nF_false_to_le_max. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $n$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $matita_arithmetics_nat.nat$ and the function that maps $i$ to $matita_basics_logic.And$ applied to $matita_arithmetics_nat.lt$ applied to $i$ and $n$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $i$ and $matita_basics_bool.true$, for all functions $__1$ from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $p$ and $m$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $f$ applied to $m$ and $matita_basics_bool.false$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_minimization.max$ applied to $n$ and $f$ and $p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)", "predict": "postulate f_false_to_le_max : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_arithmetics_nat.lt i n) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f i) matita_basics_bool.true)))) -> (__1 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt p m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (f m) matita_basics_bool.false)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_minimization.max n f) p)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_mop. Låt $n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Då för alla element $nil$ av $B$, för alla element $R$ av $Dop$ av $B$ och $nil$, för alla funktioner $f$ från naturliga tal till element av $B$, för alla element $a$ och $_x_969$ och $_x_970$ av $B$, $B$.\nAssistant:", "label": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B", "predict": "postulate let_mop : (n : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (R : Dop B nil) -> (f : (_ : Nat) -> B) -> (a : B) -> (_x_969 : B) -> (_x_970 : B) -> B"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_fwd_plus_plus_ge. Let $m1$ and $m2$ be natural numbers. Assume that $m2 \\leq m1$. Then for all natural numbers $n1$ and $n2$, if $m1 + n1 \\leq m2 + n2$, then $n1 \\leq n2$.\nAssistant:", "label": "postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (_ : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (__1 : Leq (plus m1 n1) (plus m2 n2)) -> Leq n1 n2", "predict": "postulate le_fwd_plus_plus_ge : (m1 : Nat) -> (m2 : Nat) -> (le : Leq m2 m1) -> (n1 : Nat) -> (n2 : Nat) -> (_ : Lt m1 m2) -> and (Leq n1 n2) (Leq n2 n1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15611. Soit $p, m, n \\in N$. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$. Supposons que $b m - a p = 1$. Alors $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : soit p, m, n \\in N. supposons que 0 < p et 1 = diviseur commun plus grand de p et m. supposons que p est divisible par m \\times n. soit c un nombre naturel. supposons que m n = p c. soit a \\in N. soit _clearme0 : ex Nat (\\ b : Nat -> disjonct (Eq (minus (times a p) (times b m)) (diviseur commun plus grand de p m)) (Eq (minus (times b m) (times a p)) (diviseur commun plus grand de p m))) soit b \\in N. supposons que le diviseur commun plus grand de p et m est égal à a p - b m ou égal à b m - a p. supposons que b m - a p = 1. alors m b - p a = 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1617. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c \\in N$. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Då för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är det största gemensama delaret av $p$ och $m$ lika med skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (smrd : Eq (gcd p m) 1) -> (c : Nat) -> (nm : Eq (prod m n) (prod p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> Eq (prod a p) (prod b m))) -> (H : Eq (minus (prod a p) (prod b m)) (prod p c)) -> (H0 : Eq (minus (prod b m) (prod a p)) (prod p c)) -> (H1 : Eq (gcd p m) (gcd a m)) -> (H2 : Eq (gcd a p) (gcd b m)) -> (H3 : Eq (gcd p m) (gcd a m)) -> (H4 : Eq (gcd a p) (gcd b m)) -> (H5 : Eq (gcd p m) (gcd a m)) -> Eq (gcd p m) (gcd a m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_max_f_max_g. Soient $f$ et $g$ des fonctions des nombres naturels à des valeurs booléennes. Soit $n \\in N$. Soit $__$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $f$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $g$ appliqué à $i$ et de $true$. Alors $max$ appliqué à $n$ et $f$ est inférieur ou ágal à $max$ appliqué à $n$ et $g$.\nAssistant:", "label": "postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> Leq (max n f) (max n g)", "predict": "postulate le_max_f_max_g : (f : (_ : Nat) -> bool) -> (g : (_ : Nat) -> bool) -> (n : Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (f i) true) -> Eq (g i) true) -> and (min (max n f) (max n g)) (min (max n g) f)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_inv_O. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b2$ be elements of $B$. Let $__$ be an element of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$. Assume that $0 = l$. Then $b1 = b2$.\nAssistant:", "label": "postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (__1 : Eq 0 l) -> Eq b1 b2", "predict": "postulate lstar_inv_O : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar B R l b1 b2) -> (posn : Eq 0 l) -> Eq b1 b2"}
{"prompt": "Human: Translate the following French statement into Agda.\nProd_rect_Type4_body. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Alors pour toutes les fonctions $Q_$ des éléments $_x_692$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $univs.Type4$, pour toutes les fonctions $_H_mk_Prod$ des éléments $_fst$ de $cic.Term$ de $univs.Type0$ et de $_A$ et des éléments $_snd$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $univs.Type4$ et de $Q_$ appliqué à $matita_basics_types.mk_Prod$ appliqué à $_A$ et $_B$ et $_fst$ et $_snd$, pour tous les éléments $x_692$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Prod$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $univs.Type4$ et $Q_$ appliqué à $x_692$.\nAssistant:", "label": "postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)", "predict": "postulate Prod_rect_Type4_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Univ univs.Type4) -> (_H_mk_Prod : (_fst : cic.Term univs.Type0 _A) -> (_snd : cic.Term univs.Type0 _B) -> cic.Term univs.Type4 (Q_ (matita_basics_types.mk_Prod _A _B _fst _snd))) -> (x_692 : cic.Term univs.Type0 (matita_basics_types.Prod _A _B)) -> cic.Term univs.Type4 (Q_ x_692)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15441. Låt $p, q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $n$ är mindre än eller lika med $m$. Då om $n$ är mindre än eller lika med summan av $q$ och $1$, så om $n$ inte är delbart med $m$, så för alla naturliga tal $a$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$, för alla naturliga tal $b$, om skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ är lika med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ eller skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat", "label": "postulate let_clause_15441 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))", "predict": " påpostulate let_clause_15441 : let p, q : Nat -> let Hind : (m : Nat) -> (n : Nat) -> Lt 0 n -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjunk Eq (minus (times a n) (times b m)) (gcd_aux q m n)) Eq (minus (times b m) (times a n)) (gcd_aux q m n))) -> let m : Nat -> let n : Nat -> (posn : Lt 0 n) -> (nm : Eq n m) -> (Hind : (a : Nat) -> ex Nat (\\ b : Nat -> disjunk Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (Hindb : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (H : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> (H0 : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> Eq (times (gcd_aux q n (mod m n)) (gcd_aux q m n)) (gcd_aux q m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEnum_body. Låt $A$ vara en mängd. Låt $_xxx$ vara ett element av $range$ av $A$. Låt $_x_942 \\in N$. Då $A$.\nAssistant:", "label": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate enum_body : M (A : Set) -> (_xxx : range A) -> (_x_942 : N) -> (A : Set) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : letpostulate let A : Set -> range A -> (_ : A) -> (_ : Eq A (range A)) -> (_ : Eq (_ : range A) (A)) -> A) -> (_ : letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate letpostulate"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_Sfalse. Låt $k \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara en funktion från element av $B$ och element $__1$ av $B$ till element av $B$. Då för alla funktioner $f$ från naturliga tal till element av $B$, om kontradiktion är lika med $p (k)$, så är $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på summan av $k$ och $1$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) false) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate bigop_Sfalse : (k : Nat) -> (p : (_ : Nat) -> Prop) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0 < p$ and $1$ is equal to the greatest common divisor of $p$ and $m$. Assume that $p$ is divisible by $m \\times n$. Let $c$ be a natural number. Assume that $m n = p c$. Let $a$ be a natural number. Let $_clearme0$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$. Let $b$ be a natural number. Assume that the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or equal to $b m - a p$ and the greatest common divisor of $p$ and $m$ is equal to $b m - a p$. Then if $b m - a p = 1$, then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (divnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (cn : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (H : Eq (gcd p m) a p - b m) -> (H0 : Eq (gcd p m) b m - a p) -> (H1 : Eq (gcd p m) b m - a p) -> (H2 : Eq (gcd p m) (gcd a m) (gcd b m)) -> (H3 : Eq (gcd p m) a m -> Eq (gcd a m) (gcd b m)) -> (H4 : Eq (gcd p m) b m -> Eq (gcd a m) (gcd b m)) -> (H5 : Eq (gcd p m) (gcd a b) (gcd b m)) -> (H6 : Eq (gcd p m) a b -> Eq (gcd a b) (gcd b m)) -> Eq (gcd p m) (gcd a b)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1062. Soit $a, b, q, r, q1, r1 \\in N$. Soit $_clearme$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q$ et de $r$. Supposons que $r$ est inférieur à $b$. Supposons que $a$ est égal à la somme du produit de $q$ et de $b$ et de $r$. Soit $_clearme0$ un élément de $div_mod_spec$ de $a$ et de $b$ et de $q1$ et de $r1$. Alors si $r1$ est inférieur à $b$, alors si $a$ est égal à la somme du produit de $q1$ et de $b$ et de $r1$, alors si $q$ n'est pas inférieur ou ágal à $q1$, alors $a$ est égal à la somme de $r1$ et du produit de $b$ et de $q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : soit a, b, q, r, q1, r1 \\in N"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $Hle$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p (n1)= true$. Soient $x2515$ et $x2516$ des nombres naturels. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))) -> (Hle : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> (Hcase : Eq (p n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : soit n : Nat Soit p : (_ : Nat) -> bool Soient g1 : (_ : Nat) -> Nat Soient g2 : (_ : Nat) -> n1 : Nat Soit Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (_ : __1 : Eq p i) -> Leq g1 i) -> (g2 : (_ : Nat) -> Leq bigop n1 (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) -> (Hle : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq p i) -> Leq g1 i) -> (Hle0 : p n1) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_smallest_factor_n. Let $n$ be a natural number. Then $smallest_factor$ applied to $n$ is less than or equal to $n$.\nAssistant:", "label": "postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n", "predict": "postulate le_smallest_factor_n : (n : Nat) -> Leq (smallest_factor n) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_sqrt_to_le_times_l. Låt $m, n \\in N$. Då om $n \\leq \\sqrt{ m}$, så $n n \\leq m$.\nAssistant:", "label": "postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> (_ : Leq n (sqrt m)) -> Leq (times n n) m", "predict": "postulate le_sqrt_to_le_times_l : (m : Nat) -> (n : Nat) -> då om n <= sqrt m, så n n le m"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_p_ord. Let $p$ and $a$ and $b$ and $c$ and $d$ and $n$ and $m$ be natural numbers. Assume that $0 < n$. Then if $0 < m$, then if $p$ is prime, then if $n$ is divisible by $m$, then if $p_ord (n, p)= mk_Prod (Nat, Nat, a, b)$, then if $p_ord (m, p)= mk_Prod (Nat, Nat, c, d)$, then $b$ is divisible by $d$ and $a \\leq c$.\nAssistant:", "label": "postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : Eq (p_ord n p) (mk_Prod Nat Nat a b)) -> (__5 : Eq (p_ord m p) (mk_Prod Nat Nat c d)) -> and (divisible b d) (Leq a c)", "predict": "postulate divides_to_p_ord : (p : Nat) -> (a : Nat) -> (b : Nat) -> (c : Nat) -> (d : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> (__4 : p_ord n p) -> (__5 : p_ord m p) -> and (divisible b d) (and (Leq a c) (Gt d c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_false_to_le_max. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, p \\in N$. Då för alla element $__$ av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och $Eq$ applicerat på $f$ applicerat på $i$ och $true$, för alla funktioner $__1$ från naturliga tal $m$ och element $__1$ av $Lt$ av $p$ och $m$ till element av $Eq$ av $f (m)$ och kontradiktion, $max (n, f)\\leq p$.\nAssistant:", "label": "postulate f_false_to_le_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (p : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) false) -> Leq (max n f) p", "predict": "postulate f_false_to_le_max : (f : (_ : Nat) -> Sann) -> (n : Nat) -> (p : Nat) -> (ex : Nat -> (_ : Eq (f n) true) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) (contradiction)) -> max n f) -> (x : Nat) -> (__1 : (m : Nat) -> (__1 : Lt p m) -> Eq (f m) (contradiction)) -> Leq (max n f) p"}
{"prompt": "Human: Translate the following English statement into Agda.\nFound_max_spec. Let $n$ be a natural number. Let $f$ be a function from natural numbers to booleans. Let $m \\in N$. Then if $m < n$ and $f (m)= true$, then for all functions $__2$ from natural numbers $i$ and elements $__2$ of $Lt$ of $m$ and $i$ and elements $__3$ of $Lt$ of $i$ and $n$ to elements of $Eq$ of $f (i)$ and absurdity, $max_spec$ holds for $n$ and $f$ and $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (f' : (_ : Nat) -> bool) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1068. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i$ and $j$ be natural numbers. Assume that $i \\leq n$ and $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b \\in N$. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Assume that $f (b)= j$. Let $__$ be a function from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$. Then for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (len : Leq i n) -> (lenj : Leq j n) -> (a : Nat) -> (le : Leq a n) -> (fa : i) -> (b : Nat) -> (leb : Leq b n) -> (fb : b) -> (_ : (_ : Nat) -> Leq i0 n) -> Leq (f i0) n -> letinjf : injn f n -> (Hind : Eq a b) -> f a"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_m. Let $f$ be a function from natural numbers to booleans. Then for all natural numbers $n$ and $b$, $Nat$.\nAssistant:", "label": "postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat", "predict": "postulate let_m : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_Aop. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $return_sort$ vara ett element av $cic.Sort$. Låt $return_type$ vara en funktion från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $return_sort$. Då för alla funktioner $return$ från element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (return : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_Aop : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ return_sort) -> (z : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term return_sort (return_type z) (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_or_ge. Soit $m, n \\in N$. Alors $m$ est inférieur ou ágal à $n$ ou $n$ est inférieur ou ágal à $m$.\nAssistant:", "label": "postulate le_or_ge : (m : Nat) -> (n : Nat) -> or (Leq m n) (Leq n m)", "predict": "postulate le_or_ge : (m : Nat) -> (n : Nat) -> or (Lt m n) (Lt n m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15622. Soient $m$ et $n$ et $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $posm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $m$. Soit $pnm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $d$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $d$ et $m$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Alors pour tous les éléments", "label": "postulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita", "predict": " depostespostulate let_clause_15622 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (pnm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd n m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ d : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times c n) (matita_arithmetics_nat.times d m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))) -> (H : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times d m) (matita_arithmetics_nat.times c n)) (matita_arithmetics_nat.S mat"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_ord. Soient $p$ et $n$ des nombres naturels. Alors si $1$ est inférieur à $p$, alors si $0$ est inférieur à $n$, alors $n$ est égal au produit de la puissance de $p$ et de $ord$ appliqué à $n$ et $p$ et de $ord_rem$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate exp_ord : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))", "predict": "postulate exp_ord : sont : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Eq n (times (pow p (ord n p)) (ord_rem n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_log2_sqrt. Soit $n$ un nombre naturel. Supposons que $2 ^ 6 \\leq n$. Alors $\\log_ 2 {n}< \\sqrt{ n}$.\nAssistant:", "label": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)", "predict": "postulate lt_log2_sqrt : soit n un nombre naturel. supposons 2^6 <= n. alors log_ 2 {n} < sqrt n."}
{"prompt": "Human: Translate the following French statement into Agda.\nDistr. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $A$, pour tous les éléments $xxx$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $A$ et $nil$, pour tous les éléments $a$ et $b$ et $c$ de $cic.Term$ de $univs.Type0$ et de $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $nil$ et $matita_arithmetics_bigops.sum$ appliqué à $A$ et $nil$ et $xxx$ et $b$ et $c$ et $matita_arithmetics_bigops.aop__o__op$ appliqué à $A$ et $nil$ et $matita_arithmetics_bigops.sum$ appliqué à $A$ et $nil$ et $xxx$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $b$ et $matita_arithmetics_bigops.prod$ appliqué à $A$ et $nil$ et $xxx$ et $a$ et $c$.\nAssistant:", "label": "postulate distr : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))", "predict": "postulate distr : soit A un elemente de cic.Univ univs.Type0. Alors pour tous les elements nil de cic.Term univs.Type0 A. pour tous elements xxx de cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A nil). pour tous elements a et b et c de cic.Term univs.Type0 A. cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.prod A nil xxx a (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) b c)) (matita_arithmetics_bigops.aop__o__op A nil (matita_arithmetics_bigops.sum A nil xxx) (matita_arithmetics_bigops.prod A nil xxx a b) (matita_arithmetics_bigops.prod A nil xxx a c)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_ind_aux. Låt $A$ vara en mängd. Låt $f$ vara en funktion från element av $A$ till naturliga tal. Låt $P$ vara ett element av $predicate$ av $A$. Låt $__$ vara en funktion från naturliga tal $n$ och funktioner från element $a$ av $A$ och element av $Lt$ av $f$ applicerat på $a$ och $n$ till element av $P$ av $a$ och element $a$ av $A$ och element $__1$ av $Eq$ av $f$ applicerat på $a$ och $n$ till element av $P$ av $a$. Låt $n$ vara ett naturligt tal. Låt $a$ vara ett element av $A$. Anta att $f$ applicerat på $a$ är lika med $n$. Då håller $P$ för $a$.\nAssistant:", "label": "postulate f_ind_aux : (A : Set) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a", "predict": "postulate f_ind_aux : (A : Mngd) -> (f : (_ : A) -> Nat) -> (P : predicate A) -> (_ : (n : Nat) -> (_ : (a : A) -> (_ : Lt (f a) n) -> P a) -> (a : A) -> (__1 : Eq (f a) n) -> P a) -> (n : Nat) -> (a : A) -> (__1 : Eq (f a) n) -> P a"}
{"prompt": "Human: Translate the following French statement into Agda.\nAxiome. Soit $__$ un nombre naturel. Alors le successeur de $__$ est un nombre naturel.\nAssistant:", "label": "postulate succ : (_ : Nat) -> Nat", "predict": "postulate succ : (_ : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAppend_l2_injective_r. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $l1$ och $l2$ och $l3$ och $l4$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $A$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l3$ och $matita_basics_lists_list.length$ applicerat på $A$ och $l4$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l1$ och $l3$ och $matita_basics_lists_list.append$ applicerat på $A$ och $l2$ och $l4$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_lists_list.list$ applicerat på $A$ och $l3$ och $l4$.\nAssistant:", "label": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)", "predict": "postulate append_l2_injective_r : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l3 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l4 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_basics_lists_list.length A l3) (matita_basics_lists_list.length A l4))) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l3) (matita_basics_lists_list.append A l2 l4))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) l3 l4)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_881$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Aop", "label": "postulate Aop_rect_CProp2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_881)", "predict": "postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> (Q_ : (x_881 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H : cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op __ __1) __1 __2 __3 __4 __5 __6 __7 __8 __9 __10 __11 __12 __13 __14 __15 __16 __17 __18 __19 __20 __21 __22 __23 __24 __25 __26 __27 __28 __29 __30 __31 __32 __33 __34 __35 __36 __37 __38 __39 __40 __41 __42 __43 __44 __45 __46 __47 __48 __49 __50 __51 __52 __53 __54 __55 __56 __57 __58 __59 __60 __61 __62 __63 __64 __65 __66 __67 __68 __69 __"}
{"prompt": "Human: Translate the following French statement into Agda.\nFold_sum. Soient $A$ et $B$ des éléments de $cic.Univ$ de $univs.Type0$. Soient $I$ et $J$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Alors pour tous les éléments $op$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $I$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $J$ et $matita_basics_lists_list.fold$ appliqué à $A$ et $B$ et $matita_basics_lists_list.op$ appliqué à $B$ et $nil$ et $op$ et $nil$ et la fonction qui envoie $i$ à $matita_basics_bool.true$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_basics_lists_list.append$ appliqué à $A$ et $I$ et $J$.\nAssistant:", "label": "postulate fold_sum : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (I : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (J : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))", "predict": "postulate fold_sum : soit A B : cic.Univ univs.Type0\n    soit I J : cic.Term univs.Type0 (matita_basics_lists_list.list A)\n    soit nil : cic.Term univs.Type0 B\n  -> tous (op : cic.Term univs.Type0 (matita_basics_lists_list.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_basics_lists_list.op B nil op (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) I (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) J)) (matita_basics_lists_list.fold A B (matita_basics_lists_list.op B nil op) nil (\\ i : cic.Term univs.Type0 A -> matita_basics_bool.true) (\\ i : cic.Term univs.Type0 A -> f i) (matita_basics_lists_list.append A I J)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type0. Let $Hterm$ be a natural number. Let $P$ be a function from natural numbers $_z683$ to sets. Let $_H1$ be a function from elements $_z684$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Then for all functions $_H2$ from natural numbers $x_390$ and functions $_x_392$ from elements $_z684$ of $Eq$ of $Hterm$ and $x_390$ to elements of $P$ of $x_390$ and elements $_z684$ of $Eq$ of $Hterm$ and $x_390 + 1$ to elements of $P$ of $x_390 + 1$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm x_390 + 1) -> P x_390 + 1) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_inv_rect_Type3. Pour tous les nombres naturels $Hterm$, pour toutes les fonctions $P$ des nombres naturels $_z665$ à des éléments de $Type3$, pour toutes les fonctions $_H1$ des éléments $_z666$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_378$ et des fonctions $_x_380$ des éléments $_z666$ de $Eq$ de $Hterm$ et de $x_378$ à des éléments de $P$ de $x_378$ et des éléments $_z666$ de $Eq$ de $Hterm$ et de la somme de $x_378$ et de $1$ à des éléments de $P$ de la somme de $x_378$ et de $1$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type3 : (Hterm : Nat) -> (P : (_z665 : Nat) -> Type3) -> (_H1 : (_z666 : Eq Hterm 0) -> P 0) -> (_H2 : (x_378 : Nat) -> (_x_380 : (_z666 : Eq Hterm x_378) -> P x_378) -> (_z666 : Eq Hterm (plus x_378 1)) -> P (plus x_378 1)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Then for all natural numbers $n$, for all elements $permf$ of $permut$ of $f$ and $n$, for all natural numbers $i$ and $j$, if $i \\leq n$ and $j \\leq n$, then for all natural numbers $a$, if $a \\leq n$ and $f (a)= i$ and $a \\leq n$, then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$ and $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (lain : Leq a n) -> (fa : f a) -> (b : Nat) -> (lebn : Leq b n) -> (fb : f b) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq f (i0)) -> (injf : injn f n) -> (auto : Eq a b) -> f a"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_div_S. Let $n$ and $m$ be natural numbers. Assume that $0 < m$. Then $n < (n \\div m + 1)m$.\nAssistant:", "label": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (plus (div n m) 1) m)", "predict": "postulate lt_div_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Lt n (times (n div m) (plus 1 m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nNot_forall_to_exists. Soit $P$ une fonction des nombres naturels à des propositions. Alors pour tous les nombres naturels $n$, pour toutes les fonctions $__$ des nombres naturels $i$ à des éléments de $decidable$ de $P$ appliqué à $i$, s'il n'est pas le cas que $prod$ tienne pour $Set$ et $Prop$ et $Nat$ et la fonction qui envoie $i$ à $prod$ appliqué à $Prop$ et $Prop$ et $Lt$ appliqué à $i$ et $n$ et la fonction qui envoie $__1$ à $P$ appliqué à $i$, alors $ex$ tient pour $Nat$ et la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de la négation de $P$ appliqué à $i$.\nAssistant:", "label": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))", "predict": "postulate not_forall_to_exists : soit P : (_ : Nat) -> Prop -> (n : Nat) -> (__ : (i : Nat) -> decidable (P i)) -> (__1 : P i) -> ex Nat (\\ i : Nat -> conj (Lt i n) (\\ __1 : P i -> P i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_log2_sqrt. Låt $n \\in N$. Då om $2 ^ 6 \\leq n$, så $\\log_ 2 {n}< \\sqrt{ n}$.\nAssistant:", "label": "postulate lt_log2_sqrt : (n : Nat) -> (_ : Leq (pow 2 6) n) -> Lt (log 2 n) (sqrt n)", "predict": "postulate lt_log2_sqrt : let n : Nat in då om 2^6 <= n then \\log_ 2 {n} < sqrt n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_inv_lstar. För alla mängder $B$, för alla element $R$ av $relation$ av $B$, för alla naturliga tal $l$, för alla element $b1$ och $b2$ av $B$, för alla element $__$ av $lstar_r$ av $B$ och $R$ och $l$ och $b1$ och $b2$, håller $lstar$ för $B$ och $R$ och $l$ och $b1$ och $b2$.\nAssistant:", "label": "postulate lstar_r_inv_lstar : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar_r B R l b1 b2) -> lstar B R l b1 b2", "predict": "postulate lstar_r_inv_lstar : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b2 : B) -> (_ : lstar_r B R l b1 b2) -> lstar B R l b1 b2"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_gcd_times_1. Let $p$ and $n$ and $m$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $p$ and $n$. Then if $1$ is equal to the greatest common divisor of $p$ and $m$, then $1$ is equal to the greatest common divisor of $p$ and the product of $n$ and $m$.\nAssistant:", "label": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1", "predict": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq 1 (gcd p n)) -> (__2 : Eq 1 (gcd p m)) -> Eq 1 (gcd p (times n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_S_times_2. Soit $n$ un nombre naturel. Supposons que $0 < n$. Alors $n + 1 \\leq 2 n$.\nAssistant:", "label": "postulate le_S_times_2 : (n : Nat) -> (_ : Lt 0 n) -> Leq (plus n 1) (times 2 n)", "predict": "postulate le_S_times_2 : soit n un nombre naturel. supposons que 0 < n. alors n + 1 <= 2 n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLeb_elim. Låt $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $P$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Då för alla funktioner $__$ från element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$, för alla funktioner $__1$ från element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $matita_arithmetics_nat.le$ applicerat på $n$ och $m$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $matita_arithmetics_nat.leb$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate leb_elim : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))", "predict": "postulate let : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (P : (__ : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (__ : (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> cic.Term cic.prop (P (matita_basics_bool.true))) -> (__1 : (__1 : cic.Term cic.prop (matita_basics_logic.Not (matita_arithmetics_nat.le n m))) -> cic.Term cic.prop (P (matita_basics_bool.false))) -> cic.Term cic.prop (P (matita_arithmetics_nat.leb n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLhd_cons_ltl. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Alors pour tous les éléments $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_lists_list.list$ appliqué à $A$ et $matita_basics_lists_list.append$ appliqué à $A$ et $matita_basics_lists_list.lhd$ appliqué à $A$ et $l$ et $n$ et $matita_basics_lists_list.ltl$ appliqué à $A$ et $l$ et $n$ et $l$.\nAssistant:", "label": "postulate lhd_cons_ltl : (A : cic.Univ univs.Type0) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)", "predict": "postulate lhd_cons_ltl : soit A un element de cic.Univ univs.Type0. Alors pour tous les elements n de cic.Term univs.Type0 matita_arithmetics_nat.nat, pour tous les elements l de cic.Term univs.Type0 (matita_basics_lists_list.list A), cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A (matita_basics_lists_list.lhd A l n) (matita_basics_lists_list.ltl A l n)) l)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNot_divides_S_fact. Let $n$ and $i$ be natural numbers. Assume that $1 < i$ and $i \\leq n$. Then $i$ is not divisible by $n! + 1$.\nAssistant:", "label": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (__1 : Leq i n) -> not (divisible i (plus (factorial n) 1))", "predict": "postulate not_divides_S_fact : (n : Nat) -> (i : Nat) -> (_ : Lt 1 i) -> (le_n : Leq i n) -> not (divisible i (plus (pow n i) 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_discr. Låt $a1$ vara en mängd. Låt $a2$ vara ett element av $a1$. Låt $x$ och $y$ vara element av $Aop$ av $a1$ och $a2$. Anta att $x$ är lika med $y$. Då håller $match_Aop$ för $a1$ och $a2$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar", "label": "postulate Aop_discr : (a1 : Set) -> (a2 : a1) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> (_e : Eq x y) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ t0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t1 : ((a : a1) -> Eq (t0 a2 a) a) -> \\ t2 : ((a : a1) -> Eq (t0 a a2) a) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t0 a (t0 b c)) (t0 (t0 a b) c)) -> match_Aop a1 a2 (plus Type2 1) (\\ _ : Aop a1 a2 -> univ Type2) (\\ u0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u1 : ((a : a1) -> Eq (u0 a2 a) a) -> \\ u2 : ((a : a1) -> Eq (u0 a a2) a) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u0 a (u0 b c)) (u0 (u0 a b) c)) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0) (\\ e0 : Eq (R0 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0) u0 -> prod Prop Type1 (Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1) (\\ e1 : Eq (R1 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x_19 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ p0 : Eq t0 x0 -> prod Set Prop a1 (\\ a : a1 -> Eq (x0 a2 a) a)) x_19 _x_20) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t0 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ _ : Eq t0 x0 -> (\\ x01 : ((__1 : a1) -> (__2 : a1) -> a1) -> \\ p0 : Eq t0 x01 -> prod Set Prop a1 (\\ a : a1 -> Eq (x01 a2 a) a)) x0 __) t1 (\\ x0 : ((_ : a1) -> (__1 : a1) -> a1) ->", "predict": "postulate låt : (a1 : Mngd) -> (a2 : Mngd) -> (x : Aop a1 a2) -> (y : Aop a1 a2) -> Eq x y"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_mod_to_divides. Soient $n$ et $m$ et $q$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $q$. Alors pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $n$ et $q$ et $matita_arithmetics_div_and_mod.mod$ appliqué à $m$ et $q$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $q$ et $matita_arithmetics_nat.minus$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))", "predict": "postulate eq_mod_to_divides : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O q)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_div_and_mod.mod n q) (matita_arithmetics_div_and_mod.mod m q))) -> cic.Term cic.prop (matita_arithmetics_primes.divides q (matita_arithmetics_nat.minus n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nUnit_inv_rect_Type2. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$. Let $P$ be a function from elements $_z924$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.unit$ to elements of $cic.Univ$ of $univs.Type2$. Let $_H1$ be a function from elements $_z925$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.unit$ and $Hterm$ and $matita_basics_types.it$ to elements of $cic.Term$ of $univs.Type2$ and $P$ applied to $matita_basics_types.it$. Then $cic.Term$ holds for $univs.Type2$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate unit_inv_rect_Type2 : (Hterm : cic.Term univs.Type0 matita_basics_types.unit) -> (P : (_z924 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H1 : (_z925 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_types.unit) Hterm matita_basics_types.it)) -> cic.Term univs.Type2 (P matita_basics_types.it)) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type4. Låt $Q_$ vara en funktion från naturliga tal $_x_369$ till element av $Type4$. Låt $_H_O$ vara ett element av $Q_$ av $0$. Då för alla funktioner $_H_S$ från naturliga tal $x_370$ och element $_x_372$ av $Q_$ av $x_370$ till element av $Q_$ av summan av $x_370$ och $1$, för alla naturliga tal $x_369$, håller $Q_$ för $x_369$.\nAssistant:", "label": "postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369", "predict": "postulate nat_rect_Type4 : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (x_370 : Nat) -> (_x_372 : Q_ x_370) -> (x_369 : Nat) -> Q_ x_369"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter_True. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Univ$ of $return_sort$. Let $return$ be a function from elements $z$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $z$. Let $z$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.True$. Then $cic.Term$ holds for $return_sort$ and $return_type$ applied to $z$.\nAssistant:", "label": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound5. Soit $n, m \\in N$. Alors si $nth_prime$ appliqué à $n$ est inférieur à $m$, alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound5 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound5 : soit n, m : Nat -> alors (nth_prime n) < m -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDPair_inv_rect_Type0. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1134$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type0$. Then for all functions $_H1$ from elements $dpi1$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $_dpi2$ of $cic.Term$ of $univs.Type0$ and $x2$ applied to $dpi1$ and elements $_z1135$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.DPair$ applied to $x1$ and $x2$ and $Hterm$ and $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$ to elements of $cic.Term$ of $univs.Type0$ and $P$ applied to $matita_basics_types.mk_DPair$ applied to $x1$ and $x2$ and $dpi1$ and $_dpi2$, $cic.Term$ holds for $univs.Type0$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)", "predict": "postulate DPair_inv_rect_Type0 : (x1 : cic.Univ univs.Type0) -> (x2 : (__ : cic.Term univs.Type0 x1) -> cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> (P : (_z1134 : cic.Term univs.Type0 (matita_basics_types.DPair x1 x2)) -> cic.Univ univs.Type0) -> (_H1 : (dpi1 : cic.Term univs.Type0 x1) -> (_dpi2 : cic.Term univs.Type0 (x2 dpi1)) -> (_z1135 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.DPair x1 x2)) Hterm (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P (matita_basics_types.mk_DPair x1 x2 dpi1 _dpi2))) -> cic.Term univs.Type0 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $m$ är lika med $1$. Anta att $p$ är delbart med produkten av $m$ och $n$. Låt $c$ vara ett naturligt tal. Anta att produkten av $m$ och $n$ är lika med produkten av $p$ och $c$. Låt $a \\in N$. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$ eller skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ är lika med det största gemensama delaret av $p$ och $m$. Då om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med det största gemensama delaret av $p$ och $m$, så om skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ är lika med $1$, så är skillnaden mellan produkten av $p$ och $a$ och produkten av $m$ och $b$ lika med $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : let p m n : Nat\n  and (Lt 0 p) (Eq (gcd p m) 1) (Eq p (times m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPermut_invert_permut. For all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $f$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.permut$ applied to $matita_arithmetics_permutation.invert_permut$ applied to $n$ and $f$ and $n$.\nAssistant:", "label": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)", "predict": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p$ and $m$ and $n$ be natural numbers. Then if $0 < p$, then if $1$ is equal to the greatest common divisor of $p$ and $m$, then if $p$ is divisible by $m \\times n$, then for all natural numbers $c$, if $m n = p c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the greatest common divisor of $p$ and $m$ is equal to $a p - b m$ or the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if the greatest common divisor of $p$ and $m$ is equal to $b m - a p$, then if $b m - a p = 1$, then $m b - p a = 1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq 1 (gcd p m)) -> (_clearme : divisible p m) -> (c : Nat) -> (nm : Eq m n) -> (cn : Eq p m \\* n) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (gcd p m) (a p - b m)) (Eq (gcd p m) (b m - a p))) -> (H : Eq (gcd p m) (b m - a p)) -> (H0 : Eq b m - a p) -> Eq m b - p a"}
{"prompt": "Human: Translate the following French statement into Agda.\nNat_inv_rect_Type2. Soit $Hterm$ un nombre naturel. Alors pour toutes les fonctions $P$ des nombres naturels $_z671$ à des éléments de $Type2$, pour toutes les fonctions $_H1$ des éléments $_z672$ de $Eq$ de $Hterm$ et de $0$ à des éléments de $P$ de $0$, pour toutes les fonctions $_H2$ des nombres naturels $x_382$ et des fonctions $_x_384$ des éléments $_z672$ de $Eq$ de $Hterm$ et de $x_382$ à des éléments de $P$ de $x_382$ et des éléments $_z672$ de $Eq$ de $Hterm$ et de la somme de $x_382$ et de $1$ à des éléments de $P$ de la somme de $x_382$ et de $1$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type2 : (Hterm : Nat) -> (P : (_z671 : Nat) -> Type2) -> (_H1 : (_z672 : Eq Hterm 0) -> P 0) -> (_H2 : (x_382 : Nat) -> (_x_384 : (_z672 : Eq Hterm x_382) -> P x_382) -> (_z672 : Eq Hterm (plus x_382 1)) -> P (plus x_382 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type2 : soit Hterm un nombre naturel. Alors pour toutes les fonctions P des nombres naturels _z671 à des éléments de Type2, pour toutes les fonctions _H1 des éléments _z672 de Eq Hterm 0 à des éléments de P 0, pour toutes les fonctions _H2 des nombres naturels x_382 et des fonctions _x_384 des éléments _z672 de Eq Hterm x_382 à des éléments de P x_382 et des éléments _z672 de Eq Hterm (plus x_382 1) à des éléments de P (plus x_382 1), P Hterm."}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind. Let $_n, _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075$ be a natural number. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp0. Låt $_A$ vara ett element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_115$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_nmk$ vara en funktion från funktioner $x_116$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_116$. Då för alla element $x_115$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_115$.\nAssistant:", "label": "postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)", "predict": "postulate Not_rect_CProp0 : (_A : cic.Univ cic.prop) -> (Q_ : (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_116 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) -> (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_115)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_to_or_lt_eq. Låt $n$ och $m$ vara naturliga tal. Anta att $n \\leq m$. Då $n < m$ eller $n = m$.\nAssistant:", "label": "postulate le_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> or (Lt n m) (Eq n m)", "predict": "postulate let_to_or_lt_eq : (n : Nat) -> (m : Nat) -> (ltml : Lt n m) -> or (and (Ltml n m) (and (Leq n m) (Eq n m)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_times_gcd_aux. Soient $p$ et $m$ et $n$ et $d$ et $c$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $c$. Soit $__1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$. Soit $__3$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $p$. Soit $__4$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $m$. Soit $__5$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_nat.times$ appliqué à $c$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $p$ et $m$ et $n$.\nAssistant:", "label": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))", "predict": "postulate divides_times_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O c)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__3 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c m))) -> (__5 : cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c n))) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_nat.times c (matita_arithmetics_gcd.gcd_aux p m n)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLength_unique_le. Let $n$ be a natural number. Let $l$ be a list of natural numbers. Then for all elements $__$ of $unique$ of $Nat$ and $l$, for all functions $__1$ from natural numbers $x$ and elements $__1$ of $mem$ of $Nat$ and $x$ and $l$ to elements of $Lt$ of $x$ and $n$, $length (Nat, l)\\leq n$.\nAssistant:", "label": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n", "predict": "postulate length_unique_le : (n : Nat) -> (l : list Nat) -> (_ : unique Nat l) -> (__1 : (x : Nat) -> (__1 : mem Nat x l) -> Lt x n) -> Leq (length Nat l) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_exp1. Pour tous les nombres naturels $p$ et $n$ et $q$ et $r$, si $0 < p$ et $p$ n'est pas divisible par $r$, alors si $n = p ^ q r$, alors $p_ord (n, p)= mk_Prod (Nat, Nat, q, r)$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)", "predict": "postulate p_ord_exp1 : tous les nombres naturels p et n et q et r et (si 0 < p et p n'est pas divisible par r) (si n = p ^ q r) alors p_ord (n, p) = mk_Prod Nat Nat q r"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1607. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posd : Eq (minus (times c n) (times d m)) 1) -> (H : Eq (minus (times c n) (times d m)) (times c n)) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (gcd m n) (minus (times m d) (times n c))) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1544. Låt $p$ och $q$ vara naturliga tal. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Låt $m, n \\in N$. Anta att $0$ är mindre än $n$. Anta att $n$ är mindre än eller lika med $m$. Anta att $n$ är mindre än eller lika med summan av $q$ och $1$. Anta att $n$ inte är delbart med $m$. Låt $a$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$. Låt $b \\in N$. Anta att skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ är lika med $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ eller skillnaden mellan produkten av $b$ och $n$ och produkten av $", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "apostulate let_clause_1544 : let p q : Nat -> let Hind : (m : Nat) -> (n : Nat) -> Lt 0 n -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjunk (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> let m : Nat -> let n : Nat -> (posn : Lt 0 n) -> (same : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (b : Nat) -> (Hindb : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind0 : Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) -> (Hind1 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind2 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind3 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind4 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind5 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind6 : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> (Hind7 : Eq (minus (times a b) (times n m)) (gcd_aux q n (mod m n))) -> (Hind8"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_to_not_le. Soient $n$ et $m$ des nombres naturels. Supposons que $n$ est inférieur à $m$. Alors $m$ n'est pas inférieur ou ágal à $n$.\nAssistant:", "label": "postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (_ : Lt n m) -> not (Leq m n)", "predict": "postulate lt_to_not_le : (n : Nat) -> (m : Nat) -> (posn : Lt n m) -> not (Leq m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16002. Låt $m, n, a, b \\in N$. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Då om det största gemensama delaret av $n$ och $m$ är lika med $1$, så för alla naturliga tal $c$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så om skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$, så är det största gemensama delaret av $m$ och $n$ lika med skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : let m n a b : N -> anta that 0 < n -> anta that 0 < m -> då (smilarsoma n m) (samep (samep n m) 1) (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : ex Nat (\\ e : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (H : Eq (minus (times c n) (times d m)) (times (times d m) (times c n))) -> (H0 : Eq (minus (times d m) (times c n)) 1) -> (H1 : Eq (times (times d m) (times c n)) 1) -> Eq (smilarsoma m n) (minus (times m n) (times d m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16171. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a$ un nombre naturel. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Alors pour tous les nombres naturels $b$, si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $b m - a p$, alors si $b m - a p = 1$, alors $m b - p a$ est égal au diviseur commun plus grand de $p$ et de $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (eqn : Eq 1 (div (comm : max p m) m)) -> (c : Nat) -> (posm : Eq m n) -> (c0 : ex Nat (\\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : max p m) m)) (Eq (minus (times b m) (times a p)) (div (comm : max p m) m)))) -> (b : Nat) -> (_clearme0 : ex Nat (\\ _ : Nat -> Eq m n)) -> (posn : Eq (div p m) a) -> (H : Eq (div p m) b) -> (H0 : Eq (div p m) b) -> (H1 : Eq m n) -> (H2 : Eq b m) -> Eq (div p m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_rect_CProp0. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_885$ de $Aop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_nill$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $_nil$ et $a$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $_nil$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et de $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $Q_$ de $mk_Aop$ appliqué à $A$ et $_nil$ et $op$ et $_nill$ et $_nilr$ et $_assoc$, pour tous les éléments $x_885$ de $Aop$ de $A$ et de $_nil$, $Q_$ tient pour $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate Aop_rect_CProp0 : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be a natural number. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n (_n)$. Then for all functions $case_le_S$ from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of $m + 1$ and $le_S (_n, m, __)$, for all natural numbers $__$, if $_n \\leq __$, then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type m + 1) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type2. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_869$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type2$. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type2$ och $Q_$ applicerat på", "label": "postulate Aop_rect_Type2 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)", "predict": "postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type2) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type2 (Q_ (op (op a b) c))) -> (x_869 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type2 (Q_ x_869)"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_41. Nous pouvons démontrer que la somme de la somme de la puissance de $n$ et de $2$ et du produit de $3$ et de $n$ et de $5$ est impaire pour chaque entier $n$.\nAssistant:", "label": "postulate noLabel_41 : all Int (\\ n -> odd (plus (plus (pow n 2) (times 3 n)) 5))", "predict": "postulate noLabel_41 : Nous pouvons démontrer que la somme de la somme de la puissance de n et de 2 et du produit de 3 et de n et de 5 est impaire pour chaque entier n."}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I_gen. For all elements $a$ and $b$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all functions $p$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$, for all elements $B$ of $cic.Univ$ of $univs.Type0$, for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita_arithmetics_big", "label": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp0_body. För alla element $_n$ och $_m$ och $_q$ och $_r$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla funktioner $Q_$ från element $_x_857$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_div_mod_spec_intro$ från element $x_859$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $_r$ och $_m$ och element $x_858$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $_n$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $_q$ och $_m$ och $_r$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $_n$ och $_m$ och $_q$ och $_r$ och $x_859$ och $x_858$, för alla element $x_857$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $_n$ och $_m$ och $_q$ och $_r$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_857$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)", "predict": "postulate div_mod_spec_rect_CProp0_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_r : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Univ cic.prop) -> (_H_div_mod_spec_intro : (x_859 : cic.Term cic.prop (matita_arithmetics_nat.lt _r _m)) -> (x_858 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _n (matita_arithmetics_nat.plus (matita_arithmetics_nat.times _q _m) _r))) -> cic.Term cic.prop (Q_ (matita_arithmetics_div_and_mod.div_mod_spec_intro _n _m _q _r x_859 x_858))) -> (x_857 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec _n _m _q _r)) -> cic.Term cic.prop (Q_ x_857)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p2 (n1)= true$ et $p1 (n1)= true$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n un nombre naturel. soit (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : N) -> (Hind : (_ : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> true) -> (p2 : (_ : Nat) -> Eq i true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_Type4_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_891$ av $ACop$ av $A$ och $_nil$ till element av $Type4$. Då för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_891$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_891$.\nAssistant:", "label": "postulate ACop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_891 : ACop A _nil) -> Q_ x_891", "predict": "postulate ACop_rect_Type4_body : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_891 : ACop A _nil) -> Type4) -> (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> (x_891 : ACop A _nil) -> Q_ x_891"}
{"prompt": "Human: Translate the following French statement into Agda.\nTrue_inv_rect_CProp4. Soit $Hterm$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$. Soit $P$ une fonction des éléments $_z161$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H1$ des éléments $_z162$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $cic.prop$ et $univs.Type2$ et $matita_basics_logic.True$ et $Hterm$ et $matita_basics_logic.I$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_logic.I$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate True_inv_rect_CProp4 : (Hterm : cic.Term cic.prop matita_basics_logic.True) -> (P : (_z161 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H1 : (_z162 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I)) -> cic.Term cic.prop (P matita_basics_logic.I)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate True_inv_rect_CProp4 : soit Hterm un élément de cic.Term cic.prop matita_basics_logic.True ; Soit P une fonction des éléments _z161 de cic.Term cic.prop matita_basics_logic.True à des éléments de cic.Univ cic.prop ; Alors pour toutes les fonctions _H1 des éléments _z162 de cic.Term cic.prop matita_basics_logic.eq (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm matita_basics_logic.I à des éléments de cic.Term cic.prop (P matita_basics_logic.I) ; cic.Term cic.prop P matita_basics_logic.I"}
{"prompt": "Human: Translate the following French statement into Agda.\nOrd_times. Soit $p, m, n \\in N$. Supposons que $0$ est inférieur à $m$. Alors si $0$ est inférieur à $n$, alors si $p$ est premier, alors $ord$ appliqué à le produit de $m$ et de $n$ et $p$ est égal à la somme de $ord$ appliqué à $m$ et $p$ et de $ord$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : soit p, m, n : N -> supposons que 0 est inférieur a m. Alors si 0 est inférieur a n, alors si p est premier, alors ord applied to the product of m and n and p is equal to the plus of ord applied to m and p and ord applied to n and p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_rect_Type0. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_676$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type0$. Då för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type0$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_676$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $univs.Type0$ och $Q_$ applicerat på $x_676$.\nAssistant:", "label": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)", "predict": "postulate Sig_rect_Type0 : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type0) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ (matita_basics_types.mk_Sig A _pi1 _pi2) (_f _pi1) _pi2)) -> (x_676 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type0 (Q_ x_676)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc. Låt $A$ vara en mängd. Låt $nil$ vara ett element av $A$. Låt $xxx$ vara ett element av $Aop$ av $A$ och $nil$. Låt $a$ och $b$ och $c$ vara element av $A$. Då $op (A, nil, xxx, a, op (A, nil, xxx, b, c))= op (A, nil, xxx, op (A, nil, xxx, a, b), c)$.\nAssistant:", "label": "postulate assoc : (A : Set) -> (nil : A) -> (xxx : Aop A nil) -> (a : A) -> (b : A) -> (c : A) -> Eq (op A nil xxx a (op A nil xxx b c)) (op A nil xxx (op A nil xxx a b) c)", "predict": "postulate låt : (A : Mngd) -> (nil : Mngd) -> (xxx : Mngd A nil) -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngdpostulate låt : (A : Mngd) -> (nil : Mngd) -> (xxx : Mngd A nil) -> (a : Mngd) -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (b : Mngd) -> (c : Mngd) -> (op : (_ : A) -> (_ : nil) -> Mngd A nil -> Mngd A xxx -> (a : Mngd) -> (b : Mngd) -> ("}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15692. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0$ är mindre än $n$. Anta att $0$ är mindre än $m$. Anta att det största gemensama delaret av $n$ och $m$ är lika med $1$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ är lika med $1$ eller skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Anta att skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ är lika med $1$. Då är skillnaden mellan produkten av $m$ och $d$ och produkten av $n$ och $c$ lika med $1$.\nAssistant:", "label": "postulate let_clause_15692 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15692 : let m n a b : Nat\n  and ( Lt 0 n) ( Lt 0 m) ( Eq ( gcd n m) 1)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b, m \\in N$. Då för alla element $__$ av $min_spec$ av $n$ och $b$ och $f$ och $m$, är $min$ applicerat på $n$ och $b$ och $f$ lika med $m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m", "predict": "postulate min_spec_to_min : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (b : Nat) -> (m : Nat) -> (_ : min_spec n b f m) -> Eq (min n b f) m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLog_times_l. Let $p$ and $n$ and $m$ be natural numbers. Then if $0 < n$, then if $0 < m$, then if $1 < p$, then $\\log_ p {n}+ \\log_ p {m}\\leq \\log_ p {(n m)}$.\nAssistant:", "label": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (plus (log p n) (log p m)) (log p (times n m))", "predict": "postulate log_times_l : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Lt 1 p) -> Leq (log_ p n) (log_ p m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_sigma_p. For all natural numbers $n$, for all functions $p1$ and $p2$ from natural numbers to booleans, for all functions $g1$ and $g2$ from natural numbers to natural numbers, for all functions $__$ from natural numbers $i$ and elements of $Lt$ of $i$ and $n$ and elements $__1$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Eq$ of $p2 (i)$ and $true$, for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Lt$ of $i$ and $n$ and elements $__2$ of $Eq$ of $p1 (i)$ and $true$ to elements of $Leq$ of $g1 (i)$ and $g2 (i)$, for all elements $__2$ of $ex$ of $Nat$ and the function that maps $i$ to the conjunction of $Lt$ applied to $i$ and $n$ and the disjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and $true$ and $Lt$ applied to $g1$ applied to $i$ and $g2$ applied to $i$ and the conjunction of the conjunction of $Eq$ applied to $p1$ applied to $i$ and absurdity and $Eq$ applied to $p2$ applied to $i$ and $true$ and $Lt$ applied to $0$ and $g2$ applied to $i$, $bigop$ applied to $n$ and the function that maps $i$ to $p2$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g2$ applied to $i$ is less than $bigop$ applied to $n$ and the function that maps $i$ to $p1$ applied to $i$ and $Nat$ and $0$ and $plus$ and the function that maps $i$ to $g1$ applied to $i$.\nAssistant:", "label": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq p1 i) -> Eq p2 i) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq p1 i) -> Leq g1 i) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq p1 i) (Lt (g1 i) (g2 i))) (and (and (Eq p1 i) false) (Eq p2 i)) (Lt 0 (g2 i)))) -> Lt (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i)) (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nEq_fact_B. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_factorial.fact$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_exp.exp$ appliqué à $matita_arithmetics_factorial.fact$ appliqué à $n$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_chebyshev_factorization.B$ appliqué à $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$.\nAssistant:", "label": "postulate eq_fact_B : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate eq_fact_B : soit n : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_factorial.fact (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_nat.times (matita_arithmetics_exp.exp (matita_arithmetics_factorial.fact n) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) (matita_arithmetics_chebyshev_factorization.B (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16171. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0$ est inférieur à $p$. Supposons que le diviseur commun plus grand de $p$ et de $m$ est égal à $1$. Supposons que $p$ est divisible par le produit de $m$ et de $n$. Soit $c$ un nombre naturel. Supposons que le produit de $m$ et de $n$ est égal au produit de $p$ et de $c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Supposons que la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ est égale au diviseur commun plus grand de $p$ et de $m$ ou la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Supposons que la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale au diviseur commun plus grand de $p$ et de $m$. Alors si la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ est égale à $1$, alors le diviseur commun plus grand de $p$ et de $m$ est égal à la différence du produit de $m$ et de $b$ et du produit de $p$ et de $a$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (divcomm : Eq (gcd p m) 1) -> (div : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (divcomm p m)) (Eq (minus (times b m) (times a p)) (divcomm p m)))) -> (b : Nat) -> (_clearme1 : ex Nat (\\ _ : Eq (minus (times a p) (times b m)) (divcomm p m)) -> Eq (minus (times b m) (times a p)) (divcomm p m)) -> (H : Eq (minus (times b m) (times a p)) (divcomm p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (divcomm p m) (minus (times m b) (times p a))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_Type1. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_953$ de $Dop$ de $A$ et de $_nil$ à des éléments de $Type1$, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_953$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_953$.\nAssistant:", "label": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953", "predict": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b \\in N$. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Då om $f (b)= j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (H : Leq a n) -> (f a) = i) -> (b : Nat) -> (Hb : Leq b n) -> (f b) = j) -> (Hc : f b) -> (__ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (Hind : Eq a b) -> f a"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1544. Let $p, q \\in N$. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m$ and $n$ be natural numbers. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Then for all natural numbers $b$, if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$, then if $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$, then $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (nm : Leq n m) -> (nm0 : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (b : Nat) -> (Hind' : or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Hind : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind0 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind1 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind2 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n))) -> (Hind3 : (a : Nat) -> (b : Nat) -> or (Eq (minus (times a (mod m n)) b) (gcd_aux q n (mod m n)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1553. Låt $n, n0 \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $a$ som disjunktionen av $Eq$ applicerat på $n0$ och produkten av $2$ och $a$ och $Eq$ applicerat på $n0$ och summan av produkten av $2$ och $a$ och $1$. Låt $a \\in N$. Anta att $n0 = 2 a$ eller $n0 = 2 a + 1$. Anta att $n0 = 2 a + 1$. Då $n0 = a + (a + 1)$.\nAssistant:", "label": "postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (_clearme : ex Nat (\\ a : Nat -> or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (_clearme0 : or (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1))) -> (Hn : Eq n0 (plus (times 2 a) 1)) -> Eq n0 (plus a (plus a 1))", "predict": "postulate let_clause_1553 : (n : Nat) -> (n0 : Nat) -> (l : ex Nat (\\ a : Nat -> disjunkion (Eq n0 (times 2 a)) (Eq n0 (plus (times 2 a) 1)))) -> (a : Nat) -> (auto : or (Eq n0 2 a) (Eq n0 2 a + 1)) -> (auto' : Eq n0 2 a + 1) -> (auto'' : Eq n0 2 a) -> (auto''' : n0 = a + (a + 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_inv_rect_CProp3. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $x2$ vara ett element av $cic.Term$ av $univs.Type0$ och $x1$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1542$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x1$ och $x2$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $univs.Type0$ och $x1$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $x2$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $x1$ och $op$ applicerat på $a$ och $x2$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $b$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $c$ av $cic.Term$ av $univ", "label": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nInjective_compose. Låt $A$ och $B$ och $C$ vara element av $cic.Univ$ av $univs.Type0$. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $B$. Låt $g$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $C$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.injective$ applicerat på $A$ och $B$ och $f$, för alla element $__1$ av $cic.Term$ av $cic.prop$ och $matita_basics_relations.injective$ applicerat på $B$ och $C$ och $g$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.injective$ applicerat på $A$ och $C$ och funktionen som avbildar $x$ som $g$ applicerat på $f$ applicerat på $x$.\nAssistant:", "label": "postulate injective_compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (__ : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__1 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (\\ x : cic.Term univs.Type0 A -> g (f x)))", "predict": "postulate injective_compose : (A : cic.Univ univs.Type0) -> (B : cic.Univ univs.Type0) -> (C : cic.Univ univs.Type0) -> (f : (__ : cic.Term univs.Type0 A) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 B) -> cic.Term univs.Type0 C) -> (x : (__ : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__1 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (g x))) -> (__2 : cic.Term cic.prop (matita_basics_relations.injective A B f)) -> (__3 : cic.Term cic.prop (matita_basics_relations.injective B C g)) -> cic.Term cic.prop (matita_basics_relations.injective A C (g x))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_ind_body. Let $_n \\in N$. Let $Q_$ be a function from natural numbers $x_417$ and elements $_x_418$ of $Leq$ of $_n$ and $x_417$ to propositions. Then for all elements $_H_le_n$ of $Q_$ of $_n$ and $le_n (_n)$, for all functions $_H_le_S$ from natural numbers $m$ and elements $x_419$ of $Leq$ of $_n$ and $m$ and elements $_x_421$ of $Q_$ of $m$ and $x_419$ to elements of $Q_$ of $m + 1$ and $le_S (_n, m, x_419)$, for all natural numbers $x_417$, if $_n \\leq x_417$, then $Q_$ holds for $x_417$ and $x_418$.\nAssistant:", "label": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ (plus m 1) (le_S _n m x_419)) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418", "predict": "postulate le_ind_body : (_n : Nat) -> (Q_ : (x_417 : Nat) -> (_x_418 : Leq _n x_417) -> Prop) -> (_H_le_n : Q_ _n (le_n _n)) -> (_H_le_S : (m : Nat) -> (x_419 : Leq _n m) -> (_x_421 : Q_ m x_419) -> Q_ m + 1) -> (x_417 : Nat) -> (x_418 : Leq _n x_417) -> Q_ x_417 x_418"}
{"prompt": "Human: Translate the following French statement into Agda.\nProp50. $n$ n'est pas et pair et impair pour chaque nombre naturel $n$.\nAssistant:", "label": "postulate prop50 : all Nat (\\ n -> not (and (even n) (odd n)))", "predict": "postulate prop50 : not (and (even n) (prime n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15624. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d$ vara ett naturligt tal. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Då om $d m - c n = 1$, så $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : let m : Nat and n : Nat and a : Nat and b : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 n) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) c) n)) -> (H1 : Eq (minus (times d m) c) n) -> Eq m n"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_Aop. Let $A$ be a set. Then for all elements $_nil$ of $A$, for all elements $return_sort$ of $Sort$, for all functions $return_type$ from elements $z$ of $Aop$ of $A$ and $_nil$ to elements of $return_sort$, for all functions $case_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $return_type$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, for all elements $z$ of $Aop$ of $A$ and $_nil$, $return_type$ holds for $z$.\nAssistant:", "label": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z", "predict": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBigop_body. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__1$ vara en funktion från element $__1$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $H$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $__2$ av $cic.Term$ av $univs.Type0$ och $H$, för alla funktioner $__3$ från element $__3$ av $cic.Term$ av $univs.Type0$ och $H$ och element $__4$ av $cic.Term$ av $univs.Type0$ och $H$ till element av $cic.Term$ av $univs.Type0$ och $H$, för alla funktioner $__4$ från element $__4$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $H$, håller $cic.Term$ för $univs.Type0$ och $H$.\nAssistant:", "label": "postulate bigop_body : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H", "predict": "postulate bigop_body : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (H : cic.Univ univs.Type0) -> (__2 : (__2 : cic.Term univs.Type0 H) -> (__3 : (__3 : cic.Term univs.Type0 H) -> (__4 : cic.Term univs.Type0 H) -> cic.Term univs.Type0 H) -> (__4 : (__4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 H) -> cic.Term univs.Type0 H"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_plus. Let $n, p, q \\in N$. Then if $n$ is both divisible by $p$ and divisible by $q$, then $n$ is divisible by $p + q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n p + q"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16005. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$ och $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$ och $d m - c n = 1$. Då är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : let m n a b : Nat -> let n m : Nat -> let a b : Nat -> let c : Nat -> let _clearme : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let d : Nat -> let m : Nat -> let n : Nat -> let _clearme0 : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let d0 : Nat -> let m0 : Nat -> let n0 : Nat -> let _clearme1 : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m1 : Nat -> let n1 : Nat -> let c1 : Nat -> let _clearme2 : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m2 : Nat -> let n2 : Nat -> let c2 : Nat -> let _clearme3 : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) 1)) -> let m3 : Nat -> let n3 : Nat -> let c3 : Nat -> let _clearme4 : ex Nat (\\ d : Nat -> disjunk (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1) (Eq (times d m) (times c n)) "}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sigma_p. Låt $n$ vara ett naturligt tal. Låt $p1$ och $p2$ vara funktioner från naturliga tal till sanningsvärden. Då för alla funktioner $g1$ och $g2$ från naturliga tal till naturliga tal, för alla funktioner $__$ från naturliga tal $i$ och element av $Lt$ av $i$ och $n$ och element $__1$ av $Eq$ av $p1 (i)$ och $true$ till element av $Eq$ av $p2 (i)$ och $true$, för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Lt$ av $i$ och $n$ och element $__2$ av $Eq$ av $p1 (i)$ och $true$ till element av $Leq$ av $g1 (i)$ och $g2 (i)$, för alla element $__2$ av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och disjunktionen av konjunktionen av $Eq$ applicerat på $p1$ applicerat på $i$ och $true$ och $Lt$ applicerat på $g1$ applicerat på $i$ och $g2$ applicerat på $i$ och konjunktionen av konjunktionen av $Eq$ applicerat på $p1$ applicerat på $i$ och kontradiktion och $Eq$ applicerat på $p2$ applicerat på $i$ och $true$ och $Lt$ applicerat på $0$ och $g2$ applicerat på $i$, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p2$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g2$ applicerat på $i$ mindre än $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p1$ applicerat på $i$ och $Nat$ och $0$ och $plus$ och funktionen som avbildar $i$ som $g1$ applicerat på $i$.\nAssistant:", "label": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (__2 : ex Nat (\\ i : Nat -> and (Lt i n) (or (and (Eq (p1 i) true) (Lt (g1 i) (g2 i))) (and (and (Eq (p1 i) false) (Eq (p2 i) true)) (Lt 0 (g2 i)))))) -> Lt (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate lt_sigma_p : (n : Nat) -> (p1 : (_ : Nat) -> sann) -> (p2 : (_ : Nat) -> sann) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq p1 (true)) -> Eq p2 (true)) -> (__1 : (_ : Nat) -> (__1 : Lt i n) -> (__2 : Eq p1 (true)) -> Leq g1 i g2) -> (__2 : ex Nat (\\ i : Nat -> (\\ __1 : Lt i n) -> (__2 : Eq p1 (true)) -> Lt (g1 i) (g2 i)) -> conj (conj (Eq p1 (true)) (Eq p2 i)) true) -> Lt 0 (g2 i)"}
{"prompt": "Human: Translate the following English statement into Agda.\nOrd_times. Let $p, m, n \\in N$. Assume that $0$ is less than $m$. Assume that $0$ is less than $n$. Then if $p$ is prime, then $ord$ applied to the product of $m$ and $n$ and $p$ is equal to the sum of $ord$ applied to $m$ and $p$ and $ord$ applied to $n$ and $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_rect_CProp5_body. Soit $_A$ un ensemble. Alors pour toutes les fonctions $Q_$ des éléments $_x_931$ de $range$ de $_A$ à des propositions, pour toutes les fonctions $_H_mk_range$ des fonctions $_enum$ des nombres naturels à des éléments de $_A$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes à des éléments de $Q_$ de $mk_range (_A, _enum, _upto, _filter)$, pour tous les éléments $x_931$ de $range$ de $_A$, $Q_$ tient pour $x_931$.\nAssistant:", "label": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931", "predict": "postulate range_rect_CProp5_body : (_A : Set) -> (Q_ : (_x_931 : range _A des propositions) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_931 : range _A) -> Q_ x_931) -> (x_931 : range _A) -> Q_ x_931"}
{"prompt": "Human: Translate the following English statement into Agda.\nS_pred. Let $n \\in N$. Assume that $0 < n$. Then $pred (n)+ 1 = n$.\nAssistant:", "label": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (plus (pred n) 1) n", "predict": "postulate S_pred : (n : Nat) -> (_ : Lt 0 n) -> Eq (pred n) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_times. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0$ är mindre än $m$. Då om $0$ är mindre än $n$, så om $p$ är primt, så är $ord$ applicerat på produkten av $m$ och $n$ och $p$ lika med summan av $ord$ applicerat på $m$ och $p$ och $ord$ applicerat på $n$ och $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : let (p : Nat) (m : Nat) (n : Nat) -> Nat\n  and (Lt 0 m) (and (Lt 0 n) (Eq (ord (times m n) p) (plus (ord (times m p) (ord n p)))))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_to_lt_max. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m \\in N$. Anta att $0 < n$. Då om kontradiktion är lika med $f (n)$, så om $max (m, f)\\leq n$, så $max (m, f)< n$.\nAssistant:", "label": "postulate false_to_lt_max : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Eq (f n) false) -> (__2 : Leq (max m f) n) -> Lt (max m f) n", "predict": "postulate låt : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (H : Eq (f n) 0) -> (auto : Leq (max m f) n) -> Lt (max m f) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_invert_permut. Soit $f$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $n$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_permutation.permut$ appliqué à $f$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_permutation.permut$ appliqué à $matita_arithmetics_permutation.invert_permut$ appliqué à $n$ et $f$ et $n$.\nAssistant:", "label": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)", "predict": "postulate permut_invert_permut : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.permut f n)) -> cic.Term cic.prop (matita_arithmetics_permutation.permut (matita_arithmetics_permutation.invert_permut n f) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nInjn_Sn_n. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $__$ vara ett element av $injn$ av $f$ och summan av $n$ och $1$. Då håller $injn$ för $f$ och $n$.\nAssistant:", "label": "postulate injn_Sn_n : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (_ : injn f (plus n 1)) -> injn f n", "predict": "postulate injn_Sn_n : let f : (_ : Nat) -> Nat -> let n : Nat -> let _ : injn f (plus n 1) -> injn f n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp0_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Då för alla funktioner $Q_$ från element $_x_885$ av $Aop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, för alla element $x_885$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Pont) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c \\in N$. Then for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nBool_inv_rect_Type3. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $P$ une fonction des éléments $_z599$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$ à des éléments de $cic.Univ$ de $univs.Type3$. Alors pour toutes les fonctions $_H1$ des éléments $_z600$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $Hterm$ et $matita_basics_bool.true$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_bool.true$, pour toutes les fonctions $_H2$ des éléments $_z600$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $Hterm$ et $matita_basics_bool.false$ à des éléments de $cic.Term$ de $univs.Type3$ et de $P$ appliqué à $matita_basics_bool.false$, $cic.Term$ tient pour $univs.Type3$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate bool_inv_rect_Type3 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)", "predict": "postulate bool_inv_rect_Type3 : soit (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z599 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ univs.Type3) -> (_H1 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term univs.Type3 (P matita_basics_bool.true)) -> (_H2 : (_z600 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term univs.Type3 (P matita_basics_bool.false)) -> cic.Term univs.Type3 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1573. Låt $n$ och $m$ vara naturliga tal. Anta att $0 < n$. Anta att $m$ är delbart med $n$. Låt $d$ vara ett naturligt tal. Då om $0 = m$, så om $n = m d$, så $n = m$.\nAssistant:", "label": "postulate let_clause_1573 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 n) -> (_clearme : divisible m n) -> (d : Nat) -> (auto : Eq 0 m) -> (auto' : Eq n (times m d)) -> Eq n m", "predict": "postulate let_clause_1573 : let n : Nat -> let m : Nat -> (n : Nat) -> (m : Nat) -> (d : Nat) -> (H : Lt 0 n) -> (H0 : Eq 0 m) -> (H1 : Eq n m) -> Eq n m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1062. Let $a, b, q, r, q1, r1 \\in N$. Let $_clearme$ be an element of $div_mod_spec$ of $a$ and $b$ and $q$ and $r$. Assume that $r < b$ and $a = q b + r$. Let $_clearme0$ be an element of $div_mod_spec$ of $a$ and $b$ and $q1$ and $r1$. Then if $r1 < b$ and $a = q1 b + r1$, then if $q$ is not less than or equal to $q1$, then $a = r1 + b q1$.\nAssistant:", "label": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (ltrb : Lt r b) -> (spec : Eq a (plus (times q b) r)) -> (_clearme0 : div_mod_spec a b q1 r1) -> (ltr1b : Lt r1 b) -> (spec1 : Eq a (plus (times q1 b) r1)) -> (leqq1 : not (Leq q q1)) -> Eq a (plus r1 (times b q1))", "predict": "postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (r < b) -> (a : Nat) -> (_clearme0 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q : Nat) -> (not (Leq q q1)) -> (a : Nat) -> (_clearme1 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme2 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme3 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme4 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme5 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (a : Nat) -> (_clearme6 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q1 : Nat) -> (not (Leq q1 q1)) -> (postulate let_clause_1062 : (a : Nat) -> (b : Nat) -> (q : Nat) -> (r : Nat) -> (q1 : Nat) -> (r1 : Nat) -> (_clearme : div_mod_spec a b q r) -> (r < b) -> (a : Nat) -> (_clearme0 : div_mod_spec a b q1 r1) -> (r1 < b) -> (q : Nat) -> (not (Leq q q1)) -> (a : Nat) -> (_clearme"}
{"prompt": "Human: Translate the following French statement into Agda.\nNoLabel_64. Pour tous les entiers $n$, si $3 n - 5$ est impair, alors $n$ est pair.\nAssistant:", "label": "postulate noLabel_64 : (n : Int) -> if (odd (minus (times 3 n) 5)) (even n)", "predict": "postulate noLabel_64 : tous (entiers n) (\\ _ : impair 3 n -> pair n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_Type4. Pour tous les ensembles $x1$, pour tous les éléments $x2$ de $x1$, pour tous les éléments $Hterm$ de $Aop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1506$ de $Aop$ de $x1$ et de $x2$ à des éléments de $Type4$, pour toutes les fonctions $_H1$ des fonctions $op$ des éléments de $x1$ et des éléments $__1$ de $x1$ à des éléments de $x1$ et des fonctions $_nill$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (x2, a)$ et de $a$ et des fonctions $_nilr$ des éléments $a$ de $x1$ à des éléments de $Eq$ de $op (a, x2)$ et de $a$ et des fonctions $_assoc$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ et des éléments $c$ de $x1$ à des éléments de $Eq$ de $op (a, op (b, c))$ et de $op (op (a, b), c)$ et des éléments $_z1507$ de $Eq$ de $Hterm$ et de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ à des éléments de $P$ de $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type4 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1506 : Aop x1 x2) -> Type4) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1507 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_x_times_x. För alla naturliga tal $x$, är $x$ mindre än eller lika med produkten av $x$ och $x$.\nAssistant:", "label": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)", "predict": "postulate le_x_times_x : (x : Nat) -> Leq x (times x x)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n \\in N$. Assume that $5 < n$. Let $m \\in N$. Assume that $6 \\leq m$. Assume that $(m + 1)^ 2 \\leq 2 ^ m$. Let $a$ be a natural number. Then if $6 \\leq a$, then if $2 (a + 1)+ 1 \\leq 2 ^ a$, then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (le : Leq m 6) -> (H : And (And (Leq m 6) (pow (m + 1) 2)) (pow (a : Nat) 1 (pow (2 a) 2))) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_sigma. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $__$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $__1$ une fonction des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Alors $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ est inférieur ou ágal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$.\nAssistant:", "label": "postulate le_sigma : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))", "predict": "postulate le_sigma : soit n : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> and (bigop n (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_O_to_eq. Pour tous les nombres naturels $n$, si $n$ est inférieur ou ágal à $0$, alors $0$ est égal à $n$.\nAssistant:", "label": "postulate le_n_O_to_eq : (n : Nat) -> (_ : Leq n 0) -> Eq 0 n", "predict": "postulate le_n_O_to_eq : (n : Nat) -> (_ : Leq n 0) -> Eq 0 n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_lop. Låt $n \\in N$. Anta att $1 \\leq n$. Då $list_of_primes (n)= cons (Nat, 2, tail (Nat, list_of_primes (n)))$.\nAssistant:", "label": "postulate eq_lop : (n : Nat) -> (_ : Leq 1 n) -> Eq (list_of_primes n) (cons Nat 2 (tail Nat (list_of_primes n)))", "predict": "postulate eq_lop : let n : Nat in let anta : Leq 1 n in let list_of_primes : (n : Nat) -> cons Nat 2 (tail Nat (list_of_primes n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1068. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i$ är mindre än eller lika med $n$. Anta att $j$ är mindre än eller lika med $n$. Låt $a$ vara ett naturligt tal. Anta att $a$ är mindre än eller lika med $n$ och $f$ applicerat på $a$ är lika med $i$. Anta att $a$ är mindre än eller lika med $n$. Anta att $f$ applicerat på $a$ är lika med $i$. Låt $b \\in N$. Anta att $b$ är mindre än eller lika med $n$ och $f$ applicerat på $b$ är lika med $j$. Anta att $b$ är mindre än eller lika med $n$. Då om $f$ applicerat på $b$ är lika med $j$, så för alla funktioner $__$ från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f$ applicerat på $i0$ och $n$, för alla element $injf$ av $injn$ av $f$ och $n$, om $a$ är lika med $b$, så är $f$ applicerat på $a$ lika med $i$.\nAssistant:", "label": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) i", "predict": "postulate let_clause_1068 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (auto : and (Leq i n) (Leq j n)) -> (a : Nat) -> (auto' : and (Leq a n) (Leq f a)) -> (auto'' : and (Leq a n) (Leq f a)) -> (b : Nat) -> (auto'' : and (Leq b n) (Leq f b)) -> (auto''' : and (Leq f b) j) -> (auto' : and (Leq i n) (Leq f i)) -> (auto : (_ : Nat) -> Leq (f i) n) -> (auto' : (injf : injn f n) -> and (Leq a b) (f a)) -> (auto'' : Eq a b) -> f a"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_times_gcd_aux. Let $p, m, n, d, c \\in N$. Assume that $0 < c$. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq p$. Assume that $d$ is divisible by $c \\times m$. Then if $d$ is divisible by $c \\times n$, then $d$ is divisible by $c \\times gcd_aux (p, m, n)$.\nAssistant:", "label": "postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt 0 n) -> (__2 : Leq n m) -> (__3 : Leq n p) -> (__4 : divisible d (times c m)) -> (__5 : divisible d (times c n)) -> divisible d (times c (gcd_aux p m n))", "predict": "postulate divides_times_gcd_aux : (p : Nat) -> (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : Lt n m) -> (__2 : Leq n m) -> (__3 : divisible d c * m) -> (__4 : divisible d c * n) -> divisible d (c * gcd_aux p m n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTheta_pred. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $matita_arithmetics_chebyshev_chebyshev_theta.theta$ applicerat på $matita_arithmetics_nat.pred$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$.\nAssistant:", "label": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))", "predict": "postulate theta_pred : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)) (matita_arithmetics_chebyshev_chebyshev_theta.theta (matita_arithmetics_nat.pred (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15611. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c$ be a natural number. Assume that the product of $m$ and $n$ is equal to the product of $p$ and $c$. Let $a$ be a natural number. Then for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to $1$, then the difference of the product of $m$ and $b$ and the product of $p$ and $a$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1", "predict": "postulate let_clause_15611 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (minus (times m b) (times p a)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$. Assume that $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$. Then if $a \\leq n$, then if $f (a)= i$, then for all natural numbers $b$, if $b \\leq n$ and $f (b)= j$, then if $b \\leq n$, then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ai : Nat) -> (aj : Nat) -> (a : Nat) -> (Ha : Leq a n) -> (fa : f a) -> (Hb : Leq b n) -> (fb : f b) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq f (i0)) -> (injf : injn f n) -> (auto : Eq a b) -> f a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_inv_ind. Låt $x1$ och $x2$ vara naturliga tal. Låt $x3$ vara en funktion från naturliga tal till sanningsvärden. Låt $x4 \\in N$. Då för alla element $_Hterm$ av $min_spec$ av $x1$ och $x2$ och $x3$ och $x4$, för alla funktioner $P$ från naturliga tal $_z1890$ till påståenden, för alla funktioner $_H1$ från naturliga tal $m$ och element $_x_1080$ av $Leq$ av $x2$ och $m$ och element $_x_1079$ av $Lt$ av $m$ och summan av $x1$ och $x2$ och element $_x_1078$ av $Eq$ av $x3$ applicerat på $m$ och $true$ och funktioner $_x_1077$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och $m$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och $m$ till element av $P$ av $m$, för alla funktioner $_H2$ från funktioner $_x_1081$ från naturliga tal $i$ och element av $Leq$ av $x2$ och $i$ och element $__1$ av $Lt$ av $i$ och summan av $x1$ och $x2$ till element av $Eq$ av $x3$ applicerat på $i$ och kontradiktion och element $_z1891$ av $Eq$ av $x4$ och summan av $x1$ och $x2$ till element av $P$ av summan av $x1$ och $x2$, håller $P$ för $x4$.\nAssistant:", "label": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> bool) -> (x4 : Nat) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P : (_z1890 : Nat) -> Prop) -> (_H1 : (m : Nat) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) false) -> (_z1891 : Eq x4 m) -> P m) -> (_H2 : (_x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) false) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4", "predict": "postulate min_spec_inv_ind : (x1 : Nat) -> (x2 : Nat) -> (x3 : (_ : Nat) -> Sann) -> (x4 : Nat) -> (P : (_ : Nat) -> Påstånd) -> (_Hterm : min_spec x1 x2 x3 x4) -> (P' : (_ : Nat) -> Påstånd) -> (_H1 : (m : Nat) -> (_ : Leq x2 m) -> (_x_1080 : Leq x2 m) -> (_x_1079 : Lt m (plus x1 x2)) -> (_x_1078 : Eq (x3 m) true) -> (_x_1077 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i m) -> Eq (x3 i) i) -> (_z1891 : Eq x4 m) -> P m) -> (P' : (_ : Nat) -> Påstånd) -> (_H2 : (_ : x_1081 : (i : Nat) -> (_ : Leq x2 i) -> (__1 : Lt i (plus x1 x2)) -> Eq (x3 i) (contradiktion)) -> (_z1891 : Eq x4 (plus x1 x2)) -> P (plus x1 x2)) -> P x4"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_sqrt_to_lt_times_r. For all elements $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $matita_arithmetics_nat.times$ applied to $n$ and $n$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_r : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt m) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.times n n))", "predict": "postulate lt_sqrt_to_lt_times_r : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_sqrt.sqrt m) n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt m (matita_arithmetics_nat.times n n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Låt $return_sort$ vara ett element av $Sort$. Låt $return_type$ vara en funktion från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$. Låt $case_lstar_O$ vara en funktion från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_O (B, _R, b)$. Låt $case_lstar_S$ vara en funktion från element $b1$ av $B$ och element $b$ av $B$ och element av $_R$ av $b1$ och $b$ och naturliga tal $l$ och element $b2$ av $B$ och element $__1$ av $lstar$ av $B$ och $_R$ och $l$ och $b$ och $b2$ till element av $return_type$ av $l + 1$ och $b1$ och $b2$ och $lstar_S (B, _R, b1, b, __, l, b2, __1)$. Låt $__$ vara ett naturligt tal. Då för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort) -> (case_lstar_O : (b : B) -> return_type 0 b b (lstar_O B _R b)) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : _R b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type (plus l 1) b1 b2 (lstar_S B _R b1 b __ l b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar : let B : Mngd Låt _R : relation B Låt return_sort : Sort Låt return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar B _R __ __1 __2) -> return_sort -> (case_lstar_O : (b : B) -> return_type 0 b b) -> (case_lstar_S : (b1 : B) -> (b : B) -> (_ : relation b1 b) -> (l : Nat) -> (b2 : B) -> (__1 : lstar B _R l b b2) -> return_type l + 1 b1 b2) -> (_ : Nat) -> (z : lstar B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10471. Let $n1$ and $n2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p1$ and $p2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $op$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $B$ and $nil$. Let $f1$ and $f2$ be functions from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$. Let $_clearme$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_bigops.iso$ applied to $B$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f1$ and $n1$ and $p1$ and $matita_arithmetics_bigops.mk_range$ applied to $B$ and $f2$ and $n2$ and $p2$. Let $h$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $_clearme0$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $cic.prod$ applied to $univs.Type0$ and $univs.Type0$ and $matita_arithmetics_nat.nat$ and the function that maps $__$ to $matita_arithmetics_nat.nat$ and the function that maps $k$ to $matita_basics_logic.And$ applied to $matita_basics_logic.And$ applied to $cic.prod$ applied to $univs.Type0$ and $cic.prop$ and $matita_arithmetics_nat.nat$ and the function that maps $i$ to $cic.prod$ applied to $cic.prop$", "label": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : ((__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term un", "predict": "postulate let_clause_10471 : (n1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop B nil)) -> (f1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (f2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (_clearme : cic.Term cic.prop (matita_arithmetics_bigops.iso B (matita_arithmetics_bigops.mk_range B f1 n1 p1) (matita_arithmetics_bigops.mk_range B f2 n2 p2))) -> (h : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex (cic.prod univs.Type0 univs.Type0 matita_arithmetics_nat.nat (\\ __ : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat)) (\\ k : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.And (matita_basics_logic.And (cic.prod univs.Type0 cic.prop matita_arithmetics_nat.nat (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.prod cic.prop (matita_arithmetics_nat.nat (\\ j : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_n_O_elim. Soit $n$ un nombre naturel. Alors si $n \\leq 0$, alors pour toutes les fonctions $P$ des nombres naturels $__1$ à des propositions, pour tous les éléments $__1$ de $P$ de $0$, $P$ tient pour $n$.\nAssistant:", "label": "postulate le_n_O_elim : (n : Nat) -> (_ : Leq n 0) -> (P : (__1 : Nat) -> Prop) -> (__1 : P 0) -> P n", "predict": "postulate le_n_O_elim : soit n un nombre naturel. Alors si n <= 0, alors pour toutes les fonctions P des nombres naturels __1 a des propositions, pour tous les elements __1 de P de 0, P tient pour n."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_rect_CProp5. För alla naturliga tal $_n$ och $_m$ och $_q$ och $_r$, för alla funktioner $Q_$ från element $_x_841$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$ till påståenden, för alla funktioner $_H_div_mod_spec_intro$ från element $x_843$ av $Lt$ av $_r$ och $_m$ och element $x_842$ av $Eq$ av $_n$ och $_q _m + _r$ till element av $Q_$ av $div_mod_spec_intro (_n, _m, _q, _r, x_843, x_842)$, för alla element $x_841$ av $div_mod_spec$ av $_n$ och $_m$ och $_q$ och $_r$, håller $Q_$ för $x_841$.\nAssistant:", "label": "postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841", "predict": "postulate div_mod_spec_rect_CProp5 : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_841 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_843 : Lt _r _m) -> (x_842 : Eq _n _q _m + _r) -> Q_ (div_mod_spec _n _m _q _r x_843 x_842)) -> (x_841 : div_mod_spec _n _m _q _r) -> Q_ x_841"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_minus_O. For all natural numbers $n$ and $m$, if $n \\leq m$, then $n - m = 0$.\nAssistant:", "label": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0", "predict": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq n - m 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_max_n. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Då för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_minimization.max$ applicerat på $n$ och $f$ och $n$.\nAssistant:", "label": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)", "predict": "postulate lt_max_n : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_minimization.max n f) n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nProp110. Let $a, c \\in Z$. Assume that both $a$ and $c$ are odd. Then $a b + b c$ is even for every integer $b$.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : (a : Z) -> (c : Z) -> even (plus a b) (b c)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_times_SO_to_gcd_SO. Låt $m$ och $n$ och $p$ vara naturliga tal. Anta att $0 < n$ och $0 < p$. Då om $1$ är lika med det största gemensama delaret av $m$ och produkten av $n$ och $p$, så är $1$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate gcd_times_SO_to_gcd_SO : (m : Nat) -> (n : Nat) -> (p : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 p) -> (__2 : Eq (gcd m (times n p)) 1) -> Eq (gcd m n) 1", "predict": "postulate gcd_times_SO_to_gcd_SO : let (m : Nat) -> let (n : Nat) -> let (p : Nat) -> (posn : Lt 0 n) -> (posp : Lt 0 p) -> Eq 1 (gcd (div m n) (times n p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_rect_Type1. Let $x1$ be a set. Then for all elements $x2$ of $x1$, for all elements $Hterm$ of $Aop$ of $x1$ and $x2$, for all functions $P$ from elements $_z1524$ of $Aop$ of $x1$ and $x2$ to elements of $Type1$, for all functions $_H1$ from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $x2$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $x2$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ and elements $_z1525$ of $Eq$ of $Hterm$ and $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$ to elements of $P$ of $mk_Aop$ applied to $x1$ and $x2$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type1 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1524 : Aop x1 x2) -> Type1) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1525 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla element $xxx$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $A$ och $nil$, för alla element $a$ och $b$ och $c$ av $cic.Term$ av $univs.Type0$ och $A$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $b$ och $c$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $matita_arithmetics_bigops.op$ applicerat på $A$ och $nil$ och $xxx$ och $a$ och $b$ och $c$.\nAssistant:", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A nil xxx a (matita_arithmetics_bigops.op A nil xxx b c)) (matita_arithmetics_bigops.op A nil xxx (matita_arithmetics_bigops.op A nil xxx a b) c))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBijn_n_Sn. Let $f$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $n$. Then for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $f$ applied to $matita_arithmetics_nat.S$ applied to $n$ and $matita_arithmetics_nat.S$ applied to $n$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_permutation.bijn$ applied to $f$ and $matita_arithmetics_nat.S$ applied to $n$.\nAssistant:", "label": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))", "predict": "postulate bijn_n_Sn : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_permutation.bijn f n)) -> (__1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (f (matita_arithmetics_nat.S n)) (matita_arithmetics_nat.S n))) -> cic.Term cic.prop (matita_arithmetics_permutation.bijn f (matita_arithmetics_nat.S n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_aux_to_not_mod_O. Soit $p, n, m, q, r \\in N$. Supposons que $1 < m$. Supposons que $0 < n$. Alors si $n \\leq p$, alors si $p_ord_aux (p, n, m)= mk_Prod (Nat, Nat, q, r)$, alors $mod (r, m)$ n'est pas égal à $0$.\nAssistant:", "label": "postulate p_ord_aux_to_not_mod_O : (p : Nat) -> (n : Nat) -> (m : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 m) -> (__1 : Lt 0 n) -> (__2 : Leq n p) -> (__3 : Eq (p_ord_aux p n m) (mk_Prod Nat Nat q r)) -> not (Eq (mod r m) 0)", "predict": "postulate p_ord_aux_to_not_mod_O : soit p, n, m, q, r \\in N"}
{"prompt": "Human: Translate the following English statement into Agda.\nMin_spec_ind_body. Let $_n, _b \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_1075$ and elements $_x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$ to propositions. Let $_H_found_min_spec$ be a function from natural numbers $m$ and elements $x_1080$ of $Leq$ of $_b$ and $m$ and elements $x_1079$ of $Lt$ of $m$ and the sum of $_n$ and $_b$ and elements $x_1078$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_1077$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and $m$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $m$ and $x_1080$ and $x_1079$ and $x_1078$ and $x_1077$. Let $_H_not_found_min_spec$ be a function from functions $x_1081$ from natural numbers $i$ and elements of $Leq$ of $_b$ and $i$ and elements $__1$ of $Lt$ of $i$ and the sum of $_n$ and $_b$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of the sum of $_n$ and $_b$ and $not_found_min_spec$ applied to $_n$ and $_b$ and $_f$ and $x_1081$. Let $x_1075 \\in N$. Then for all elements $x_1076$ of $min_spec$ of $_n$ and $_b$ and $_f$ and $x_1075$, $Q_$ holds for $x_1075$ and $x_1076$.\nAssistant:", "label": "postulate min_spec_ind_body : (_n : Nat) -> (_b : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> (x_1076 : min_spec _n _b _f x_1075) -> Q_ x_1075 x_1076", "predict": "postulate min_spec_ind_body : (_n : N) -> (_b : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_1075 : Nat) -> (_x_1076 : min_spec _n _b _f x_1075) -> Prop) -> (_H_found_min_spec : (m : Nat) -> (x_1080 : Leq _b m) -> (x_1079 : Lt m (plus _n _b)) -> (x_1078 : Eq (_f m) true) -> (x_1077 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i m) -> Eq (_f i) false) -> Q_ m (found_min_spec _n _b _f m x_1080 x_1079 x_1078 x_1077)) -> (_H_not_found_min_spec : (x_1081 : (i : Nat) -> (_ : Leq _b i) -> (__1 : Lt i (plus _n _b)) -> Eq (_f i) false) -> Q_ (plus _n _b) (not_found_min_spec _n _b _f x_1081)) -> (x_1075 : Nat) -> Q_ x_1075 x_1076"}
{"prompt": "Human: Translate the following English statement into Agda.\nConfluent1. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $A$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_relations.predicate$ applied to $A$.\nAssistant:", "label": "postulate confluent1 : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.predicate A)", "predict": "postulate confluent1 : (A : cic.Univ univs.Type0) -> (__ : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Term univs.Type0 (matita_basics_relations.predicate A)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_l. Let $B$ be a set. Let $R$ be a function from elements of $B$ and elements $__1$ of $B$ to propositions. Let $b2$ be an element of $B$. Let $P$ be an element of $relation2$ of $Nat$ and $B$. Let $__$ be an element of $P$ of $0$ and $b2$. Let $__1$ be a function from natural numbers $l$ and elements $b1$ of $B$ and elements $b$ of $B$ and elements $__1$ of $R$ of $b1$ and $b$ and elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b$ and $b2$ and elements $__3$ of $P$ of $l$ and $b$ to elements of $P$ of the sum of $l$ and $1$ and $b1$. Let $l \\in N$. Then for all elements $b1$ of $B$, for all elements $__2$ of $lstar$ of $B$ and $R$ and $l$ and $b1$ and $b2$, $P$ holds for $l$ and $b1$.\nAssistant:", "label": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1", "predict": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> all (P l b1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp5. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_959$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod$ applied to $a$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $Q_$ of $mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_959$.\nAssistant:", "label": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959", "predict": "postulate Dop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMin_spec_to_min. Låt $f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Då för alla element $n$ och $b$ och $m$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_minimization.min_spec$ applicerat på $n$ och $b$ och $f$ och $m$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_minimization.min$ applicerat på $n$ och $b$ och $f$ och $m$.\nAssistant:", "label": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)", "predict": "postulate min_spec_to_min : (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_minimization.min_spec n b f m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_minimization.min n b f) m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_Type0_body. Låt $_A$ vara en mängd. Låt $Q_$ vara en funktion från element $_x_927$ av $range$ av $_A$ till mängder. Låt $_H_mk_range$ vara en funktion från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$. Då för alla element $x_927$ av $range$ av $_A$, håller $Q_$ för $x_927$.\nAssistant:", "label": "postulate range_rect_Type0_body : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927", "predict": "postulate range_rect_Type0_body : (_A : Mngd) -> (Q_ : (_x_927 : range _A) -> Mngd) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type4_body. Let $_n$ and $_m$ and $_q$ and $_r$ be natural numbers. Let $Q_$ be a function from elements $_x_813$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type4$. Let $_H_div_mod_spec_intro$ be a function from elements $x_815$ of $Lt$ of $_r$ and $_m$ and elements $x_814$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_815$ and $x_814$. Let $x_813$ be an element of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$. Then $Q_$ holds for $x_813$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813", "predict": "postulate div_mod_spec_rect_Type4_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_813 : div_mod_spec _n _m _q _r) -> Type4) -> (_H_div_mod_spec_intro : (x_815 : Lt _r _m) -> (x_814 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_815 x_814)) -> (x_813 : div_mod_spec _n _m _q _r) -> Q_ x_813"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLt_sqrt_to_lt_times_l. Låt $m$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $n$ och $matita_arithmetics_sqrt.sqrt$ applicerat på $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $n$ och $n$ och $m$.\nAssistant:", "label": "postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)", "predict": "postulate lt_sqrt_to_lt_times_l : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt n (matita_arithmetics_sqrt.sqrt m))) -> cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.times n n) m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nUnit_rect_Type2. Soit $Q_$ une fonction des éléments $_x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$ à des éléments de $cic.Univ$ de $univs.Type2$. Alors pour tous les éléments $_H_it$ de $cic.Term$ de $univs.Type2$ et de $Q_$ appliqué à $matita_basics_types.it$, pour tous les éléments $x_503$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.unit$, $cic.Term$ tient pour $univs.Type2$ et $Q_$ appliqué à $x_503$.\nAssistant:", "label": "postulate unit_rect_Type2 : (Q_ : (_x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type2) -> (_H_it : cic.Term univs.Type2 (Q_ matita_basics_types.it)) -> (x_503 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type2 (Q_ x_503)", "predict": "postulate unit_rect_Type2 : soit Q_ une fonction des elements _x_503 de cic.Term univs.Type0 matita_basics_types.unit à des elements de cic.Univ univs.Type2. Alors pour tous les elements _H_it de cic.Term univs.Type2 Q_ applied matita_basics_types.it, pour tous les elements x_503 de cic.Term univs.Type0 matita_basics_types.unit, cic.Term univs.Type2 Q_ applied x_503."}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $return_sort$ be an element of $cic.Sort$. Let $return_type$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$ to elements of $cic.Univ$ of $return_sort$. Let $case_le_n$ be an element of $cic.Term$ of $return_sort$ and $return_type$ applied to $_n$ and $matita_arithmetics_nat.le_n$ applied to $_n$. Let $case_le_S$ be a function from elements $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $m$ to elements of $cic.Term$ of $return_sort$ and $return_type$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $matita_arithmetics_nat.le_S$ applied to $_n$ and $m$ and $__$. Then for all elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $z$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $_n$ and $__$, $cic.Term$ holds for $return_sort$ and $return_type$ applied to $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)", "predict": "postulate match_le : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (return_sort : cic.Sort) -> (return_type : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Univ return_sort) -> (case_le_n : cic.Term return_sort (return_type _n (matita_arithmetics_nat.le_n _n))) -> (case_le_S : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le _n m)) -> cic.Term return_sort (return_type (matita_arithmetics_nat.S m) (matita_arithmetics_nat.le_S _n m __))) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (z : cic.Term cic.prop (matita_arithmetics_nat.le _n __)) -> cic.Term return_sort (return_type __ z)"}
{"prompt": "Human: Translate the following French statement into Agda.\nS. Soit $__$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate S : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate soit : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_forall_to_exists. Låt $P$ vara en funktion från naturliga tal till påståenden. Låt $n$ vara ett naturligt tal. Låt $__$ vara en funktion från naturliga tal $i$ till element av $decidable$ av $P$ applicerat på $i$. Då om det inte är fallet att $prod$ håller för $Set$ och $Prop$ och $Nat$ och funktionen som avbildar $i$ som $prod$ applicerat på $Prop$ och $Prop$ och $Lt$ applicerat på $i$ och $n$ och funktionen som avbildar $__1$ som $P$ applicerat på $i$, så håller $ex$ för $Nat$ och funktionen som avbildar $i$ som konjunktionen av $Lt$ applicerat på $i$ och $n$ och negationen av $P$ applicerat på $i$.\nAssistant:", "label": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (__1 : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ __1 : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> and (Lt i n) (not (P i)))", "predict": "postulate not_forall_to_exists : (P : (_ : Nat) -> Prop) -> (n : Nat) -> (_ : (i : Nat) -> decidable (P i)) -> (H : not (prod Set Prop Nat (\\ i : Nat -> prod Prop Prop (Lt i n) (\\ _ : Lt i n -> P i)))) -> ex Nat (\\ i : Nat -> P i)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPlus_div. Pour tous les nombres naturels $n$ et $m$ et $d$, si $0 < d$ et $d$ est divisible par $n$, alors si $d$ est divisible par $m$, alors $(n + m)\\div d = n \\div d + m \\div d$.\nAssistant:", "label": "postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) (plus (div n d) (div m d))", "predict": "postulate plus_div : (n : Nat) -> (m : Nat) -> (d : Nat) -> (_ : Lt 0 d) -> (__1 : divisible d n) -> (__2 : divisible d m) -> Eq (div (plus n m) d) n (div d m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRange_rect_CProp1_body. Låt $_A$ vara en mängd. Då för alla funktioner $Q_$ från element $_x_937$ av $range$ av $_A$ till påståenden, för alla funktioner $_H_mk_range$ från funktioner $_enum$ från naturliga tal till element av $_A$ och naturliga tal $_upto$ och funktioner $_filter$ från naturliga tal till sanningsvärden till element av $Q_$ av $mk_range (_A, _enum, _upto, _filter)$, för alla element $x_937$ av $range$ av $_A$, håller $Q_$ för $x_937$.\nAssistant:", "label": "postulate range_rect_CProp1_body : (_A : Set) -> (Q_ : (_x_937 : range _A) -> Prop) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937", "predict": "postulate range_rect_CProp1_body : (_A : Mngd) -> (Q_ : (_x_937 : range _A) -> påståenden) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> sanningsvärden) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_937 : range _A) -> Q_ x_937"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_Strue. Soit $k \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Alors pour tous les éléments $nil$ de $B$, pour toutes les fonctions $op$ des éléments de $B$ et des éléments $__1$ de $B$ à des éléments de $B$, pour toutes les fonctions $f$ des nombres naturels à des éléments de $B$, si $p (k)= true$, alors $op$ appliqué à $f$ appliqué à $k$ et $bigop$ appliqué à $k$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ est égal à $bigop$ appliqué à la somme de $k$ et de $1$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_Strue : (k : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Eq (p k) true) -> Eq (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)))", "predict": "postulate bigop_Strue : soit k : Nat -> soit p : (_ : Nat) -> B -> all (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : p k) -> Eq (op (f k) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) (bigop (plus k 1) (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop1. Låt $k$ och $n$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $p$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $B$. Då för alla funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $B$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $B$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla funktioner $f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ till element av $cic.Term$ av $univs.Type0$ och $B$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $k$, för alla funktioner $__1$ från element $i$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$ och element $__1$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $n$ och $i$ och element $__2$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $i$ och $k$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $p$ applicerat på $i$ och $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2", "label": "postulate pad_bigop1 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop n (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i) B nil op (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate pad_bigop1 : (k : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Term univs.Type0 B) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n k)) -> (__1 : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n i)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt i k)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (p i) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_CProp4. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla element $_nil$ av $cic.Term$ av $univs.Type0$ och $A$, för alla funktioner $Q_$ från element $_x_957$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.Dop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $A$ och $_nil$ och funktioner $prod$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_null$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $prod$ applicerat på $a$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_arithmetics_bigops.mk_Dop$ applicerat på $A$", "label": "postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)", "predict": "postulate Dop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum b c (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum b c (matita_arithmetics_bigops.aop__o__op A _nil sum b c))) -> (x_957 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_957)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOrd_times. För alla naturliga tal $p$ och $m$ och $n$, om $0$ är mindre än $m$, så om $0$ är mindre än $n$, så om $p$ är primt, så är $ord$ applicerat på produkten av $m$ och $n$ och $p$ lika med summan av $ord$ applicerat på $m$ och $p$ och $ord$ applicerat på $n$ och $p$.\nAssistant:", "label": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prime p) -> Eq (ord (times m n) p) (plus (ord m p) (ord n p))", "predict": "postulate ord_times : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 m) -> (__1 : Lt 0 n) -> (__2 : prim p) -> Eq (ord (times m n) p) (plus (ord (times m p) (ord n p)) (ord n p))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSubR. Pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $_R$ et $_S$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$, $cic.Univ$ tient pour $cic.prop$.\nAssistant:", "label": "postulate subR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop", "predict": "postulate SubR : (A : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (_S : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_gcd_times_1. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $n$. Anta att $1$ är lika med det största gemensama delaret av $p$ och $m$. Då är $1$ lika med det största gemensama delaret av $p$ och produkten av $n$ och $m$.\nAssistant:", "label": "postulate eq_gcd_times_1 : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : Eq (gcd p n) 1) -> (__3 : Eq (gcd p m) 1) -> Eq (gcd p (times n m)) 1", "predict": "postulate eq_gcd_times_1 : let p : Nat -> let n : Nat -> let m : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> Eq 1 (gcd p n) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLstar_r_sn. Låt $B$ vara en mängd. Låt $R$ vara ett element av $relation$ av $B$. Låt $l$ vara ett naturligt tal. Låt $b$ och $b2$ vara element av $B$. Låt $__$ vara ett element av $lstar_r$ av $B$ och $R$ och $l$ och $b$ och $b2$. Då för alla element $b1$ av $B$, för alla element $__1$ av $R$ av $b1$ och $b$, håller $lstar_r$ för $B$ och $R$ och $l + 1$ och $b1$ och $b2$.\nAssistant:", "label": "postulate lstar_r_sn : (B : Set) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate låt : (B : Mngd) -> (R : relation B) -> (l : Nat) -> (b : B) -> (b2 : B) -> (_ : lstar_r B R l b b2) -> (b1 : B) -> (__1 : R b1 b) -> lstar_r B R l + 1 b1 b2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNoLabel_47. Vi kan bevisa att summan av skillnaden mellan potensen av $n$ och $2$ och produkten av $3$ och $n$ och $9$ är udda för varje heltal $n$.\nAssistant:", "label": "postulate noLabel_47 : all Int (\\ n -> odd (plus (minus (pow n 2) (times 3 n)) 9))", "predict": "postulate noLabel_47 : vi kan bevisa att summan av skillnaden mellan potensen av n och 2 och produkten av 3 och n och 9 är udda för varje heltal n."}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type2_body. For all natural numbers $_n$ and $_m$ and $_q$ and $_r$, for all functions $Q_$ from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$, for all functions $_H_div_mod_spec_intro$ from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$, for all elements $x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825", "predict": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"}
{"prompt": "Human: Translate the following French statement into Agda.\nLog_exp. Soient $p$ et $n$ et $m$ des nombres naturels. Alors si $1 < p$ et $0 < m$, alors $\\log_ p {p ^ n m}= n + (\\log_ p {m})$.\nAssistant:", "label": "postulate log_exp : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> Eq (log p (times (pow p n) m)) (plus n (log p m))", "predict": "postulate log_exp : sont_p n m -> (_ : Lt 1 p) -> (0 : Lt m 0) -> log_ p (p^n m) = n + (log_ p m)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_gcd_aux. Soient $p$ et $m$ et $n$ et $d$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $p$, pour tous les éléments $__3$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, pour tous les éléments $__4$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_gcd.gcd_aux$ appliqué à $p$ et $m$ et $n$.\nAssistant:", "label": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))", "predict": "postulate divides_gcd_aux : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (H : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.le n p)) -> (__3 : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__4 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd_aux p m n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15624. Let $m, n, a, b \\in N$. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Assume that the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then the difference of the product of $m$ and $d$ and the product of $n$ and $c$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15624 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times m d) (times n c)) 1) -> Eq (minus (times m d) (times n c)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_I_gen. Let $a$ and $b$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $nil$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Then for all elements $op$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $B$ and $nil$, for all functions $f$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $a$ and $b$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.minus$ applied to $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $B$ and $nil$ and $matita_arithmetics_bigops.op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to $matita_arithmetics_nat.plus$ applied to $i$ and $a$ and $matita_arithmetics_bigops.bigop$ applied to $b$ and the function that maps $i$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $a$ and $i$ and $p$ applied to $i$ and $B$ and $nil$ and $matita", "label": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))", "predict": "postulate bigop_I_gen : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p i0) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.bigop b (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb a i) (p i)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_CProp5_body. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $A$ et $_nil$ et des fonctions $_comm$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et $matita_arithmetics_bigops.op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_bigops.mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_905$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $A$ et $_nil$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)", "predict": "postulate ACop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_ACop : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> (_comm : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_arithmetics_bigops.op A _nil aop a b) (matita_arithmetics_bigops.op A _nil aop b a))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_ACop A _nil aop _comm))) -> (x_905 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> cic.Term cic.prop (Q_ x_905)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMin. Soient $__$ et $__1$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $__2$ des éléments $__2$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$, $cic.Term$ tient pour $univs.Type0$ et $matita_arithmetics_nat.nat$.\nAssistant:", "label": "postulate min : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat", "predict": "postulate soit : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__2 : (__2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type0 matita_arithmetics_nat.nat"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15625. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Alors si $1$ est égal au diviseur commun plus grand de $n$ et de $m$, alors pour tous les nombres naturels $c$, pour tous les éléments $_clearme$ de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$, pour tous les nombres naturels $d$, si $c n - d m = 1$ ou $d m - c n = 1$ et $d m - c n = 1$, alors $m d - n c = 1$.\nAssistant:", "label": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (minus (times m d) (times n c)) 1", "predict": "postulate let_clause_15625 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (cnd : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dnd : Nat) -> (auto : Eq (times d m) n) -> (auto' : or (Eq (minus (times d m) (times c n)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq m n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1544. Let $p$ and $q$ be natural numbers. Let $Hind$ be a function from natural numbers $m$ and natural numbers $n$ and elements of $Lt$ of $0$ and $n$ and elements $__1$ of $Leq$ of $n$ and $m$ and elements $__2$ of $Leq$ of $n$ and $q$ to elements of $ex$ of $Nat$ and the function that maps $a$ to $ex$ applied to $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $n$ and the product of $b$ and $m$ and $gcd_aux$ applied to $q$ and $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $n$ and $gcd_aux$ applied to $q$ and $m$ and $n$. Let $m, n \\in N$. Assume that $0 < n$. Assume that $n \\leq m$. Assume that $n \\leq q + 1$. Assume that $n$ is not divisible by $m$. Let $a$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $mod$ applied to $m$ and $n$ and the product of $b$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$ and $Eq$ applied to the difference of the product of $b$ and $n$ and the product of $a$ and $mod$ applied to $m$ and $n$ and $gcd_aux$ applied to $q$ and $n$ and $mod$ applied to $m$ and $n$. Let $b \\in N$. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ or $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$. Assume that $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$. Then $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n)))) -> (m : Nat) -> (n : Nat) -> (posn : Lt n m) -> (lt2n : Leq n m) -> (lt2q : Leq n q + 1) -> (divnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) b) n) (Eq (minus (times b n) (times a (mod m n))) n)) -> (Hind' : or (Eq (minus (times a (mod m n)) n) b) (Eq (minus (times b n) (times a (mod m n))) n)) -> (Hind'' : Eq (minus (times a (mod m n)) n) b) -> Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProp90. Låt $n$ vara ett naturligt tal. Då om $n$ är både jämnt och primt, så $n = 2$.\nAssistant:", "label": "postulate prop90 : (n : Nat) -> if (and (even n) (prime n)) (Eq n 2)", "predict": "postulate prop90 : let n : Nat in do (if (and (prime n) (even n)) n)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nOption_inv_rect_Type4. Låt $x1$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$. Låt $P$ vara en funktion från element $_z1044$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.option$ applicerat på $x1$ till element av $cic.Univ$ av $univs.Type4$. Då för alla funktioner $_H1$ från element $_z1045$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.None$ applicerat på $x1$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.None$ applicerat på $x1$, för alla funktioner $_H2$ från element $x_591$ av $cic.Term$ av $univs.Type0$ och $x1$ och element $_z1045$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_types.option$ applicerat på $x1$ och $Hterm$ och $matita_basics_types.Some$ applicerat på $x1$ och $x_591$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_basics_types.Some$ applicerat på $x1$ och $x_591$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate option_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1044 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ univs.Type4) -> (_H1 : (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term univs.Type4 (P (matita_basics_types.None x1))) -> (_H2 : (x_591 : cic.Term univs.Type0 x1) -> (_z1045 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P (matita_basics_types.Some x1 x_591))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_le. Låt $_n$ och $__$ vara naturliga tal. Låt $return_sort$ vara ett element av $Sort$. Då för alla funktioner $return_type$ från element $z$ av $Leq$ av $_n$ och $__$ till element av $return_sort$, för alla funktioner $return$ från element $z$ av $Leq$ av $_n$ och $__$ till element av $return_type$ av $z$, om $_n \\leq __$, så håller $return_type$ för $z$.\nAssistant:", "label": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (z : Leq _n __) -> return_type z", "predict": "postulate filter_le : (_n : Nat) -> (_ : Nat) -> (return_sort : Sort) -> (z : Leq _n __) -> (return_type : (z : Leq _n __) -> return_sort) -> (return : (z : Leq _n __) -> return_type z) -> (_n : Nat) -> (__ : Nat) -> (z : Leq _n __) -> return_type z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_to_divides_ord_rem. Låt $p, n, m \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $p$ är primt. Då om $n$ är delbart med $m$, så är $ord_rem (n, p)$ delbart med $ord_rem (m, p)$.\nAssistant:", "label": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> divisible (ord_rem n p) (ord_rem m p)", "predict": "postulate divides_to_divides_ord_rem : (p : Nat) -> (n : Nat) -> (m : Nat) -> and (Lt 0 n) (Lt 0 m) (prime p) -> (H : divisible n m) -> and (divisible (ord_rem n p) (ord_rem m p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$ and $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Then if $c n - d m = 1$ or $d m - c n = 1$ and $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> Eq (m d - n c) (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1561. Soient $p$ et $m$ et $n$ des nombres naturels. Supposons que $0 < p$ et $1$ est égal au diviseur commun plus grand de $p$ et de $m$. Supposons que $p$ est divisible par $m \\times n$. Soit $c$ un nombre naturel. Supposons que $m n = p c$. Soit $a \\in N$. Soit $_clearme0$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $p$ et du produit de $b$ et de $m$ et le diviseur commun plus grand de $p$ et de $m$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $p$ et le diviseur commun plus grand de $p$ et de $m$. Soit $b \\in N$. Alors si le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$ ou égal à $b m - a p$ et le diviseur commun plus grand de $p$ et de $m$ est égal à $a p - b m$, alors si $a p - b m = 1$, alors $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posp : Lt 0 p) -> (posm : Eq 1 (div (comm : greater p m) m)) -> (pnm : divisible p m) -> (c : Nat) -> (nm : Nat) -> (auto : Eq m n) -> (auto' : ex Nat (\\ b : Nat -> disj (Eq (minus (times a p) (times b m)) (div (comm : greater p m) m)) (Eq (minus (times b m) (times a p)) (div (comm : greater p m) m))) (Eq (minus (times b m) (times a p)) (div (comm : greater p m) m))) -> (auto'' : Eq c (times a b)) -> (auto''' : Eq b m) -> (auto''': Eq (div (comm : greater p m) m) a) -> (auto'''': Eq (div (comm : greater p m) m) p) -> (auto'''''' : Eq p m) -> Eq (times a b) (times (div (comm : greater p m) m) (div (comm : greater p m) m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nEx_ind_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all functions $_P$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Univ$ of $cic.prop$, for all functions $Q_$ from elements $_x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_ex_intro$ from elements $x$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $x_236$ of $cic.Term$ of $cic.prop$ and $_P$ applied to $x$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_logic.ex_intro$ applied to $A$ and $_P$ and $x$ and $x_236$, for all elements $x_235$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.ex$ applied to $A$ and $_P$, $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_235$.\nAssistant:", "label": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)", "predict": "postulate ex_ind_body : (A : cic.Univ univs.Type0) -> (_P : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Univ cic.prop) -> (_H_ex_intro : (x : cic.Term univs.Type0 A) -> (x_236 : cic.Term cic.prop (_P x)) -> cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) -> (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P)) -> cic.Term cic.prop (Q_ x_235)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod. Pour tous les nombres naturels $n$ et $m$, $n = n \\div m m + mod (n, m)$.\nAssistant:", "label": "postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (plus (times (div n m) m) (mod n m))", "predict": "postulate div_mod : (n : Nat) -> (m : Nat) -> Eq n (n div m m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_div_mod_spec. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $n$ and $m$, $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_div_and_mod.div_mod_spec$ applied to $m$ and $n$ and $matita_arithmetics_div_and_mod.div$ applied to $m$ and $n$ and $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)", "predict": "postulate divides_to_div_mod_spec : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides n m)) -> cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec m n (matita_arithmetics_div_and_mod.div m n) matita_arithmetics_nat.O)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMod_S. För alla naturliga tal $n$ och $m$, om $0 < m$ och $mod (n, m)+ 1 < m$, så $mod (n + 1, m)= mod (n, m)+ 1$.\nAssistant:", "label": "postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (plus (mod n m) 1) m) -> Eq (mod (plus n 1) m) (plus (mod n m) 1)", "predict": "postulate mod_S : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : Lt (mod n m) + 1) -> Eq (mod n m) (mod n m) + 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTo_min. För alla naturliga tal $i$ och $n$ och $m$, om $i \\leq n$, så om $i \\leq m$, så $i \\leq min (n, m)$.\nAssistant:", "label": "postulate to_min : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i n) -> (__1 : Leq i m) -> Leq i (min n m)", "predict": "postulate to_min : (i : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Leq i n) -> (__1 : Leq i m) -> Leq i (min n m)"}
{"prompt": "Human: Translate the following English statement into Agda.\nGcd_1_to_lt_n. Let $i$ and $n$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.le$ applied to $i$ and $n$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_gcd.gcd$ applied to $i$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $i$ and $n$.\nAssistant:", "label": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)", "predict": "postulate gcd_1_to_lt_n : (i : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le i n)) -> (__2 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd i n) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> cic.Term cic.prop (matita_arithmetics_nat.lt i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAssoc. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Then for all elements $nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all elements $xxx$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.Aop$ applied to $A$ and $nil$, for all elements $a$ and $b$ and $c$ of $cic.Term$ of $univs.Type0$ and $A$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $b$ and $c$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $matita_basics_lists_list.op$ applied to $A$ and $nil$ and $xxx$ and $a$ and $b$ and $c$.\nAssistant:", "label": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))", "predict": "postulate assoc : (A : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 A) -> (xxx : cic.Term univs.Type0 (matita_basics_lists_list.Aop A nil)) -> (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (matita_basics_lists_list.op A nil xxx a (matita_basics_lists_list.op A nil xxx b c)) (matita_basics_lists_list.op A nil xxx (matita_basics_lists_list.op A nil xxx a b) c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1$ un nombre naturel. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$. Supposons que $p2 (n1)= true$ et $p1 (n1)= true$. Soit $x2515, x2516 \\in N$. Alors $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> true) -> (p2 : (_ : Nat) -> Eq (p1 (i)) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 (i)) -> Leq g1 i) -> Leq (bigop n1 (\\ i : Nat -> p1 (i)) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 (i)) Nat 0 plus (\\ i : Nat -> g2 i)) -> (H1 : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> Eq (p2 (i)) true) -> (H2 : (_ : Nat) -> (i : Nat) -> (__1 : Eq p1 (i)) -> Leq g1 i) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 / x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_mod_to_divides. Let $p, m, n \\in N$. Assume that $0$ is less than $n$. Assume that $p$ is divisible by $mod$ applied to $m$ and $n$. Then if $p$ is divisible by $n$, then $p$ is divisible by $m$.\nAssistant:", "label": "postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m", "predict": "postulate divides_mod_to_divides : (p : Nat) -> (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : divisible p (mod m n)) -> (__2 : divisible p n) -> divisible p m"}
{"prompt": "Human: Translate the following English statement into Agda.\nLog_div. Let $p, n, m \\in N$. Then if $1$ is less than $p$, then if $0$ is less than $m$, then if $m$ is less than or equal to $n$, then the logarithm of $p$ and the quotient of $n$ and $m$ is less than or equal to the difference of the logarithm of $p$ and $n$ and the logarithm of $p$ and $m$.\nAssistant:", "label": "postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))", "predict": "postulate log_div : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 m) -> (__2 : Leq m n) -> Leq (log p (div n m)) (minus (log p n) (log p m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_inv_rect_Type0. Soit $x1$ un ensemble. Soit $x2$ un élément de $x1$. Alors pour tous les éléments $Hterm$ de $ACop$ de $x1$ et de $x2$, pour toutes les fonctions $P$ des éléments $_z1596$ de $ACop$ de $x1$ et de $x2$ à des ensembles, pour toutes les fonctions $_H1$ des éléments $aop$ de $Aop$ de $x1$ et de $x2$ et des fonctions $_comm$ des éléments $a$ de $x1$ et des éléments $b$ de $x1$ à des éléments de $Eq$ de $op (x1, x2, aop, a, b)$ et de $op (x1, x2, aop, b, a)$ et des éléments $_z1597$ de $Eq$ de $Hterm$ et de $mk_ACop (x1, x2, aop, _comm)$ à des éléments de $P$ de $mk_ACop (x1, x2, aop, _comm)$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm", "predict": "postulate ACop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : ACop x1 x2) -> (P : (_z1596 : ACop x1 x2) -> Set) -> (_H1 : (aop : Aop x1 x2) -> (_comm : (a : x1) -> (b : x1) -> Eq (op x1 x2 aop a b) (op x1 x2 aop b a)) -> (_z1597 : Eq Hterm (mk_ACop x1 x2 aop _comm)) -> P (mk_ACop x1 x2 aop _comm)) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_Type2_body. For all elements $_A$ of $cic.Univ$ of $univs.Type0$, for all functions $Q_$ from elements $_x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H_mk_range$ from functions $_enum$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $_A$ and elements $_upto$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and functions $_filter$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$ to elements of $cic.Term$ of $univs.Type2$ and $Q_$ applied to $matita_arithmetics_bigops.mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$, for all elements $x_923$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.range$ applied to $_A$, $cic.Term$ holds for $univs.Type2$ and $Q_$ applied to $x_923$.\nAssistant:", "label": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)", "predict": "postulate range_rect_Type2_body : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Univ univs.Type2) -> (_H_mk_range : (_enum : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 _A) -> (_upto : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_filter : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Term univs.Type2 (Q_ (matita_arithmetics_bigops.mk_range _A _enum _upto _filter))) -> (x_923 : cic.Term univs.Type0 (matita_arithmetics_bigops.range _A)) -> cic.Term univs.Type2 (Q_ x_923)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_div_S_S_div. Soient $n$ et $m$ des nombres naturels. Alors si $0 < m$, alors $(n + 1)\\div m \\leq n \\div m + 1$.\nAssistant:", "label": "postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (plus (div n m) 1)", "predict": "postulate le_div_S_S_div : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> Leq (div (plus n 1) m) (div n m + 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nSmallest_factor_to_min. For all natural numbers $n$, if $1$ is less than $n$, then $smallest_factor$ applied to $n$ is equal to $min$ applied to $n$ and $2$ and the function that maps $m$ to $eqb$ applied to $mod$ applied to $n$ and $m$ and $0$.\nAssistant:", "label": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))", "predict": "postulate smallest_factor_to_min : (n : Nat) -> (_ : Lt 1 n) -> Eq (smallest_factor n) (min n 2 (\\ m : Nat -> eqb (mod n m) 0))"}
{"prompt": "Human: Translate the following English statement into Agda.\nP_ord_times. Let $p$ and $a$ and $b$ and $qa$ and $ra$ and $qb$ and $rb$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $a$. Let $__2$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $b$. Then for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $a$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qa$ and $ra$, for all elements $__4$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to $b$ and $p$ and $matita_basics_types.mk_Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $qb$ and $rb$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_types.Prod$ applied to $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.p_ord$ applied to", "label": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_ar", "predict": "postulate p_ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qa : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (ra : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (qb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (rb : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O a)) -> (__2 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord a p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qa ra))) -> (__4 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_ord.p_ord b p) (matita_basics_types.mk_Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat qb rb))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Prod matita_arithmetics_nat.nat matita_arithmetics_nat.nat)) (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_basics_logic.rfl a p)) (matita_basics_logic.rfl b (matita_basics_logic.rfl c d e f g h i j k l m n o p q r"}
{"prompt": "Human: Translate the following English statement into Agda.\nOrd_times. For all elements $p$ and $m$ and $n$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $m$, for all elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.O$ and $n$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_primes.prime$ applied to $p$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_ord.ord$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $n$ and $p$ and $matita_arithmetics_nat.plus$ applied to $matita_arithmetics_ord.ord$ applied to $m$ and $p$ and $matita_arithmetics_ord.ord$ applied to $n$ and $p$.\nAssistant:", "label": "postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))", "predict": "postulate ord_times : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O n)) -> (__2 : cic.Term cic.prop (matita_arithmetics_primes.prime p)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_ord.ord (matita_arithmetics_nat.times m n) p) (matita_arithmetics_nat.plus (matita_arithmetics_ord.ord m p) (matita_arithmetics_ord.ord n p)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10331. Soit $n \\in N$. Supposons que $5 < n$. Soit $m \\in N$. Alors si $6 \\leq m$ et $(m + 1)^ 2 \\leq 2 ^ m$, alors pour tous les nombres naturels $a$, si $6 \\leq a$ et $2 (a + 1)+ 1 \\leq 2 ^ a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : soit n : Nat -> supposons (Lt 5 n) (m : Nat) -> (H : Leq 6 m) -> (auto : (m : Nat) -> Leq 2 (m + 1)) -> (H' : Leq 6 a) -> (auto' : Leq 2 (a + 1) + 1) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 x2516 (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n \\in N$. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i, j \\in N$. Anta att $i \\leq n$ och $j \\leq n$. Låt $a \\in N$. Anta att $a \\leq n$ och $f (a)= i$ och $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$ och $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Låt $injf$ vara ett element av $injn$ av $f$ och $n$. Anta att $a = b$. Då $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i, j : Nat) -> (l : Nat) -> (a : Nat) -> (b : Nat) -> (_ : Leq i n) -> (j : Leq n) -> (a : Nat) -> (b : Nat) -> (f : (_ : Nat) -> Nat) -> (f0 : (_ : Nat) -> Nat) -> (injf : injn f n) -> (Hc : Eq a b) -> (f0 : (_ : Nat) -> Nat) -> (H : Leq f i0 n) -> (Hc0 : Leq f (f i0) n) -> (Hc1 : Leq f b n) -> (Hc2 : Leq f (f b) n) -> (_e : Eq (f a) j) -> (Hc3 : Leq a b) -> (Hc4 : Eq (f a) i0) -> (Hc5 : Leq a (f n)) -> (Hc6 : Eq f (f n)) -> Eq (f (f a)) (f (f b))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_O_log. Pour tous les éléments $p$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $p$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $matita_arithmetics_log.log$ appliqué à $p$ et $n$.\nAssistant:", "label": "postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))", "predict": "postulate lt_O_log : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) n)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.le p n)) -> cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O (matita_arithmetics_log.log p n))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_ord_rem. For all natural numbers $n$ and $m$, if $n$ is prime and $0 < m$, then if $n$ is divisible by $m$, then $ord_rem (m, n)< m$.\nAssistant:", "label": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m", "predict": "postulate lt_ord_rem : (n : Nat) -> (m : Nat) -> (_ : prime n) -> (__1 : Lt 0 m) -> (__2 : divisible n m) -> Lt (ord_rem m n) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l. Soit $B$ un ensemble. Soit $R$ une fonction des éléments de $B$ et des éléments $__1$ de $B$ à des propositions. Soit $b2$ un élément de $B$. Soit $P$ un élément de $relation2$ de $Nat$ et de $B$. Soit $__$ un élément de $P$ de $0$ et de $b2$. Soit $__1$ une fonction des nombres naturels $l$ et des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $__1$ de $R$ de $b1$ et de $b$ et des éléments $__2$ de $lstar$ de $B$ et de $R$ et de $l$ et de $b$ et de $b2$ et des éléments $__3$ de $P$ de $l$ et de $b$ à des éléments de $P$ de $l + 1$ et de $b1$. Soit $l$ un nombre naturel. Soit $b1$ un élément de $B$. Soit $__2$ un élément de $lstar$ de $B$ et de $R$ et de $l$ et de $b1$ et de $b2$. Alors $P$ tient pour $l$ et $b1$.\nAssistant:", "label": "postulate lstar_ind_l : (B : Set) -> (R : (_ : B) -> (__1 : B) -> Prop) -> (b2 : B) -> (P : relation2 Nat B) -> (_ : P 0 b2) -> (__1 : (l : Nat) -> (b1 : B) -> (b : B) -> (__1 : R b1 b) -> (__2 : lstar B R l b b2) -> (__3 : P l b) -> P (plus l 1) b1) -> (l : Nat) -> (b1 : B) -> (__2 : lstar B R l b1 b2) -> P l b1", "predict": "postulate lstar_ind_l : soit B un ensemble. soit R une fonction des elements de B et des elements __1 de B a des propositions. soit b2 un element de B. soit P un element de relation2 Nat B. soit __ un element of P 0 b2. soit __1 une fonction des nombres naturels l et des elements b1 de B et des elements b de B et des elements __1 de R b1 b. soit __2 de lstar B R l b b2. soit __3 de P l b. soit l un nombre naturel. soit b1 un element de B. soit __2 de lstar B R l b1 b2. alors P tient pour l b1."}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10336. Let $n$ and $m$ be natural numbers. Let $Hind$ be a function from natural numbers $p$ and elements of $Lt$ of $p$ and $m$ and elements $__1$ of $Lt$ of $1$ and $p$ to elements of $Leq$ of $Psi (p)$ and $pred (p)\\times (2 ^ (2 p - 3))$. Let $a \\in N$. Assume that $m = 2 a$ or $m = 2 a + 1$ and $m = 2 a + 1$. Assume that $1 < 2 a + 1$ and $0 < a$. Then for all natural numbers $x2515$ and $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (am : or (Eq m 2 a) (Eq m 2 a + 1)) -> (Hm : Lt 1 2 a + 1) -> (Ha : Lt a 0) -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod x2515 x2516"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type4_body. Låt $Q_$ vara en funktion från naturliga tal $_x_369$ till element av $Type4$. Låt $_H_O$ vara ett element av $Q_$ av $0$. Låt $_H_S$ vara en funktion från naturliga tal $x_370$ och element $_x_372$ av $Q_$ av $x_370$ till element av $Q_$ av $x_370 + 1$. Låt $x_369 \\in N$. Då håller $Q_$ för $x_369$.\nAssistant:", "label": "postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ (plus x_370 1)) -> (x_369 : Nat) -> Q_ x_369", "predict": "postulate nat_rect_Type4_body : (Q_ : (_x_369 : Nat) -> Type4) -> (_H_O : Q_ 0) -> (_H_S : (x_370 : Nat) -> (_x_372 : Q_ x_370) -> Q_ x_370 + 1) -> (x_369 : Nat) -> (Q_ : x_369 -> Q_ x_369) -> Q_ x_369"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_minus_associative. Soient $x$ et $y$ et $z$ des nombres naturels. Supposons que $z \\leq y$. Supposons que $y \\leq x$. Alors $x - (y - z)= x - y + z$.\nAssistant:", "label": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Leq z y) -> (__1 : Leq y x) -> Eq (minus x (minus y z)) (plus (minus x y) z)", "predict": "postulate minus_minus_associative : (x : Nat) -> (y : Nat) -> (z : Nat) -> (zLeqy : Leq z y) -> (yLeqx : Leq y x) -> (H : z <= y) -> (H0 : y <= x) -> x - (y - z) = x - y + z"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp5_body. Pour tous les ensembles $A$, pour tous les éléments $_nil$ de $A$, pour toutes les fonctions $Q_$ des éléments $_x_959$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod (a, _nil)$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod (a, aop__o__op (A, _nil, sum, b, c))$ et de $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ à des éléments de $Q_$ de $mk_Dop (A, _nil, sum, prod, _null, _distr)$, pour tous les éléments $x_959$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_959$.\nAssistant:", "label": "postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959", "predict": "postulate Dop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_959 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_959 : Dop A _nil) -> Q_ x_959"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_ind. För alla element $A$ av $cic.Univ$ av $univs.Type0$, för alla funktioner $_f$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_664$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_mk_Sig$ från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$, för alla element $x_664$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_664$.\nAssistant:", "label": "postulate Sig_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)", "predict": "postulate Sig_ind : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ cic.prop) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term cic.prop (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_664 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term cic.prop (Q_ x_664)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_Type3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_nil$ vara ett element av $cic.Term$ av $univs.Type0$ och $A$. Låt $Q_$ vara en funktion från element $_x_787$ av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.Aop$ applicerat på $A$ och $_nil$ till element av $cic.Univ$ av $univs.Type3$. Då för alla funktioner $_H_mk_Aop$ från funktioner $op$ från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ och element $__1$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $univs.Type0$ och $A$ och funktioner $_nill$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $_nil$ och $a$ och $a$ och funktioner $_nilr$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $_nil$ och $a$ och funktioner $_assoc$ från element $a$ av $cic.Term$ av $univs.Type0$ och $A$ och element $b$ av $cic.Term$ av $univs.Type0$ och $A$ och element $c$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $A$ och $op$ applicerat på $a$ och $op$ applicerat på $b$ och $c$ och $op$ applicerat på $op$ applicerat på $a$ och $b$ och $c$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $mat", "label": "postulate Aop_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787)", "predict": "postulate låt : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ univs.Type3) -> (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type3 (Q_ (matita_basics_lists_list.Aop A _nil) _nilr _assoc)) -> (x_787 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term univs.Type3 (Q_ x_787 (matita_basics_lists_list.mk_Aop A _nil))"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_Type2. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_897$ of $ACop$ of $A$ and $_nil$ to elements of $Type2$. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op$ applied to $A$ and $_nil$ and $aop$ and $a$ and $b$ and $op$ applied to $A$ and $_nil$ and $aop$ and $b$ and $a$ to elements of $Q_$ of $mk_ACop$ applied to $A$ and $_nil$ and $aop$ and $_comm$. Let $x_897$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_897$.\nAssistant:", "label": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897", "predict": "postulate ACop_rect_Type2 : (A : Set) -> (_nil : A) -> (Q_ : (_x_897 : ACop A _nil) -> Type2) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_897 : ACop A _nil) -> Q_ x_897"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_inv_rect_Type2. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$. Then for all functions $P$ from elements $_z1716$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type2$, for all functions $_H1$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $univs.Type0$ and $x1$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $x2$ and $x2$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $prod$ applied to $a$ and $matita_ar", "label": "postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)", "predict": "postulate Dop_inv_rect_Type2 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1716 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ univs.Type2) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.ACop x1 x2)) (matita_arithmetics_bigops.Dop x1 x2))) -> (_z1717 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term univs.Type2 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_d_times_gcd. Låt $m$ och $n$ och $d$ och $c$ vara naturliga tal. Anta att $0 < c$ och $d$ är delbart med $c \\times m$. Då om $d$ är delbart med $c \\times n$, så är $d$ delbart med produkten av $c$ och det största gemensama delaret av $n$ och $m$.\nAssistant:", "label": "postulate divides_d_times_gcd : (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> (_ : Lt 0 c) -> (__1 : divisible d (times c m)) -> (__2 : divisible d (times c n)) -> divisible d (times c (gcd n m))", "predict": "postulate divides_d_times_gcd : let (m : Nat) -> (n : Nat) -> (d : Nat) -> (c : Nat) -> Nat\n  -> and (Lt 0 c) (div d c)\n  -> and (div d c) (div (div c m) (gcd n m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPad_bigop1. Let $k, n \\in N$. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Let $op$ be a function from elements of $B$ and elements $__1$ of $B$ to elements of $B$. Then for all functions $f$ from natural numbers to elements of $B$, if $n$ is less than or equal to $k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $Eq$ of $p$ applied to $i$ and absurdity, $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_sum. Soient $k1$ et $k2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soient $p1$ et $p2$ des fonctions des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_bool.bool$. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $nil$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $op$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$. Alors pour toutes les fonctions $f$ et $g$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et $matita_arithmetics_bigops.bigop$ appliqué à $k1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $k2$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $k1$ et $", "label": "postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1", "predict": "postulate bigop_sum : (k1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (k2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p1 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (p2 : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (g : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop k1 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p1 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i)) (matita_arithmetics_bigops.bigop k2 (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p2 i) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> g i))) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.plus k1 (matita_arithmetics_nat.times k1 k2)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus k1 (matita_arithmetics_nat.times k1 k2)) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nRelation2. Låt $__$ och $__1$ vara element av $cic.Univ$ av $univs.Type0$. Då håller $cic.Univ$ för $univs.Type0$.\nAssistant:", "label": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0", "predict": "postulate relation2 : (__ : cic.Univ univs.Type0) -> (__1 : cic.Univ univs.Type0) -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1560. Let $n, m \\in N$. Assume that $n$ is divisible by $m$. Assume that $0 = n$. Let $d \\in N$. Assume that $m = 0 d$. Then $n = 0$.\nAssistant:", "label": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (H : Eq 0 n) -> (d : Nat) -> (auto : Eq m (times 0 d)) -> Eq n 0", "predict": "postulate let_clause_1560 : (n : Nat) -> (m : Nat) -> (divnm : divisible n m) -> (zero : Eq 0 n) -> (d : Nat) -> (eqm0d : Eq m 0 d) -> Eq n 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1704. Låt $m$ vara ett naturligt tal. Anta att $0$ är mindre än $m$. Låt $a, x1029 \\in N$. Då är $x1029$ lika med $aop__o__op$ applicerat på $Nat$ och $0$ och $plusAC$ och $x1029$ och $0$.\nAssistant:", "label": "postulate let_clause_1704 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x1029 : Nat) -> Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)", "predict": "postulate let_clause_1704 : let m : Nat -> and (Lt 0 m) (Lett x1029 : Nat) -> x1029 : Eq x1029 (aop__o__op Nat 0 plusAC x1029 0)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp4_body. For all sets $A$, for all elements $_nil$ of $A$, for all functions $Q_$ from elements $_x_957$ of $Dop$ of $A$ and $_nil$ to propositions, for all functions $_H_mk_Dop$ from elements $sum$ of $ACop$ of $A$ and $_nil$ and functions $prod$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_null$ from elements $a$ of $A$ to elements of $Eq$ of $prod (a, _nil)$ and $_nil$ and functions $_distr$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $prod (a, aop__o__op (A, _nil, sum, b, c))$ and $aop__o__op (A, _nil, sum, prod (a, b), prod (a, c))$ to elements of $Q_$ of $mk_Dop (A, _nil, sum, prod, _null, _distr)$, for all elements $x_957$ of $Dop$ of $A$ and $_nil$, $Q_$ holds for $x_957$.\nAssistant:", "label": "postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957", "predict": "postulate Dop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_957 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_957 : Dop A _nil) -> Q_ x_957"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind_r_aux. Let $B$ be an element of $cic.Univ$ of $univs.Type0$. Let $R$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation$ applied to $B$. Let $b1$ be an element of $cic.Term$ of $univs.Type0$ and $B$. Let $P$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_relations.relation2$ applied to $matita_arithmetics_nat.nat$ and $B$. Then for all elements $__$ of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.O$ and $b1$, for all functions $__1$ from elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $b2$ of $cic.Term$ of $univs.Type0$ and $B$ and elements $__1$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b1$ and $b$ and elements $__2$ of $cic.Term$ of $cic.prop$ and $R$ applied to $b$ and $b2$ and elements $__3$ of $cic.Term$ of $cic.prop$ and $P$ applied to $l$ and $b$ to elements of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_arithmetics_nat.plus$ applied to $l$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $b2$, for all elements $l$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $b$ and $b2$ of $cic.Term$ of $univs.Type0$ and $B$, for all elements $__2$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_lstar.lstar$ applied to $B$ and $R$ and $l$ and $b$ and $b2$, for all elements $__3$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $B$ and $b$ and $b1$, $cic.Term$ holds for $cic.prop$ and $P$ applied to $l$ and $b2$.\nAssistant:", "label": "postulate lstar_ind_r_aux : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) -> cic.Term cic.prop (P l b2)", "predict": "postulate lstar_ind_r_aux : (B : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (b1 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b1)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__2 : cic.Term cic.prop (R b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b1)) -> cic.Term cic.prop (P l b2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1575. Låt $m$ och $n$ och $a$ och $b$ vara naturliga tal. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Låt $d \\in N$. Anta att $c n - d m = 1$ eller $d m - c n = 1$. Anta att $c n - d m = 1$. Då för alla naturliga tal $x1029$, $x1029 = x1029 (n c - m d)$.\nAssistant:", "label": "postulate let_clause_1575 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> (x1029 : Nat) -> Eq x1029 (times x1029 (minus (times n c) (times m d)))", "predict": "postulate let_clause_1575 : let m : Nat and n : Nat and a : Nat and b : Nat -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (lt1 : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) m) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (d : Nat) -> (pos : Eq c d) -> (Hc : Eq n m) -> (Hm : Eq c d) -> (Hn : Eq (times d m) (times c n)) -> (Hc0 : all Nat (\\ x1029 : Nat -> Eq x1029 (n c - m d))) -> Eq x1029 (x1029 (n c - m d))"}
{"prompt": "Human: Translate the following English statement into Agda.\nSum_rect_CProp5_body. Let $_A$ and $_B$ be elements of $cic.Univ$ of $univs.Type0$. Let $Q_$ be a function from elements $_x_561$ of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_inl$ be a function from elements $x_562$ of $cic.Term$ of $univs.Type0$ and $_A$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inl$ applied to $_A$ and $_B$ and $x_562$. Let $_H_inr$ be a function from elements $x_563$ of $cic.Term$ of $univs.Type0$ and $_B$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_basics_types.inr$ applied to $_A$ and $_B$ and $x_563$. Let $x_561$ be an element of $cic.Term$ of $univs.Type0$ and $matita_basics_types.Sum$ applied to $_A$ and $_B$. Then $cic.Term$ holds for $cic.prop$ and $Q_$ applied to $x_561$.\nAssistant:", "label": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)", "predict": "postulate Sum_rect_CProp5_body : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_562 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_562))) -> (_H_inr : (x_563 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_563))) -> (x_561 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_561)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1551. Pour tous les éléments $m$ et $n$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $eqn0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.O$ et $n$, pour tous les éléments $x347$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $x347$ et $n$.\nAssistant:", "label": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))", "predict": "postulate let_clause_1551 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (eqn0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) matita_arithmetics_nat.O n)) -> (x347 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.times x347 n))"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_rect_CProp0. Soient $_A$ et $_B$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_inl$ une fonction des éléments $x_582$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inl$ appliqué à $_A$ et $_B$ et $x_582$. Soit $_H_inr$ une fonction des éléments $x_583$ de $cic.Term$ de $univs.Type0$ et de $_B$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.inr$ appliqué à $_A$ et $_B$ et $x_583$. Alors pour tous les éléments $x_581$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $_A$ et $_B$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_581$.\nAssistant:", "label": "postulate Sum_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)", "predict": "postulate Sum_rect_CProp0 : (_A : cic.Univ univs.Type0) -> (_B : cic.Univ univs.Type0) -> (Q_ : (_x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Univ cic.prop) -> (_H_inl : (x_582 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.inl _A _B x_582))) -> (_H_inr : (x_583 : cic.Term univs.Type0 _B) -> cic.Term cic.prop (Q_ (matita_basics_types.inr _A _B x_583))) -> (x_581 : cic.Term univs.Type0 (matita_basics_types.Sum _A _B)) -> cic.Term cic.prop (Q_ x_581)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLt_inv_plus_l. Soient $x$ et $y$ et $z$ des nombres naturels. Supposons que $x + y < z$. Alors $x < z$ et $y < z - x$.\nAssistant:", "label": "postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_ : Lt (plus x y) z) -> and (Lt x z) (Lt y (minus z x))", "predict": "postulate lt_inv_plus_l : (x : Nat) -> (y : Nat) -> (z : Nat) -> (H : Lt x y z) -> and (Lt x z) (Lt y z - x)"}
{"prompt": "Human: Translate the following French statement into Agda.\nMinus_plus. Soient $n$ et $m$ et $p$ des nombres naturels. Alors la différence de la différence de $n$ et de $m$ et de $p$ est égale à la différence de $n$ et de la somme de $m$ et de $p$.\nAssistant:", "label": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))", "predict": "postulate minus_plus : (n : Nat) -> (m : Nat) -> (p : Nat) -> Eq (minus (minus n m) p) (minus n (plus m p))"}
{"prompt": "Human: Translate the following English statement into Agda.\nPrimes_below_to_bertrand. Let $pm \\in N$. Let $l$ be a list of natural numbers. Assume that $pm$ is prime. Then for all elements $__1$ of $primes_below$ of $l$ and $pm + 1$, for all functions $__2$ from natural numbers $p$ and elements $__2$ of $mem$ of $Nat$ and $p$ and $l$ and elements $__3$ of $Lt$ of $2$ and $p$ to elements of $ex$ of $Nat$ and the function that maps $pp$ to the conjunction of the conjunction of $mem$ applied to $Nat$ and $pp$ and $l$ and $Lt$ applied to $pp$ and $p$ and $Leq$ applied to $p$ and the product of $2$ and $pp$, for all natural numbers $n$, if $0 < n$ and $n < pm$, then $bertrand$ holds for $n$.\nAssistant:", "label": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (_ : prime pm) -> (__1 : primes_below l (plus pm 1)) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> (__4 : Lt n pm) -> bertrand n", "predict": "postulate primes_below_to_bertrand : (pm : Nat) -> (l : list Nat) -> (prime : prime pm) -> (__1 : primes_below l pm + 1) -> (__2 : (p : Nat) -> (__2 : mem Nat p l) -> (__3 : Lt 2 p) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))) -> (n : Nat) -> (__3 : Lt 0 n) -> and (and (prime n) (and (Lt n pm) (Leq p (times 2 n)))) -> bertrand n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_lstar_r. Låt $B$ vara en mängd. Låt $_R$ vara ett element av $relation$ av $B$. Då för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från naturliga tal och element $__1$ av $B$ och element $__2$ av $B$ och element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $return_sort$, för alla funktioner $case_lstar_r_O$ från element $b$ av $B$ till element av $return_type$ av $0$ och $b$ och $b$ och $lstar_r_O$ applicerat på $B$ och $_R$ och $b$, för alla funktioner $case_lstar_r_S$ från naturliga tal $l$ och element $b1$ av $B$ och element $b$ av $B$ och element av $lstar_r$ av $B$ och $_R$ och $l$ och $b1$ och $b$ och element $b2$ av $B$ och element $__1$ av $_R$ av $b$ och $b2$ till element av $return_type$ av summan av $l$ och $1$ och $b1$ och $b2$ och $lstar_r_S$ applicerat på $B$ och $_R$ och $l$ och $b1$ och $b$ och $__$ och $b2$ och $__1$, för alla naturliga tal $__$, för alla element $__1$ och $__2$ av $B$, för alla element $z$ av $lstar_r$ av $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $return_type$ för $__$ och $__1$ och $__2$ och $z$.\nAssistant:", "label": "postulate match_lstar_r : (B : Set) -> (_R : relation B) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) -> (case_lstar_r_O : (b : B) -> return_type 0 b b (lstar_r_O B _R b)) -> (case_lstar_r_S : (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B _R l b1 b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (plus l 1) b1 b2 (lstar_r_S B _R l b1 b __ b2 __1)) -> (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z", "predict": "postulate match_lstar_r : let B : Mngd B let _R : relation B Då for (return_sort : Sort) (return_type : (_ : Nat) -> (__1 : B) -> (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_sort) (case_lstar_r_O : (b : B) -> return_type 0 b b) (b : B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (l1 : lstar_r B _R l b b) -> (b2 : B) -> (__1 : _R b b2) -> return_type (sum m1 m2) (lstar_r_S B _R l b b __ b2 __1) (__1 : B) (__2 : B) -> (z : lstar_r B _R __ __1 __2) -> return_type __ __1 __2 z"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_inv_rect_Type3. Låt $x1$ vara en mängd. Låt $x2$ vara ett element av $x1$. Låt $Hterm$ vara ett element av $Dop$ av $x1$ och $x2$. Låt $P$ vara en funktion från element $_z1710$ av $Dop$ av $x1$ och $x2$ till element av $Type3$. Då för alla funktioner $_H1$ från element $sum$ av $ACop$ av $x1$ och $x2$ och funktioner $prod$ från element av $x1$ och element $__1$ av $x1$ till element av $x1$ och funktioner $_null$ från element $a$ av $x1$ till element av $Eq$ av $prod (a, x2)$ och $x2$ och funktioner $_distr$ från element $a$ av $x1$ och element $b$ av $x1$ och element $c$ av $x1$ till element av $Eq$ av $prod (a, aop__o__op (x1, x2, sum, b, c))$ och $aop__o__op (x1, x2, sum, prod (a, b), prod (a, c))$ och element $_z1711$ av $Eq$ av $Hterm$ och $mk_Dop (x1, x2, sum, prod, _null, _distr)$ till element av $P$ av $mk_Dop (x1, x2, sum, prod, _null, _distr)$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate Dop_inv_rect_Type3 : (x1 : Set) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (_H1 : (sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> P Hterm", "predict": "postulate Dop_inv_rect_Type3 : (x1 : Mngd) -> (x2 : x1) -> (Hterm : Dop x1 x2) -> (P : (_z1710 : Dop x1 x2) -> Type3) -> (Hterm : Dop x1 x2) -> (_H1 : (sum : ACop x1 x2) -> (_ : sum : ACop x1 x2) -> (prod : (_ : x1) -> (__1 : x1) -> x1) -> (_null : (a : x1) -> Eq (prod a x2) x2) -> (_distr : (a : x1) -> (b : x1) -> (c : x1) -> Eq (prod a (aop__o__op x1 x2 sum b c)) (aop__o__op x1 x2 sum (prod a b) (prod a c))) -> (_z1711 : Eq Hterm (mk_Dop x1 x2 sum prod _null _distr)) -> P (mk_Dop x1 x2 sum prod _null _distr)) -> (Hterm : Dop x1 x2) -> P Hterm"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_pi_p_M. Let $m$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_primes.divides$ applied to $matita_arithmetics_bigops.bigop$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $m$ and the function that maps $p$ to $matita_basics_bool.andb$ applied to $matita_arithmetics_nat.leb$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $m$ and $p$ and $matita_arithmetics_primes.primeb$ applied to $p$ and $matita_arithmetics_nat.nat$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $matita_arithmetics_nat.times$ and the function that maps $p$ to $p$ and $matita_arithmetics_binomial.M$ applied to $m$.\nAssistant:", "label": "postulate divides_pi_p_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))", "predict": "postulate divides_pi_p_M : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_arithmetics_primes.divides (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) m))) (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.andb (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S m)) p) (matita_arithmetics_primes.primeb p)) matita_arithmetics_nat.nat (matita_arithmetics_nat.S matita_arithmetics_nat.O) matita_arithmetics_nat.times (\\ p : cic.Term univs.Type0 matita_arithmetics_nat.nat -> p)) (matita_arithmetics_binomial.M m))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1063. Let $f$ be a function from natural numbers to natural numbers. Let $n \\in N$. Let $permf$ be an element of $permut$ of $f$ and $n$. Let $i, j \\in N$. Assume that $i \\leq n$ and $j \\leq n$. Let $a$ be a natural number. Assume that $a \\leq n$ and $f (a)= i$ and $a \\leq n$. Assume that $f (a)= i$. Let $b$ be a natural number. Assume that $b \\leq n$ and $f (b)= j$ and $b \\leq n$. Then if $f (b)= j$, then for all functions $__$ from natural numbers $i0$ and elements of $Leq$ of $i0$ and $n$ to elements of $Leq$ of $f (i0)$ and $n$, for all elements $injf$ of $injn$ of $f$ and $n$, if $a = b$, then $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (ain : Nat) -> (a : Nat) -> (abin : Nat) -> (fbin : (a : Nat) -> i) -> (abin0 : Nat) -> (fbin0 : (a : Nat) -> j) -> (b : Nat) -> (bin : Nat) -> (b0 : Nat) -> (fbin0 : (a : Nat) -> b) -> (Hind : Eq (f (b)) j) -> (Hind0 : (_ : (i0 : Nat) -> Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (ainf : Eq a n) -> (abinf : Nat) -> (fbin : (a : Nat) -> i) -> (abinf0 : Nat) -> (fbin0 : (a : Nat) -> j) -> (binf : (b : Nat) -> Eq (f b) j) -> (Hind1 : Eq (f (b)) j) -> (Hind2 : Eq (f a) i) -> (Hind3 : Eq a n) -> Eq (f a) j"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_exp. Låt $n, m, i \\in N$. Anta att $0$ är mindre än $m$. Anta att $mod$ applicerat på $n$ och $m$ inte är lika med $0$. Låt $p \\in N$. Då om $i$ är mindre än eller lika med $p$, så är $p_ord_aux$ applicerat på $p$ och produkten av potensen av $m$ och $i$ och $n$ och $m$ lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $i$ och $n$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (p : Nat) -> (auto : Lt 0 m) -> (auto' : not (Eq (mod n m) 0)) -> (auto'' : Eq p (p_ord_aux p (times (pow m i) n) m)) -> Eq (mk_Prod Nat Nat i n) (mk_Prod Nat Nat i n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAxiom. Let $_p, _n \\in N$. Then the logarithm of $_p$ and $_n$ is a natural number.\nAssistant:", "label": "postulate log : (_p : Nat) -> (_n : Nat) -> Nat", "predict": "postulate log : (_p : Nat) -> (_n : Nat) -> Nat"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nEq_ind_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type2$. Låt $_x$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $Q_$ vara en funktion från element $x_1$ av $cic.Term$ av $univs.Type2$ och $A$ och element $_x_2$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_1$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_refl$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $_x$ och $matita_basics_logic.refl$ applicerat på $A$ och $_x$. Låt $x_1$ vara ett element av $cic.Term$ av $univs.Type2$ och $A$. Låt $x_2$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $A$ och $_x$ och $x_1$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_1$ och $x_2$.\nAssistant:", "label": "postulate eq_ind_body : (A : cic.Univ univs.Type2) -> (_x : cic.Term univs.Type2 A) -> (Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop) -> (_H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)", "predict": "postulate eq_ind_body : let A : cic.Univ univs.Type2 in let _x : cic.Term univs.Type2 A in let Q_ : (x_1 : cic.Term univs.Type2 A) -> (_x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Univ cic.prop in let _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x))) -> (x_1 : cic.Term univs.Type2 A) -> (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1)) -> cic.Term cic.prop (Q_ x_1 x_2)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_rect_Type2_body. Let $_n, _m, _q, _r \\in N$. Let $Q_$ be a function from elements $_x_825$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to elements of $Type2$. Let $_H_div_mod_spec_intro$ be a function from elements $x_827$ of $Lt$ of $_r$ and $_m$ and elements $x_826$ of $Eq$ of $_n$ and the sum of the product of $_q$ and $_m$ and $_r$ to elements of $Q_$ of $div_mod_spec_intro$ applied to $_n$ and $_m$ and $_q$ and $_r$ and $x_827$ and $x_826$. Let $x_825$ be an element of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$. Then $Q_$ holds for $x_825$.\nAssistant:", "label": "postulate div_mod_spec_rect_Type2_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825", "predict": "postulate div_mod_spec_rect_Type2_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_825 : div_mod_spec _n _m _q _r) -> Type2) -> (_H_div_mod_spec_intro : (x_827 : Lt _r _m) -> (x_826 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_827 x_826)) -> (x_825 : div_mod_spec _n _m _q _r) -> Q_ x_825"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_log. Soit $p, n \\in N$. Supposons que $0 < n$. Alors $p ^ (\\log_ p {n})\\leq n$.\nAssistant:", "label": "postulate le_exp_log : (p : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> Leq (pow p (log p n)) n", "predict": "postulate le_exp_log : soit p : N -> n : Nat -> (_ : Lt 0 n) -> Leq (p (\\ log_p n)) n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nTrue_rect_CProp4. Låt $Q_$ vara en funktion från element $_x_54$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$ till element av $cic.Univ$ av $cic.prop$. Låt $_H_I$ vara ett element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.I$. Låt $x_54$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.True$. Då håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_54$.\nAssistant:", "label": "postulate True_rect_CProp4 : (Q_ : (_x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ x_54)", "predict": "postulate True_rect_CProp4 : (Q_ : cic.Term cic.prop matita_basics_logic.True) -> (låt : cic.Univ cic.prop) -> (_H_I : cic.Term cic.prop (Q_)) -> (x_54 : cic.Term cic.prop matita_basics_logic.True) -> cic.Term cic.prop (Q_ (x_54))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_O. For all sets $B$, for all elements $R$ of $relation$ of $B$, for all elements $b$ of $B$, $lstar_r$ holds for $B$ and $R$ and $0$ and $b$ and $b$.\nAssistant:", "label": "postulate lstar_r_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar_r B R 0 b b", "predict": "postulate lstar_r_O : (B : Set) -> (R : relation B) -> (b : B) -> lstar_r B R 0 b b"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFmax_false. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, m \\in N$. Då om $max (n, f)= m$, så om kontradiktion är lika med $f (m)$, så $m = 0$.\nAssistant:", "label": "postulate fmax_false : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (_ : Eq (max n f) m) -> (__1 : Eq (f m) false) -> Eq m 0", "predict": "postulate fmax_false : (f : (_ : Nat) -> Prop) -> (n : Nat) -> (m : Nat) -> (ltml : Lt (max n f) m) -> Eq (f m) m -> Eq m 0"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1607. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0 < n$. Supposons que $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Alors si $c n - d m = 1$ ou $d m - c n = 1$, alors si $d m - c n = 1$, alors $m d - n c$ est égal au diviseur commun plus grand de $m$ et de $n$.\nAssistant:", "label": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_1607 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (times d m) (times d m)) -> (H' : Eq (times d m) (times c n)) -> Eq (div m n) (gcd m n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1617. Let $p, m, n \\in N$. Assume that $0$ is less than $p$. Assume that the greatest common divisor of $p$ and $m$ is equal to $1$. Assume that $p$ is divisible by the product of $m$ and $n$. Let $c \\in N$. Then if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the greatest common divisor of $p$ and $m$ is equal to the difference of the product of $p$ and $a$ and the product of $m$ and $b$.\nAssistant:", "label": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (gcd p m) (minus (times p a) (times m b))", "predict": "postulate let_clause_1617 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (pdivnm : divisible p (times m n)) -> (c : Nat) -> (auto : Eq (times m n) (times p c)) -> (auto' : all Nat (\\ a : Nat -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (all Nat (\\ b : Nat -> Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (minus (times a p) (times b m)) (gcd p m)) -> (Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times p a) (times m b))) -> Eq (gcd p m) (minus (times a p) (times b m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nMatch_div_mod_spec. Soit $_n, _m, _q, _r \\in N$. Soit $return_sort$ un élément de $Sort$. Soit $return_type$ une fonction des éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des éléments de $return_sort$. Soit $case_div_mod_spec_intro$ une fonction des éléments de $Lt$ de $_r$ et de $_m$ et des éléments $__1$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $return_type$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $__$ et $__1$. Alors pour tous les éléments $z$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $return_type$ tient pour $z$.\nAssistant:", "label": "postulate match_div_mod_spec : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (return_sort : Sort) -> (return_type : (z : div_mod_spec _n _m _q _r) -> return_sort) -> (case_div_mod_spec_intro : (_ : Lt _r _m) -> (__1 : Eq _n (plus (times _q _m) _r)) -> return_type (div_mod_spec_intro _n _m _q _r __ __1)) -> (z : div_mod_spec _n _m _q _r) -> return_type z", "predict": "postulate match_div_mod_spec : _n : N -> _m : N -> _q : N -> _r : N -> Sort -> return_sort : Sort"}
{"prompt": "Human: Translate the following English statement into Agda.\nFilter. Let $T$ be an element of $cic.Univ$ of $univs.Type0$. Let $_p$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $T$ to elements of $cic.Term$ of $univs.Type0$ and $matita_basics_bool.bool$. Then for all elements $_l$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$, $cic.Term$ holds for $univs.Type0$ and $matita_basics_lists_list.list$ applied to $T$.\nAssistant:", "label": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)", "predict": "postulate filter : (T : cic.Univ univs.Type0) -> (_p : (__ : cic.Term univs.Type0 T) -> cic.Term univs.Type0 matita_basics_bool.bool) -> (_l : cic.Term univs.Type0 (matita_basics_lists_list.list T)) -> cic.Term univs.Type0 (matita_basics_lists_list.list T)"}
{"prompt": "Human: Translate the following French statement into Agda.\nChecker_abl. Soient $a$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.checker$ appliqué à $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $a$ et $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $b$ et $l$ et $matita_basics_bool.true$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.And$ appliqué à $matita_basics_logic.And$ appliqué à $matita_arithmetics_nat.lt$ appliqué à $a$ et $b$ et $matita_arithmetics_nat.le$ appliqué à $b$ et $matita_arithmetics_nat.times$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $a$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_bool.bool$ et $matita_arithmetics_chebyshev_bertrand256.checker$ appliqué à $matita_basics_lists_list.cons$ appliqué à $matita_arithmetics_nat.nat$ et $b$ et $l$ et $matita_basics_bool.true$.\nAssistant:", "label": "postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))", "predict": "postulate checker_abl : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat a (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l))) matita_basics_bool.true)) -> cic.Term cic.prop (matita_basics_logic.And (matita_basics_logic.And (matita_arithmetics_nat.lt a b) (matita_arithmetics_nat.le b (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) a))) (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_chebyshev_bertrand256.checker (matita_basics_lists_list.cons matita_arithmetics_nat.nat b l)) matita_basics_bool.true))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1561. For all natural numbers $p$ and $m$ and $n$, if $0$ is less than $p$, then if the greatest common divisor of $p$ and $m$ is equal to $1$, then if $p$ is divisible by the product of $m$ and $n$, then for all natural numbers $c$, if the product of $m$ and $n$ is equal to the product of $p$ and $c$, then for all natural numbers $a$, for all elements $_clearme0$ of $ex$ of $Nat$ and the function that maps $b$ to the disjunction of $Eq$ applied to the difference of the product of $a$ and $p$ and the product of $b$ and $m$ and the greatest common divisor of $p$ and $m$ and $Eq$ applied to the difference of the product of $b$ and $m$ and the product of $a$ and $p$ and the greatest common divisor of $p$ and $m$, for all natural numbers $b$, if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$ or the difference of the product of $b$ and $m$ and the product of $a$ and $p$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to the greatest common divisor of $p$ and $m$, then if the difference of the product of $a$ and $p$ and the product of $b$ and $m$ is equal to $1$, then the difference of the product of $p$ and $a$ and the product of $m$ and $b$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1"}
{"prompt": "Human: Translate the following English statement into Agda.\nPad_bigop_nil. Let $k$ and $n$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $n \\leq k$, then for all functions $__1$ from natural numbers $i$ and elements $__1$ of $Leq$ of $n$ and $i$ and elements $__2$ of $Lt$ of $i$ and $k$ to elements of $or$ of $Eq$ applied to $p$ applied to $i$ and absurdity and $Eq (f (i), nil)$, $bigop$ applied to $k$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$ is equal to $bigop$ applied to $n$ and the function that maps $i$ to $p$ applied to $i$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to $f$ applied to $i$.\nAssistant:", "label": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))", "predict": "postulate pad_bigop_nil : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> or (Eq (p i) false) (Eq (f i) nil)) -> Eq (bigop k (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop n (\\ i : Nat -> p i) B nil (op B nil op) (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_inv_rect_Type0. Let $x1$ be a set. Let $x2$ be an element of $x1$. Let $Hterm$ be an element of $Aop$ of $x1$ and $x2$. Let $P$ be a function from elements $_z1530$ of $Aop$ of $x1$ and $x2$ to sets. Let $_H1$ be a function from functions $op$ from elements of $x1$ and elements $__1$ of $x1$ to elements of $x1$ and functions $_nill$ from elements $a$ of $x1$ to elements of $Eq$ of $op (x2, a)$ and $a$ and functions $_nilr$ from elements $a$ of $x1$ to elements of $Eq$ of $op (a, x2)$ and $a$ and functions $_assoc$ from elements $a$ of $x1$ and elements $b$ of $x1$ and elements $c$ of $x1$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ and elements $_z1531$ of $Eq$ of $Hterm$ and $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$ to elements of $P$ of $mk_Aop (x1, x2, op, _nill, _nilr, _assoc)$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm", "predict": "postulate Aop_inv_rect_Type0 : (x1 : Set) -> (x2 : x1) -> (Hterm : Aop x1 x2) -> (P : (_z1530 : Aop x1 x2) -> Set) -> (_H1 : (op : (_ : x1) -> (__1 : x1) -> x1) -> (_nill : (a : x1) -> Eq (op x2 a) a) -> (_nilr : (a : x1) -> Eq (op a x2) a) -> (_assoc : (a : x1) -> (b : x1) -> (c : x1) -> Eq (op a (op b c)) (op (op a b) c)) -> (_z1531 : Eq Hterm (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P (mk_Aop x1 x2 op _nill _nilr _assoc)) -> P Hterm"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_to_lt_to_lt. Soient $n$ et $m$ et $p$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $n$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $m$ et $p$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_nat.lt$ appliqué à $n$ et $p$.\nAssistant:", "label": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)", "predict": "postulate le_to_lt_to_lt : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le n m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt m p)) -> cic.Term cic.prop (matita_arithmetics_nat.lt n p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_a. Pour tous les éléments $a$ et $b$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $B$ de $cic.Univ$ de $univs.Type0$, pour tous les éléments $nil$ de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $op$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $B$ et $nil$, pour toutes les fonctions $f$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $B$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.le$ appliqué à $a$ et $b$, $cic.Term$ tient pour $cic.prop$ et $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $B$ et $matita_arithmetics_bigops.bigop$ appliqué à $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.S$ appliqué à $b$ et $a$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $matita_basics_bool.true$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $B$ et $nil$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $i$ et $a$ et $matita_arithmetics_bigops.op$ appliqué à $B$ et $nil$ et $op$ et $matita_arithmetics_bigops.bigop$", "label": "postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus b a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f (matita_arithmetics_nat.S i0)) (matita_arithmetics_nat.plus i a))) (f a)))", "predict": "postulate bigop_a : (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (B : cic.Univ univs.Type0) -> (nil : cic.Term univs.Type0 B) -> (op : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop B nil)) -> (f : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 B) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le a b)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a))) (matita_arithmetics_bigops.op B nil op (matita_arithmetics_bigops.bigop (matita_arithmetics_nat.minus (matita_arithmetics_nat.S b) a) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_bool.true) (matita_arithmetics_nat.plus i a)) B nil (matita_arithmetics_bigops.op B nil op) (\\ i : cic.Term univs.Type0 matita_arithmetics_nat.nat -> (\\ i0 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> f i0) (matita_arithmetics_nat.plus i a)) (matita_arithmetics_bigops.bigop (matita"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_rect_CProp4_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_903$ of $ACop$ of $A$ and $_nil$ to propositions. Let $_H_mk_ACop$ be a function from elements $aop$ of $Aop$ of $A$ and $_nil$ and functions $_comm$ from elements $a$ of $A$ and elements $b$ of $A$ to elements of $Eq$ of $op (A, _nil, aop, a, b)$ and $op (A, _nil, aop, b, a)$ to elements of $Q_$ of $mk_ACop (A, _nil, aop, _comm)$. Let $x_903$ be an element of $ACop$ of $A$ and $_nil$. Then $Q_$ holds for $x_903$.\nAssistant:", "label": "postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903", "predict": "postulate ACop_rect_CProp4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_903 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_903 : ACop A _nil) -> Q_ x_903"}
{"prompt": "Human: Translate the following French statement into Agda.\nAllr_fwd_append_sn. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation$ appliqué à $A$. Soient $l1$ et $l2$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.list$ appliqué à $A$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_lists_list.Allr$ appliqué à $A$ et $R$ et $matita_basics_lists_list.append$ appliqué à $A$ et $l1$ et $l2$. Alors $cic.Term$ tient pour $cic.prop$ et $matita_basics_lists_list.Allr$ appliqué à $A$ et $R$ et $l1$.\nAssistant:", "label": "postulate Allr_fwd_append_sn : (A : cic.Univ univs.Type0) -> (R : cic.Term univs.Type0 (matita_basics_relations.relation A)) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2))) -> cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)", "predict": "postulate Allr_fwd_append_sn : soit A un élément de cic.Univ univs.Type0. Soit R un élément de cic.Term univs.Type0 (matita_basics_relations.relation A). Soient l1 et l2 des éléments de cic.Term univs.Type0 (matita_basics_lists_list.list A). Soit __ : cic.Term cic.prop (matita_basics_lists_list.Allr A R (matita_basics_lists_list.append A l1 l2)). Alors cic.Term cic.prop (matita_basics_lists_list.Allr A R l1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nDiv_mod_spec_ind_body. Soit $_n, _m, _q, _r \\in N$. Soit $Q_$ une fonction des éléments $_x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$ à des propositions. Alors pour toutes les fonctions $_H_div_mod_spec_intro$ des éléments $x_811$ de $Lt$ de $_r$ et de $_m$ et des éléments $x_810$ de $Eq$ de $_n$ et de la somme du produit de $_q$ et de $_m$ et de $_r$ à des éléments de $Q_$ de $div_mod_spec_intro$ appliqué à $_n$ et $_m$ et $_q$ et $_r$ et $x_811$ et $x_810$, pour tous les éléments $x_809$ de $div_mod_spec$ de $_n$ et de $_m$ et de $_q$ et de $_r$, $Q_$ tient pour $x_809$.\nAssistant:", "label": "postulate div_mod_spec_ind_body : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809", "predict": "postulate div_mod_spec_ind_body : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810) x_810) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16005. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c$ vara ett naturligt tal. Låt $_clearme$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$. Då för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $d m - c n = 1$, så är $m d - n c$ lika med det största gemensama delaret av $m$ och $n$.\nAssistant:", "label": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16005 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 0 m) -> (two : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ e : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times d m) (times c n)) 1)) -> (D : Nat) -> (H : Eq (times d m) (times n c)) -> Eq m d n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_to_leb_false. For all elements $n$ and $m$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$, for all elements $__$ of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $m$ and $n$, $cic.Term$ holds for $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_bool.bool$ and $matita_arithmetics_nat.leb$ applied to $n$ and $m$ and $matita_basics_bool.false$.\nAssistant:", "label": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)", "predict": "postulate lt_to_leb_false : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb n m) matita_basics_bool.false)"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp4. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_875$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$. Then for all elements $x_875$ of $c", "label": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)", "predict": "postulate Aop_rect_CProp4 : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_875 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term cic.prop (Q_ x_875)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nChecker_spec. Låt $tl$ vara en lista av naturliga tal. Låt $a \\in N$. Då för alla listor $l$ av naturliga tal, om $checker (l)= true$, så om $l = cons (Nat, a, tl)$, så för alla naturliga tal $p$, för alla element $__2$ av $mem$ av $Nat$ och $p$ och $tl$, håller $ex$ för $Nat$ och funktionen som avbildar $pp$ som konjunktionen av konjunktionen av $mem$ applicerat på $Nat$ och $pp$ och $l$ och $Lt$ applicerat på $pp$ och $p$ och $Leq$ applicerat på $p$ och produkten av $2$ och $pp$.\nAssistant:", "label": "postulate checker_spec : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (_ : Eq (checker l) true) -> (__1 : Eq l (cons Nat a tl)) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\\ pp : Nat -> and (and (mem Nat pp l) (Lt pp p)) (Leq p (times 2 pp)))", "predict": "postulate let : (tl : list Nat) -> (a : Nat) -> (l : list Nat) -> (checker : (_ : list Nat) -> bool) -> (l : cons Nat a tl) -> (p : Nat) -> (__2 : mem Nat p tl) -> ex Nat (\\ nat : Nat -> pp (pp l (Lt pp p)) (Leq p (times 2 pp)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLog_exp. Låt $p$ och $n$ och $m$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $__$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $p$. Låt $__1$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Då håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_log.log$ applicerat på $p$ och $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $p$ och $n$ och $m$ och $matita_arithmetics_nat.plus$ applicerat på $n$ och $matita_arithmetics_log.log$ applicerat på $p$ och $m$.\nAssistant:", "label": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m)))", "predict": "postulate log_exp : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (l : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S matita_arithmetics_nat.O) p)) -> (__1 : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (c : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_log.log p (matita_arithmetics_nat.times (matita_arithmetics_exp.exp p n) m)) (matita_arithmetics_nat.plus n (matita_arithmetics_log.log p m))))"}
{"prompt": "Human: Translate the following English statement into Agda.\nRange_rect_Type0. Let $_A$ be a set. Let $Q_$ be a function from elements $_x_927$ of $range$ of $_A$ to sets. Let $_H_mk_range$ be a function from functions $_enum$ from natural numbers to elements of $_A$ and natural numbers $_upto$ and functions $_filter$ from natural numbers to booleans to elements of $Q_$ of $mk_range$ applied to $_A$ and $_enum$ and $_upto$ and $_filter$. Then for all elements $x_927$ of $range$ of $_A$, $Q_$ holds for $x_927$.\nAssistant:", "label": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927", "predict": "postulate range_rect_Type0 : (_A : Set) -> (Q_ : (_x_927 : range _A) -> Set) -> (_H_mk_range : (_enum : (_ : Nat) -> _A) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> Q_ (mk_range _A _enum _upto _filter)) -> (x_927 : range _A) -> Q_ x_927"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSig_rect_Type3_body. Låt $A$ vara ett element av $cic.Univ$ av $univs.Type0$. Låt $_f$ vara en funktion från element $__$ av $cic.Term$ av $univs.Type0$ och $A$ till element av $cic.Univ$ av $cic.prop$. Låt $Q_$ vara en funktion från element $_x_670$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$ till element av $cic.Univ$ av $univs.Type3$. Låt $_H_mk_Sig$ vara en funktion från element $pi1$ av $cic.Term$ av $univs.Type0$ och $A$ och element $_pi2$ av $cic.Term$ av $cic.prop$ och $_f$ applicerat på $pi1$ till element av $cic.Term$ av $univs.Type3$ och $Q_$ applicerat på $matita_basics_types.mk_Sig$ applicerat på $A$ och $_f$ och $pi1$ och $_pi2$. Låt $x_670$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_types.Sig$ applicerat på $A$ och $_f$. Då håller $cic.Term$ för $univs.Type3$ och $Q_$ applicerat på $x_670$.\nAssistant:", "label": "postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)", "predict": "postulate Sig_rect_Type3_body : (A : cic.Univ univs.Type0) -> (_f : (__ : cic.Term univs.Type0 A) -> cic.Univ cic.prop) -> (Q_ : (_x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Univ univs.Type3) -> (_H_mk_Sig : (pi1 : cic.Term univs.Type0 A) -> (_pi2 : cic.Term cic.prop (_f pi1)) -> cic.Term univs.Type3 (Q_ (matita_basics_types.mk_Sig A _f pi1 _pi2))) -> (x_670 : cic.Term univs.Type0 (matita_basics_types.Sig A _f)) -> cic.Term univs.Type3 (Q_ x_670)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nProp110. För alla heltal $a$ och $c$, om $a$ är udda och $c$ är udda, så för alla heltal $b$, är $a b + b c$ jämnt.\nAssistant:", "label": "postulate prop110 : (a : Int) -> (c : Int) -> and (odd a) (odd c) -> all Int (\\ b -> even (plus (times a b) (times b c)))", "predict": "postulate prop110 : forall a c, (odd a) && (odd c) -> allint b (a * b) + (c * b)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_rect_Type0. Låt $Q_$ vara en funktion från naturliga tal $_x_389$ till mängder. Låt $_H_O$ vara ett element av $Q_$ av $0$. Då för alla funktioner $_H_S$ från naturliga tal $x_390$ och element $_x_392$ av $Q_$ av $x_390$ till element av $Q_$ av $x_390 + 1$, för alla naturliga tal $x_389$, håller $Q_$ för $x_389$.\nAssistant:", "label": "postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> Set) -> (_H_O : Q_ 0) -> (_H_S : (x_390 : Nat) -> (_x_392 : Q_ x_390) -> Q_ (plus x_390 1)) -> (x_389 : Nat) -> Q_ x_389", "predict": "postulate nat_rect_Type0 : (Q_ : (_x_389 : Nat) -> M) -> (_H_O : Q_ 0) -> (x_390 : Nat) -> (_x_392 : Q_ x_390) -> (x_389 : Nat) -> Q_ x_389"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Soit $n1 \\in N$. Soit $Hind$ une fonction des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$. Soit $H1$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Eq$ de $p2$ appliqué à $i$ et de $true$. Soit $H2$ une fonction des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de la somme de $n1$ et de $1$ et des éléments $__1$ de $Eq$ de $p1$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$. Supposons que $p2$ appliqué à $n1$ est égal à $true$. Alors si $p1$ appliqué à $n1$ est égal à $true$, alors pour tous les nombres naturels $x2515", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n : Nat Soient p1 : (_ : Nat) -> p2 : (_ : Nat) -> g1 : (_ : Nat) -> g2 : (_ : Nat) -> n1 : Nat Soit Hind : (_ : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i)) -> (H1 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (__1 : Lt i (plus n1 1)) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (p2 : (_ : Nat) -> Eq (p1 n1) true) -> (p1 : (_ : Nat) -> Eq (p1 n1) true) -> let_clause_1033"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_inv_ind. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$. Alors pour toutes les fonctions $P$ des éléments $_z1038$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $x1$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $_z1039$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.None$ appliqué à $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.None$ appliqué à $x1$, pour toutes les fonctions $_H2$ des éléments $x_587$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1039$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.option$ appliqué à $x1$ et $Hterm$ et $matita_basics_types.Some$ appliqué à $x1$ et $x_587$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.Some$ appliqué à $x1$ et $x_587$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate option_inv_ind : (x1 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.option x1)) -> (P : (_z1038 : cic.Term univs.Type0 (matita_basics_types.option x1)) -> cic.Univ cic.prop) -> (_H1 : (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1))) -> cic.Term cic.prop (P (matita_basics_types.None x1))) -> (_H2 : (x_587 : cic.Term univs.Type0 x1) -> (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P (matita_basics_types.Some x1 x_587))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate option_inv_ind : soit x1 un élément de cic.Univ univs.Type0. Soit Hterm un élément de cic.Term univs.Type0 (matita_basics_types.option x1). Alors pour toutes les fonctions P des éléments _z1038 de cic.Term univs.Type0 (matita_basics_types.option x1) à des éléments de cic.Univ cic.prop, pour toutes les fonctions _H1 des éléments _z1039 de cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.None x1)) à des éléments de cic.Term cic.prop (P (matita_basics_types.None x1)). Pour toutes les fonctions _H2 (x_587 : cic.Term univs.Type0 x1) et (_z1039 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.option x1)) Hterm (matita_basics_types.Some x1 x_587))) à des éléments de cic.Term cic.prop (P (matita_basics_types.Some x1 x_587)). Et enfin cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_ind. Soit $A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $_nil$ un élément de $cic.Term$ de $univs.Type0$ et de $A$. Soit $Q_$ une fonction des éléments $_x_781$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_lists_list.Aop$ appliqué à $A$ et $_nil$ à des éléments de $cic.Univ$ de $cic.prop$. Alors pour toutes les fonctions $_H_mk_Aop$ des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $univs.Type0$ et de $A$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $_nil$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $_nil$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $A$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $A$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $A$ et $op$ appliqué à $a$ et $op$ appliqué à $b$ et $c$ et $op$ appliqué à $op$ appliqué à $a$ et $b$ et $c$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appl", "label": "postulate Aop_ind : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ (matita_basics_lists_list.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_781 : cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil)) -> cic.Term cic.prop (Q_ x_781)", "predict": "iquéepostulate Aop_ind : soit A un élément de cic.Univ univs.Type0. soit _nil un élément de cic.Term univs.Type0 A. soit Q_ une fonction des _x_781 de cic.Term univs.Type0 (matita_basics_lists_list.Aop A _nil) des éléments de cic.Univ cic.prop. alors pour toutes les fonctions _H_mk_Aop des fonctions op des __ de cic.Term univs.Type0 A et des __1 de cic.Term univs.Type0 A à des cic.Term univs.Type0 A et des (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term cic.prop (Q_ _x_781 (matita_basics_lists_list.Aop A _nil) des éléments de cic.Univ cic.prop)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_minus_O. Let $n$ and $m$ be natural numbers. Assume that $n \\leq m$. Then $n - m = 0$.\nAssistant:", "label": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq (minus n m) 0", "predict": "postulate eq_minus_O : (n : Nat) -> (m : Nat) -> (_ : Leq n m) -> Eq n m"}
{"prompt": "Human: Translate the following French statement into Agda.\nOption_rect_CProp2. Soit $_A$ un élément de $cic.Univ$ de $univs.Type0$. Soit $Q_$ une fonction des éléments $_x_626$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H_None$ un élément de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.None$ appliqué à $_A$. Soit $_H_Some$ une fonction des éléments $x_627$ de $cic.Term$ de $univs.Type0$ et de $_A$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_basics_types.Some$ appliqué à $_A$ et $x_627$. Soit $x_626$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.option$ appliqué à $_A$. Alors $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_626$.\nAssistant:", "label": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)", "predict": "postulate option_rect_CProp2 : (_A : cic.Univ univs.Type0) -> (Q_ : (_x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Univ cic.prop) -> (_H_None : cic.Term cic.prop (Q_ (matita_basics_types.None _A))) -> (_H_Some : (x_627 : cic.Term univs.Type0 _A) -> cic.Term cic.prop (Q_ (matita_basics_types.Some _A x_627))) -> (x_626 : cic.Term univs.Type0 (matita_basics_types.option _A)) -> cic.Term cic.prop (Q_ x_626)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_Type0. Let $Hterm$ be a natural number. Let $P$ be a function from natural numbers $_z683$ to sets. Let $_H1$ be a function from elements $_z684$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_390$ and functions $_x_392$ from elements $_z684$ of $Eq$ of $Hterm$ and $x_390$ to elements of $P$ of $x_390$ and elements $_z684$ of $Eq$ of $Hterm$ and the sum of $x_390$ and $1$ to elements of $P$ of the sum of $x_390$ and $1$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm", "predict": "postulate nat_inv_rect_Type0 : (Hterm : Nat) -> (P : (_z683 : Nat) -> Set) -> (_H1 : (_z684 : Eq Hterm 0) -> P 0) -> (_H2 : (x_390 : Nat) -> (_x_392 : (_z684 : Eq Hterm x_390) -> P x_390) -> (_z684 : Eq Hterm (plus x_390 1)) -> P (plus x_390 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNot_rect_CProp4_body. För alla element $_A$ av $cic.Univ$ av $cic.prop$, för alla funktioner $Q_$ från element $_x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$ till element av $cic.Univ$ av $cic.prop$, för alla funktioner $_H_nmk$ från funktioner $x_101$ från element $__$ av $cic.Term$ av $cic.prop$ och $_A$ till element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Term$ av $cic.prop$ och $Q_$ applicerat på $matita_basics_logic.nmk$ applicerat på $_A$ och $x_101$, för alla element $x_100$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.Not$ applicerat på $_A$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_100$.\nAssistant:", "label": "postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)", "predict": "postulate Not_rect_CProp4_body : (_A : cic.Univ cic.prop) -> (Q_ : (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Univ cic.prop) -> (_H_nmk : (x_101 : (__ : cic.Term cic.prop _A) -> cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) -> (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A)) -> cic.Term cic.prop (Q_ x_100)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_r_S. Let $B$ be a set. Let $R$ be an element of $relation$ of $B$. Let $l$ be a natural number. Let $b1$ and $b$ be elements of $B$. Then for all elements $__$ of $lstar_r$ of $B$ and $R$ and $l$ and $b1$ and $b$, for all elements $b2$ of $B$, for all elements $__1$ of $R$ of $b$ and $b2$, $lstar_r$ holds for $B$ and $R$ and $l + 1$ and $b1$ and $b2$.\nAssistant:", "label": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R (plus l 1) b1 b2", "predict": "postulate lstar_r_S : (B : Set) -> (R : relation B) -> (l : Nat) -> (b1 : B) -> (b : B) -> (_ : lstar_r B R l b1 b) -> (b2 : B) -> (__1 : R b b2) -> lstar_r B R l + 1 b1 b2"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nNat_inv_ind. Låt $Hterm$ vara ett naturligt tal. Låt $P$ vara en funktion från naturliga tal $_z653$ till påståenden. Låt $_H1$ vara en funktion från element $_z654$ av $Eq$ av $Hterm$ och $0$ till element av $P$ av $0$. Då för alla funktioner $_H2$ från naturliga tal $x_366$ och funktioner $_x_368$ från element $_z654$ av $Eq$ av $Hterm$ och $x_366$ till element av $P$ av $x_366$ och element $_z654$ av $Eq$ av $Hterm$ och $x_366 + 1$ till element av $P$ av $x_366 + 1$, håller $P$ för $Hterm$.\nAssistant:", "label": "postulate nat_inv_ind : (Hterm : Nat) -> (P : (_z653 : Nat) -> Prop) -> (_H1 : (_z654 : Eq Hterm 0) -> P 0) -> (_H2 : (x_366 : Nat) -> (_x_368 : (_z654 : Eq Hterm x_366) -> P x_366) -> (_z654 : Eq Hterm (plus x_366 1)) -> P (plus x_366 1)) -> P Hterm", "predict": "postulate nat_inv_ind : låt Hterm vara ett naturligt tal. låt P vara en funktion från naturliga tal _z653 till påståenden. låt _H1 vara en funktion från _z654 av Eq av Hterm och 0 till P av 0. då för alla funktioner _H2 från naturliga tal x_366 och funktioner _x_368 från _z654 av Eq av Hterm x_366 till P x_366 och _z654 av Eq av Hterm x_366 + 1 till P x_366 + 1, håller P för Hterm."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nF_min_true. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n$ och $b$ vara naturliga tal. Låt $__$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $i$ som konjunktionen av konjunktionen av $Leq$ applicerat på $b$ och $i$ och $Lt$ applicerat på $i$ och summan av $n$ och $b$ och $Eq$ applicerat på $f$ applicerat på $i$ och $true$. Då $f (min (n, b, f))= true$.\nAssistant:", "label": "postulate f_min_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : ex Nat (\\ i : Nat -> and (and (Leq b i) (Lt i (plus n b))) (Eq (f i) true))) -> Eq (f (min n b f)) true", "predict": "postulate f_min_true : let f : (_ : Nat) -> sanningsvärden f = let n : Nat -> let b : Nat -> (_ : ex Nat (\\ i : Nat -> (\\ j : Nat -> (\\ k : Nat -> i) (Leq b i) (Lt i (plus n b)) Eq (f i) true)))) -> (_ : Eq (f (min n b f)) true)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nUnit_rect_Type1. Låt $Q_$ vara en funktion från element $_x_505$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$ till element av $cic.Univ$ av $univs.Type1$. Då för alla element $_H_it$ av $cic.Term$ av $univs.Type1$ och $Q_$ applicerat på $matita_basics_types.it$, för alla element $x_505$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.unit$, håller $cic.Term$ för $univs.Type1$ och $Q_$ applicerat på $x_505$.\nAssistant:", "label": "postulate unit_rect_Type1 : (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) -> (x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type1 (Q_ x_505)", "predict": "postulate let : (Q_ : (_x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Univ univs.Type1) -> (_H_it : cic.Term univs.Type1 (Q_ matita_basics_types.it)) -> (x_505 : cic.Term univs.Type0 matita_basics_types.unit) -> cic.Term univs.Type1 (Q_ x_505)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_exp1. Låt $p, n, q, r \\in N$. Anta att $0 < p$ och $p$ inte är delbart med $r$. Då om $n = p ^ q r$, så $p_ord (n, p)= mk_Prod (Nat, Nat, q, r)$.\nAssistant:", "label": "postulate p_ord_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 0 p) -> (__1 : not (divisible p r)) -> (__2 : Eq n (times (pow p q) r)) -> Eq (p_ord n p) (mk_Prod Nat Nat q r)", "predict": "postulate p_ord_exp1 : let p, n, q, r : Nat -> and (Lt 0 p) (not (divisible p r)) -> (eqn n (p ^ q r)) -> p_ord (n, p) = mk_Prod Nat Nat q r"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sqrt_n1. Let $n$ be a natural number. Then the difference of $n$ and the product of $2$ and the square root of $n$ is less than or equal to the exponentiation of the square root of $n$ and $2$.\nAssistant:", "label": "postulate le_sqrt_n1 : (n : Nat) -> Leq (minus n (times 2 (sqrt n))) (pow (sqrt n) 2)", "predict": "postulate le_sqrt_n1 : (n : Nat) -> Leq (minus n (times 2 (sqrt n))) (pow (sqrt n) 2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nF3_ind_aux. Soient $A1$ et $A2$ et $A3$ des ensembles. Soit $f$ une fonction des éléments de $A1$ et des éléments $__1$ de $A2$ et des éléments $__2$ de $A3$ à des nombres naturels. Soit $P$ un élément de $relation3$ de $A1$ et de $A2$ et de $A3$. Soit $__$ une fonction des nombres naturels $n$ et des fonctions des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments de $Lt$ de $f (a1, a2, a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$ et des éléments $a1$ de $A1$ et des éléments $a2$ de $A2$ et des éléments $a3$ de $A3$ et des éléments $__1$ de $Eq$ de $f (a1, a2, a3)$ et de $n$ à des éléments de $P$ de $a1$ et de $a2$ et de $a3$. Soit $n \\in N$. Soit $a1$ un élément de $A1$. Soit $a2$ un élément de $A2$. Soit $a3$ un élément de $A3$. Alors si $f (a1, a2, a3)= n$, alors $P$ tient pour $a1$ et $a2$ et $a3$.\nAssistant:", "label": "postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3", "predict": "postulate f3_ind_aux : (A1 : Set) -> (A2 : Set) -> (A3 : Set) -> (f : (_ : A1) -> (__1 : A2) -> (__2 : A3) -> Nat) -> (P : relation3 A1 A2 A3) -> (_ : (n : Nat) -> (_ : (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (_ : Lt (f a1 a2 a3) n) -> P a1 a2 a3) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3) -> (n : Nat) -> (a1 : A1) -> (a2 : A2) -> (a3 : A3) -> (__1 : Eq (f a1 a2 a3) n) -> P a1 a2 a3"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type5_body. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $_nil$ be an element of $cic.Term$ of $univs.Type0$ and $A$. Let $Q_$ be a function from elements $_x_865$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $univs.Type5$. Let $_H_mk_Aop$ be a function from functions $op$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_nill$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $cic.Term$ of $univs.Type5$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc", "label": "postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)", "predict": "postulate Aop_rect_Type5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Univ univs.Type5) -> (_H_mk_Aop : (op : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_nill : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op _nil a) a)) -> (_nilr : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a _nil) a)) -> (_assoc : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (op a (op b c)) (op (op a b) c))) -> cic.Term univs.Type5 (Q_ (matita_arithmetics_bigops.mk_Aop A _nil op _nill _nilr _assoc))) -> (x_865 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop A _nil)) -> cic.Term univs.Type5 (Q_ x_865)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFilter_True. Soit $return_sort$ un élément de $cic.Sort$. Alors pour toutes les fonctions $return_type$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Univ$ de $return_sort$, pour toutes les fonctions $return$ des éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$ à des éléments de $cic.Term$ de $return_sort$ et de $return_type$ appliqué à $z$, pour tous les éléments $z$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.True$, $cic.Term$ tient pour $return_sort$ et $return_type$ appliqué à $z$.\nAssistant:", "label": "postulate filter_True : (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop matita_basics_logic.True) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_True : soit (return_sort un element de cic.Sort) alors pour toutes les fonctions return_type des elements z de cic.Term cic.prop matita_basics_logic.True à des elements de cic.Univ return_sort) pour toutes les fonctions return des elements z de cic.Term cic.prop matita_basics_logic.True à des elements de cic.Term return_sort (return_type z)) pour tous les elements z de cic.Term cic.prop matita_basics_logic.True"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$. Alors pour toutes les fonctions $P$ des éléments $_z1740$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Dop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H1$ des éléments $sum$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.ACop$ appliqué à $x1$ et $x2$ et des fonctions $prod$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_null$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $prod$ appliqué à $a$ et $x2$ et $x2$ et des fonctions $_distr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $c$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$", "label": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a (matita_arithmetics_bigops.aop__o__op x1 x2 sum b c)) (matita_arithmetics_bigops.aop__o__op x1 x2 sum (prod a b) (prod a c)))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _distr))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Dop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> (P : (_z1740 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (prod : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_null : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x2) x2)) -> (_distr : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (prod a x1) (prod b x1))) -> (_z1741 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _H1))) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Dop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Dop x1 x2 sum prod _null _H1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFilter_lstar. Låt $B$ vara ett element av $cic.Univ$ av $univs.Type0$. Då för alla element $_R$ av $cic.Term$ av $univs.Type0$ och $matita_basics_relations.relation$ applicerat på $B$, för alla element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__1$ och $__2$ av $cic.Term$ av $univs.Type0$ och $B$, för alla element $return_sort$ av $cic.Sort$, för alla funktioner $return_type$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $cic.Univ$ av $return_sort$, för alla funktioner $return$ från element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$ till element av $cic.Term$ av $return_sort$ och $return_type$ applicerat på $z$, för alla element $z$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_lstar.lstar$ applicerat på $B$ och $_R$ och $__$ och $__1$ och $__2$, håller $cic.Term$ för $return_sort$ och $return_type$ applicerat på $z$.\nAssistant:", "label": "postulate filter_lstar : (B : cic.Univ univs.Type0) -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)", "predict": "postulate filter_lstar : cic.Univ univs.Type0 -> (_R : cic.Term univs.Type0 (matita_basics_relations.relation B)) -> (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : cic.Term univs.Type0 B) -> (__2 : cic.Term univs.Type0 B) -> (return_sort : cic.Sort) -> (return_type : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Univ return_sort) -> (return : (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)) -> (z : cic.Term cic.prop (matita_arithmetics_lstar.lstar B _R __ __1 __2)) -> cic.Term return_sort (return_type z)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_ind. Let $_n, _m, _q, _r \\in N$. Let $Q_$ be a function from elements $_x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$ to propositions. Let $_H_div_mod_spec_intro$ be a function from elements $x_811$ of $Lt$ of $_r$ and $_m$ and elements $x_810$ of $Eq$ of $_n$ and $_q _m + _r$ to elements of $Q_$ of $div_mod_spec_intro (_n, _m, _q, _r, x_811, x_810)$. Then for all elements $x_809$ of $div_mod_spec$ of $_n$ and $_m$ and $_q$ and $_r$, $Q_$ holds for $x_809$.\nAssistant:", "label": "postulate div_mod_spec_ind : (_n : Nat) -> (_m : Nat) -> (_q : Nat) -> (_r : Nat) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n (plus (times _q _m) _r)) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809", "predict": "postulate div_mod_spec_ind : (_n : N) -> (_m : N) -> (_q : N) -> (_r : N) -> (Q_ : (_x_809 : div_mod_spec _n _m _q _r) -> Prop) -> (_H_div_mod_spec_intro : (x_811 : Lt _r _m) -> (x_810 : Eq _n _q _m + _r) -> Q_ (div_mod_spec_intro _n _m _q _r x_811 x_810)) -> (x_809 : div_mod_spec _n _m _q _r) -> Q_ x_809"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1617. Soient $p$ et $m$ et $n$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $posn$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_nat.lt$ appliqué à $matita_arithmetics_nat.O$ et $p$. Soit $gcd1$ un élément de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_gcd.gcd$ appliqué à $p$ et $m$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$. Soit $_clearme$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $p$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$. Soit $c$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $nm$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.times$ appliqué à $m$ et $n$ et $matita_arithmetics_nat.times$ appliqué à $p$ et $c$, pour tous les éléments $a$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $_clearme0$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.ex$ appliqué à $matita_arithmetics_nat.nat$ et la fonction qui envoie $b$ à $matita_basics_logic.Or$ appliqué à $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $matita_arithmetics_nat.minus$ appliqué à $matita_arithmetics_nat.times$ appliqué à $a$ et $p$ et $matita_arithmetics_nat.times$ appliqué à $b$ et $m$ et $matita_arithmetics_gcd.gcd$ appl", "label": "postulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p", "predict": "iquépostulate let_clause_1617 : (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posn : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O p)) -> (gcd1 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_gcd.gcd p m) (matita_arithmetics_nat.S matita_arithmetics_nat.O))) -> (_clearme : cic.Term cic.prop (matita_arithmetics_primes.divides p (matita_arithmetics_nat.times m n))) -> (c : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (nm : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p c))) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_clearme0 : cic.Term cic.prop (matita_basics_logic.ex matita_arithmetics_nat.nat (\\ b : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_basics_logic.Or (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.minus (matita_arithmetics_nat.times a p) (matita_arithmetics_nat.times b m)) (matita_arithmetics_gcd.gcd p m)) (matita_arithmetics_nat.S matita_arithmetics_nat.O)))) -> (b : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.times m n) (matita_arithmetics_nat.times p"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_10331. Låt $n$ vara ett naturligt tal. Anta att $5$ är mindre än $n$. Låt $m \\in N$. Anta att $6$ är mindre än eller lika med $m$. Anta att potensen av summan av $m$ och $1$ och $2$ är mindre än eller lika med potensen av $2$ och $m$. Låt $a \\in N$. Då om $6$ är mindre än eller lika med $a$, så om summan av produkten av $2$ och summan av $a$ och $1$ och $1$ är mindre än eller lika med potensen av $2$ och $a$, så för alla naturliga tal $x2515$ och $x2516$, är $x2515$ lika med summan av produkten av $x2516$ och kvoten av $x2515$ och $x2516$ och $mod$ applicerat på $x2515$ och $x2516$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : let n : Nat -> let (5 : Nat) -> let (m : Nat) -> let (nm : Nat) -> let (H : Lt 5 n) -> let (Lm : Eq 6 m) -> let (Hm : Lt (plus m 1) 2) -> let (a : Nat) -> let (Ht : Eq 6 a) -> let (Hlt : Lt (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> let (x2515 : Nat) -> let (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nChecker. Låt $__$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Då håller $cic.Term$ för $univs.Type0$ och $matita_basics_bool.bool$.\nAssistant:", "label": "postulate checker : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool", "predict": "postulate låt : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> cic.Term univs.Type0 matita_basics_bool.bool"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMatch_Aop. För alla mängder $A$, för alla element $_nil$ av $A$, för alla element $return_sort$ av $Sort$, för alla funktioner $return_type$ från element $z$ av $Aop$ av $A$ och $_nil$ till element av $return_sort$, för alla funktioner $case_mk_Aop$ från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $return_type$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$, för alla element $z$ av $Aop$ av $A$ och $_nil$, håller $return_type$ för $z$.\nAssistant:", "label": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z", "predict": "postulate match_Aop : (A : Set) -> (_nil : A) -> (return_sort : Sort) -> (return_type : (z : Aop A _nil) -> return_sort) -> (case_mk_Aop : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> return_type (mk_Aop A _nil op _nill _nilr _assoc)) -> (z : Aop A _nil) -> return_type z"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_dividesb_true. Soient $n$ et $m$ des nombres naturels. Alors si $0 < n$, alors si $n$ est divisible par $m$, alors $dividesb (n, m)= true$.\nAssistant:", "label": "postulate divides_to_dividesb_true : (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : divisible n m) -> Eq (dividesb n m) true", "predict": "postulate divides_to_dividesb_true : sont n et m des nombres naturels. Alors si 0 < n, alors si n est divisible par m, alors dividesb (n, m) = true"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLd_to_prime. Låt $i$ vara ett naturligt tal. Då för alla listor $acc$ av naturliga tal, om $1$ är mindre än $i$, så för alla element $__1$ av $primes_below$ av $acc$ och $i$, om $list_divides$ applicerat på $acc$ och $i$ är lika med kontradiktion, så är $i$ primt.\nAssistant:", "label": "postulate ld_to_prime : (i : Nat) -> (acc : list Nat) -> (_ : Lt 1 i) -> (__1 : primes_below acc i) -> (__2 : Eq (list_divides acc i) false) -> prime i", "predict": "postulate låt : (i : Nat) -> (acc : list Nat) -> (ltml : Lt 1 i) -> (__1 : primes_below acc i) -> (ltmlc : Eq (list_divides acc i) (contradiction)) -> prim i"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAop_rect_CProp5_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_877$ av $Aop$ av $A$ och $_nil$ till påståenden. Låt $_H_mk_Aop$ vara en funktion från funktioner $op$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_nill$ från element $a$ av $A$ till element av $Eq$ av $op (_nil, a)$ och $a$ och funktioner $_nilr$ från element $a$ av $A$ till element av $Eq$ av $op (a, _nil)$ och $a$ och funktioner $_assoc$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $op (a, op (b, c))$ och $op (op (a, b), c)$ till element av $Q_$ av $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Då för alla element $x_877$ av $Aop$ av $A$ och $_nil$, håller $Q_$ för $x_877$.\nAssistant:", "label": "postulate Aop_rect_CProp5_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_877 : Aop A _nil) -> Ptn) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_877 : Aop A _nil) -> Q_ x_877"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_ind_body. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_889$ av $ACop$ av $A$ och $_nil$ till påståenden, för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op$ applicerat på $A$ och $_nil$ och $aop$ och $a$ och $b$ och $op$ applicerat på $A$ och $_nil$ och $aop$ och $b$ och $a$ till element av $Q_$ av $mk_ACop$ applicerat på $A$ och $_nil$ och $aop$ och $_comm$, för alla element $x_889$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_889$.\nAssistant:", "label": "postulate ACop_ind_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889", "predict": "postulate låt : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_889 : ACop A _nil) -> Pta) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_889 : ACop A _nil) -> Q_ x_889"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1561. Låt $p$ och $m$ och $n$ vara naturliga tal. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c \\in N$. Anta att $m n = p c$. Låt $a \\in N$. Då för alla element $_clearme0$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$, för alla naturliga tal $b$, om det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$, så om $a p - b m = 1$, så $p a - m b = 1$.\nAssistant:", "label": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times a p) (times b m)) (gcd p m)) -> (H0 : Eq (minus (times a p) (times b m)) 1) -> Eq (minus (times p a) (times m b)) 1", "predict": "postulate let_clause_1561 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (ltml : Lt 0 p) -> (eqn : Eq 1 (gcd p m)) -> (c : Nat) -> (nm : Eq m n) -> (ac : Nat) -> (b : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> and (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (H : Eq (times b m) p) -> (H0 : Eq (times a m) p) -> Eq (times p m) (gcd p m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1063. Låt $f$ vara en funktion från naturliga tal till naturliga tal. Låt $n$ vara ett naturligt tal. Låt $permf$ vara ett element av $permut$ av $f$ och $n$. Låt $i$ och $j$ vara naturliga tal. Anta att $i \\leq n$. Anta att $j \\leq n$. Låt $a$ vara ett naturligt tal. Anta att $a \\leq n$ och $f (a)= i$. Anta att $a \\leq n$. Anta att $f (a)= i$. Låt $b$ vara ett naturligt tal. Anta att $b \\leq n$ och $f (b)= j$. Anta att $b \\leq n$. Anta att $f (b)= j$. Låt $__$ vara en funktion från naturliga tal $i0$ och element av $Leq$ av $i0$ och $n$ till element av $Leq$ av $f (i0)$ och $n$. Då för alla element $injf$ av $injn$ av $f$ och $n$, om $a = b$, så $f (a)= j$.\nAssistant:", "label": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (lein : Leq i n) -> (lejn : Leq j n) -> (a : Nat) -> (_clearme : and (Leq a n) (Eq (f a) i)) -> (lean : Leq a n) -> (fa : Eq (f a) i) -> (b : Nat) -> (_clearme0 : and (Leq b n) (Eq (f b) j)) -> (lebn : Leq b n) -> (fb : Eq (f b) j) -> (_ : (i0 : Nat) -> (_ : Leq i0 n) -> Leq (f i0) n) -> (injf : injn f n) -> (auto : Eq a b) -> Eq (f a) j", "predict": "postulate let_clause_1063 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (permf : permut f n) -> (i : Nat) -> (j : Nat) -> (a : Nat) -> (leina : Leq a n) -> (fa : f a) -> (b : Nat) -> (lejb : Leq b n) -> (fb : f b) -> (_ : (_ : Nat) -> Leq i0 n) -> (Hind : Leq i0 n) -> (Hindf : Leq (f i0) n) -> (Hindb : Leq b n) -> (Hindc : Leq (f b) j) -> (_clearme : and (Leq i n) (Leq j n)) -> (Hindf0 : Leq (f i) n) -> (Hind0 : Leq i n) -> (Hind1 : Leq f (f i)) -> (Hind2 : Leq n (f i)) -> (Hind3 : Leq i n) -> (Hind4 : Leq a n) -> (Hind5 : Leq f a) -> (Hind6 : Leq b n) -> (Hind7 : Leq f b) -> (Hind8 : Leq i0 n) -> (Hind9 : Leq (f i0) n) -> (Hind10 : Leq i0 n) -> (Hind11 : Leq i n) -> (Hind12 : Leq (f i) n) -> (Hind13 : Leq n (f i)) -> (Hind14 : Leq a n) -> (Hind15 : Leq f a) -> (Hind16 : Leq b n) -> (Hind17 : Leq f b) -> (Hind18 : Leq i0 n) -> (Hind19 : Leq (f i0) n) -> (Hind20 : Leq i0 n) -> (Hind21 : Leq i n) -> (Hind22 : Leq (f i) n) -> (Hind23 : Leq n (f i)) -> (Hind24 : Leq a n) -> (Hind25 : Leq f a) -> (Hind26 : Leq b n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1034. Let $n, m, p \\in N$. Assume that $0$ is less than $p$. Let $x2515, x2516 \\in N$. Then $x2515$ is equal to the sum of $mod$ applied to $x2515$ and $x2516$ and the product of $x2516$ and the quotient of $x2515$ and $x2516$.\nAssistant:", "label": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))", "predict": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_15691. Låt $m, n, a, b \\in N$. Anta att $0 < n$. Anta att $0 < m$. Anta att $1$ är lika med det största gemensama delaret av $n$ och $m$. Låt $c \\in N$. Då för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $d$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $c$ och $n$ och produkten av $d$ och $m$ och $1$ och $Eq$ applicerat på skillnaden mellan produkten av $d$ och $m$ och produkten av $c$ och $n$ och $1$, för alla naturliga tal $d$, om $c n - d m = 1$ eller $d m - c n = 1$, så om $c n - d m = 1$, så $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (zero : Lt n m) -> (one : Eq 0 m) -> (two : Eq 1 (max (gcd n m) 1)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> (\\ _clearme : Eq (minus (times c n) m) (times d m)) 1)) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) c) 1)) -> (Hc : Eq (times d m) 1) -> (Hn : Eq n c) -> (Hm : Eq m d) -> (Hn0 : Eq (times d m) 1) -> Eq n c m"}
{"prompt": "Human: Translate the following English statement into Agda.\nR3. Let $T0$ be an element of $cic.Univ$ of $univs.Type0$. Let $a0$ be an element of $cic.Term$ of $univs.Type0$ and $T0$. Let $T1$ be a function from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ to elements of $cic.Univ$ of $univs.Type0$. Let $a1$ be an element of $cic.Term$ of $univs.Type0$ and $T1$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$. Let $T2$ be a function from elements $x0$ of $cic.Term$ of $univs.Type0$ and $T0$ and elements $p0$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $x0$ and elements $x1$ of $cic.Term$ of $univs.Type0$ and $T1$ applied to $x0$ and $p0$ and elements $__$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T1$ applied to $x0$ and $p0$ and $matita_basics_logic.R1$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $T1$ and $a1$ and $x0$ and $p0$ and $x1$ to elements of $cic.Univ$ of $univs.Type0$. Let $a2$ be an element of $cic.Term$ of $univs.Type0$ and $T2$ applied to $a0$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $T0$ and $a0$ and $a1$ and $matita_basics_logic.refl$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2", "label": "postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type", "predict": "postulate R3 : (T0 : cic.Univ univs.Type0) -> (a0 : cic.Term univs.Type0 T0) -> (T1 : (x0 : cic.Term univs.Type0 T0) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> cic.Univ univs.Type0) -> (a1 : cic.Term univs.Type0 (T1 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0))) -> (T2 : (x0 : cic.Term univs.Type0 T0) -> (p0 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 x0)) -> (x1 : cic.Term univs.Type0 (T1 x0 p0)) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1)) -> cic.Univ univs.Type0) -> (a2 : cic.Term univs.Type0 (T2 a0 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0) a0) a1 (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 (T1 x0 p0)) (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0) x1))) -> cic.Univ univs.Type0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAssoc_plus1. För alla naturliga tal $a$ och $b$ och $c$, är summan av $c$ och summan av $b$ och $a$ lika med summan av summan av $b$ och $c$ och $a$.\nAssistant:", "label": "postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)", "predict": "postulate assoc_plus1 : (a : Nat) -> (b : Nat) -> (c : Nat) -> Eq (plus c (plus b a)) (plus (plus b c) a)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_pi. Soit $n \\in N$. Soit $p$ une fonction des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Alors pour toutes les fonctions $__$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n$ et des éléments $__1$ de $Eq$ de $p$ appliqué à $i$ et de $true$ à des éléments de $Leq$ de $g1$ appliqué à $i$ et de $g2$ appliqué à $i$, $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ est inférieur ou ágal à $bigop$ appliqué à $n$ et la fonction qui envoie $i$ à $p$ appliqué à $i$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$.\nAssistant:", "label": "postulate le_pi : (n : Nat) -> (p : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (_ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i)) (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))", "predict": "postulate le_pi : soit n : Nat\n        soit p : (_ : Nat) -> bool\n        soit g1 : (_ : Nat) -> Nat\n        soit g2 : (_ : Nat) -> Nat\n        et __ : (i : Nat) -> (_ : Lt i n) -> (__1 : Eq (p i) true) -> Leq (g1 i) (g2 i)\n        et bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g1 i) is inferior or (bigop n (\\ i : Nat -> p i) Nat 1 times (\\ i : Nat -> g2 i))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind_l_aux. Soit $B$ un élément de $cic.Univ$ de $univs.Type0$. Soit $R$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $B$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $b2$ un élément de $cic.Term$ de $univs.Type0$ et de $B$. Soit $P$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_relations.relation2$ appliqué à $matita_arithmetics_nat.nat$ et $B$. Soit $__$ un élément de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.O$ et $b2$. Soit $__1$ une fonction des éléments $l$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $b1$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $B$ et des éléments $__1$ de $cic.Term$ de $cic.prop$ et de $R$ appliqué à $b1$ et $b$ et des éléments $__2$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b$ et $b2$ et des éléments $__3$ de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $l$ et $b$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_arithmetics_nat.plus$ appliqué à $l$ et $matita_arithmetics_nat.S$ appliqué à $matita_arithmetics_nat.O$ et $b1$. Soit $l$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soient $b1$ et $b$ des éléments de $cic.Term$ de $univs.Type0$ et de $B$. Soit $__2$ un élément de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_lstar.lstar$ appliqué à $B$ et $R$ et $l$ et $b1$ et $b$. Alors pour tous les éléments $__3$ de $", "label": "postulate lstar_ind_l_aux : (B : cic.Univ univs.Type0) -> (R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop) -> (b2 : cic.Term univs.Type0 B) -> (P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B)) -> (__ : cic.Term cic.prop (P matita_arithmetics_nat.O b2)) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop (P l b)) -> cic.Term cic.prop (P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1)) -> (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 B) b b2)) -> cic.Term cic.prop (P l b1)", "predict": "postulate lstar_ind_l_aux : soit B un élément de cic.Univ univs.Type0. soit R : (__ : cic.Term univs.Type0 B) -> (__1 : cic.Term univs.Type0 B) -> cic.Univ cic.prop. soit b2 : cic.Term univs.Type0 B. soit P : cic.Term univs.Type0 (matita_basics_relations.relation2 matita_arithmetics_nat.nat B) -> (__ : cic.Term cic.prop P (matita_arithmetics_nat.O) b2) -> (__1 : (l : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (b1 : cic.Term univs.Type0 B) -> (b : cic.Term univs.Type0 B) -> (__1 : cic.Term cic.prop (R b1 b)) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b b2)) -> (__3 : cic.Term cic.prop P l b) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b1) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b1 b)) -> (__3 : cic.Term cic.prop P l b1) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b2) -> (b1 : cic.Term univs.Type0 B) -> (b2 : cic.Term univs.Type0 B) -> (__2 : cic.Term cic.prop (matita_arithmetics_lstar.lstar B R l b2 b)) -> (__3 : cic.Term cic.prop P l b2) -> cic.Term cic.prop P (matita_arithmetics_nat.plus l (matita_arithmetics_nat.S matita_arithmetics_nat.O)) b"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_times_n_to_lt_r. Let $n$ and $p$ and $q$ be natural numbers. Assume that the product of $n$ and $p$ is less than the product of $n$ and $q$. Then $p$ is less than $q$.\nAssistant:", "label": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q", "predict": "postulate lt_times_n_to_lt_r : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : Lt (times n p) (times n q)) -> Lt p q"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_16001. Soit $m, n, a, b \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Alors pour tous les nombres naturels $d$, si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$, alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors le diviseur commun plus grand de $m$ et de $n$ est égal à la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$.\nAssistant:", "label": "postulate let_clause_16001 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (gcd m n) (minus (times n c) (times m d))", "predict": "postulate let_clause_16001 : soit m, n, a, b : N\n  -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (div (comm : Nat m n) 1) (Nat c)) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (dn : Nat) -> (H : Eq (minus (times c n) (times d m)) 1) -> (Hm : Eq (minus (times d m) (times c n)) 1) -> (Hc : Eq (minus (times c n) (times d m)) 1) -> Eq (div m n) (minus (times n c) (times m d))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLstar_ind. Soit $B$ un ensemble. Soit $_R$ un élément de $relation$ de $B$. Soit $Q_$ une fonction des nombres naturels $x_1233$ et des éléments $x_1232$ de $B$ et des éléments $x_1231$ de $B$ et des éléments $_x_1234$ de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$ à des propositions. Soit $_H_lstar_O$ une fonction des éléments $b$ de $B$ à des éléments de $Q_$ de $0$ et de $b$ et de $b$ et de $lstar_O (B, _R, b)$. Soit $_H_lstar_S$ une fonction des éléments $b1$ de $B$ et des éléments $b$ de $B$ et des éléments $x_1236$ de $_R$ de $b1$ et de $b$ et des nombres naturels $l$ et des éléments $b2$ de $B$ et des éléments $x_1235$ de $lstar$ de $B$ et de $_R$ et de $l$ et de $b$ et de $b2$ et des éléments $_x_1238$ de $Q_$ de $l$ et de $b$ et de $b2$ et de $x_1235$ à des éléments de $Q_$ de $l + 1$ et de $b1$ et de $b2$ et de $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$. Soit $x_1233$ un nombre naturel. Soient $x_1232$ et $x_1231$ des éléments de $B$. Soit $x_1234$ un élément de $lstar$ de $B$ et de $_R$ et de $x_1233$ et de $x_1232$ et de $x_1231$. Alors $Q_$ tient pour $x_1233$ et $x_1232$ et $x_1231$ et $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind : soit B un ensemble. soit _R un element de relation de B. soit Q_ une fonction des nombres naturels x_1233 et des elements x_1232 de B et des elements x_1231 de B et des elements _x_1234 de lstar de B _R x_1233 x_1232 x_1231 et des propositions. soit _H_lstar_O une fonction des elements b de B a des elements Q_ 0 b b et b et lstar_O (B _R b). soit _H_lstar_S une fonction des elements b1 de B et des elements b de B et des elements x_1236 de _R b1 b et des nombres l et des elements b2 de B et des elements x_1235 de lstar de B _R l b b2 et des elements _x_1238 de Q_ l b b2 x_1235 et des elements Q_ l + 1 b1 b2 lstar_S (B _R b1 b x_1236 l b2 x_1235). soit x_1233 un nombre naturel. soient x_1232 et x_1231 des elements de B. soient x_1234 un element de lstar de B _R x_1233 x_1232 x_1231. alors Q_ tient pour x_1233 x_1232 x_1231 x_1234."}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1034. Låt $n$ och $m$ och $p$ vara naturliga tal. Anta att $0 < p$. Då för alla naturliga tal $x2515$ och $x2516$, $x2515 = mod (x2515, x2516)+ x2516 (x2515 \\div x2516)$.\nAssistant:", "label": "postulate let_clause_1034 : (n : Nat) -> (m : Nat) -> (p : Nat) -> (posp : Lt 0 p) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (mod x2515 x2516) (times x2516 (div x2515 x2516)))", "predict": "postulate let_clause_1034 : let n : Nat -> m : Nat -> p : Nat -> (x2515 : Nat) -> (x2516 : Nat) -> x2515 = mod x2515 x2516 + x2516 (x2515 / x2516)"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_inv_rect_CProp0. Let $Hterm \\in N$. Let $P$ be a function from natural numbers $_z713$ to propositions. Let $_H1$ be a function from elements $_z714$ of $Eq$ of $Hterm$ and $0$ to elements of $P$ of $0$. Let $_H2$ be a function from natural numbers $x_414$ and functions $_x_416$ from elements $_z714$ of $Eq$ of $Hterm$ and $x_414$ to elements of $P$ of $x_414$ and elements $_z714$ of $Eq$ of $Hterm$ and the sum of $x_414$ and $1$ to elements of $P$ of the sum of $x_414$ and $1$. Then $P$ holds for $Hterm$.\nAssistant:", "label": "postulate nat_inv_rect_CProp0 : (Hterm : Nat) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm", "predict": "postulate nat_inv_rect_CProp0 : (Hterm : N) -> (P : (_z713 : Nat) -> Prop) -> (_H1 : (_z714 : Eq Hterm 0) -> P 0) -> (_H2 : (x_414 : Nat) -> (_x_416 : (_z714 : Eq Hterm x_414) -> P x_414) -> (_z714 : Eq Hterm (plus x_414 1)) -> P (plus x_414 1)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1692. Låt $m$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $posm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $matita_arithmetics_nat.O$ och $m$. Då för alla element $a$ och $x358$ och $x359$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_bigops.aop__o__op$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.O$ och $matita_arithmetics_sigma_pi.plusAC$ och $x358$ och $matita_arithmetics_nat.times$ applicerat på $x358$ och $x359$ och $matita_arithmetics_nat.times$ applicerat på $x358$ och $matita_arithmetics_nat.S$ applicerat på $x359$.\nAssistant:", "label": "postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))", "predict": "postulate let_clause_1692 : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (posm : cic.Term cic.prop (matita_arithmetics_nat.lt matita_arithmetics_nat.O m)) -> (a : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x358 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x359 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_bigops.aop__o__op matita_arithmetics_nat.nat matita_arithmetics_nat.O matita_arithmetics_sigma_pi.plusAC x358 (matita_arithmetics_nat.times x358 x359)) (matita_arithmetics_nat.times x358 (matita_arithmetics_nat.S x359)))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDivides_fact_to_le. För alla naturliga tal $p$ och $n$, om $p$ är primt, så om $p$ är delbart med $n!$, så $p \\leq n$.\nAssistant:", "label": "postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p (factorial n)) -> Leq p n", "predict": "postulate divides_fact_to_le : (p : Nat) -> (n : Nat) -> (_ : prime p) -> (__1 : divisible p n) -> Leq p n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLe_exp_prim4l. Låt $n$ vara ett naturligt tal. Anta att $0 < n$. Då $2 ^ (4 n + 1)\\leq 4 n ^ (prim (4 n)+ 1)$.\nAssistant:", "label": "postulate le_exp_prim4l : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (plus (times 4 n) 1)) (pow (times 4 n) (plus (prim (times 4 n)) 1))", "predict": "postulate le_exp_prim4l : lett Nat (\\ n -> ett Nat) (and (Lt 0 n) (Leq 2 (pow 4 n + 1)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_log_n_n. Let $p$ and $n$ be natural numbers. Assume that $1 < p$. Assume that $0 < n$. Then $\\log_ p {n}< n$.\nAssistant:", "label": "postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (log p n) n", "predict": "postulate lt_log_n_n : (p : Nat) -> (n : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> Lt (log p n) n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Let $c$ be a natural number. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d$ be a natural number. Assume that the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$. Then if the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then the greatest common divisor of $m$ and $n$ is equal to the difference of the product of $m$ and $d$ and the product of $n$ and $c$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_ind_body. Soient $_n$ et $_m$ des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour toutes les fonctions $Q_$ des éléments $_x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$ à des éléments de $cic.Univ$ de $cic.prop$, pour toutes les fonctions $_H_quotient$ des éléments $q$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ et des éléments $x_1193$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_arithmetics_nat.nat$ et $_m$ et $matita_arithmetics_nat.times$ appliqué à $_n$ et $q$ à des éléments de $cic.Term$ de $cic.prop$ et de $Q_$ appliqué à $matita_arithmetics_primes.quotient$ appliqué à $_n$ et $_m$ et $q$ et $x_1193$, pour tous les éléments $x_1192$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $_n$ et $_m$, $cic.Term$ tient pour $cic.prop$ et $Q_$ appliqué à $x_1192$.\nAssistant:", "label": "postulate divides_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)", "predict": "postulate divides_ind_body : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (_m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Q_ : (_x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Univ cic.prop) -> (_H_quotient : (q : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x_1193 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) _m (matita_arithmetics_nat.times _n q))) -> cic.Term cic.prop (Q_ (matita_arithmetics_primes.quotient _n _m q x_1193))) -> (x_1192 : cic.Term cic.prop (matita_arithmetics_primes.divides _n _m)) -> cic.Term cic.prop (Q_ x_1192)"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_mod_spec_discr. Let $a1, a2, a3, a4 \\in N$. Let $x$ and $y$ be elements of $div_mod_spec$ of $a1$ and $a2$ and $a3$ and $a4$. Then if $x$ is equal to $y$, then $match_div_mod_spec$ holds for $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $t0$ and $t1$ to $match_div_mod_spec$ applied to $a1$ and $a2$ and $a3$ and $a4$ and the sum of $Type2$ and $1$ and the function that maps $__$ to $univ$ applied to $Type2$ and the function that maps $u0$ and $u1$ to $prod$ applied to the sum of $Type1$ and $1$ and $Type1$ and $univ$ applied to $Type1$ and the function that maps $P$ to $prod$ applied to $Type1$ and $Type1$ and $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R0$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and $u0$ and the function that maps $e0$ to $prod$ applied to $Prop$ and $Type1$ and $Eq$ applied to $R1$ applied to $Lt$ applied to $a4$ and $a2$ and $t0$ and the function that maps $x_19$ and $_x_20$ to the function that maps $x0$ and $p0$ to $Eq$ applied to $a1$ and the sum of the product of $a3$ and $a2$ and $a4$ applied to $x_19$ and $_x_20$ and $t1$ and $u0$ and $", "label": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Lt a4 a2 -> \\ t1 : Eq a1 (plus (times a3 a2) a4) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Lt a4 a2 -> \\ u1 : Eq a1 (plus (times a3 a2) a4) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1) (\\ _e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a2 -> \\ p0 : Eq t0 x0 -> Eq a1 (plus (times a3 a2) a4)) x_19 _x_20) t1 u0 e0) u1 -> P))) (\\ _z53 : ((e0 : Eq (R0 (Lt a4 a2) t0) u0) -> (_e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Lt a4 a2 -> \\ _x_20 : Eq t0 x_19 -> (\\ x0 : Lt a4 a", "predict": "postulate div_mod_spec_discr : (a1 : Nat) -> (a2 : Nat) -> (a3 : Nat) -> (a4 : Nat) -> (x : div_mod_spec a1 a2 a3 a4) -> (y : div_mod_spec a1 a2 a3 a4) -> (_e : Eq x y) -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ t0 : Nat -> \\ t1 : Nat -> match_div_mod_spec a1 a2 a3 a4 (plus Type2 1) (\\ _ : div_mod_spec a1 a2 a3 a4 -> univ Type2) (\\ u0 : Nat -> \\ u1 : Nat -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (Lt a4 a2) t0) u0) (\\ e0 : Eq (R0 (Lt a4 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> _x_20) t1) u0) (\\ e1 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\\ e2 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\\ e3 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3 a2) a4 x_19 _x_20 t1 u0))) (\\ e4 : Eq (R1 (Lt a4 a2) t0 (\\ x_19 : Nat -> _x_20) t1) u0 -> Eq a1 (plus (times a3"}
{"prompt": "Human: Translate the following French statement into Agda.\nRange_inv_rect_Type2. Soit $x1$ un ensemble. Soit $Hterm$ un élément de $range$ de $x1$. Soit $P$ une fonction des éléments $_z1650$ de $range$ de $x1$ à des éléments de $Type2$. Alors pour toutes les fonctions $_H1$ des fonctions $_enum$ des nombres naturels à des éléments de $x1$ et des nombres naturels $_upto$ et des fonctions $_filter$ des nombres naturels à des valeurs booléennes et des éléments $_z1651$ de $Eq$ de $Hterm$ et de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$ à des éléments de $P$ de $mk_range$ appliqué à $x1$ et $_enum$ et $_upto$ et $_filter$, $P$ tient pour $Hterm$.\nAssistant:", "label": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm", "predict": "postulate range_inv_rect_Type2 : (x1 : Set) -> (Hterm : range x1) -> (P : (_z1650 : range x1) -> Type2) -> (_H1 : (_enum : (_ : Nat) -> x1) -> (_upto : Nat) -> (_filter : (_ : Nat) -> bool) -> (_z1651 : Eq Hterm (mk_range x1 _enum _upto _filter)) -> P (mk_range x1 _enum _upto _filter)) -> P Hterm"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPlus_minus. För alla element $m$ och $n$ och $p$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, för alla element $__$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $m$ och $n$, håller $cic.Term$ för $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.minus$ applicerat på $n$ och $m$ och $p$ och $matita_arithmetics_nat.minus$ applicerat på $matita_arithmetics_nat.plus$ applicerat på $n$ och $p$ och $m$.\nAssistant:", "label": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))", "predict": "postulate plus_minus : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.le m n)) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) (matita_arithmetics_nat.plus (matita_arithmetics_nat.minus n m) p) (matita_arithmetics_nat.minus (matita_arithmetics_nat.plus n p) m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_to_dividesb_true1. Pour tous les nombres naturels $n$ et $m$, si $0$ est inférieur à $m$, alors si $n$ est divisible par $m$, alors $dividesb$ appliqué à $n$ et $m$ est égal à $true$.\nAssistant:", "label": "postulate divides_to_dividesb_true1 : (n : Nat) -> (m : Nat) -> (_ : Lt 0 m) -> (__1 : divisible n m) -> Eq (dividesb n m) true", "predict": "postulate divides_to_dividesb_true1 : tous les nombres naturels n m si 0 est inférieur a m alors si n est divisible par m alors dividesb n m est égal à true"}
{"prompt": "Human: Translate the following English statement into Agda.\nACop_inv_rect_Type4. Let $x1$ be an element of $cic.Univ$ of $univs.Type0$. Let $x2$ be an element of $cic.Term$ of $univs.Type0$ and $x1$. Let $Hterm$ be an element of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$. Let $P$ be a function from elements $_z1572$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ to elements of $cic.Univ$ of $univs.Type4$. Then for all functions $_H1$ from elements $aop$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Aop$ applied to $x1$ and $x2$ and functions $_comm$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $x1$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $x1$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $x1$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $a$ and $b$ and $matita_arithmetics_bigops.op$ applied to $x1$ and $x2$ and $aop$ and $b$ and $a$ and elements $_z1573$ of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_bigops.ACop$ applied to $x1$ and $x2$ and $Hterm$ and $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$ to elements of $cic.Term$ of $univs.Type4$ and $P$ applied to $matita_arithmetics_bigops.mk_ACop$ applied to $x1$ and $x2$ and $aop$ and $_comm$, $cic.Term$ holds for $univs.Type4$ and $P$ applied to $Hterm$.\nAssistant:", "label": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate ACop_inv_rect_Type4 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> (P : (_z1572 : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x1 x2)) -> cic.Univ univs.Type4) -> (_H1 : (aop : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (_comm : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (matita_arithmetics_bigops.op x1 x2 aop a b) (matita_arithmetics_bigops.op x1 x2 aop b a))) -> (_z1573 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.ACop x1 x2)) Hterm (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P (matita_arithmetics_bigops.mk_ACop x1 x2 aop _comm))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16921. Let $m \\in N$. Assume that $0$ is less than $m$. Then for all natural numbers $a$ and $x358$ and $x359$, $aop__o__op$ applied to $Nat$ and $0$ and $plusAC$ and $x358$ and the product of $x358$ and $x359$ is equal to the product of $x358$ and the sum of $x359$ and $1$.\nAssistant:", "label": "postulate let_clause_16921 : (m : Nat) -> (posm : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))", "predict": "postulate let_clause_16921 : (m : Nat) -> (posn : Lt 0 m) -> (a : Nat) -> (x358 : Nat) -> (x359 : Nat) -> Eq (aop__o__op Nat 0 plusAC x358 (times x358 x359)) (times x358 (plus x359 1))"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nAll_below. Låt $_l$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_lists_list.list$ applicerat på $matita_arithmetics_nat.nat$. Då för alla element $_n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Univ$ för $cic.prop$.\nAssistant:", "label": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop", "predict": "postulate all_below : (_l : cic.Term univs.Type0 (matita_basics_lists_list.list matita_arithmetics_nat.nat)) -> (all : (_n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Univ cic.prop) -> cic.Univ cic.prop"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nACop_rect_CProp1_body. Låt $A$ vara en mängd. Låt $_nil$ vara ett element av $A$. Låt $Q_$ vara en funktion från element $_x_911$ av $ACop$ av $A$ och $_nil$ till påståenden. Då för alla funktioner $_H_mk_ACop$ från element $aop$ av $Aop$ av $A$ och $_nil$ och funktioner $_comm$ från element $a$ av $A$ och element $b$ av $A$ till element av $Eq$ av $op (A, _nil, aop, a, b)$ och $op (A, _nil, aop, b, a)$ till element av $Q_$ av $mk_ACop (A, _nil, aop, _comm)$, för alla element $x_911$ av $ACop$ av $A$ och $_nil$, håller $Q_$ för $x_911$.\nAssistant:", "label": "postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911", "predict": "postulate ACop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_911 : ACop A _nil) -> Prop) -> (Q_ : (_H_mk_ACop : (aop : Aop A) -> (_nil : A) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_911 : ACop A _nil) -> Q_ x_911"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_16002. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Assume that $1$ is equal to the greatest common divisor of $n$ and $m$. Let $c \\in N$. Let $_clearme$ be an element of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$. Let $d \\in N$. Then if $c n - d m = 1$ or $d m - c n = 1$, then if $d m - c n = 1$, then $m d - n c$ is equal to the greatest common divisor of $m$ and $n$.\nAssistant:", "label": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (gcd m n) (minus (times m d) (times n c))", "predict": "postulate let_clause_16002 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) m) (Eq (minus (times d m) (times c n)) m)) -> (H : Eq (minus (times d m) c) (gcd m n)) -> Eq m d (gcd m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPermut_S_mod. Pour tous les nombres naturels $n$, $permut$ tient pour $S_mod$ appliqué à la somme de $n$ et de $1$ et $n$.\nAssistant:", "label": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n", "predict": "postulate permut_S_mod : (n : Nat) -> permut (S_mod (plus n 1)) n"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_priml1. Pour tous les nombres naturels $n$, si $0 < n$, alors $2 n \\div ((\\log_ 2 {n})+ 2)- 1 \\leq prim (2 n)$.\nAssistant:", "label": "postulate le_priml1 : (n : Nat) -> (_ : Lt 0 n) -> Leq (minus (div (times 2 n) (plus (log 2 n) 2)) 1) (prim (times 2 n))", "predict": "postulate le_priml1 : tous les nombres naturels n, (0 < n) -> 2 n / ((log_2 n) + 2) - 1 <= prim (2 n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nFmin_true. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n, m, b \\in N$. Supposons que $m$ est égal à $min$ appliqué à $n$ et $b$ et $f$. Supposons que $m$ est inférieur à la somme de $n$ et de $b$. Alors $f$ appliqué à $m$ est égal à $true$.\nAssistant:", "label": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (_ : Eq m (min n b f)) -> (__1 : Lt m (plus n b)) -> Eq (f m) true", "predict": "postulate fmin_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (m : Nat) -> (b : Nat) -> (eqm : Eq m (min n b f)) -> (ltm : Lt m (plus n b)) -> Eq (f m) true"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1562. Soit $m, n, a, b \\in N$. Supposons que $0 < n$ et $0 < m$. Supposons que $1$ est égal au diviseur commun plus grand de $n$ et de $m$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Alors si $c n - d m = 1$ ou $d m - c n = 1$ et $c n - d m = 1$, alors $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_1562 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (eqn1 : Eq 1 (div (plus n m) (gcd n m))) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disj (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (H : Eq (minus (times d m) (times c n)) 1) -> Eq (times n c) m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15321. Soient $n$ et $m$ des nombres naturels. Supposons que $0 < m$. Supposons que $0 = n$. Supposons que $0$ est divisible par $m$. Soit $q$ un nombre naturel. Supposons que $m = 0 q$. Alors $m = 0$.\nAssistant:", "label": "postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (eqn0 : Eq 0 n) -> (_clearme : divisible 0 m) -> (q : Nat) -> (eqm : Eq m (times 0 q)) -> Eq m 0", "predict": "postulate let_clause_15321 : (n : Nat) -> (m : Nat) -> (posn : Lt 0 m) -> (posn0 : Eq 0 n) -> (posn1 : divisible 0 m) -> (q : Nat) -> (eqm0 : Eq m 0) -> (auto : Eq q 0) -> Eq m 0"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_CProp0_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_885$ of $Aop$ of $A$ and $_nil$ to propositions. Let $_H_mk_Aop$ be a function from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op (_nil, a)$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op (a, _nil)$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op (a, op (b, c))$ and $op (op (a, b), c)$ to elements of $Q_$ of $mk_Aop (A, _nil, op, _nill, _nilr, _assoc)$. Then for all elements $x_885$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_885$.\nAssistant:", "label": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885", "predict": "postulate Aop_rect_CProp0_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_885 : Aop A _nil) -> Prop) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_885 : Aop A _nil) -> Q_ x_885"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_plus_r. För alla element $n$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$, håller $cic.Term$ för $cic.prop$ och $matita_basics_relations.monotonic$ applicerat på $matita_arithmetics_nat.nat$ och $matita_arithmetics_nat.lt$ och funktionen som avbildar $m$ som $matita_arithmetics_nat.plus$ applicerat på $n$ och $m$.\nAssistant:", "label": "postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))", "predict": "postulate monotonic_lt_plus_r : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term cic.prop (matita_basics_relations.monotonic matita_arithmetics_nat.nat matita_arithmetics_nat.lt (\\ m : cic.Term univs.Type0 matita_arithmetics_nat.nat -> matita_arithmetics_nat.plus n m))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1033. Soit $n$ un nombre naturel. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soient $g1$ et $g2$ des fonctions des nombres naturels à des nombres naturels. Alors pour tous les nombres naturels $n1$, pour toutes les fonctions $Hind$ des fonctions des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$ et des fonctions $__1$ des nombres naturels $i$ et des éléments $__1$ de $Lt$ de $i$ et de $n1$ et des éléments $__2$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$ à des éléments de $Leq$ de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g1$ appliqué à $i$ et de $bigop$ appliqué à $n1$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $Nat$ et $0$ et $plus$ et la fonction qui envoie $i$ à $g2$ appliqué à $i$, pour toutes les fonctions $H1$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Eq$ de $p2 (i)$ et de $true$, pour toutes les fonctions $H2$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $n1 + 1$ et des éléments $__1$ de $Eq$ de $p1 (i)$ et de $true$ à des éléments de $Leq$ de $g1 (i)$ et de $g2 (i)$, si $p2 (n1)= true$ et $p1 (n1)= true$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_1033 : (n : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (g1 : (_ : Nat) -> Nat) -> (g2 : (_ : Nat) -> Nat) -> (n1 : Nat) -> (Hind : (_ : (i : Nat) -> (_ : Lt i n1) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) -> (H1 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Eq (p2 i) true) -> (H2 : (i : Nat) -> (_ : Lt i (plus n1 1)) -> (__1 : Eq (p1 i) true) -> Leq (g1 i) (g2 i)) -> (Hp2 : Eq (p2 n1) true) -> (Hp1 : Eq (p1 n1) true) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_1033 : soit n un nombre naturel. soit (p1 : (_ : Nat) -> bool) et (p2 : (_ : Nat) -> bool) et (g1 : (_ : Nat) -> Nat) et (g2 : (_ : Nat) -> Nat) alors pour tous les nombres naturels n1, pour toutes les fonctions Hind : (_ : Nat) -> (_ : Lt i n1) -> (__1 : Eq p1 i) -> Eq p2 i) et (__1 : (i : Nat) -> (__1 : Lt i n1) -> (__2 : Eq p1 i) -> Leq g1 i) et (Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i))) (Leq (bigop n1 (\\ i : Nat -> p1 i) Nat 0 plus (\\ i : Nat -> g1 i)) (bigop n1 (\\ i : Nat -> p2 i) Nat 0 plus (\\ i : Nat -> g2 i)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMatch_le. Let $_n$ be a natural number. Let $return_sort$ be an element of $Sort$. Let $return_type$ be a function from natural numbers and elements $z$ of $Leq$ of $_n$ and $__$ to elements of $return_sort$. Let $case_le_n$ be an element of $return_type$ of $_n$ and $le_n$ applied to $_n$. Let $case_le_S$ be a function from natural numbers $m$ and elements of $Leq$ of $_n$ and $m$ to elements of $return_type$ of the sum of $m$ and $1$ and $le_S$ applied to $_n$ and $m$ and $__$. Then for all natural numbers $__$, if $_n$ is less than or equal to $__$, then $return_type$ holds for $__$ and $z$.\nAssistant:", "label": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z", "predict": "postulate match_le : (_n : Nat) -> (return_sort : Sort) -> (return_type : (_ : Nat) -> (z : Leq _n __) -> return_sort) -> (case_le_n : return_type _n (le_n _n)) -> (case_le_S : (m : Nat) -> (_ : Leq _n m) -> return_type (plus m 1) (le_S _n m __)) -> (_ : Nat) -> (z : Leq _n __) -> return_type __ z"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1545. Soient $m$ et $n$ des nombres naturels. Supposons que $0$ est égal au diviseur commun plus grand de $m$ et de $n$. Supposons que $0$ est divisible par $n$. Soit $q1 \\in N$. Supposons que $n = 0 q1$. Supposons que $0$ est divisible par $m$. Soit $q2 \\in N$. Supposons que $m = 0 q2$. Alors $m = 0$.\nAssistant:", "label": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (H : Eq (gcd m n) 0) -> (_clearme : divisible 0 n) -> (q1 : Nat) -> (H1 : Eq n (times 0 q1)) -> (_clearme0 : divisible 0 m) -> (q2 : Nat) -> (H2 : Eq m (times 0 q2)) -> Eq m 0", "predict": "postulate let_clause_1545 : (m : Nat) -> (n : Nat) -> (posn : Eq 0 (div m n)) -> (posn' : divisible 0 n) -> (q1 : Nat) -> (posn2 : Eq n 0 q1) -> (posn3 : divisible 0 m) -> (q2 : Nat) -> (posn4 : Eq m 0 q2) -> Eq m 0"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_16171. Låt $p, m, n \\in N$. Anta att $0 < p$ och $1$ är lika med det största gemensama delaret av $p$ och $m$. Anta att $p$ är delbart med $m \\times n$. Låt $c$ vara ett naturligt tal. Anta att $m n = p c$. Låt $a$ vara ett naturligt tal. Låt $_clearme0$ vara ett element av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $p$ och produkten av $b$ och $m$ och det största gemensama delaret av $p$ och $m$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $p$ och det största gemensama delaret av $p$ och $m$. Låt $b \\in N$. Då om det största gemensama delaret av $p$ och $m$ är lika med $a p - b m$ eller lika med $b m - a p$ och det största gemensama delaret av $p$ och $m$ är lika med $b m - a p$, så om $b m - a p = 1$, så är $m b - p a$ lika med det största gemensama delaret av $p$ och $m$.\nAssistant:", "label": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 p) -> (gcd1 : Eq (gcd p m) 1) -> (_clearme : divisible p (times m n)) -> (c : Nat) -> (nm : Eq (times m n) (times p c)) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m)))) -> (b : Nat) -> (_clearme1 : or (Eq (minus (times a p) (times b m)) (gcd p m)) (Eq (minus (times b m) (times a p)) (gcd p m))) -> (H : Eq (minus (times b m) (times a p)) (gcd p m)) -> (H0 : Eq (minus (times b m) (times a p)) 1) -> Eq (gcd p m) (minus (times m b) (times p a))", "predict": "postulate let_clause_16171 : (p : Nat) -> (m : Nat) -> (n : Nat) -> (a : Nat) -> (_clearme0 : ex Nat (\\ b : Nat -> (\\ p : Nat -> (\\ m : Nat -> (\\ n : Nat -> ( Eq (p (times n)) m) c) -> (a : Nat) -> (_clearme1 : Eq (m n) p) -> Eq (Eq (p (times b)) m) (Eq (a p) (times n b)) -> Eq (p m) (times n b)) -> Eq (b n) (times m n)) -> (H : Eq (p m) a) -> Eq (b n) (times m n)) -> (Hm : Eq (p m) a) -> Eq (b n) (times m n)) -> Eq (p m) a"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_rect_CProp0. För alla funktioner $Q_$ från element $_x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$ till element av $cic.Univ$ av $cic.prop$, för alla element $x_78$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.False$, håller $cic.Term$ för $cic.prop$ och $Q_$ applicerat på $x_78$.\nAssistant:", "label": "postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)", "predict": "postulate False_rect_CProp0 : (Q_ : (_x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Univ cic.prop) -> (x_78 : cic.Term cic.prop matita_basics_logic.False) -> cic.Term cic.prop (Q_ x_78)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1047. Låt $k, n \\in N$. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Då för alla mängder $B$, för alla element $nil$ av $B$, för alla funktioner $op$ från element av $B$ och element $__1$ av $B$ till element av $B$, för alla funktioner $f$ från naturliga tal till element av $B$, om $n \\leq k$, så för alla naturliga tal $j$, om $n \\leq j$, så för alla funktioner $Hind$ från funktioner från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j$ till element av $Eq$ av $p (i)$ och kontradiktion till element av $Eq$ av $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ och $bigop$ applicerat på $j$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$, för alla funktioner $Hfalse$ från naturliga tal $i$ och element av $Leq$ av $n$ och $i$ och element $__1$ av $Lt$ av $i$ och $j + 1$ till element av $Eq$ av $p (i)$ och kontradiktion, för alla naturliga tal $x2571$ och $x2572$, $x2571 = x2572 (x2571 \\div x2572)+ mod (x2571, x2572)$.\nAssistant:", "label": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (lenk : Leq n k) -> (j : Nat) -> (leup : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i (plus j 1)) -> Eq (p i) false) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 (plus (times x2572 (div x2571 x2572)) (mod x2571 x2572))", "predict": "postulate let_clause_1047 : (k : Nat) -> (n : Nat) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (n : Nat) -> (j : Nat) -> (ltml : Leq n k) -> (jlt : Leq n j) -> (Hind : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) (contradiction)) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Hfalse : (_ : (i : Nat) -> (_ : Leq n i) -> (__1 : Lt i j) -> Eq (p i) (contradiction)) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop j (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> (Htrue : Eq (p n) (contradiction)) -> (x2571 : Nat) -> (x2572 : Nat) -> Eq x2571 x2572 (x2571 div x2572) + (mod x2571 x2572)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nSmallest_factor_to_prime. Låt $n$ vara ett naturligt tal. Anta att $1 < n$. Anta att $smallest_factor (n)= n$. Då är $n$ primt.\nAssistant:", "label": "postulate smallest_factor_to_prime : (n : Nat) -> (_ : Lt 1 n) -> (__1 : Eq (smallest_factor n) n) -> prime n", "predict": "postulate smallest_factor_to_prime : let n : Nat in let (lt : Lt n 1) in let (factorial : prime n) in n"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nP_ord_to_exp1. Låt $p$ och $n$ och $q$ och $r$ vara naturliga tal. Anta att $1$ är mindre än $p$. Anta att $0$ är mindre än $n$. Anta att $p_ord$ applicerat på $n$ och $p$ är lika med $mk_Prod$ applicerat på $Nat$ och $Nat$ och $q$ och $r$. Då är $p$ inte delbart med $r$ och $n$ är lika med produkten av potensen av $p$ och $q$ och $r$.\nAssistant:", "label": "postulate p_ord_to_exp1 : (p : Nat) -> (n : Nat) -> (q : Nat) -> (r : Nat) -> (_ : Lt 1 p) -> (__1 : Lt 0 n) -> (__2 : Eq (p_ord n p) (mk_Prod Nat Nat q r)) -> and (not (divisible p r)) (Eq n (times (pow p q) r))", "predict": "postulate p_ord_to_exp1 : let (p : Nat) (n : Nat) (q : Nat) (r : Nat) -> and (Lt 1 p) (Lt 0 n) (Eq (p_ord n p) (mk_Prod Nat Nat q r)) (Eq p (p_ord n p)) (Eq n (times (pow p q) r))"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop. Let $__$ be a natural number. Then for all functions $__1$ from natural numbers $__1$ to booleans, for all sets $H$, for all elements $__2$ of $H$, for all functions $__3$ from elements $__3$ of $H$ and elements $__4$ of $H$ to elements of $H$, for all functions $__4$ from natural numbers $__4$ to elements of $H$, $H$.\nAssistant:", "label": "postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H", "predict": "postulate bigop : (_ : Nat) -> (__1 : (__1 : Nat) -> bool) -> (H : Set) -> (__2 : H) -> (__3 : (__3 : H) -> (__4 : H) -> H) -> (__4 : (__4 : Nat) -> H) -> H"}
{"prompt": "Human: Translate the following French statement into Agda.\nSum_inv_rect_CProp1. Soient $x1$ et $x2$ des éléments de $cic.Univ$ de $univs.Type0$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1026$ de $cic.Term$ de $univs.Type0$ et de $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des éléments $x_577$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $_z1027$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_577$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inl$ appliqué à $x1$ et $x2$ et $x_577$. Alors pour toutes les fonctions $_H2$ des éléments $x_578$ de $cic.Term$ de $univs.Type0$ et de $x2$ et des éléments $_z1027$ de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $matita_basics_types.Sum$ appliqué à $x1$ et $x2$ et $Hterm$ et $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_578$ à des éléments de $cic.Term$ de $cic.prop$ et de $P$ appliqué à $matita_basics_types.inr$ appliqué à $x1$ et $x2$ et $x_578$, $cic.Term$ tient pour $cic.prop$ et $P$ appliqué à $Hterm$.\nAssistant:", "label": "postulate Sum_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1026 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_577 : cic.Term univs.Type0 x1) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_577))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_577))) -> (_H2 : (x_578 : cic.Term univs.Type0 x2) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Sum_inv_rect_CProp1 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Univ univs.Type0) -> (Hterm : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> (P : (_z1026 : cic.Term univs.Type0 (matita_basics_types.Sum x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (x_577 : cic.Term univs.Type0 x1) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inl x1 x2 x_577))) -> cic.Term cic.prop (P (matita_basics_types.inl x1 x2 x_577))) -> (_H2 : (x_578 : cic.Term univs.Type0 x2) -> (_z1027 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_types.Sum x1 x2)) Hterm (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P (matita_basics_types.inr x1 x2 x_578))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nP_ord_exp. Soit $n, m, i \\in N$. Supposons que $0 < m$ et $mod (n, m)$ n'est pas égal à $0$. Soit $p$ un nombre naturel. Alors si $i \\leq p$, alors $p_ord_aux (p, m ^ i n, m)= mk_Prod (Nat, Nat, i, n)$.\nAssistant:", "label": "postulate p_ord_exp : (n : Nat) -> (m : Nat) -> (i : Nat) -> (_ : Lt 0 m) -> (__1 : not (Eq (mod n m) 0)) -> (p : Nat) -> (__2 : Leq i p) -> Eq (p_ord_aux p (times (pow m i) n) m) (mk_Prod Nat Nat i n)", "predict": "postulate p_ord_exp : soit n, m, i : Nat -> (posn : Lt 0 m) -> (modn : not (Eq (n, m) 0)) -> (p : Nat) -> (i : Nat) -> (H : Leq i p) -> p_ord_aux (p, m ^ i n, m)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nMonotonic_lt_minus_l. Låt $p$ och $q$ och $n$ vara naturliga tal. Anta att $n$ är mindre än eller lika med $q$. Då om $q$ är mindre än $p$, så är skillnaden mellan $q$ och $n$ mindre än skillnaden mellan $p$ och $n$.\nAssistant:", "label": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> (_ : Leq n q) -> (__1 : Lt q p) -> Lt (minus q n) (minus p n)", "predict": "postulate monotonic_lt_minus_l : (p : Nat) -> (q : Nat) -> (n : Nat) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nNat_rect_Type3. Let $Q_$ be a function from natural numbers $_x_377$ to elements of $Type3$. Let $_H_O$ be an element of $Q_$ of $0$. Let $_H_S$ be a function from natural numbers $x_378$ and elements $_x_380$ of $Q_$ of $x_378$ to elements of $Q_$ of $x_378 + 1$. Let $x_377$ be a natural number. Then $Q_$ holds for $x_377$.\nAssistant:", "label": "postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ (plus x_378 1)) -> (x_377 : Nat) -> Q_ x_377", "predict": "postulate nat_rect_Type3 : (Q_ : (_x_377 : Nat) -> Type3) -> (_H_O : Q_ 0) -> (_H_S : (x_378 : Nat) -> (_x_380 : Q_ x_378) -> Q_ x_378 + 1) -> (x_377 : Nat) -> Q_ x_377"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15621. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0$ is less than $n$. Assume that $0$ is less than $m$. Assume that the greatest common divisor of $n$ and $m$ is equal to $1$. Then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$ or the difference of the product of $d$ and $m$ and the product of $c$ and $n$ is equal to $1$, then if the difference of the product of $c$ and $n$ and the product of $d$ and $m$ is equal to $1$, then the difference of the product of $n$ and $c$ and the product of $m$ and $d$ is equal to $1$.\nAssistant:", "label": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15621 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following French statement into Agda.\nMax_spec_ind. Soit $_n$ un nombre naturel. Soit $_f$ une fonction des nombres naturels à des valeurs booléennes. Soit $Q_$ une fonction des nombres naturels $x_971$ et des éléments $_x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$ à des propositions. Soit $_H_found_max_spec$ une fonction des nombres naturels $m$ et des éléments $x_975$ de $Lt$ de $m$ et de $_n$ et des éléments $x_974$ de $Eq$ de $_f (m)$ et de $true$ et des fonctions $x_973$ des nombres naturels $i$ et des éléments de $Lt$ de $m$ et de $i$ et des éléments $__1$ de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $m$ et de $found_max_spec (_n, _f, m, x_975, x_974, x_973)$. Alors pour toutes les fonctions $_H_not_found_max_spec$ des fonctions $x_976$ des nombres naturels $i$ et des éléments de $Lt$ de $i$ et de $_n$ à des éléments de $Eq$ de $_f (i)$ et de contradiction à des éléments de $Q_$ de $0$ et de $not_found_max_spec (_n, _f, x_976)$, pour tous les nombres naturels $x_971$, pour tous les éléments $x_972$ de $max_spec$ de $_n$ et de $_f$ et de $x_971$, $Q_$ tient pour $x_971$ et $x_972$.\nAssistant:", "label": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (_ : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq _f m) -> (x_973 : (_ : Nat) -> (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq _f i) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1544. Låt $p, q \\in N$. Låt $Hind$ vara en funktion från naturliga tal $m$ och naturliga tal $n$ och element av $Lt$ av $0$ och $n$ och element $__1$ av $Leq$ av $n$ och $m$ och element $__2$ av $Leq$ av $n$ och $q$ till element av $ex$ av $Nat$ och funktionen som avbildar $a$ som $ex$ applicerat på $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $n$ och produkten av $b$ och $m$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $m$ och produkten av $a$ och $n$ och $gcd_aux$ applicerat på $q$ och $m$ och $n$. Då för alla naturliga tal $m$ och $n$, om $0 < n$ och $n \\leq m$, så om $n \\leq q + 1$ och $n$ inte är delbart med $m$, så för alla naturliga tal $a$, för alla element $_clearme$ av $ex$ av $Nat$ och funktionen som avbildar $b$ som disjunktionen av $Eq$ applicerat på skillnaden mellan produkten av $a$ och $mod$ applicerat på $m$ och $n$ och produkten av $b$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$ och $Eq$ applicerat på skillnaden mellan produkten av $b$ och $n$ och produkten av $a$ och $mod$ applicerat på $m$ och $n$ och $gcd_aux$ applicerat på $q$ och $n$ och $mod$ applicerat på $m$ och $n$, för alla naturliga tal $b$, om $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$ eller $b n - a mod (m, n)= gcd_aux (q, n, mod (m, n))$ och $a mod (m, n)- b n = gcd_aux (q, n, mod (m, n))$, så $a mod (m, n)- n b = gcd_aux (q, n, mod (m, n))$.\nAssistant:", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> let_Hind : (m : Nat) -> (n : Nat) -> (Hind : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> disjunkion (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (and (and (Lt 0 n) (and (Leq n m) (Leq n q))) (or (and (Eq (minus (times a (mod m n)) n) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) (and (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (and (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (Eq (minus (times n b) (times a (mod m n))) (gcd_aux q n (mod m n)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDop_rect_CProp1_body. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Alors pour toutes les fonctions $Q_$ des éléments $_x_965$ de $Dop$ de $A$ et de $_nil$ à des propositions, pour toutes les fonctions $_H_mk_Dop$ des éléments $sum$ de $ACop$ de $A$ et de $_nil$ et des fonctions $prod$ des éléments de $A$ et des éléments $__1$ de $A$ à des éléments de $A$ et des fonctions $_null$ des éléments $a$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $_nil$ et de $_nil$ et des fonctions $_distr$ des éléments $a$ de $A$ et des éléments $b$ de $A$ et des éléments $c$ de $A$ à des éléments de $Eq$ de $prod$ appliqué à $a$ et $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $b$ et $c$ et de $aop__o__op$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ appliqué à $a$ et $b$ et $prod$ appliqué à $a$ et $c$ à des éléments de $Q_$ de $mk_Dop$ appliqué à $A$ et $_nil$ et $sum$ et $prod$ et $_null$ et $_distr$, pour tous les éléments $x_965$ de $Dop$ de $A$ et de $_nil$, $Q_$ tient pour $x_965$.\nAssistant:", "label": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965", "predict": "postulate Dop_rect_CProp1_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_965 : Dop A _nil) -> Prop) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_965 : Dop A _nil) -> Q_ x_965"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_upper_bound7. Soient $n$ et $m$ des nombres naturels. Supposons que $nth_prime$ appliqué à $n$ est inférieur à $m$. Alors $Nat$.\nAssistant:", "label": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (ltml : Lt (nth_prime n) m) -> Nat", "predict": "postulate let_upper_bound7 : (n : Nat) -> (m : Nat) -> (H : Lt (nth_prime n) m) -> Nat"}
{"prompt": "Human: Translate the following English statement into Agda.\nDiv_div. Let $n, d \\in N$. Then if $0 < n$, then if $d$ is divisible by $n$, then $n \\div (n \\div d)= d$.\nAssistant:", "label": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div n (div n d)) d", "predict": "postulate div_div : (n : Nat) -> (d : Nat) -> (_ : Lt 0 n) -> (__1 : divisible d n) -> Eq (div (div n d) d) d"}
{"prompt": "Human: Translate the following English statement into Agda.\nLe_sqrt_nl. Let $n$ and $m$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_arithmetics_nat.lt$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_nat.times$ applied to $m$ and $matita_arithmetics_nat.pred$ applied to $m$ and $n$ and $matita_arithmetics_exp.exp$ applied to $matita_arithmetics_sqrt.sqrt$ applied to $matita_arithmetics_nat.times$ applied to $matita_arithmetics_exp.exp$ applied to $m$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$ and $n$ and $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.S$ applied to $matita_arithmetics_nat.O$.\nAssistant:", "label": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))", "predict": "postulate le_sqrt_nl : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_nat.lt (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) -> cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.times (matita_arithmetics_nat.times m (matita_arithmetics_nat.pred m)) n) (matita_arithmetics_exp.exp (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_exp.exp m (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))) n)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_plus. Soit $n, p, q \\in N$. Supposons que $n$ est divisible par $p$. Supposons que $n$ est divisible par $q$. Alors $n$ est divisible par la somme de $p$ et de $q$.\nAssistant:", "label": "postulate divides_plus : (n : Nat) -> (p : Nat) -> (q : Nat) -> (_ : divisible n p) -> (__1 : divisible n q) -> divisible n (plus p q)", "predict": "postulate divides_plus : soit n, p, q : N -> propos (divisible n p) (divisible n q)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_1075. Let $f$ be a function from natural numbers to natural numbers. Let $n$ be a natural number. Let $bijf$ be an element of $bijn$ of $f$ and the sum of $n$ and $1$. Assume that $f$ applied to the sum of $n$ and $1$ is equal to the sum of $n$ and $1$. Let $i \\in N$. Assume that $i$ is less than or equal to $n$. Let $a \\in N$. Assume that $a$ is less than or equal to the sum of $n$ and $1$ and $f$ applied to $a$ is equal to $i$. Then if $a$ is less than or equal to the sum of $n$ and $1$, then if $f$ applied to $a$ is equal to $i$, then if $a$ is equal to the sum of $n$ and $1$, then $i$ is equal to $a$.\nAssistant:", "label": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (_clearme : and (Leq a (plus n 1)) (Eq (f a) i)) -> (lean : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (Hc : Eq a (plus n 1)) -> Eq i a", "predict": "postulate let_clause_1075 : (f : (_ : Nat) -> Nat) -> (n : Nat) -> (bijf : bijn f (plus n 1)) -> (fS : Eq (f (plus n 1)) (plus n 1)) -> (i : Nat) -> (lein : Leq i n) -> (a : Nat) -> (lea : Leq a (plus n 1)) -> (fa : Eq (f a) i) -> (H : Eq a (plus n 1)) -> Eq i a"}
{"prompt": "Human: Translate the following French statement into Agda.\nBigop_sum. Soit $k1, k2 \\in N$. Soient $p1$ et $p2$ des fonctions des nombres naturels à des valeurs booléennes. Soit $B$ un ensemble. Soit $nil$ un élément de $B$. Alors pour tous les éléments $op$ de $Aop$ de $B$ et de $nil$, pour toutes les fonctions $f$ et $g$ des nombres naturels à des éléments de $B$, $bigop$ appliqué à la somme de $k1$ et de $k2$ et la fonction qui envoie $i$ à $match_bool$ appliqué à $Set$ et la fonction qui envoie $__$ à $bool$ et $p1$ appliqué à la différence de $i$ et de $k2$ et $p2$ appliqué à $i$ et $leb$ appliqué à $k2$ et $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $match_bool$ appliqué à $Set$ et la fonction qui envoie $__$ à $B$ et $f$ appliqué à la différence de $i$ et de $k2$ et $g$ appliqué à $i$ et $leb$ appliqué à $k2$ et $i$ est égal à $op$ appliqué à $B$ et $nil$ et $op$ et $bigop$ appliqué à $k1$ et la fonction qui envoie $i$ à $p1$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $f$ appliqué à $i$ et $bigop$ appliqué à $k2$ et la fonction qui envoie $i$ à $p2$ appliqué à $i$ et $B$ et $nil$ et $op$ appliqué à $B$ et $nil$ et $op$ et la fonction qui envoie $i$ à $g$ appliqué à $i$.\nAssistant:", "label": "postulate bigop_sum : (k1 : Nat) -> (k2 : Nat) -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f i)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g i))) (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (minus i k2)) (p2 i) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (minus i k2)) (g i) (leb k2 i)))", "predict": "postulate bigop_sum : soit k1 : Nat -> k2 : Nat -> (p1 : (_ : Nat) -> bool) -> (p2 : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (g : (_ : Nat) -> B) -> Eq (bigop (plus k1 k2) (\\ i : Nat -> match_bool Set (\\ _ : bool -> bool) (p1 (\\ i : Nat -> minus i k2) p2) (leb k2 i)) B nil (op B nil op) (\\ i : Nat -> match_bool Set (\\ _ : bool -> B) (f (\\ i : Nat -> minus i k2) g) (leb k2 i))) (op B nil op (bigop k1 (\\ i : Nat -> p1 i) B nil (op B nil op) (\\ i : Nat -> f (\\ i : Nat -> minus i k2) g)) (bigop k2 (\\ i : Nat -> p2 i) B nil (op B nil op) (\\ i : Nat -> g (\\ i : Nat -> minus i k2) f)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nExp_pi_bc. Pour tous les nombres naturels $a$ et $b$ et $c$, pour toutes les fonctions $f$ des nombres naturels à des nombres naturels, $bigop$ appliqué à la différence de $c$ et de $b$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $b$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ au produit de $a$ et de $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $b$ est égal au produit de $a ^ (c - b)$ et de $bigop$ appliqué à la différence de $c$ et de $b$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $true$ appliqué à la somme de $i$ et de $b$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la fonction qui envoie $i0$ à $f$ appliqué à $i0$ appliqué à la somme de $i$ et de $b$.\nAssistant:", "label": "postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (times (pow a (minus c b)) (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b)))) (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> times a (f i0)) (plus i b)))", "predict": "postulate exp_pi_bc : (a : Nat) -> (b : Nat) -> (c : Nat) -> (f : (_ : Nat) -> Nat) -> Eq (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> times a (f i0)) (plus i b))) (times a (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> true) (plus i b)) Nat 1 times (\\ i : Nat -> (\\ i0 : Nat -> f i0)) (plus i b)))"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_10336. Soient $n$ et $m$ des nombres naturels. Soit $Hind$ une fonction des nombres naturels $p$ et des éléments de $Lt$ de $p$ et de $m$ et des éléments $__1$ de $Lt$ de $1$ et de $p$ à des éléments de $Leq$ de $Psi (p)$ et de $pred (p)\\times (2 ^ (2 p - 3))$. Soit $a$ un nombre naturel. Supposons que $m = 2 a$ ou $m = 2 a + 1$ et $m = 2 a + 1$. Alors si $1 < 2 a + 1$ et $0 < a$, alors pour tous les nombres naturels $x2515$ et $x2516$, $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (p : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (times (pred p) (pow 2 (minus (times 2 p) 3)))) -> (a : Nat) -> (_clearme : or (Eq m (times 2 a)) (Eq m (plus (times 2 a) 1))) -> (Hm : Eq m (plus (times 2 a) 1)) -> (Hlt : Lt 1 (plus (times 2 a) 1)) -> (Ha : Lt 0 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10336 : (n : Nat) -> (m : Nat) -> (Hind : (_ : Nat) -> (_ : Lt p m) -> (__1 : Lt 1 p) -> Leq (Psi p) (pred p) * (2 ^ (2 p - 3))) -> (a : Nat) -> (posn : Lt m 2 a) -> (posn1 : Lt 1 2 a) -> (Hind' : (x2515 : Nat) -> (x2516 : Nat) -> x2515 = x2516 (x2515 / x2516) + mod (x2515, x2516))"}
{"prompt": "Human: Translate the following English statement into Agda.\nLstar_ind. Let $B$ be a set. Let $_R$ be an element of $relation$ of $B$. Let $Q_$ be a function from natural numbers $x_1233$ and elements $x_1232$ of $B$ and elements $x_1231$ of $B$ and elements $_x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$ to propositions. Then for all functions $_H_lstar_O$ from elements $b$ of $B$ to elements of $Q_$ of $0$ and $b$ and $b$ and $lstar_O (B, _R, b)$, for all functions $_H_lstar_S$ from elements $b1$ of $B$ and elements $b$ of $B$ and elements $x_1236$ of $_R$ of $b1$ and $b$ and natural numbers $l$ and elements $b2$ of $B$ and elements $x_1235$ of $lstar$ of $B$ and $_R$ and $l$ and $b$ and $b2$ and elements $_x_1238$ of $Q_$ of $l$ and $b$ and $b2$ and $x_1235$ to elements of $Q_$ of $l + 1$ and $b1$ and $b2$ and $lstar_S (B, _R, b1, b, x_1236, l, b2, x_1235)$, for all natural numbers $x_1233$, for all elements $x_1232$ and $x_1231$ of $B$, for all elements $x_1234$ of $lstar$ of $B$ and $_R$ and $x_1233$ and $x_1232$ and $x_1231$, $Q_$ holds for $x_1233$ and $x_1232$ and $x_1231$ and $x_1234$.\nAssistant:", "label": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ (plus l 1) b1 b2 (lstar_S B _R b1 b x_1236 l b2 x_1235)) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234", "predict": "postulate lstar_ind : (B : Set) -> (_R : relation B) -> (Q_ : (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (_x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Prop) -> (_H_lstar_O : (b : B) -> Q_ 0 b b (lstar_O B _R b)) -> (_H_lstar_S : (b1 : B) -> (b : B) -> (x_1236 : _R b1 b) -> (l : Nat) -> (b2 : B) -> (x_1235 : lstar B _R l b b2) -> (_x_1238 : Q_ l b b2 x_1235) -> Q_ l + 1 b1 b2 lstar_S B _R b1 b x_1236 l b2 x_1235) -> (x_1233 : Nat) -> (x_1232 : B) -> (x_1231 : B) -> (x_1234 : lstar B _R x_1233 x_1232 x_1231) -> Q_ x_1233 x_1232 x_1231 x_1234"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_rect_Type1. Låt $A$ vara en mängd. Då för alla element $_nil$ av $A$, för alla funktioner $Q_$ från element $_x_953$ av $Dop$ av $A$ och $_nil$ till element av $Type1$, för alla funktioner $_H_mk_Dop$ från element $sum$ av $ACop$ av $A$ och $_nil$ och funktioner $prod$ från element av $A$ och element $__1$ av $A$ till element av $A$ och funktioner $_null$ från element $a$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $_nil$ och $_nil$ och funktioner $_distr$ från element $a$ av $A$ och element $b$ av $A$ och element $c$ av $A$ till element av $Eq$ av $prod$ applicerat på $a$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $b$ och $c$ och $aop__o__op$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ applicerat på $a$ och $b$ och $prod$ applicerat på $a$ och $c$ till element av $Q_$ av $mk_Dop$ applicerat på $A$ och $_nil$ och $sum$ och $prod$ och $_null$ och $_distr$, för alla element $x_953$ av $Dop$ av $A$ och $_nil$, håller $Q_$ för $x_953$.\nAssistant:", "label": "postulate Dop_rect_Type1 : (A : Set) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953", "predict": "postulate Dop_rect_Type1 : Dop_rect_Type1 : (A : Mngd) -> (_nil : A) -> (Q_ : (_x_953 : Dop A _nil) -> Type1) -> (_H_mk_Dop : (sum : ACop A _nil) -> (prod : (_ : A) -> (__1 : A) -> A) -> (_null : (a : A) -> Eq (prod a _nil) _nil) -> (_distr : (a : A) -> (b : A) -> (c : A) -> Eq (prod a (aop__o__op A _nil sum b c)) (aop__o__op A _nil sum (prod a b) (prod a c))) -> Q_ (mk_Dop A _nil sum prod _null _distr)) -> (x_953 : Dop A _nil) -> Q_ x_953"}
{"prompt": "Human: Translate the following English statement into Agda.\nDop_rect_CProp5_body. For all elements $A$ of $cic.Univ$ of $univs.Type0$, for all elements $_nil$ of $cic.Term$ of $univs.Type0$ and $A$, for all functions $Q_$ from elements $_x_959$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.Dop$ applied to $A$ and $_nil$ to elements of $cic.Univ$ of $cic.prop$, for all functions $_H_mk_Dop$ from elements $sum$ of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_bigops.ACop$ applied to $A$ and $_nil$ and functions $prod$ from elements $__$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $univs.Type0$ and $A$ and functions $_null$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $_nil$ and $_nil$ and functions $_distr$ from elements $a$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $b$ of $cic.Term$ of $univs.Type0$ and $A$ and elements $c$ of $cic.Term$ of $univs.Type0$ and $A$ to elements of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $A$ and $prod$ applied to $a$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $b$ and $c$ and $matita_arithmetics_bigops.aop__o__op$ applied to $A$ and $_nil$ and $sum$ and $prod$ applied to $a$ and $b$ and $prod$ applied to $a$ and $c$ to elements of $cic.Term$ of $cic.prop$ and $Q_$ applied to $matita_arithmetics_bigops.mk_Dop$ applied to $A$ and $_nil$ and $sum$ and $prod$ and $_null$ and $_distr$, for all elements $x_959$ of $", "label": "postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)", "predict": "postulate Dop_rect_CProp5_body : (A : cic.Univ univs.Type0) -> (_nil : cic.Term univs.Type0 A) -> (Q_ : (_x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Univ cic.prop) -> (_H_mk_Dop : (sum : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop A _nil)) -> (prod : (__ : cic.Term univs.Type0 A) -> (__1 : cic.Term univs.Type0 A) -> cic.Term univs.Type0 A) -> (_null : (a : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a _nil) _nil)) -> (_distr : (a : cic.Term univs.Type0 A) -> (b : cic.Term univs.Type0 A) -> (c : cic.Term univs.Type0 A) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 A) (prod a (matita_arithmetics_bigops.aop__o__op A _nil sum b c)) (matita_arithmetics_bigops.aop__o__op A _nil sum (prod a b) (prod a c)))) -> cic.Term cic.prop (Q_ (matita_arithmetics_bigops.mk_Dop A _nil sum prod _null _distr))) -> (x_959 : cic.Term univs.Type0 (matita_arithmetics_bigops.Dop A _nil)) -> cic.Term cic.prop (Q_ x_959)"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrimeb_true_to_prime. Pour tous les nombres naturels $n$, si $primeb$ appliqué à $n$ est égal à $true$, alors $n$ est premier.\nAssistant:", "label": "postulate primeb_true_to_prime : (n : Nat) -> (_ : Eq (primeb n) true) -> prime n", "predict": "postulate primeb_true_to_prime : tous les nombres naturels n -> (primeb : (_ : Nat) -> Eq (primeb n) true) -> premier n"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_15691. Let $m$ and $n$ and $a$ and $b$ be natural numbers. Assume that $0 < n$. Assume that $0 < m$. Then if $1$ is equal to the greatest common divisor of $n$ and $m$, then for all natural numbers $c$, for all elements $_clearme$ of $ex$ of $Nat$ and the function that maps $d$ to the disjunction of $Eq$ applied to the difference of the product of $c$ and $n$ and the product of $d$ and $m$ and $1$ and $Eq$ applied to the difference of the product of $d$ and $m$ and the product of $c$ and $n$ and $1$, for all natural numbers $d$, if $c n - d m = 1$ or $d m - c n = 1$, then if $c n - d m = 1$, then $n c - m d = 1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (H : Eq 1 (gcd n m)) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) d) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H0 : Eq (minus (times d m) 1) 1) -> Eq n c m"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_15691. Soient $m$ et $n$ et $a$ et $b$ des nombres naturels. Supposons que $0$ est inférieur à $n$. Supposons que $0$ est inférieur à $m$. Supposons que le diviseur commun plus grand de $n$ et de $m$ est égal à $1$. Soit $c \\in N$. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $d$ à la disjonction de $Eq$ appliqué à la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ et $1$ et de $Eq$ appliqué à la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ et $1$. Soit $d$ un nombre naturel. Supposons que la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$ ou la différence du produit de $d$ et de $m$ et du produit de $c$ et de $n$ est égale à $1$. Alors si la différence du produit de $c$ et de $n$ et du produit de $d$ et de $m$ est égale à $1$, alors la différence du produit de $n$ et de $c$ et du produit de $m$ et de $d$ est égale à $1$.\nAssistant:", "label": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (pnm : Eq (gcd n m) 1) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (_clearme0 : or (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1)) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1", "predict": "postulate let_clause_15691 : (m : Nat) -> (n : Nat) -> (a : Nat) -> (b : Nat) -> (posn : Lt 0 n) -> (posm : Lt 0 m) -> (c : Nat) -> (_clearme : ex Nat (\\ d : Nat -> disjonct (Eq (minus (times c n) (times d m)) 1) (Eq (minus (times d m) (times c n)) 1))) -> (d : Nat) -> (posn : Eq (minus (times c n) (times d m)) 1) -> (posm : Eq (minus (times d m) (times c n)) 1) -> (H : Eq (minus (times c n) (times d m)) 1) -> Eq (minus (times n c) (times m d)) 1"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFalse_min. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Låt $n, b \\in N$. Anta att $f$ applicerat på $b$ är lika med kontradiktion. Då är $min$ applicerat på summan av $n$ och $1$ och $b$ och $f$ lika med $min$ applicerat på $n$ och summan av $b$ och $1$ och $f$.\nAssistant:", "label": "postulate false_min : (f : (_ : Nat) -> bool) -> (n : Nat) -> (b : Nat) -> (_ : Eq (f b) false) -> Eq (min (plus n 1) b f) (min n (plus b 1) f)", "predict": "postulate false_min : let f : (_ : Nat) -> Sann"}
{"prompt": "Human: Translate the following French statement into Agda.\nSub_hk. Soit $__$ une fonction des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Soit $__1$ une fonction des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$ à des éléments de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$. Alors pour tous les éléments $A$ de $cic.Univ$ de $univs.Type0$, $cic.Term$ tient pour $univs.Type0$ et $matita_basics_relations.relation$ appliqué à $matita_arithmetics_bigops.range$ appliqué à $A$.\nAssistant:", "label": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))", "predict": "postulate sub_hk : (__ : (__ : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__1 : (__1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (A : cic.Univ univs.Type0) -> cic.Term univs.Type0 (matita_basics_relations.relation (matita_arithmetics_bigops.range A))"}
{"prompt": "Human: Translate the following French statement into Agda.\nPrimes_below_lop. Soit $n$ un nombre naturel. Alors $primes_below$ tient pour $list_of_primes$ appliqué à $n$ et la somme de $n$ et de $2$.\nAssistant:", "label": "postulate primes_below_lop : (n : Nat) -> primes_below (list_of_primes n) (plus n 2)", "predict": "postulate primes_below_lop : soit n un nombre naturel. alors primes_below tient pour (list_of_primes n) (plus n 2)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nGcd_1_to_divides_times_to_divides. Låt $p$ och $n$ och $m$ vara naturliga tal. Anta att $0$ är mindre än $p$. Anta att det största gemensama delaret av $p$ och $n$ är lika med $1$. Anta att $p$ är delbart med produkten av $n$ och $m$. Då är $p$ delbart med $m$.\nAssistant:", "label": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 p) -> (__1 : Eq (gcd p n) 1) -> (__2 : divisible p (times n m)) -> divisible p m", "predict": "postulate gcd_1_to_divides_times_to_divides : (p : Nat) -> (n : Nat) -> (m : Nat) -> let (l : Lt 0 p) -> Eq (gcd p n) 1 -> (h : Eq p (div n m)) -> Eq p m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDiv_mod_spec_inv_rect_Type4. Låt $x1$ och $x2$ och $x3$ och $x4$ vara element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $Hterm$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$. Då för alla funktioner $P$ från element $_z1440$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ till element av $cic.Univ$ av $univs.Type4$, för alla funktioner $_H1$ från element $x_815$ av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $x4$ och $x2$ och element $x_814$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_arithmetics_nat.nat$ och $x1$ och $matita_arithmetics_nat.plus$ applicerat på $matita_arithmetics_nat.times$ applicerat på $x3$ och $x2$ och $x4$ och element $_z1441$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $cic.prop$ och $univs.Type2$ och $matita_arithmetics_div_and_mod.div_mod_spec$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $Hterm$ och $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_815$ och $x_814$ till element av $cic.Term$ av $univs.Type4$ och $P$ applicerat på $matita_arithmetics_div_and_mod.div_mod_spec_intro$ applicerat på $x1$ och $x2$ och $x3$ och $x4$ och $x_815$ och $x_814$, håller $cic.Term$ för $univs.Type4$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)", "predict": "postulate div_mod_spec_inv_rect_Type4 : (x1 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x2 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x3 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (x4 : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (Hterm : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> (P : (_z1440 : cic.Term cic.prop (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) -> cic.Univ univs.Type4) -> (_H1 : (x_815 : cic.Term cic.prop (matita_arithmetics_nat.lt x4 x2)) -> (x_814 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) x1 (matita_arithmetics_nat.plus (matita_arithmetics_nat.times x3 x2) x4))) -> (_z1441 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift cic.prop univs.Type2 (matita_arithmetics_div_and_mod.div_mod_spec x1 x2 x3 x4)) Hterm (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P (matita_arithmetics_div_and_mod.div_mod_spec_intro x1 x2 x3 x4 x_815 x_814))) -> cic.Term univs.Type4 (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nPad_bigop1. Låt $k$ och $n$ vara naturliga tal. Låt $p$ vara en funktion från naturliga tal till sanningsvärden. Låt $B$ vara en mängd. Låt $nil$ vara ett element av $B$. Låt $op$ vara en funktion från element av $B$ och element $__1$ av $B$ till element av $B$. Då för alla funktioner $f$ från naturliga tal till element av $B$, om $n$ är mindre än eller lika med $k$, så för alla funktioner $__1$ från naturliga tal $i$ och element $__1$ av $Leq$ av $n$ och $i$ och element $__2$ av $Lt$ av $i$ och $k$ till element av $Eq$ av $p$ applicerat på $i$ och kontradiktion, är $bigop$ applicerat på $n$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$ lika med $bigop$ applicerat på $k$ och funktionen som avbildar $i$ som $p$ applicerat på $i$ och $B$ och $nil$ och $op$ och funktionen som avbildar $i$ som $f$ applicerat på $i$.\nAssistant:", "label": "postulate pad_bigop1 : (k : Nat) -> (n : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : (_ : B) -> (__1 : B) -> B) -> (f : (_ : Nat) -> B) -> (_ : Leq n k) -> (__1 : (i : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) false) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))", "predict": "postulate pad_bigop1 : let (k : Nat) (n : Nat) -> let (p : (_ : Nat) -> bool) -> let (B : Set) -> let (nil : B) -> let (op : (_ : B) -> (__1 : B) -> B) -> let (f : (_ : Nat) -> B) -> (_ : (n : Nat) -> or (Leq n k) (Eq (p n) (p i))) -> (__1 : (_ : Nat) -> (__1 : Leq n i) -> (__2 : Lt i k) -> Eq (p i) (op n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))) -> Eq (bigop n (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i)) (bigop k (\\ i : Nat -> p i) B nil op (\\ i : Nat -> f i))"}
{"prompt": "Human: Translate the following English statement into Agda.\nDivides_to_le_ord. Let $p, n, m \\in N$. Assume that $0 < n$. Assume that $0 < m$. Assume that $p$ is prime. Assume that $n$ is divisible by $m$. Then $ord (n, p)\\leq ord (m, p)$.\nAssistant:", "label": "postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (__2 : prime p) -> (__3 : divisible n m) -> Leq (ord n p) (ord m p)", "predict": "postulate divides_to_le_ord : (p : Nat) -> (n : Nat) -> (m : Nat) -> (_ : Lt 0 n) -> (__1 : Lt 0 m) -> (H : prime p) -> (Hn : divisible n m) -> Leq (ord n p) (ord m p)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLet_clause_1544. Soit $p, q \\in N$. Soit $Hind$ une fonction des nombres naturels $m$ et des nombres naturels $n$ et des éléments de $Lt$ de $0$ et de $n$ et des éléments $__1$ de $Leq$ de $n$ et de $m$ et des éléments $__2$ de $Leq$ de $n$ et de $q$ à des éléments de $ex$ de $Nat$ et de la fonction qui envoie $a$ à $ex$ appliqué à $Nat$ et la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $n$ et du produit de $b$ et de $m$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $m$ et du produit de $a$ et de $n$ et $gcd_aux$ appliqué à $q$ et $m$ et $n$. Soit $m, n \\in N$. Supposons que $0$ est inférieur à $n$. Supposons que $n$ est inférieur ou ágal à $m$. Supposons que $n$ est inférieur ou ágal à la somme de $q$ et de $1$. Supposons que $n$ n'est pas divisible par $m$. Soit $a$ un nombre naturel. Soit $_clearme$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $b$ à la disjonction de $Eq$ appliqué à la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ et de $Eq$ appliqué à la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$. Soit $b$ un nombre naturel. Alors si la différence du produit de $a$ et de $mod$ appliqué à $m$ et $n$ et du produit de $b$ et de $n$ est égale à $gcd_aux$ appliqué à $q$ et $n$ et $mod$ appliqué à $m$ et $n$ ou la différence du produit de $b$ et de $n$ et du produit de $a$ et de $mod$ appliqué à $m$ et $", "label": "postulate let_clause_1544 : (p : Nat) -> (q : Nat) -> (Hind : (m : Nat) -> (n : Nat) -> (_ : Lt 0 n) -> (__1 : Leq n m) -> (__2 : Leq n q) -> ex Nat (\\ a : Nat -> ex Nat (\\ b : Nat -> or (Eq (minus (times a n) (times b m)) (gcd_aux q m n)) (Eq (minus (times b m) (times a n)) (gcd_aux q m n))))) -> (m : Nat) -> (n : Nat) -> (posn : Lt 0 n) -> (lenm : Leq n m) -> (lenS : Leq n (plus q 1)) -> (ndivnm : not (divisible n m)) -> (a : Nat) -> (_clearme : ex Nat (\\ b : Nat -> or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n))))) -> (b : Nat) -> (_clearme0 : or (Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) (Eq (minus (times b n) (times a (mod m n))) (gcd_aux q n (mod m n)))) -> (H : Eq (minus (times a (mod m n)) (times b n)) (gcd_aux q n (mod m n))) -> Eq (minus (times a (mod m n)) (times n b)) (gcd_aux q n (mod m n))", "predict": "n$ est égale à $gcdpostulate let_clause_1544 : soit p, q \\in N"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_Psil. Soit $n \\in N$. Alors si $0 < n$, alors $2 ^ n \\leq Psi (2 n)$.\nAssistant:", "label": "postulate le_exp_Psil : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 n) (Psi (times 2 n))", "predict": "postulate le_exp_Psil : soit n : Nat -> alors (Lt 0 n) (pow 2 n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLt_SO_nth_prime_n. Let $n \\in N$. Then $1$ is less than $nth_prime$ applied to $n$.\nAssistant:", "label": "postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)", "predict": "postulate lt_SO_nth_prime_n : (n : Nat) -> Lt 1 (nth_prime n)"}
{"prompt": "Human: Translate the following English statement into Agda.\nEnum_body. Let $A$ be a set. Let $_xxx$ be an element of $range$ of $A$. Then for all natural numbers $_x_942$, $A$.\nAssistant:", "label": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A", "predict": "postulate enum_body : (A : Set) -> (_xxx : range A) -> (_x_942 : Nat) -> A"}
{"prompt": "Human: Translate the following French statement into Agda.\nPi_p_primeb5. Soit $n$ un nombre naturel. Alors si $1 < n$, alors $bigop$ appliqué à la somme de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du produit de $2$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$ est égal à $bigop$ appliqué à la somme du produit de $2$ et de $n$ et de $1$ et la fonction qui envoie $p$ à $primeb$ appliqué à $p$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $p$ à $bigop$ appliqué à le logarithme de $p$ et du produit de $2$ et de $n$ et la fonction qui envoie $i$ à $true$ et $Nat$ et $1$ et $times$ et la fonction qui envoie $i$ à la puissance de $p$ et du produit de $2$ et du quotient de $n$ et de la puissance de $p$ et de la somme de $i$ et de $1$.\nAssistant:", "label": "postulate pi_p_primeb5 : (n : Nat) -> (_ : Lt 1 n) -> Eq (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1)))))))", "predict": "postulate pi_p_primeb5 : soit n : Nat -> (1 < n) -> Eq (bigop (plus n 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p n) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (times 2 (div n (pow p (plus i 1))))))) (bigop (plus (times 2 n) 1) (\\ p : Nat -> primeb p) Nat 1 times (\\ p : Nat -> bigop (log p (times 2 n)) (\\ i : Nat -> true) Nat 1 times (\\ i : Nat -> pow p (plus 2 (div n (pow p (plus i 1)))))))"}
{"prompt": "Human: Translate the following French statement into Agda.\nF_max_true. Soit $f$ une fonction des nombres naturels à des valeurs booléennes. Soit $n$ un nombre naturel. Soit $__$ un élément de $ex$ de $Nat$ et de la fonction qui envoie $i$ à la conjonction de $Lt$ appliqué à $i$ et $n$ et de $Eq$ appliqué à $f$ appliqué à $i$ et $true$. Alors $f$ appliqué à $max$ appliqué à $n$ et $f$ est égal à $true$.\nAssistant:", "label": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true", "predict": "postulate f_max_true : (f : (_ : Nat) -> bool) -> (n : Nat) -> (_ : ex Nat (\\ i : Nat -> and (Lt i n) (Eq (f i) true))) -> Eq (f (max n f)) true"}
{"prompt": "Human: Translate the following English statement into Agda.\nBigop_sumI. Let $a$ and $b$ and $c$ be natural numbers. Let $p$ be a function from natural numbers to booleans. Let $B$ be a set. Let $nil$ be an element of $B$. Then for all elements $op$ of $Aop$ of $B$ and $nil$, for all functions $f$ from natural numbers to elements of $B$, if $a \\leq b$, then if $b \\leq c$, then $op$ applied to $B$ and $nil$ and $op$ and $bigop$ applied to the difference of $c$ and $b$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $b$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $b$ and $bigop$ applied to the difference of $b$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$ is equal to $bigop$ applied to the difference of $c$ and $a$ and the function that maps $i$ to the function that maps $i0$ to $p$ applied to $i0$ applied to the sum of $i$ and $a$ and $B$ and $nil$ and $op$ applied to $B$ and $nil$ and $op$ and the function that maps $i$ to the function that maps $i0$ to $f$ applied to $i0$ applied to the sum of $i$ and $a$.\nAssistant:", "label": "postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (bigop (minus c a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))) (op B nil op (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i b)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil (op B nil op) (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a))))", "predict": "postulate bigop_sumI : (a : Nat) -> (b : Nat) -> (c : Nat) -> (p : (_ : Nat) -> bool) -> (B : Set) -> (nil : B) -> (op : Aop B nil) -> (f : (_ : Nat) -> B) -> (_ : Leq a b) -> (__1 : Leq b c) -> Eq (op B nil op (bigop (minus c b) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i b)) B nil op (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i b))) (bigop (minus b a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil op (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))) (bigop (minus c a) (\\ i : Nat -> (\\ i0 : Nat -> p i0) (plus i a)) B nil op (\\ i : Nat -> (\\ i0 : Nat -> f i0) (plus i a)))"}
{"prompt": "Human: Translate the following English statement into Agda.\nMax_spec_ind_body. Let $_n \\in N$. Let $_f$ be a function from natural numbers to booleans. Let $Q_$ be a function from natural numbers $x_971$ and elements $_x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$ to propositions. Let $_H_found_max_spec$ be a function from natural numbers $m$ and elements $x_975$ of $Lt$ of $m$ and $_n$ and elements $x_974$ of $Eq$ of $_f$ applied to $m$ and $true$ and functions $x_973$ from natural numbers $i$ and elements of $Lt$ of $m$ and $i$ and elements $__1$ of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $m$ and $found_max_spec$ applied to $_n$ and $_f$ and $m$ and $x_975$ and $x_974$ and $x_973$. Let $_H_not_found_max_spec$ be a function from functions $x_976$ from natural numbers $i$ and elements of $Lt$ of $i$ and $_n$ to elements of $Eq$ of $_f$ applied to $i$ and absurdity to elements of $Q_$ of $0$ and $not_found_max_spec$ applied to $_n$ and $_f$ and $x_976$. Then for all natural numbers $x_971$, for all elements $x_972$ of $max_spec$ of $_n$ and $_f$ and $x_971$, $Q_$ holds for $x_971$ and $x_972$.\nAssistant:", "label": "postulate max_spec_ind_body : (_n : Nat) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972", "predict": "postulate max_spec_ind_body : (_n : N) -> (_f : (_ : Nat) -> bool) -> (Q_ : (x_971 : Nat) -> (_x_972 : max_spec _n _f x_971) -> Prop) -> (_H_found_max_spec : (m : Nat) -> (x_975 : Lt m _n) -> (x_974 : Eq (_f m) true) -> (x_973 : (i : Nat) -> (_ : Lt m i) -> (__1 : Lt i _n) -> Eq (_f i) false) -> Q_ m (found_max_spec _n _f m x_975 x_974 x_973)) -> (_H_not_found_max_spec : (x_976 : (i : Nat) -> (_ : Lt i _n) -> Eq (_f i) false) -> Q_ 0 (not_found_max_spec _n _f x_976)) -> (x_971 : Nat) -> (x_972 : max_spec _n _f x_971) -> Q_ x_971 x_972"}
{"prompt": "Human: Translate the following English statement into Agda.\nEq_plus_to_le. Let $n$ and $m$ and $p$ be elements of $cic.Term$ of $univs.Type0$ and $matita_arithmetics_nat.nat$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_arithmetics_nat.nat$ and $n$ and $matita_arithmetics_nat.plus$ applied to $m$ and $p$. Then $cic.Term$ holds for $cic.prop$ and $matita_arithmetics_nat.le$ applied to $m$ and $n$.\nAssistant:", "label": "postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)", "predict": "postulate eq_plus_to_le : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_arithmetics_nat.nat) n (matita_arithmetics_nat.plus m p))) -> cic.Term cic.prop (matita_arithmetics_nat.le m n)"}
{"prompt": "Human: Translate the following French statement into Agda.\nACop_rect_CProp5. Soit $A$ un ensemble. Soit $_nil$ un élément de $A$. Soit $Q_$ une fonction des éléments $_x_905$ de $ACop$ de $A$ et de $_nil$ à des propositions. Alors pour toutes les fonctions $_H_mk_ACop$ des éléments $aop$ de $Aop$ de $A$ et de $_nil$ et des fonctions $_comm$ des éléments $a$ de $A$ et des éléments $b$ de $A$ à des éléments de $Eq$ de $op$ appliqué à $A$ et $_nil$ et $aop$ et $a$ et $b$ et de $op$ appliqué à $A$ et $_nil$ et $aop$ et $b$ et $a$ à des éléments de $Q_$ de $mk_ACop$ appliqué à $A$ et $_nil$ et $aop$ et $_comm$, pour tous les éléments $x_905$ de $ACop$ de $A$ et de $_nil$, $Q_$ tient pour $x_905$.\nAssistant:", "label": "postulate ACop_rect_CProp5 : (A : Set) -> (_nil : A) -> (Q_ : (_x_905 : ACop A _nil) -> Prop) -> (_H_mk_ACop : (aop : Aop A _nil) -> (_comm : (a : A) -> (b : A) -> Eq (op A _nil aop a b) (op A _nil aop b a)) -> Q_ (mk_ACop A _nil aop _comm)) -> (x_905 : ACop A _nil) -> Q_ x_905", "predict": "postulate ACop_rect_CProp5 : soit A un ensemble. soit _nil un élément de A. soit Q_ une fonction des _x_905 de ACop de A _nil à des propositions. alors pour toutes les fonctions _H_mk_ACop des elements aop de Aop de A _nil et des fonctions _comm des elements a de A et des elements b de A à des éléments de Eq (op A _nil aop a b) (op A _nil aop b a)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nExample1. $smallest_factor (3)= 3$.\nAssistant:", "label": "postulate example1 : Eq (smallest_factor 3) 3", "predict": "postulate example1 : Eq (smallest_factor 3) 3"}
{"prompt": "Human: Translate the following English statement into Agda.\nAop_rect_Type4_body. Let $A$ be a set. Let $_nil$ be an element of $A$. Let $Q_$ be a function from elements $_x_863$ of $Aop$ of $A$ and $_nil$ to elements of $Type4$. Then for all functions $_H_mk_Aop$ from functions $op$ from elements of $A$ and elements $__1$ of $A$ to elements of $A$ and functions $_nill$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $_nil$ and $a$ and $a$ and functions $_nilr$ from elements $a$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $_nil$ and $a$ and functions $_assoc$ from elements $a$ of $A$ and elements $b$ of $A$ and elements $c$ of $A$ to elements of $Eq$ of $op$ applied to $a$ and $op$ applied to $b$ and $c$ and $op$ applied to $op$ applied to $a$ and $b$ and $c$ to elements of $Q_$ of $mk_Aop$ applied to $A$ and $_nil$ and $op$ and $_nill$ and $_nilr$ and $_assoc$, for all elements $x_863$ of $Aop$ of $A$ and $_nil$, $Q_$ holds for $x_863$.\nAssistant:", "label": "postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863", "predict": "postulate Aop_rect_Type4_body : (A : Set) -> (_nil : A) -> (Q_ : (_x_863 : Aop A _nil) -> Type4) -> (_H_mk_Aop : (op : (_ : A) -> (__1 : A) -> A) -> (_nill : (a : A) -> Eq (op _nil a) a) -> (_nilr : (a : A) -> Eq (op a _nil) a) -> (_assoc : (a : A) -> (b : A) -> (c : A) -> Eq (op a (op b c)) (op (op a b) c)) -> Q_ (mk_Aop A _nil op _nill _nilr _assoc)) -> (x_863 : Aop A _nil) -> Q_ x_863"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDop_discr. Låt $a1$ vara en mängd. Då för alla element $a2$ av $a1$, för alla element $x$ och $y$ av $Dop$ av $a1$ och $a2$, om $x$ är lika med $y$, så håller $match_Dop$ för $a1$ och $a2$ och summan av $Type2$ och $1$ och funktionen som avbildar $__$ som $univ$ applicerat på $Type2$ och funktionen som avbildar $t0$ och $t1$ och $t2$ och $t3$ som $match_Dop$ applicerat på $a1$ och $a2$ och summan av $Type2", "label": "postulate Dop_discr : (a1 : Set) -> (a2 : a1) -> (x : Dop a1 a2) -> (y : Dop a1 a2) -> (_e : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ t0 : ACop a1 a2 -> \\ t1 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ t2 : ((a : a1) -> Eq (t1 a a2) a2) -> \\ t3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (t1 a (aop__o__op a1 a2 t0 b c)) (aop__o__op a1 a2 t0 (t1 a b) (t1 a c))) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Dop a1 a2 -> univ Type2) (\\ u0 : ACop a1 a2 -> \\ u1 : ((_ : a1) -> (__1 : a1) -> a1) -> \\ u2 : ((a : a1) -> Eq (u1 a a2) a2) -> \\ u3 : ((a : a1) -> (b : a1) -> (c : a1) -> Eq (u1 a (aop__o__op a1 a2 u0 b c)) (aop__o__op a1 a2 u0 (u1 a b) (u1 a c))) -> prod (plus Type1 1) Type1 (univ Type1) (\\ P : Type1 -> prod Type1 Type1 (prod Prop Type1 (Eq (R0 (ACop a1 a2) t0) u0) (\\ e0 : Eq (R0 (ACop a1 a2) t0) u0 -> prod Prop Type1 (Eq (R1 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 u0 e0) u1) (\\ e1 : Eq (R1 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 u0 e0) u1 -> prod Prop Type1 (Eq (R2 (ACop a1 a2) t0 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 (\\ x0 : ACop a1 a2 -> \\ p0 : Eq t0 x0 -> \\ x1 : (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) x0 p0 -> \\ _ : Eq (R1 (ACop a1 a2) t0 (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> prod Set Set a1 (\\ _ : a1 -> prod Set Set a1 (\\ __1 : a1 -> a1))) t1 x0 p0) x1 -> (\\ x01 : ACop a1 a2 -> \\ p01 : Eq t0 x01 -> \\ x11 : ((__1 : a1) -> (__2 : a1) ->", "predict": "postulate låt : (a1 : Mngd) -> (a2 : a1) -> (x : a1) -> (y : a1) -> (_ : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3 : match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type2 -> \\ t3postulate match_Dop : (a1 : Mngd) -> (a2 : a1) -> (x : a1) -> (y : a1) -> (_ : Eq x y) -> match_Dop a1 a2 (plus Type2 1) (\\ _ : Type2 -> univ) (\\ t0 : Type2 -> \\ t1 : Type2 -> \\ t2 : Type"}
{"prompt": "Human: Translate the following English statement into Agda.\nNil_append_elim. Let $A$ be an element of $cic.Univ$ of $univs.Type0$. Let $l1$ and $l2$ be elements of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$. Let $P$ be a function from elements $__$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ and elements $__1$ of $cic.Term$ of $univs.Type0$ and $matita_basics_lists_list.list$ applied to $A$ to elements of $cic.Univ$ of $cic.prop$. Let $__$ be an element of $cic.Term$ of $cic.prop$ and $matita_basics_logic.eq$ applied to $cic.lift$ applied to $univs.Type0$ and $univs.Type2$ and $matita_basics_lists_list.list$ applied to $A$ and $matita_basics_lists_list.append$ applied to $A$ and $l1$ and $l2$ and $matita_basics_lists_list.nil$ applied to $A$. Let $__1$ be an element of $cic.Term$ of $cic.prop$ and $P$ applied to $matita_basics_lists_list.nil$ applied to $A$ and $matita_basics_lists_list.nil$ applied to $A$. Then $cic.Term$ holds for $cic.prop$ and $P$ applied to $l1$ and $l2$.\nAssistant:", "label": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)", "predict": "postulate nil_append_elim : (A : cic.Univ univs.Type0) -> (l1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (l2 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (P : (__ : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> (__1 : cic.Term univs.Type0 (matita_basics_lists_list.list A)) -> cic.Univ cic.prop) -> (__ : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_basics_lists_list.list A)) (matita_basics_lists_list.append A l1 l2) (matita_basics_lists_list.nil A))) -> (__1 : cic.Term cic.prop (P (matita_basics_lists_list.nil A) (matita_basics_lists_list.nil A))) -> cic.Term cic.prop (P l1 l2)"}
{"prompt": "Human: Translate the following French statement into Agda.\nLe_exp_priml. Soit $n \\in N$. Supposons que $0 < n$. Alors $2 ^ (2 n)\\leq 2 n ^ (prim (2 n)+ 1)$.\nAssistant:", "label": "postulate le_exp_priml : (n : Nat) -> (_ : Lt 0 n) -> Leq (pow 2 (times 2 n)) (pow (times 2 n) (plus (prim (times 2 n)) 1))", "predict": "postulate le_exp_priml : soit n : Nat -> (posn : Lt 0 n) -> Leq 2 ^ (2 n) 2 n (prim (2 n) + 1)"}
{"prompt": "Human: Translate the following English statement into Agda.\nLet_clause_10331. Let $n$ be a natural number. Assume that $5 < n$. Let $m$ be a natural number. Assume that $6 \\leq m$ and $(m + 1)^ 2 \\leq 2 ^ m$. Let $a \\in N$. Assume that $6 \\leq a$ and $2 (a + 1)+ 1 \\leq 2 ^ a$. Let $x2515$ and $x2516$ be natural numbers. Then $x2515 = x2516 (x2515 \\div x2516)+ mod (x2515, x2516)$.\nAssistant:", "label": "postulate let_clause_10331 : (n : Nat) -> (lt4n : Lt 5 n) -> (m : Nat) -> (le4m : Leq 6 m) -> (Hind : Leq (pow (plus m 1) 2) (pow 2 m)) -> (a : Nat) -> (lea : Leq 6 a) -> (Hinda : Leq (plus (times 2 (plus a 1)) 1) (pow 2 a)) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (plus (times x2516 (div x2515 x2516)) (mod x2515 x2516))", "predict": "postulate let_clause_10331 : (n : Nat) -> (lt : Lt 5 n) -> (m : Nat) -> (lt2 : Leq m 6) -> (Hind : Leq m (plus 1 2)) -> (a : Nat) -> (lt3 : Leq 6 a) -> (x2515 : Nat) -> (x2516 : Nat) -> Eq x2515 (x2516 (x2515 div x2516) + mod x2515 x2516)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nDpi1__o__aop. För alla element $x0$ av $cic.Univ$ av $univs.Type0$, för alla element $x1$ av $cic.Term$ av $univs.Type0$ och $x0$, för alla funktioner $x2$ från element $__$ av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ till element av $cic.Univ$ av $univs.Type0$, för alla element $x3$ av $cic.Term$ av $univs.Type0$ och $matita_basics_types.DPair$ applicerat på $matita_arithmetics_bigops.ACop$ applicerat på $x0$ och $x1$ och $x2$, håller $cic.Term$ för $univs.Type0$ och $matita_arithmetics_bigops.Aop$ applicerat på $x0$ och $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)", "predict": "postulate dpi1__o__aop : (x0 : cic.Univ univs.Type0) -> (x1 : cic.Term univs.Type0 x0) -> (x2 : (__ : cic.Term univs.Type0 (matita_arithmetics_bigops.ACop x0 x1)) -> cic.Univ univs.Type0) -> (x3 : cic.Term univs.Type0 (matita_basics_types.DPair (matita_arithmetics_bigops.ACop x0 x1) x2)) -> cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x0 x1)"}
{"prompt": "Human: Translate the following French statement into Agda.\nCommutative_plus. $commutative$ tient pour $Nat$ et $plus$.\nAssistant:", "label": "postulate commutative_plus : commutative Nat plus", "predict": "postulate commutative_plus : commutative Nat plus"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nFound_max_spec. Låt $n \\in N$. Låt $f$ vara en funktion från naturliga tal till sanningsvärden. Då för alla naturliga tal $m$, om $m < n$ och $f (m)= true$, så för alla funktioner $__2$ från naturliga tal $i$ och element $__2$ av $Lt$ av $m$ och $i$ och element $__3$ av $Lt$ av $i$ och $n$ till element av $Eq$ av $f (i)$ och kontradiktion, håller $max_spec$ för $n$ och $f$ och $m$.\nAssistant:", "label": "postulate found_max_spec : (n : Nat) -> (f : (_ : Nat) -> bool) -> (m : Nat) -> (_ : Lt m n) -> (__1 : Eq (f m) true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) false) -> max_spec n f m", "predict": "postulate let : (n : Nat) -> (f : (_ : Nat) -> Prop) -> (m : Nat) -> (_ : Lt m n) -> (f' : (_ : Nat) -> true) -> (__2 : (i : Nat) -> (__2 : Lt m i) -> (__3 : Lt i n) -> Eq (f i) (contradiction)) -> max_spec n f m"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nBool_inv_rect_CProp1. Låt $Hterm$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$. Låt $P$ vara en funktion från element $_z641$ av $cic.Term$ av $univs.Type0$ och $matita_basics_bool.bool$ till element av $cic.Univ$ av $cic.prop$. Låt $_H1$ vara en funktion från element $_z642$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.true$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.true$. Då för alla funktioner $_H2$ från element $_z642$ av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $Hterm$ och $matita_basics_bool.false$ till element av $cic.Term$ av $cic.prop$ och $P$ applicerat på $matita_basics_bool.false$, håller $cic.Term$ för $cic.prop$ och $P$ applicerat på $Hterm$.\nAssistant:", "label": "postulate bool_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)", "predict": "postulate bool_inv_rect_CProp1 : (Hterm : cic.Term univs.Type0 matita_basics_bool.bool) -> (P : (_z641 : cic.Term univs.Type0 matita_basics_bool.bool) -> cic.Univ cic.prop) -> (_H1 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.true)) -> cic.Term cic.prop (P matita_basics_bool.true)) -> (_H2 : (_z642 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) Hterm matita_basics_bool.false)) -> cic.Term cic.prop (P matita_basics_bool.false)) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following French statement into Agda.\nAop_inv_rect_CProp3. Soit $x1$ un élément de $cic.Univ$ de $univs.Type0$. Soit $x2$ un élément de $cic.Term$ de $univs.Type0$ et de $x1$. Soit $Hterm$ un élément de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$. Soit $P$ une fonction des éléments $_z1542$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_bigops.Aop$ appliqué à $x1$ et $x2$ à des éléments de $cic.Univ$ de $cic.prop$. Soit $_H1$ une fonction des fonctions $op$ des éléments $__$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $__1$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $univs.Type0$ et de $x1$ et des fonctions $_nill$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $x2$ et $a$ et $a$ et des fonctions $_nilr$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ à des éléments de $cic.Term$ de $cic.prop$ et de $matita_basics_logic.eq$ appliqué à $cic.lift$ appliqué à $univs.Type0$ et $univs.Type2$ et $x1$ et $op$ appliqué à $a$ et $x2$ et $a$ et des fonctions $_assoc$ des éléments $a$ de $cic.Term$ de $univs.Type0$ et de $x1$ et des éléments $b$ de $cic.Term$ de $univs.Type0$ et de $x", "label": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)", "predict": "postulate Aop_inv_rect_CProp3 : (x1 : cic.Univ univs.Type0) -> (x2 : cic.Term univs.Type0 x1) -> (Hterm : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> (P : (_z1542 : cic.Term univs.Type0 (matita_arithmetics_bigops.Aop x1 x2)) -> cic.Univ cic.prop) -> (_H1 : (op : (__ : cic.Term univs.Type0 x1) -> (__1 : cic.Term univs.Type0 x1) -> cic.Term univs.Type0 x1) -> (_nill : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op x2 a) a)) -> (_nilr : (a : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a x2) a)) -> (_assoc : (a : cic.Term univs.Type0 x1) -> (b : cic.Term univs.Type0 x1) -> (c : cic.Term univs.Type0 x1) -> cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 x1) (op a (op b c)) (op (op a b) c))) -> (_z1543 : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 (matita_arithmetics_bigops.Aop x1 x2)) Hterm (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P (matita_arithmetics_bigops.mk_Aop x1 x2 op _nill _nilr _assoc))) -> cic.Term cic.prop (P Hterm)"}
{"prompt": "Human: Translate the following Swedish statement into Agda.\nLet_clause_1033. Låt $n$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $len$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_exp.exp$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $p$ vara ett element av $cic.Term$ av $univs.Type0$ och $matita_arithmetics_nat.nat$. Låt $lep$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.le$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_sqrt.sqrt$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$ och $p$. Låt $ltp$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_arithmetics_nat.lt$ applicerat på $p$ och $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.times$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $n$. Låt $Hc$ vara ett element av $cic.Term$ av $cic.prop$ och $matita_basics_logic.eq$ applicerat på $cic.lift$ applicerat på $univs.Type0$ och $univs.Type2$ och $matita_basics_bool.bool$ och $matita_arithmetics_nat.leb$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.S$ applicerat på $matita_arithmetics_nat.O$ och $matita_arithmetics_chebyshev_bertrand.k$ applicerat på $mat", "label": "postulate let_clause_1033 : (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (len : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> (p : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (lep : cic.Term cic.prop (matita_arithmetics_nat.le (matita_arithmetics_nat.S (matita_arithmetics_sqrt.sqrt (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n))) p)) -> (ltp : cic.Term cic.prop (matita_arithmetics_nat.lt p (matita_arithmetics_nat.S (matita_arithmetics_nat.times (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) n)))) -> (Hc : cic.Term cic.prop (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 matita_basics_bool.bool) (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k (matita_arithmetics_nat.times (matita_arithmetics_nat.S (", "predict": "postulate let_clause_1033 : cic.Term univs.Type0 matita_arithmetics_nat.nat -> cic.Term univs.prop (matita_arithmetics_nat.le (matita_arithmetics_exp.exp (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)))))))) n)) -> cic.Term univs.prop (matita_arithmetics_nat.leb (matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O)) (matita_arithmetics_chebyshev_bertrand.k matita_arithmetics_nat.S (matita_arithmetics_nat.S matita_arithmetics_nat.O) (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita_arithmetics_nat.S (matita"}
{"prompt": "Human: Translate the following English statement into Agda.\nDpi1__o__aop. Let $x0$ be a set. Then for all elements $x1$ of $x0$, for all functions $x2$ from elements of $ACop$ of $x0$ and $x1$ to sets, for all elements $x3$ of $DPair$ of $ACop (x0, x1)$ and $x2$, $Aop$ holds for $x0$ and $x1$.\nAssistant:", "label": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1", "predict": "postulate dpi1__o__aop : (x0 : Set) -> (x1 : x0) -> (x2 : (_ : ACop x0 x1) -> Set) -> (x3 : DPair (ACop x0 x1) x2) -> Aop x0 x1"}
{"prompt": "Human: Translate the following French statement into Agda.\nDivides_d_gcd. Pour tous les éléments $m$ et $n$ et $d$ de $cic.Term$ de $univs.Type0$ et de $matita_arithmetics_nat.nat$, pour tous les éléments $__$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $m$, pour tous les éléments $__1$ de $cic.Term$ de $cic.prop$ et de $matita_arithmetics_primes.divides$ appliqué à $d$ et $n$, $cic.Term$ tient pour $cic.prop$ et $matita_arithmetics_primes.divides$ appliqué à $d$ et $matita_arithmetics_gcd.gcd$ appliqué à $n$ et $m$.\nAssistant:", "label": "postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))", "predict": "postulate divides_d_gcd : (m : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (n : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (d : cic.Term univs.Type0 matita_arithmetics_nat.nat) -> (__ : cic.Term cic.prop (matita_arithmetics_primes.divides d m)) -> (__1 : cic.Term cic.prop (matita_arithmetics_primes.divides d n)) -> cic.Term cic.prop (matita_arithmetics_primes.divides d (matita_arithmetics_gcd.gcd n m))"}